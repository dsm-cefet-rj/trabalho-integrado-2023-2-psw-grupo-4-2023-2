import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-7REXU52E.js";

// node_modules/pdfjs-dist/build/pdf.worker.js
var require_pdf_worker = __commonJS({
  "node_modules/pdfjs-dist/build/pdf.worker.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = root.pdfjsWorker = factory();
      else if (typeof define === "function" && define.amd)
        define("pdfjs-dist/build/pdf.worker", [], () => {
          return root.pdfjsWorker = factory();
        });
      else if (typeof exports === "object")
        exports["pdfjs-dist/build/pdf.worker"] = root.pdfjsWorker = factory();
      else
        root["pdfjs-dist/build/pdf.worker"] = root.pdfjsWorker = factory();
    })(globalThis, () => {
      return (
        /******/
        (() => {
          "use strict";
          var __webpack_modules__ = [
            ,
            /* 1 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.WorkerTask = exports2.WorkerMessageHandler = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _core_utils = __w_pdfjs_require__2(3);
              var _primitives = __w_pdfjs_require__2(4);
              var _pdf_manager = __w_pdfjs_require__2(6);
              var _annotation = __w_pdfjs_require__2(10);
              var _cleanup_helper = __w_pdfjs_require__2(68);
              var _writer = __w_pdfjs_require__2(73);
              var _message_handler = __w_pdfjs_require__2(104);
              var _worker_stream = __w_pdfjs_require__2(105);
              var _struct_tree = __w_pdfjs_require__2(72);
              class WorkerTask {
                constructor(name) {
                  this.name = name;
                  this.terminated = false;
                  this._capability = new _util.PromiseCapability();
                }
                get finished() {
                  return this._capability.promise;
                }
                finish() {
                  this._capability.resolve();
                }
                terminate() {
                  this.terminated = true;
                }
                ensureNotTerminated() {
                  if (this.terminated) {
                    throw new Error("Worker task was terminated");
                  }
                }
              }
              exports2.WorkerTask = WorkerTask;
              class WorkerMessageHandler {
                static setup(handler, port) {
                  let testMessageProcessed = false;
                  handler.on("test", function(data) {
                    if (testMessageProcessed) {
                      return;
                    }
                    testMessageProcessed = true;
                    handler.send("test", data instanceof Uint8Array);
                  });
                  handler.on("configure", function(data) {
                    (0, _util.setVerbosityLevel)(data.verbosity);
                  });
                  handler.on("GetDocRequest", function(data) {
                    return WorkerMessageHandler.createDocumentHandler(data, port);
                  });
                }
                static createDocumentHandler(docParams, port) {
                  let pdfManager;
                  let terminated = false;
                  let cancelXHRs = null;
                  const WorkerTasks = /* @__PURE__ */ new Set();
                  const verbosity = (0, _util.getVerbosityLevel)();
                  const {
                    docId,
                    apiVersion
                  } = docParams;
                  const workerVersion = "3.11.174";
                  if (apiVersion !== workerVersion) {
                    throw new Error(`The API version "${apiVersion}" does not match the Worker version "${workerVersion}".`);
                  }
                  const enumerableProperties = [];
                  for (const property in []) {
                    enumerableProperties.push(property);
                  }
                  if (enumerableProperties.length) {
                    throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + enumerableProperties.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
                  }
                  const workerHandlerName = docId + "_worker";
                  let handler = new _message_handler.MessageHandler(workerHandlerName, docId, port);
                  function ensureNotTerminated() {
                    if (terminated) {
                      throw new Error("Worker was terminated");
                    }
                  }
                  function startWorkerTask(task) {
                    WorkerTasks.add(task);
                  }
                  function finishWorkerTask(task) {
                    task.finish();
                    WorkerTasks.delete(task);
                  }
                  async function loadDocument(recoveryMode) {
                    await pdfManager.ensureDoc("checkHeader");
                    await pdfManager.ensureDoc("parseStartXRef");
                    await pdfManager.ensureDoc("parse", [recoveryMode]);
                    await pdfManager.ensureDoc("checkFirstPage", [recoveryMode]);
                    await pdfManager.ensureDoc("checkLastPage", [recoveryMode]);
                    const isPureXfa = await pdfManager.ensureDoc("isPureXfa");
                    if (isPureXfa) {
                      const task = new WorkerTask("loadXfaFonts");
                      startWorkerTask(task);
                      await Promise.all([pdfManager.loadXfaFonts(handler, task).catch((reason) => {
                      }).then(() => finishWorkerTask(task)), pdfManager.loadXfaImages()]);
                    }
                    const [numPages, fingerprints] = await Promise.all([pdfManager.ensureDoc("numPages"), pdfManager.ensureDoc("fingerprints")]);
                    const htmlForXfa = isPureXfa ? await pdfManager.ensureDoc("htmlForXfa") : null;
                    return {
                      numPages,
                      fingerprints,
                      htmlForXfa
                    };
                  }
                  function getPdfManager({
                    data,
                    password,
                    disableAutoFetch,
                    rangeChunkSize,
                    length,
                    docBaseUrl,
                    enableXfa,
                    evaluatorOptions
                  }) {
                    const pdfManagerArgs = {
                      source: null,
                      disableAutoFetch,
                      docBaseUrl,
                      docId,
                      enableXfa,
                      evaluatorOptions,
                      handler,
                      length,
                      password,
                      rangeChunkSize
                    };
                    const pdfManagerCapability = new _util.PromiseCapability();
                    let newPdfManager;
                    if (data) {
                      try {
                        pdfManagerArgs.source = data;
                        newPdfManager = new _pdf_manager.LocalPdfManager(pdfManagerArgs);
                        pdfManagerCapability.resolve(newPdfManager);
                      } catch (ex) {
                        pdfManagerCapability.reject(ex);
                      }
                      return pdfManagerCapability.promise;
                    }
                    let pdfStream, cachedChunks = [];
                    try {
                      pdfStream = new _worker_stream.PDFWorkerStream(handler);
                    } catch (ex) {
                      pdfManagerCapability.reject(ex);
                      return pdfManagerCapability.promise;
                    }
                    const fullRequest = pdfStream.getFullReader();
                    fullRequest.headersReady.then(function() {
                      if (!fullRequest.isRangeSupported) {
                        return;
                      }
                      pdfManagerArgs.source = pdfStream;
                      pdfManagerArgs.length = fullRequest.contentLength;
                      pdfManagerArgs.disableAutoFetch || (pdfManagerArgs.disableAutoFetch = fullRequest.isStreamingSupported);
                      newPdfManager = new _pdf_manager.NetworkPdfManager(pdfManagerArgs);
                      for (const chunk of cachedChunks) {
                        newPdfManager.sendProgressiveData(chunk);
                      }
                      cachedChunks = [];
                      pdfManagerCapability.resolve(newPdfManager);
                      cancelXHRs = null;
                    }).catch(function(reason) {
                      pdfManagerCapability.reject(reason);
                      cancelXHRs = null;
                    });
                    let loaded = 0;
                    const flushChunks = function() {
                      const pdfFile = (0, _core_utils.arrayBuffersToBytes)(cachedChunks);
                      if (length && pdfFile.length !== length) {
                        (0, _util.warn)("reported HTTP length is different from actual");
                      }
                      try {
                        pdfManagerArgs.source = pdfFile;
                        newPdfManager = new _pdf_manager.LocalPdfManager(pdfManagerArgs);
                        pdfManagerCapability.resolve(newPdfManager);
                      } catch (ex) {
                        pdfManagerCapability.reject(ex);
                      }
                      cachedChunks = [];
                    };
                    new Promise(function(resolve, reject) {
                      const readChunk = function({
                        value,
                        done
                      }) {
                        try {
                          ensureNotTerminated();
                          if (done) {
                            if (!newPdfManager) {
                              flushChunks();
                            }
                            cancelXHRs = null;
                            return;
                          }
                          loaded += value.byteLength;
                          if (!fullRequest.isStreamingSupported) {
                            handler.send("DocProgress", {
                              loaded,
                              total: Math.max(loaded, fullRequest.contentLength || 0)
                            });
                          }
                          if (newPdfManager) {
                            newPdfManager.sendProgressiveData(value);
                          } else {
                            cachedChunks.push(value);
                          }
                          fullRequest.read().then(readChunk, reject);
                        } catch (e) {
                          reject(e);
                        }
                      };
                      fullRequest.read().then(readChunk, reject);
                    }).catch(function(e) {
                      pdfManagerCapability.reject(e);
                      cancelXHRs = null;
                    });
                    cancelXHRs = function(reason) {
                      pdfStream.cancelAllRequests(reason);
                    };
                    return pdfManagerCapability.promise;
                  }
                  function setupDoc(data) {
                    function onSuccess(doc) {
                      ensureNotTerminated();
                      handler.send("GetDoc", {
                        pdfInfo: doc
                      });
                    }
                    function onFailure(ex) {
                      ensureNotTerminated();
                      if (ex instanceof _util.PasswordException) {
                        const task = new WorkerTask(`PasswordException: response ${ex.code}`);
                        startWorkerTask(task);
                        handler.sendWithPromise("PasswordRequest", ex).then(function({
                          password
                        }) {
                          finishWorkerTask(task);
                          pdfManager.updatePassword(password);
                          pdfManagerReady();
                        }).catch(function() {
                          finishWorkerTask(task);
                          handler.send("DocException", ex);
                        });
                      } else if (ex instanceof _util.InvalidPDFException || ex instanceof _util.MissingPDFException || ex instanceof _util.UnexpectedResponseException || ex instanceof _util.UnknownErrorException) {
                        handler.send("DocException", ex);
                      } else {
                        handler.send("DocException", new _util.UnknownErrorException(ex.message, ex.toString()));
                      }
                    }
                    function pdfManagerReady() {
                      ensureNotTerminated();
                      loadDocument(false).then(onSuccess, function(reason) {
                        ensureNotTerminated();
                        if (!(reason instanceof _core_utils.XRefParseException)) {
                          onFailure(reason);
                          return;
                        }
                        pdfManager.requestLoadedStream().then(function() {
                          ensureNotTerminated();
                          loadDocument(true).then(onSuccess, onFailure);
                        });
                      });
                    }
                    ensureNotTerminated();
                    getPdfManager(data).then(function(newPdfManager) {
                      if (terminated) {
                        newPdfManager.terminate(new _util.AbortException("Worker was terminated."));
                        throw new Error("Worker was terminated");
                      }
                      pdfManager = newPdfManager;
                      pdfManager.requestLoadedStream(true).then((stream) => {
                        handler.send("DataLoaded", {
                          length: stream.bytes.byteLength
                        });
                      });
                    }).then(pdfManagerReady, onFailure);
                  }
                  handler.on("GetPage", function(data) {
                    return pdfManager.getPage(data.pageIndex).then(function(page) {
                      return Promise.all([pdfManager.ensure(page, "rotate"), pdfManager.ensure(page, "ref"), pdfManager.ensure(page, "userUnit"), pdfManager.ensure(page, "view")]).then(function([rotate, ref, userUnit, view]) {
                        return {
                          rotate,
                          ref,
                          userUnit,
                          view
                        };
                      });
                    });
                  });
                  handler.on("GetPageIndex", function(data) {
                    const pageRef = _primitives.Ref.get(data.num, data.gen);
                    return pdfManager.ensureCatalog("getPageIndex", [pageRef]);
                  });
                  handler.on("GetDestinations", function(data) {
                    return pdfManager.ensureCatalog("destinations");
                  });
                  handler.on("GetDestination", function(data) {
                    return pdfManager.ensureCatalog("getDestination", [data.id]);
                  });
                  handler.on("GetPageLabels", function(data) {
                    return pdfManager.ensureCatalog("pageLabels");
                  });
                  handler.on("GetPageLayout", function(data) {
                    return pdfManager.ensureCatalog("pageLayout");
                  });
                  handler.on("GetPageMode", function(data) {
                    return pdfManager.ensureCatalog("pageMode");
                  });
                  handler.on("GetViewerPreferences", function(data) {
                    return pdfManager.ensureCatalog("viewerPreferences");
                  });
                  handler.on("GetOpenAction", function(data) {
                    return pdfManager.ensureCatalog("openAction");
                  });
                  handler.on("GetAttachments", function(data) {
                    return pdfManager.ensureCatalog("attachments");
                  });
                  handler.on("GetDocJSActions", function(data) {
                    return pdfManager.ensureCatalog("jsActions");
                  });
                  handler.on("GetPageJSActions", function({
                    pageIndex
                  }) {
                    return pdfManager.getPage(pageIndex).then(function(page) {
                      return pdfManager.ensure(page, "jsActions");
                    });
                  });
                  handler.on("GetOutline", function(data) {
                    return pdfManager.ensureCatalog("documentOutline");
                  });
                  handler.on("GetOptionalContentConfig", function(data) {
                    return pdfManager.ensureCatalog("optionalContentConfig");
                  });
                  handler.on("GetPermissions", function(data) {
                    return pdfManager.ensureCatalog("permissions");
                  });
                  handler.on("GetMetadata", function(data) {
                    return Promise.all([pdfManager.ensureDoc("documentInfo"), pdfManager.ensureCatalog("metadata")]);
                  });
                  handler.on("GetMarkInfo", function(data) {
                    return pdfManager.ensureCatalog("markInfo");
                  });
                  handler.on("GetData", function(data) {
                    return pdfManager.requestLoadedStream().then(function(stream) {
                      return stream.bytes;
                    });
                  });
                  handler.on("GetAnnotations", function({
                    pageIndex,
                    intent
                  }) {
                    return pdfManager.getPage(pageIndex).then(function(page) {
                      const task = new WorkerTask(`GetAnnotations: page ${pageIndex}`);
                      startWorkerTask(task);
                      return page.getAnnotationsData(handler, task, intent).then((data) => {
                        finishWorkerTask(task);
                        return data;
                      }, (reason) => {
                        finishWorkerTask(task);
                        throw reason;
                      });
                    });
                  });
                  handler.on("GetFieldObjects", function(data) {
                    return pdfManager.ensureDoc("fieldObjects");
                  });
                  handler.on("HasJSActions", function(data) {
                    return pdfManager.ensureDoc("hasJSActions");
                  });
                  handler.on("GetCalculationOrderIds", function(data) {
                    return pdfManager.ensureDoc("calculationOrderIds");
                  });
                  handler.on("SaveDocument", async function({
                    isPureXfa,
                    numPages,
                    annotationStorage,
                    filename
                  }) {
                    const globalPromises = [pdfManager.requestLoadedStream(), pdfManager.ensureCatalog("acroForm"), pdfManager.ensureCatalog("acroFormRef"), pdfManager.ensureDoc("startXRef"), pdfManager.ensureDoc("xref"), pdfManager.ensureDoc("linearization"), pdfManager.ensureCatalog("structTreeRoot")];
                    const promises = [];
                    const newAnnotationsByPage = !isPureXfa ? (0, _core_utils.getNewAnnotationsMap)(annotationStorage) : null;
                    const [stream, acroForm, acroFormRef, startXRef, xref, linearization, _structTreeRoot] = await Promise.all(globalPromises);
                    const catalogRef = xref.trailer.getRaw("Root") || null;
                    let structTreeRoot;
                    if (newAnnotationsByPage) {
                      if (!_structTreeRoot) {
                        if (await _struct_tree.StructTreeRoot.canCreateStructureTree({
                          catalogRef,
                          pdfManager,
                          newAnnotationsByPage
                        })) {
                          structTreeRoot = null;
                        }
                      } else if (await _structTreeRoot.canUpdateStructTree({
                        pdfManager,
                        newAnnotationsByPage
                      })) {
                        structTreeRoot = _structTreeRoot;
                      }
                      const imagePromises = _annotation.AnnotationFactory.generateImages(annotationStorage.values(), xref, pdfManager.evaluatorOptions.isOffscreenCanvasSupported);
                      const newAnnotationPromises = structTreeRoot === void 0 ? promises : [];
                      for (const [pageIndex, annotations] of newAnnotationsByPage) {
                        newAnnotationPromises.push(pdfManager.getPage(pageIndex).then((page) => {
                          const task = new WorkerTask(`Save (editor): page ${pageIndex}`);
                          return page.saveNewAnnotations(handler, task, annotations, imagePromises).finally(function() {
                            finishWorkerTask(task);
                          });
                        }));
                      }
                      if (structTreeRoot === null) {
                        promises.push(Promise.all(newAnnotationPromises).then(async (newRefs2) => {
                          await _struct_tree.StructTreeRoot.createStructureTree({
                            newAnnotationsByPage,
                            xref,
                            catalogRef,
                            pdfManager,
                            newRefs: newRefs2
                          });
                          return newRefs2;
                        }));
                      } else if (structTreeRoot) {
                        promises.push(Promise.all(newAnnotationPromises).then(async (newRefs2) => {
                          await structTreeRoot.updateStructureTree({
                            newAnnotationsByPage,
                            pdfManager,
                            newRefs: newRefs2
                          });
                          return newRefs2;
                        }));
                      }
                    }
                    if (isPureXfa) {
                      promises.push(pdfManager.serializeXfaData(annotationStorage));
                    } else {
                      for (let pageIndex = 0; pageIndex < numPages; pageIndex++) {
                        promises.push(pdfManager.getPage(pageIndex).then(function(page) {
                          const task = new WorkerTask(`Save: page ${pageIndex}`);
                          return page.save(handler, task, annotationStorage).finally(function() {
                            finishWorkerTask(task);
                          });
                        }));
                      }
                    }
                    const refs = await Promise.all(promises);
                    let newRefs = [];
                    let xfaData = null;
                    if (isPureXfa) {
                      xfaData = refs[0];
                      if (!xfaData) {
                        return stream.bytes;
                      }
                    } else {
                      newRefs = refs.flat(2);
                      if (newRefs.length === 0) {
                        return stream.bytes;
                      }
                    }
                    const needAppearances = acroFormRef && acroForm instanceof _primitives.Dict && newRefs.some((ref) => ref.needAppearances);
                    const xfa = acroForm instanceof _primitives.Dict && acroForm.get("XFA") || null;
                    let xfaDatasetsRef = null;
                    let hasXfaDatasetsEntry = false;
                    if (Array.isArray(xfa)) {
                      for (let i = 0, ii = xfa.length; i < ii; i += 2) {
                        if (xfa[i] === "datasets") {
                          xfaDatasetsRef = xfa[i + 1];
                          hasXfaDatasetsEntry = true;
                        }
                      }
                      if (xfaDatasetsRef === null) {
                        xfaDatasetsRef = xref.getNewTemporaryRef();
                      }
                    } else if (xfa) {
                      (0, _util.warn)("Unsupported XFA type.");
                    }
                    let newXrefInfo = /* @__PURE__ */ Object.create(null);
                    if (xref.trailer) {
                      const infoObj = /* @__PURE__ */ Object.create(null);
                      const xrefInfo = xref.trailer.get("Info") || null;
                      if (xrefInfo instanceof _primitives.Dict) {
                        xrefInfo.forEach((key, value) => {
                          if (typeof value === "string") {
                            infoObj[key] = (0, _util.stringToPDFString)(value);
                          }
                        });
                      }
                      newXrefInfo = {
                        rootRef: catalogRef,
                        encryptRef: xref.trailer.getRaw("Encrypt") || null,
                        newRef: xref.getNewTemporaryRef(),
                        infoRef: xref.trailer.getRaw("Info") || null,
                        info: infoObj,
                        fileIds: xref.trailer.get("ID") || null,
                        startXRef: linearization ? startXRef : xref.lastXRefStreamPos ?? startXRef,
                        filename
                      };
                    }
                    return (0, _writer.incrementalUpdate)({
                      originalData: stream.bytes,
                      xrefInfo: newXrefInfo,
                      newRefs,
                      xref,
                      hasXfa: !!xfa,
                      xfaDatasetsRef,
                      hasXfaDatasetsEntry,
                      needAppearances,
                      acroFormRef,
                      acroForm,
                      xfaData
                    }).finally(() => {
                      xref.resetNewTemporaryRef();
                    });
                  });
                  handler.on("GetOperatorList", function(data, sink) {
                    const pageIndex = data.pageIndex;
                    pdfManager.getPage(pageIndex).then(function(page) {
                      const task = new WorkerTask(`GetOperatorList: page ${pageIndex}`);
                      startWorkerTask(task);
                      const start = verbosity >= _util.VerbosityLevel.INFOS ? Date.now() : 0;
                      page.getOperatorList({
                        handler,
                        sink,
                        task,
                        intent: data.intent,
                        cacheKey: data.cacheKey,
                        annotationStorage: data.annotationStorage
                      }).then(function(operatorListInfo) {
                        finishWorkerTask(task);
                        if (start) {
                          (0, _util.info)(`page=${pageIndex + 1} - getOperatorList: time=${Date.now() - start}ms, len=${operatorListInfo.length}`);
                        }
                        sink.close();
                      }, function(reason) {
                        finishWorkerTask(task);
                        if (task.terminated) {
                          return;
                        }
                        sink.error(reason);
                      });
                    });
                  });
                  handler.on("GetTextContent", function(data, sink) {
                    const {
                      pageIndex,
                      includeMarkedContent,
                      disableNormalization
                    } = data;
                    pdfManager.getPage(pageIndex).then(function(page) {
                      const task = new WorkerTask("GetTextContent: page " + pageIndex);
                      startWorkerTask(task);
                      const start = verbosity >= _util.VerbosityLevel.INFOS ? Date.now() : 0;
                      page.extractTextContent({
                        handler,
                        task,
                        sink,
                        includeMarkedContent,
                        disableNormalization
                      }).then(function() {
                        finishWorkerTask(task);
                        if (start) {
                          (0, _util.info)(`page=${pageIndex + 1} - getTextContent: time=${Date.now() - start}ms`);
                        }
                        sink.close();
                      }, function(reason) {
                        finishWorkerTask(task);
                        if (task.terminated) {
                          return;
                        }
                        sink.error(reason);
                      });
                    });
                  });
                  handler.on("GetStructTree", function(data) {
                    return pdfManager.getPage(data.pageIndex).then(function(page) {
                      return pdfManager.ensure(page, "getStructTree");
                    });
                  });
                  handler.on("FontFallback", function(data) {
                    return pdfManager.fontFallback(data.id, handler);
                  });
                  handler.on("Cleanup", function(data) {
                    return pdfManager.cleanup(true);
                  });
                  handler.on("Terminate", function(data) {
                    terminated = true;
                    const waitOn = [];
                    if (pdfManager) {
                      pdfManager.terminate(new _util.AbortException("Worker was terminated."));
                      const cleanupPromise = pdfManager.cleanup();
                      waitOn.push(cleanupPromise);
                      pdfManager = null;
                    } else {
                      (0, _cleanup_helper.clearGlobalCaches)();
                    }
                    if (cancelXHRs) {
                      cancelXHRs(new _util.AbortException("Worker was terminated."));
                    }
                    for (const task of WorkerTasks) {
                      waitOn.push(task.finished);
                      task.terminate();
                    }
                    return Promise.all(waitOn).then(function() {
                      handler.destroy();
                      handler = null;
                    });
                  });
                  handler.on("Ready", function(data) {
                    setupDoc(docParams);
                    docParams = null;
                  });
                  return workerHandlerName;
                }
                static initializeFromPort(port) {
                  const handler = new _message_handler.MessageHandler("worker", "main", port);
                  WorkerMessageHandler.setup(handler, port);
                  handler.send("ready", null);
                }
              }
              exports2.WorkerMessageHandler = WorkerMessageHandler;
              function isMessagePort(maybePort) {
                return typeof maybePort.postMessage === "function" && "onmessage" in maybePort;
              }
              if (typeof window === "undefined" && !_util.isNodeJS && typeof self !== "undefined" && isMessagePort(self)) {
                WorkerMessageHandler.initializeFromPort(self);
              }
            },
            /* 2 */
            /***/
            (__unused_webpack_module, exports2) => {
              var _settled;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.VerbosityLevel = exports2.Util = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.TextRenderingMode = exports2.RenderingIntentFlag = exports2.PromiseCapability = exports2.PermissionFlag = exports2.PasswordResponses = exports2.PasswordException = exports2.PageActionEventType = exports2.OPS = exports2.MissingPDFException = exports2.MAX_IMAGE_SIZE_TO_CACHE = exports2.LINE_FACTOR = exports2.LINE_DESCENT_FACTOR = exports2.InvalidPDFException = exports2.ImageKind = exports2.IDENTITY_MATRIX = exports2.FormatError = exports2.FeatureTest = exports2.FONT_IDENTITY_MATRIX = exports2.DocumentActionEventType = exports2.CMapCompressionType = exports2.BaseException = exports2.BASELINE_FACTOR = exports2.AnnotationType = exports2.AnnotationReplyType = exports2.AnnotationPrefix = exports2.AnnotationMode = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationEditorType = exports2.AnnotationEditorPrefix = exports2.AnnotationEditorParamsType = exports2.AnnotationBorderStyleType = exports2.AnnotationActionEventType = exports2.AbortException = void 0;
              exports2.assert = assert;
              exports2.bytesToString = bytesToString;
              exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
              exports2.getModificationDate = getModificationDate;
              exports2.getUuid = getUuid;
              exports2.getVerbosityLevel = getVerbosityLevel;
              exports2.info = info;
              exports2.isArrayBuffer = isArrayBuffer;
              exports2.isArrayEqual = isArrayEqual;
              exports2.isNodeJS = void 0;
              exports2.normalizeUnicode = normalizeUnicode;
              exports2.objectFromMap = objectFromMap;
              exports2.objectSize = objectSize;
              exports2.setVerbosityLevel = setVerbosityLevel;
              exports2.shadow = shadow;
              exports2.string32 = string32;
              exports2.stringToBytes = stringToBytes;
              exports2.stringToPDFString = stringToPDFString;
              exports2.stringToUTF8String = stringToUTF8String;
              exports2.unreachable = unreachable;
              exports2.utf8StringToString = utf8StringToString;
              exports2.warn = warn;
              const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
              exports2.isNodeJS = isNodeJS;
              const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
              exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
              const FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
              exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
              const MAX_IMAGE_SIZE_TO_CACHE = 1e7;
              exports2.MAX_IMAGE_SIZE_TO_CACHE = MAX_IMAGE_SIZE_TO_CACHE;
              const LINE_FACTOR = 1.35;
              exports2.LINE_FACTOR = LINE_FACTOR;
              const LINE_DESCENT_FACTOR = 0.35;
              exports2.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;
              const BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;
              exports2.BASELINE_FACTOR = BASELINE_FACTOR;
              const RenderingIntentFlag = {
                ANY: 1,
                DISPLAY: 2,
                PRINT: 4,
                SAVE: 8,
                ANNOTATIONS_FORMS: 16,
                ANNOTATIONS_STORAGE: 32,
                ANNOTATIONS_DISABLE: 64,
                OPLIST: 256
              };
              exports2.RenderingIntentFlag = RenderingIntentFlag;
              const AnnotationMode = {
                DISABLE: 0,
                ENABLE: 1,
                ENABLE_FORMS: 2,
                ENABLE_STORAGE: 3
              };
              exports2.AnnotationMode = AnnotationMode;
              const AnnotationEditorPrefix = "pdfjs_internal_editor_";
              exports2.AnnotationEditorPrefix = AnnotationEditorPrefix;
              const AnnotationEditorType = {
                DISABLE: -1,
                NONE: 0,
                FREETEXT: 3,
                STAMP: 13,
                INK: 15
              };
              exports2.AnnotationEditorType = AnnotationEditorType;
              const AnnotationEditorParamsType = {
                RESIZE: 1,
                CREATE: 2,
                FREETEXT_SIZE: 11,
                FREETEXT_COLOR: 12,
                FREETEXT_OPACITY: 13,
                INK_COLOR: 21,
                INK_THICKNESS: 22,
                INK_OPACITY: 23
              };
              exports2.AnnotationEditorParamsType = AnnotationEditorParamsType;
              const PermissionFlag = {
                PRINT: 4,
                MODIFY_CONTENTS: 8,
                COPY: 16,
                MODIFY_ANNOTATIONS: 32,
                FILL_INTERACTIVE_FORMS: 256,
                COPY_FOR_ACCESSIBILITY: 512,
                ASSEMBLE: 1024,
                PRINT_HIGH_QUALITY: 2048
              };
              exports2.PermissionFlag = PermissionFlag;
              const TextRenderingMode = {
                FILL: 0,
                STROKE: 1,
                FILL_STROKE: 2,
                INVISIBLE: 3,
                FILL_ADD_TO_PATH: 4,
                STROKE_ADD_TO_PATH: 5,
                FILL_STROKE_ADD_TO_PATH: 6,
                ADD_TO_PATH: 7,
                FILL_STROKE_MASK: 3,
                ADD_TO_PATH_FLAG: 4
              };
              exports2.TextRenderingMode = TextRenderingMode;
              const ImageKind = {
                GRAYSCALE_1BPP: 1,
                RGB_24BPP: 2,
                RGBA_32BPP: 3
              };
              exports2.ImageKind = ImageKind;
              const AnnotationType = {
                TEXT: 1,
                LINK: 2,
                FREETEXT: 3,
                LINE: 4,
                SQUARE: 5,
                CIRCLE: 6,
                POLYGON: 7,
                POLYLINE: 8,
                HIGHLIGHT: 9,
                UNDERLINE: 10,
                SQUIGGLY: 11,
                STRIKEOUT: 12,
                STAMP: 13,
                CARET: 14,
                INK: 15,
                POPUP: 16,
                FILEATTACHMENT: 17,
                SOUND: 18,
                MOVIE: 19,
                WIDGET: 20,
                SCREEN: 21,
                PRINTERMARK: 22,
                TRAPNET: 23,
                WATERMARK: 24,
                THREED: 25,
                REDACT: 26
              };
              exports2.AnnotationType = AnnotationType;
              const AnnotationReplyType = {
                GROUP: "Group",
                REPLY: "R"
              };
              exports2.AnnotationReplyType = AnnotationReplyType;
              const AnnotationFlag = {
                INVISIBLE: 1,
                HIDDEN: 2,
                PRINT: 4,
                NOZOOM: 8,
                NOROTATE: 16,
                NOVIEW: 32,
                READONLY: 64,
                LOCKED: 128,
                TOGGLENOVIEW: 256,
                LOCKEDCONTENTS: 512
              };
              exports2.AnnotationFlag = AnnotationFlag;
              const AnnotationFieldFlag = {
                READONLY: 1,
                REQUIRED: 2,
                NOEXPORT: 4,
                MULTILINE: 4096,
                PASSWORD: 8192,
                NOTOGGLETOOFF: 16384,
                RADIO: 32768,
                PUSHBUTTON: 65536,
                COMBO: 131072,
                EDIT: 262144,
                SORT: 524288,
                FILESELECT: 1048576,
                MULTISELECT: 2097152,
                DONOTSPELLCHECK: 4194304,
                DONOTSCROLL: 8388608,
                COMB: 16777216,
                RICHTEXT: 33554432,
                RADIOSINUNISON: 33554432,
                COMMITONSELCHANGE: 67108864
              };
              exports2.AnnotationFieldFlag = AnnotationFieldFlag;
              const AnnotationBorderStyleType = {
                SOLID: 1,
                DASHED: 2,
                BEVELED: 3,
                INSET: 4,
                UNDERLINE: 5
              };
              exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
              const AnnotationActionEventType = {
                E: "Mouse Enter",
                X: "Mouse Exit",
                D: "Mouse Down",
                U: "Mouse Up",
                Fo: "Focus",
                Bl: "Blur",
                PO: "PageOpen",
                PC: "PageClose",
                PV: "PageVisible",
                PI: "PageInvisible",
                K: "Keystroke",
                F: "Format",
                V: "Validate",
                C: "Calculate"
              };
              exports2.AnnotationActionEventType = AnnotationActionEventType;
              const DocumentActionEventType = {
                WC: "WillClose",
                WS: "WillSave",
                DS: "DidSave",
                WP: "WillPrint",
                DP: "DidPrint"
              };
              exports2.DocumentActionEventType = DocumentActionEventType;
              const PageActionEventType = {
                O: "PageOpen",
                C: "PageClose"
              };
              exports2.PageActionEventType = PageActionEventType;
              const VerbosityLevel = {
                ERRORS: 0,
                WARNINGS: 1,
                INFOS: 5
              };
              exports2.VerbosityLevel = VerbosityLevel;
              const CMapCompressionType = {
                NONE: 0,
                BINARY: 1
              };
              exports2.CMapCompressionType = CMapCompressionType;
              const OPS = {
                dependency: 1,
                setLineWidth: 2,
                setLineCap: 3,
                setLineJoin: 4,
                setMiterLimit: 5,
                setDash: 6,
                setRenderingIntent: 7,
                setFlatness: 8,
                setGState: 9,
                save: 10,
                restore: 11,
                transform: 12,
                moveTo: 13,
                lineTo: 14,
                curveTo: 15,
                curveTo2: 16,
                curveTo3: 17,
                closePath: 18,
                rectangle: 19,
                stroke: 20,
                closeStroke: 21,
                fill: 22,
                eoFill: 23,
                fillStroke: 24,
                eoFillStroke: 25,
                closeFillStroke: 26,
                closeEOFillStroke: 27,
                endPath: 28,
                clip: 29,
                eoClip: 30,
                beginText: 31,
                endText: 32,
                setCharSpacing: 33,
                setWordSpacing: 34,
                setHScale: 35,
                setLeading: 36,
                setFont: 37,
                setTextRenderingMode: 38,
                setTextRise: 39,
                moveText: 40,
                setLeadingMoveText: 41,
                setTextMatrix: 42,
                nextLine: 43,
                showText: 44,
                showSpacedText: 45,
                nextLineShowText: 46,
                nextLineSetSpacingShowText: 47,
                setCharWidth: 48,
                setCharWidthAndBounds: 49,
                setStrokeColorSpace: 50,
                setFillColorSpace: 51,
                setStrokeColor: 52,
                setStrokeColorN: 53,
                setFillColor: 54,
                setFillColorN: 55,
                setStrokeGray: 56,
                setFillGray: 57,
                setStrokeRGBColor: 58,
                setFillRGBColor: 59,
                setStrokeCMYKColor: 60,
                setFillCMYKColor: 61,
                shadingFill: 62,
                beginInlineImage: 63,
                beginImageData: 64,
                endInlineImage: 65,
                paintXObject: 66,
                markPoint: 67,
                markPointProps: 68,
                beginMarkedContent: 69,
                beginMarkedContentProps: 70,
                endMarkedContent: 71,
                beginCompat: 72,
                endCompat: 73,
                paintFormXObjectBegin: 74,
                paintFormXObjectEnd: 75,
                beginGroup: 76,
                endGroup: 77,
                beginAnnotation: 80,
                endAnnotation: 81,
                paintImageMaskXObject: 83,
                paintImageMaskXObjectGroup: 84,
                paintImageXObject: 85,
                paintInlineImageXObject: 86,
                paintInlineImageXObjectGroup: 87,
                paintImageXObjectRepeat: 88,
                paintImageMaskXObjectRepeat: 89,
                paintSolidColorImageMask: 90,
                constructPath: 91
              };
              exports2.OPS = OPS;
              const PasswordResponses = {
                NEED_PASSWORD: 1,
                INCORRECT_PASSWORD: 2
              };
              exports2.PasswordResponses = PasswordResponses;
              let verbosity = VerbosityLevel.WARNINGS;
              function setVerbosityLevel(level) {
                if (Number.isInteger(level)) {
                  verbosity = level;
                }
              }
              function getVerbosityLevel() {
                return verbosity;
              }
              function info(msg) {
                if (verbosity >= VerbosityLevel.INFOS) {
                  console.log(`Info: ${msg}`);
                }
              }
              function warn(msg) {
                if (verbosity >= VerbosityLevel.WARNINGS) {
                  console.log(`Warning: ${msg}`);
                }
              }
              function unreachable(msg) {
                throw new Error(msg);
              }
              function assert(cond, msg) {
                if (!cond) {
                  unreachable(msg);
                }
              }
              function _isValidProtocol(url) {
                switch (url == null ? void 0 : url.protocol) {
                  case "http:":
                  case "https:":
                  case "ftp:":
                  case "mailto:":
                  case "tel:":
                    return true;
                  default:
                    return false;
                }
              }
              function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
                if (!url) {
                  return null;
                }
                try {
                  if (options && typeof url === "string") {
                    if (options.addDefaultProtocol && url.startsWith("www.")) {
                      const dots = url.match(/\./g);
                      if ((dots == null ? void 0 : dots.length) >= 2) {
                        url = `http://${url}`;
                      }
                    }
                    if (options.tryConvertEncoding) {
                      try {
                        url = stringToUTF8String(url);
                      } catch {
                      }
                    }
                  }
                  const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                  if (_isValidProtocol(absoluteUrl)) {
                    return absoluteUrl;
                  }
                } catch {
                }
                return null;
              }
              function shadow(obj, prop, value, nonSerializable = false) {
                Object.defineProperty(obj, prop, {
                  value,
                  enumerable: !nonSerializable,
                  configurable: true,
                  writable: false
                });
                return value;
              }
              const BaseException = function BaseExceptionClosure() {
                function BaseException2(message, name) {
                  if (this.constructor === BaseException2) {
                    unreachable("Cannot initialize BaseException.");
                  }
                  this.message = message;
                  this.name = name;
                }
                BaseException2.prototype = new Error();
                BaseException2.constructor = BaseException2;
                return BaseException2;
              }();
              exports2.BaseException = BaseException;
              class PasswordException extends BaseException {
                constructor(msg, code) {
                  super(msg, "PasswordException");
                  this.code = code;
                }
              }
              exports2.PasswordException = PasswordException;
              class UnknownErrorException extends BaseException {
                constructor(msg, details) {
                  super(msg, "UnknownErrorException");
                  this.details = details;
                }
              }
              exports2.UnknownErrorException = UnknownErrorException;
              class InvalidPDFException extends BaseException {
                constructor(msg) {
                  super(msg, "InvalidPDFException");
                }
              }
              exports2.InvalidPDFException = InvalidPDFException;
              class MissingPDFException extends BaseException {
                constructor(msg) {
                  super(msg, "MissingPDFException");
                }
              }
              exports2.MissingPDFException = MissingPDFException;
              class UnexpectedResponseException extends BaseException {
                constructor(msg, status) {
                  super(msg, "UnexpectedResponseException");
                  this.status = status;
                }
              }
              exports2.UnexpectedResponseException = UnexpectedResponseException;
              class FormatError extends BaseException {
                constructor(msg) {
                  super(msg, "FormatError");
                }
              }
              exports2.FormatError = FormatError;
              class AbortException extends BaseException {
                constructor(msg) {
                  super(msg, "AbortException");
                }
              }
              exports2.AbortException = AbortException;
              function bytesToString(bytes) {
                if (typeof bytes !== "object" || (bytes == null ? void 0 : bytes.length) === void 0) {
                  unreachable("Invalid argument for bytesToString");
                }
                const length = bytes.length;
                const MAX_ARGUMENT_COUNT = 8192;
                if (length < MAX_ARGUMENT_COUNT) {
                  return String.fromCharCode.apply(null, bytes);
                }
                const strBuf = [];
                for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
                  const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
                  const chunk = bytes.subarray(i, chunkEnd);
                  strBuf.push(String.fromCharCode.apply(null, chunk));
                }
                return strBuf.join("");
              }
              function stringToBytes(str) {
                if (typeof str !== "string") {
                  unreachable("Invalid argument for stringToBytes");
                }
                const length = str.length;
                const bytes = new Uint8Array(length);
                for (let i = 0; i < length; ++i) {
                  bytes[i] = str.charCodeAt(i) & 255;
                }
                return bytes;
              }
              function string32(value) {
                return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
              }
              function objectSize(obj) {
                return Object.keys(obj).length;
              }
              function objectFromMap(map) {
                const obj = /* @__PURE__ */ Object.create(null);
                for (const [key, value] of map) {
                  obj[key] = value;
                }
                return obj;
              }
              function isLittleEndian() {
                const buffer8 = new Uint8Array(4);
                buffer8[0] = 1;
                const view32 = new Uint32Array(buffer8.buffer, 0, 1);
                return view32[0] === 1;
              }
              function isEvalSupported() {
                try {
                  new Function("");
                  return true;
                } catch {
                  return false;
                }
              }
              class FeatureTest {
                static get isLittleEndian() {
                  return shadow(this, "isLittleEndian", isLittleEndian());
                }
                static get isEvalSupported() {
                  return shadow(this, "isEvalSupported", isEvalSupported());
                }
                static get isOffscreenCanvasSupported() {
                  return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
                }
                static get platform() {
                  if (typeof navigator === "undefined") {
                    return shadow(this, "platform", {
                      isWin: false,
                      isMac: false
                    });
                  }
                  return shadow(this, "platform", {
                    isWin: navigator.platform.includes("Win"),
                    isMac: navigator.platform.includes("Mac")
                  });
                }
                static get isCSSRoundSupported() {
                  var _a, _b;
                  return shadow(this, "isCSSRoundSupported", (_b = (_a = globalThis.CSS) == null ? void 0 : _a.supports) == null ? void 0 : _b.call(_a, "width: round(1.5px, 1px)"));
                }
              }
              exports2.FeatureTest = FeatureTest;
              const hexNumbers = [...Array(256).keys()].map((n) => n.toString(16).padStart(2, "0"));
              class Util {
                static makeHexColor(r, g, b) {
                  return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
                }
                static scaleMinMax(transform, minMax) {
                  let temp;
                  if (transform[0]) {
                    if (transform[0] < 0) {
                      temp = minMax[0];
                      minMax[0] = minMax[1];
                      minMax[1] = temp;
                    }
                    minMax[0] *= transform[0];
                    minMax[1] *= transform[0];
                    if (transform[3] < 0) {
                      temp = minMax[2];
                      minMax[2] = minMax[3];
                      minMax[3] = temp;
                    }
                    minMax[2] *= transform[3];
                    minMax[3] *= transform[3];
                  } else {
                    temp = minMax[0];
                    minMax[0] = minMax[2];
                    minMax[2] = temp;
                    temp = minMax[1];
                    minMax[1] = minMax[3];
                    minMax[3] = temp;
                    if (transform[1] < 0) {
                      temp = minMax[2];
                      minMax[2] = minMax[3];
                      minMax[3] = temp;
                    }
                    minMax[2] *= transform[1];
                    minMax[3] *= transform[1];
                    if (transform[2] < 0) {
                      temp = minMax[0];
                      minMax[0] = minMax[1];
                      minMax[1] = temp;
                    }
                    minMax[0] *= transform[2];
                    minMax[1] *= transform[2];
                  }
                  minMax[0] += transform[4];
                  minMax[1] += transform[4];
                  minMax[2] += transform[5];
                  minMax[3] += transform[5];
                }
                static transform(m1, m2) {
                  return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
                }
                static applyTransform(p, m) {
                  const xt = p[0] * m[0] + p[1] * m[2] + m[4];
                  const yt = p[0] * m[1] + p[1] * m[3] + m[5];
                  return [xt, yt];
                }
                static applyInverseTransform(p, m) {
                  const d = m[0] * m[3] - m[1] * m[2];
                  const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                  const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                  return [xt, yt];
                }
                static getAxialAlignedBoundingBox(r, m) {
                  const p1 = this.applyTransform(r, m);
                  const p2 = this.applyTransform(r.slice(2, 4), m);
                  const p3 = this.applyTransform([r[0], r[3]], m);
                  const p4 = this.applyTransform([r[2], r[1]], m);
                  return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
                }
                static inverseTransform(m) {
                  const d = m[0] * m[3] - m[1] * m[2];
                  return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
                }
                static singularValueDecompose2dScale(m) {
                  const transpose = [m[0], m[2], m[1], m[3]];
                  const a = m[0] * transpose[0] + m[1] * transpose[2];
                  const b = m[0] * transpose[1] + m[1] * transpose[3];
                  const c = m[2] * transpose[0] + m[3] * transpose[2];
                  const d = m[2] * transpose[1] + m[3] * transpose[3];
                  const first = (a + d) / 2;
                  const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
                  const sx = first + second || 1;
                  const sy = first - second || 1;
                  return [Math.sqrt(sx), Math.sqrt(sy)];
                }
                static normalizeRect(rect) {
                  const r = rect.slice(0);
                  if (rect[0] > rect[2]) {
                    r[0] = rect[2];
                    r[2] = rect[0];
                  }
                  if (rect[1] > rect[3]) {
                    r[1] = rect[3];
                    r[3] = rect[1];
                  }
                  return r;
                }
                static intersect(rect1, rect2) {
                  const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
                  const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
                  if (xLow > xHigh) {
                    return null;
                  }
                  const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
                  const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
                  if (yLow > yHigh) {
                    return null;
                  }
                  return [xLow, yLow, xHigh, yHigh];
                }
                static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
                  const tvalues = [], bounds = [[], []];
                  let a, b, c, t, t1, t2, b2ac, sqrtb2ac;
                  for (let i = 0; i < 2; ++i) {
                    if (i === 0) {
                      b = 6 * x0 - 12 * x1 + 6 * x2;
                      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                      c = 3 * x1 - 3 * x0;
                    } else {
                      b = 6 * y0 - 12 * y1 + 6 * y2;
                      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                      c = 3 * y1 - 3 * y0;
                    }
                    if (Math.abs(a) < 1e-12) {
                      if (Math.abs(b) < 1e-12) {
                        continue;
                      }
                      t = -c / b;
                      if (0 < t && t < 1) {
                        tvalues.push(t);
                      }
                      continue;
                    }
                    b2ac = b * b - 4 * c * a;
                    sqrtb2ac = Math.sqrt(b2ac);
                    if (b2ac < 0) {
                      continue;
                    }
                    t1 = (-b + sqrtb2ac) / (2 * a);
                    if (0 < t1 && t1 < 1) {
                      tvalues.push(t1);
                    }
                    t2 = (-b - sqrtb2ac) / (2 * a);
                    if (0 < t2 && t2 < 1) {
                      tvalues.push(t2);
                    }
                  }
                  let j = tvalues.length, mt;
                  const jlen = j;
                  while (j--) {
                    t = tvalues[j];
                    mt = 1 - t;
                    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
                    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
                  }
                  bounds[0][jlen] = x0;
                  bounds[1][jlen] = y0;
                  bounds[0][jlen + 1] = x3;
                  bounds[1][jlen + 1] = y3;
                  bounds[0].length = bounds[1].length = jlen + 2;
                  return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];
                }
              }
              exports2.Util = Util;
              const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
              function stringToPDFString(str) {
                if (str[0] >= "") {
                  let encoding;
                  if (str[0] === "" && str[1] === "") {
                    encoding = "utf-16be";
                  } else if (str[0] === "" && str[1] === "") {
                    encoding = "utf-16le";
                  } else if (str[0] === "" && str[1] === "" && str[2] === "") {
                    encoding = "utf-8";
                  }
                  if (encoding) {
                    try {
                      const decoder = new TextDecoder(encoding, {
                        fatal: true
                      });
                      const buffer = stringToBytes(str);
                      return decoder.decode(buffer);
                    } catch (ex) {
                      warn(`stringToPDFString: "${ex}".`);
                    }
                  }
                }
                const strBuf = [];
                for (let i = 0, ii = str.length; i < ii; i++) {
                  const code = PDFStringTranslateTable[str.charCodeAt(i)];
                  strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
                }
                return strBuf.join("");
              }
              function stringToUTF8String(str) {
                return decodeURIComponent(escape(str));
              }
              function utf8StringToString(str) {
                return unescape(encodeURIComponent(str));
              }
              function isArrayBuffer(v) {
                return typeof v === "object" && (v == null ? void 0 : v.byteLength) !== void 0;
              }
              function isArrayEqual(arr1, arr2) {
                if (arr1.length !== arr2.length) {
                  return false;
                }
                for (let i = 0, ii = arr1.length; i < ii; i++) {
                  if (arr1[i] !== arr2[i]) {
                    return false;
                  }
                }
                return true;
              }
              function getModificationDate(date = /* @__PURE__ */ new Date()) {
                const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
                return buffer.join("");
              }
              class PromiseCapability {
                constructor() {
                  __privateAdd(this, _settled, false);
                  this.promise = new Promise((resolve, reject) => {
                    this.resolve = (data) => {
                      __privateSet(this, _settled, true);
                      resolve(data);
                    };
                    this.reject = (reason) => {
                      __privateSet(this, _settled, true);
                      reject(reason);
                    };
                  });
                }
                get settled() {
                  return __privateGet(this, _settled);
                }
              }
              _settled = new WeakMap();
              exports2.PromiseCapability = PromiseCapability;
              let NormalizeRegex = null;
              let NormalizationMap = null;
              function normalizeUnicode(str) {
                if (!NormalizeRegex) {
                  NormalizeRegex = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
                  NormalizationMap = /* @__PURE__ */ new Map([["", "t"]]);
                }
                return str.replaceAll(NormalizeRegex, (_, p1, p2) => {
                  return p1 ? p1.normalize("NFKC") : NormalizationMap.get(p2);
                });
              }
              function getUuid() {
                if (typeof crypto !== "undefined" && typeof (crypto == null ? void 0 : crypto.randomUUID) === "function") {
                  return crypto.randomUUID();
                }
                const buf = new Uint8Array(32);
                if (typeof crypto !== "undefined" && typeof (crypto == null ? void 0 : crypto.getRandomValues) === "function") {
                  crypto.getRandomValues(buf);
                } else {
                  for (let i = 0; i < 32; i++) {
                    buf[i] = Math.floor(Math.random() * 255);
                  }
                }
                return bytesToString(buf);
              }
              const AnnotationPrefix = "pdfjs_internal_id_";
              exports2.AnnotationPrefix = AnnotationPrefix;
            },
            /* 3 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XRefParseException = exports2.XRefEntryException = exports2.ParserEOFException = exports2.PDF_VERSION_REGEXP = exports2.MissingDataException = void 0;
              exports2.arrayBuffersToBytes = arrayBuffersToBytes;
              exports2.collectActions = collectActions;
              exports2.encodeToXmlString = encodeToXmlString;
              exports2.escapePDFName = escapePDFName;
              exports2.escapeString = escapeString;
              exports2.getInheritableProperty = getInheritableProperty;
              exports2.getLookupTableFactory = getLookupTableFactory;
              exports2.getNewAnnotationsMap = getNewAnnotationsMap;
              exports2.getRotationMatrix = getRotationMatrix;
              exports2.isAscii = isAscii;
              exports2.isWhiteSpace = isWhiteSpace;
              exports2.log2 = log2;
              exports2.numberToString = numberToString;
              exports2.parseXFAPath = parseXFAPath;
              exports2.readInt8 = readInt8;
              exports2.readUint16 = readUint16;
              exports2.readUint32 = readUint32;
              exports2.recoverJsURL = recoverJsURL;
              exports2.stringToUTF16HexString = stringToUTF16HexString;
              exports2.stringToUTF16String = stringToUTF16String;
              exports2.toRomanNumerals = toRomanNumerals;
              exports2.validateCSSFont = validateCSSFont;
              exports2.validateFontName = validateFontName;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(4);
              var _base_stream = __w_pdfjs_require__2(5);
              const PDF_VERSION_REGEXP = /^[1-9]\.\d$/;
              exports2.PDF_VERSION_REGEXP = PDF_VERSION_REGEXP;
              function getLookupTableFactory(initializer) {
                let lookup;
                return function() {
                  if (initializer) {
                    lookup = /* @__PURE__ */ Object.create(null);
                    initializer(lookup);
                    initializer = null;
                  }
                  return lookup;
                };
              }
              class MissingDataException extends _util.BaseException {
                constructor(begin, end) {
                  super(`Missing data [${begin}, ${end})`, "MissingDataException");
                  this.begin = begin;
                  this.end = end;
                }
              }
              exports2.MissingDataException = MissingDataException;
              class ParserEOFException extends _util.BaseException {
                constructor(msg) {
                  super(msg, "ParserEOFException");
                }
              }
              exports2.ParserEOFException = ParserEOFException;
              class XRefEntryException extends _util.BaseException {
                constructor(msg) {
                  super(msg, "XRefEntryException");
                }
              }
              exports2.XRefEntryException = XRefEntryException;
              class XRefParseException extends _util.BaseException {
                constructor(msg) {
                  super(msg, "XRefParseException");
                }
              }
              exports2.XRefParseException = XRefParseException;
              function arrayBuffersToBytes(arr) {
                const length = arr.length;
                if (length === 0) {
                  return new Uint8Array(0);
                }
                if (length === 1) {
                  return new Uint8Array(arr[0]);
                }
                let dataLength = 0;
                for (let i = 0; i < length; i++) {
                  dataLength += arr[i].byteLength;
                }
                const data = new Uint8Array(dataLength);
                let pos = 0;
                for (let i = 0; i < length; i++) {
                  const item = new Uint8Array(arr[i]);
                  data.set(item, pos);
                  pos += item.byteLength;
                }
                return data;
              }
              function getInheritableProperty({
                dict,
                key,
                getArray = false,
                stopWhenFound = true
              }) {
                let values;
                const visited = new _primitives.RefSet();
                while (dict instanceof _primitives.Dict && !(dict.objId && visited.has(dict.objId))) {
                  if (dict.objId) {
                    visited.put(dict.objId);
                  }
                  const value = getArray ? dict.getArray(key) : dict.get(key);
                  if (value !== void 0) {
                    if (stopWhenFound) {
                      return value;
                    }
                    (values || (values = [])).push(value);
                  }
                  dict = dict.get("Parent");
                }
                return values;
              }
              const ROMAN_NUMBER_MAP = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
              function toRomanNumerals(number, lowerCase = false) {
                (0, _util.assert)(Number.isInteger(number) && number > 0, "The number should be a positive integer.");
                const romanBuf = [];
                let pos;
                while (number >= 1e3) {
                  number -= 1e3;
                  romanBuf.push("M");
                }
                pos = number / 100 | 0;
                number %= 100;
                romanBuf.push(ROMAN_NUMBER_MAP[pos]);
                pos = number / 10 | 0;
                number %= 10;
                romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
                romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
                const romanStr = romanBuf.join("");
                return lowerCase ? romanStr.toLowerCase() : romanStr;
              }
              function log2(x) {
                if (x <= 0) {
                  return 0;
                }
                return Math.ceil(Math.log2(x));
              }
              function readInt8(data, offset) {
                return data[offset] << 24 >> 24;
              }
              function readUint16(data, offset) {
                return data[offset] << 8 | data[offset + 1];
              }
              function readUint32(data, offset) {
                return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
              }
              function isWhiteSpace(ch) {
                return ch === 32 || ch === 9 || ch === 13 || ch === 10;
              }
              function parseXFAPath(path) {
                const positionPattern = /(.+)\[(\d+)\]$/;
                return path.split(".").map((component) => {
                  const m = component.match(positionPattern);
                  if (m) {
                    return {
                      name: m[1],
                      pos: parseInt(m[2], 10)
                    };
                  }
                  return {
                    name: component,
                    pos: 0
                  };
                });
              }
              function escapePDFName(str) {
                const buffer = [];
                let start = 0;
                for (let i = 0, ii = str.length; i < ii; i++) {
                  const char = str.charCodeAt(i);
                  if (char < 33 || char > 126 || char === 35 || char === 40 || char === 41 || char === 60 || char === 62 || char === 91 || char === 93 || char === 123 || char === 125 || char === 47 || char === 37) {
                    if (start < i) {
                      buffer.push(str.substring(start, i));
                    }
                    buffer.push(`#${char.toString(16)}`);
                    start = i + 1;
                  }
                }
                if (buffer.length === 0) {
                  return str;
                }
                if (start < str.length) {
                  buffer.push(str.substring(start, str.length));
                }
                return buffer.join("");
              }
              function escapeString(str) {
                return str.replaceAll(/([()\\\n\r])/g, (match) => {
                  if (match === "\n") {
                    return "\\n";
                  } else if (match === "\r") {
                    return "\\r";
                  }
                  return `\\${match}`;
                });
              }
              function _collectJS(entry, xref, list, parents) {
                if (!entry) {
                  return;
                }
                let parent = null;
                if (entry instanceof _primitives.Ref) {
                  if (parents.has(entry)) {
                    return;
                  }
                  parent = entry;
                  parents.put(parent);
                  entry = xref.fetch(entry);
                }
                if (Array.isArray(entry)) {
                  for (const element of entry) {
                    _collectJS(element, xref, list, parents);
                  }
                } else if (entry instanceof _primitives.Dict) {
                  if ((0, _primitives.isName)(entry.get("S"), "JavaScript")) {
                    const js = entry.get("JS");
                    let code;
                    if (js instanceof _base_stream.BaseStream) {
                      code = js.getString();
                    } else if (typeof js === "string") {
                      code = js;
                    }
                    code && (code = (0, _util.stringToPDFString)(code).replaceAll("\0", ""));
                    if (code) {
                      list.push(code);
                    }
                  }
                  _collectJS(entry.getRaw("Next"), xref, list, parents);
                }
                if (parent) {
                  parents.remove(parent);
                }
              }
              function collectActions(xref, dict, eventType) {
                const actions = /* @__PURE__ */ Object.create(null);
                const additionalActionsDicts = getInheritableProperty({
                  dict,
                  key: "AA",
                  stopWhenFound: false
                });
                if (additionalActionsDicts) {
                  for (let i = additionalActionsDicts.length - 1; i >= 0; i--) {
                    const additionalActions = additionalActionsDicts[i];
                    if (!(additionalActions instanceof _primitives.Dict)) {
                      continue;
                    }
                    for (const key of additionalActions.getKeys()) {
                      const action = eventType[key];
                      if (!action) {
                        continue;
                      }
                      const actionDict = additionalActions.getRaw(key);
                      const parents = new _primitives.RefSet();
                      const list = [];
                      _collectJS(actionDict, xref, list, parents);
                      if (list.length > 0) {
                        actions[action] = list;
                      }
                    }
                  }
                }
                if (dict.has("A")) {
                  const actionDict = dict.get("A");
                  const parents = new _primitives.RefSet();
                  const list = [];
                  _collectJS(actionDict, xref, list, parents);
                  if (list.length > 0) {
                    actions.Action = list;
                  }
                }
                return (0, _util.objectSize)(actions) > 0 ? actions : null;
              }
              const XMLEntities = {
                60: "&lt;",
                62: "&gt;",
                38: "&amp;",
                34: "&quot;",
                39: "&apos;"
              };
              function encodeToXmlString(str) {
                const buffer = [];
                let start = 0;
                for (let i = 0, ii = str.length; i < ii; i++) {
                  const char = str.codePointAt(i);
                  if (32 <= char && char <= 126) {
                    const entity = XMLEntities[char];
                    if (entity) {
                      if (start < i) {
                        buffer.push(str.substring(start, i));
                      }
                      buffer.push(entity);
                      start = i + 1;
                    }
                  } else {
                    if (start < i) {
                      buffer.push(str.substring(start, i));
                    }
                    buffer.push(`&#x${char.toString(16).toUpperCase()};`);
                    if (char > 55295 && (char < 57344 || char > 65533)) {
                      i++;
                    }
                    start = i + 1;
                  }
                }
                if (buffer.length === 0) {
                  return str;
                }
                if (start < str.length) {
                  buffer.push(str.substring(start, str.length));
                }
                return buffer.join("");
              }
              function validateFontName(fontFamily, mustWarn = false) {
                const m = /^("|').*("|')$/.exec(fontFamily);
                if (m && m[1] === m[2]) {
                  const re = new RegExp(`[^\\\\]${m[1]}`);
                  if (re.test(fontFamily.slice(1, -1))) {
                    if (mustWarn) {
                      (0, _util.warn)(`FontFamily contains unescaped ${m[1]}: ${fontFamily}.`);
                    }
                    return false;
                  }
                } else {
                  for (const ident of fontFamily.split(/[ \t]+/)) {
                    if (/^(\d|(-(\d|-)))/.test(ident) || !/^[\w-\\]+$/.test(ident)) {
                      if (mustWarn) {
                        (0, _util.warn)(`FontFamily contains invalid <custom-ident>: ${fontFamily}.`);
                      }
                      return false;
                    }
                  }
                }
                return true;
              }
              function validateCSSFont(cssFontInfo) {
                const DEFAULT_CSS_FONT_OBLIQUE = "14";
                const DEFAULT_CSS_FONT_WEIGHT = "400";
                const CSS_FONT_WEIGHT_VALUES = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]);
                const {
                  fontFamily,
                  fontWeight,
                  italicAngle
                } = cssFontInfo;
                if (!validateFontName(fontFamily, true)) {
                  return false;
                }
                const weight = fontWeight ? fontWeight.toString() : "";
                cssFontInfo.fontWeight = CSS_FONT_WEIGHT_VALUES.has(weight) ? weight : DEFAULT_CSS_FONT_WEIGHT;
                const angle = parseFloat(italicAngle);
                cssFontInfo.italicAngle = isNaN(angle) || angle < -90 || angle > 90 ? DEFAULT_CSS_FONT_OBLIQUE : italicAngle.toString();
                return true;
              }
              function recoverJsURL(str) {
                const URL_OPEN_METHODS = ["app.launchURL", "window.open", "xfa.host.gotoURL"];
                const regex = new RegExp("^\\s*(" + URL_OPEN_METHODS.join("|").replaceAll(".", "\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i");
                const jsUrl = regex.exec(str);
                if (jsUrl == null ? void 0 : jsUrl[2]) {
                  const url = jsUrl[2];
                  let newWindow = false;
                  if (jsUrl[3] === "true" && jsUrl[1] === "app.launchURL") {
                    newWindow = true;
                  }
                  return {
                    url,
                    newWindow
                  };
                }
                return null;
              }
              function numberToString(value) {
                if (Number.isInteger(value)) {
                  return value.toString();
                }
                const roundedValue = Math.round(value * 100);
                if (roundedValue % 100 === 0) {
                  return (roundedValue / 100).toString();
                }
                if (roundedValue % 10 === 0) {
                  return value.toFixed(1);
                }
                return value.toFixed(2);
              }
              function getNewAnnotationsMap(annotationStorage) {
                if (!annotationStorage) {
                  return null;
                }
                const newAnnotationsByPage = /* @__PURE__ */ new Map();
                for (const [key, value] of annotationStorage) {
                  if (!key.startsWith(_util.AnnotationEditorPrefix)) {
                    continue;
                  }
                  let annotations = newAnnotationsByPage.get(value.pageIndex);
                  if (!annotations) {
                    annotations = [];
                    newAnnotationsByPage.set(value.pageIndex, annotations);
                  }
                  annotations.push(value);
                }
                return newAnnotationsByPage.size > 0 ? newAnnotationsByPage : null;
              }
              function isAscii(str) {
                return /^[\x00-\x7F]*$/.test(str);
              }
              function stringToUTF16HexString(str) {
                const buf = [];
                for (let i = 0, ii = str.length; i < ii; i++) {
                  const char = str.charCodeAt(i);
                  buf.push((char >> 8 & 255).toString(16).padStart(2, "0"), (char & 255).toString(16).padStart(2, "0"));
                }
                return buf.join("");
              }
              function stringToUTF16String(str, bigEndian = false) {
                const buf = [];
                if (bigEndian) {
                  buf.push("");
                }
                for (let i = 0, ii = str.length; i < ii; i++) {
                  const char = str.charCodeAt(i);
                  buf.push(String.fromCharCode(char >> 8 & 255), String.fromCharCode(char & 255));
                }
                return buf.join("");
              }
              function getRotationMatrix(rotation, width, height) {
                switch (rotation) {
                  case 90:
                    return [0, 1, -1, 0, width, 0];
                  case 180:
                    return [-1, 0, 0, -1, width, height];
                  case 270:
                    return [0, -1, 1, 0, 0, height];
                  default:
                    throw new Error("Invalid rotation");
                }
              }
            },
            /* 4 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.RefSetCache = exports2.RefSet = exports2.Ref = exports2.Name = exports2.EOF = exports2.Dict = exports2.Cmd = exports2.CIRCULAR_REF = void 0;
              exports2.clearPrimitiveCaches = clearPrimitiveCaches;
              exports2.isCmd = isCmd;
              exports2.isDict = isDict;
              exports2.isName = isName;
              exports2.isRefsEqual = isRefsEqual;
              var _util = __w_pdfjs_require__2(2);
              const CIRCULAR_REF = Symbol("CIRCULAR_REF");
              exports2.CIRCULAR_REF = CIRCULAR_REF;
              const EOF = Symbol("EOF");
              exports2.EOF = EOF;
              let CmdCache = /* @__PURE__ */ Object.create(null);
              let NameCache = /* @__PURE__ */ Object.create(null);
              let RefCache = /* @__PURE__ */ Object.create(null);
              function clearPrimitiveCaches() {
                CmdCache = /* @__PURE__ */ Object.create(null);
                NameCache = /* @__PURE__ */ Object.create(null);
                RefCache = /* @__PURE__ */ Object.create(null);
              }
              class Name {
                constructor(name) {
                  this.name = name;
                }
                static get(name) {
                  return NameCache[name] || (NameCache[name] = new Name(name));
                }
              }
              exports2.Name = Name;
              class Cmd {
                constructor(cmd) {
                  this.cmd = cmd;
                }
                static get(cmd) {
                  return CmdCache[cmd] || (CmdCache[cmd] = new Cmd(cmd));
                }
              }
              exports2.Cmd = Cmd;
              const nonSerializable = function nonSerializableClosure() {
                return nonSerializable;
              };
              class Dict {
                constructor(xref = null) {
                  this._map = /* @__PURE__ */ Object.create(null);
                  this.xref = xref;
                  this.objId = null;
                  this.suppressEncryption = false;
                  this.__nonSerializable__ = nonSerializable;
                }
                assignXref(newXref) {
                  this.xref = newXref;
                }
                get size() {
                  return Object.keys(this._map).length;
                }
                get(key1, key2, key3) {
                  let value = this._map[key1];
                  if (value === void 0 && key2 !== void 0) {
                    value = this._map[key2];
                    if (value === void 0 && key3 !== void 0) {
                      value = this._map[key3];
                    }
                  }
                  if (value instanceof Ref && this.xref) {
                    return this.xref.fetch(value, this.suppressEncryption);
                  }
                  return value;
                }
                async getAsync(key1, key2, key3) {
                  let value = this._map[key1];
                  if (value === void 0 && key2 !== void 0) {
                    value = this._map[key2];
                    if (value === void 0 && key3 !== void 0) {
                      value = this._map[key3];
                    }
                  }
                  if (value instanceof Ref && this.xref) {
                    return this.xref.fetchAsync(value, this.suppressEncryption);
                  }
                  return value;
                }
                getArray(key1, key2, key3) {
                  let value = this._map[key1];
                  if (value === void 0 && key2 !== void 0) {
                    value = this._map[key2];
                    if (value === void 0 && key3 !== void 0) {
                      value = this._map[key3];
                    }
                  }
                  if (value instanceof Ref && this.xref) {
                    value = this.xref.fetch(value, this.suppressEncryption);
                  }
                  if (Array.isArray(value)) {
                    value = value.slice();
                    for (let i = 0, ii = value.length; i < ii; i++) {
                      if (value[i] instanceof Ref && this.xref) {
                        value[i] = this.xref.fetch(value[i], this.suppressEncryption);
                      }
                    }
                  }
                  return value;
                }
                getRaw(key) {
                  return this._map[key];
                }
                getKeys() {
                  return Object.keys(this._map);
                }
                getRawValues() {
                  return Object.values(this._map);
                }
                set(key, value) {
                  this._map[key] = value;
                }
                has(key) {
                  return this._map[key] !== void 0;
                }
                forEach(callback) {
                  for (const key in this._map) {
                    callback(key, this.get(key));
                  }
                }
                static get empty() {
                  const emptyDict = new Dict(null);
                  emptyDict.set = (key, value) => {
                    (0, _util.unreachable)("Should not call `set` on the empty dictionary.");
                  };
                  return (0, _util.shadow)(this, "empty", emptyDict);
                }
                static merge({
                  xref,
                  dictArray,
                  mergeSubDicts = false
                }) {
                  const mergedDict = new Dict(xref), properties = /* @__PURE__ */ new Map();
                  for (const dict of dictArray) {
                    if (!(dict instanceof Dict)) {
                      continue;
                    }
                    for (const [key, value] of Object.entries(dict._map)) {
                      let property = properties.get(key);
                      if (property === void 0) {
                        property = [];
                        properties.set(key, property);
                      } else if (!mergeSubDicts || !(value instanceof Dict)) {
                        continue;
                      }
                      property.push(value);
                    }
                  }
                  for (const [name, values] of properties) {
                    if (values.length === 1 || !(values[0] instanceof Dict)) {
                      mergedDict._map[name] = values[0];
                      continue;
                    }
                    const subDict = new Dict(xref);
                    for (const dict of values) {
                      for (const [key, value] of Object.entries(dict._map)) {
                        if (subDict._map[key] === void 0) {
                          subDict._map[key] = value;
                        }
                      }
                    }
                    if (subDict.size > 0) {
                      mergedDict._map[name] = subDict;
                    }
                  }
                  properties.clear();
                  return mergedDict.size > 0 ? mergedDict : Dict.empty;
                }
                clone() {
                  const dict = new Dict(this.xref);
                  for (const key of this.getKeys()) {
                    dict.set(key, this.getRaw(key));
                  }
                  return dict;
                }
              }
              exports2.Dict = Dict;
              class Ref {
                constructor(num, gen) {
                  this.num = num;
                  this.gen = gen;
                }
                toString() {
                  if (this.gen === 0) {
                    return `${this.num}R`;
                  }
                  return `${this.num}R${this.gen}`;
                }
                static fromString(str) {
                  const ref = RefCache[str];
                  if (ref) {
                    return ref;
                  }
                  const m = /^(\d+)R(\d*)$/.exec(str);
                  if (!m || m[1] === "0") {
                    return null;
                  }
                  return RefCache[str] = new Ref(parseInt(m[1]), !m[2] ? 0 : parseInt(m[2]));
                }
                static get(num, gen) {
                  const key = gen === 0 ? `${num}R` : `${num}R${gen}`;
                  return RefCache[key] || (RefCache[key] = new Ref(num, gen));
                }
              }
              exports2.Ref = Ref;
              class RefSet {
                constructor(parent = null) {
                  this._set = new Set(parent == null ? void 0 : parent._set);
                }
                has(ref) {
                  return this._set.has(ref.toString());
                }
                put(ref) {
                  this._set.add(ref.toString());
                }
                remove(ref) {
                  this._set.delete(ref.toString());
                }
                [Symbol.iterator]() {
                  return this._set.values();
                }
                clear() {
                  this._set.clear();
                }
              }
              exports2.RefSet = RefSet;
              class RefSetCache {
                constructor() {
                  this._map = /* @__PURE__ */ new Map();
                }
                get size() {
                  return this._map.size;
                }
                get(ref) {
                  return this._map.get(ref.toString());
                }
                has(ref) {
                  return this._map.has(ref.toString());
                }
                put(ref, obj) {
                  this._map.set(ref.toString(), obj);
                }
                putAlias(ref, aliasRef) {
                  this._map.set(ref.toString(), this.get(aliasRef));
                }
                [Symbol.iterator]() {
                  return this._map.values();
                }
                clear() {
                  this._map.clear();
                }
              }
              exports2.RefSetCache = RefSetCache;
              function isName(v, name) {
                return v instanceof Name && (name === void 0 || v.name === name);
              }
              function isCmd(v, cmd) {
                return v instanceof Cmd && (cmd === void 0 || v.cmd === cmd);
              }
              function isDict(v, type) {
                return v instanceof Dict && (type === void 0 || isName(v.get("Type"), type));
              }
              function isRefsEqual(v1, v2) {
                return v1.num === v2.num && v1.gen === v2.gen;
              }
            },
            /* 5 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.BaseStream = void 0;
              var _util = __w_pdfjs_require__2(2);
              class BaseStream {
                constructor() {
                  if (this.constructor === BaseStream) {
                    (0, _util.unreachable)("Cannot initialize BaseStream.");
                  }
                }
                get length() {
                  (0, _util.unreachable)("Abstract getter `length` accessed");
                }
                get isEmpty() {
                  (0, _util.unreachable)("Abstract getter `isEmpty` accessed");
                }
                get isDataLoaded() {
                  return (0, _util.shadow)(this, "isDataLoaded", true);
                }
                getByte() {
                  (0, _util.unreachable)("Abstract method `getByte` called");
                }
                getBytes(length) {
                  (0, _util.unreachable)("Abstract method `getBytes` called");
                }
                peekByte() {
                  const peekedByte = this.getByte();
                  if (peekedByte !== -1) {
                    this.pos--;
                  }
                  return peekedByte;
                }
                peekBytes(length) {
                  const bytes = this.getBytes(length);
                  this.pos -= bytes.length;
                  return bytes;
                }
                getUint16() {
                  const b0 = this.getByte();
                  const b1 = this.getByte();
                  if (b0 === -1 || b1 === -1) {
                    return -1;
                  }
                  return (b0 << 8) + b1;
                }
                getInt32() {
                  const b0 = this.getByte();
                  const b1 = this.getByte();
                  const b2 = this.getByte();
                  const b3 = this.getByte();
                  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                }
                getByteRange(begin, end) {
                  (0, _util.unreachable)("Abstract method `getByteRange` called");
                }
                getString(length) {
                  return (0, _util.bytesToString)(this.getBytes(length));
                }
                skip(n) {
                  this.pos += n || 1;
                }
                reset() {
                  (0, _util.unreachable)("Abstract method `reset` called");
                }
                moveStart() {
                  (0, _util.unreachable)("Abstract method `moveStart` called");
                }
                makeSubStream(start, length, dict = null) {
                  (0, _util.unreachable)("Abstract method `makeSubStream` called");
                }
                getBaseStreams() {
                  return null;
                }
              }
              exports2.BaseStream = BaseStream;
            },
            /* 6 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NetworkPdfManager = exports2.LocalPdfManager = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _chunked_stream = __w_pdfjs_require__2(7);
              var _core_utils = __w_pdfjs_require__2(3);
              var _document = __w_pdfjs_require__2(9);
              var _stream = __w_pdfjs_require__2(8);
              function parseDocBaseUrl(url) {
                if (url) {
                  const absoluteUrl = (0, _util.createValidAbsoluteUrl)(url);
                  if (absoluteUrl) {
                    return absoluteUrl.href;
                  }
                  (0, _util.warn)(`Invalid absolute docBaseUrl: "${url}".`);
                }
                return null;
              }
              class BasePdfManager {
                constructor(args) {
                  var _a;
                  if (this.constructor === BasePdfManager) {
                    (0, _util.unreachable)("Cannot initialize BasePdfManager.");
                  }
                  this._docBaseUrl = parseDocBaseUrl(args.docBaseUrl);
                  this._docId = args.docId;
                  this._password = args.password;
                  this.enableXfa = args.enableXfa;
                  (_a = args.evaluatorOptions).isOffscreenCanvasSupported && (_a.isOffscreenCanvasSupported = _util.FeatureTest.isOffscreenCanvasSupported);
                  this.evaluatorOptions = args.evaluatorOptions;
                }
                get docId() {
                  return this._docId;
                }
                get password() {
                  return this._password;
                }
                get docBaseUrl() {
                  return this._docBaseUrl;
                }
                get catalog() {
                  return this.pdfDocument.catalog;
                }
                ensureDoc(prop, args) {
                  return this.ensure(this.pdfDocument, prop, args);
                }
                ensureXRef(prop, args) {
                  return this.ensure(this.pdfDocument.xref, prop, args);
                }
                ensureCatalog(prop, args) {
                  return this.ensure(this.pdfDocument.catalog, prop, args);
                }
                getPage(pageIndex) {
                  return this.pdfDocument.getPage(pageIndex);
                }
                fontFallback(id, handler) {
                  return this.pdfDocument.fontFallback(id, handler);
                }
                loadXfaFonts(handler, task) {
                  return this.pdfDocument.loadXfaFonts(handler, task);
                }
                loadXfaImages() {
                  return this.pdfDocument.loadXfaImages();
                }
                serializeXfaData(annotationStorage) {
                  return this.pdfDocument.serializeXfaData(annotationStorage);
                }
                cleanup(manuallyTriggered = false) {
                  return this.pdfDocument.cleanup(manuallyTriggered);
                }
                async ensure(obj, prop, args) {
                  (0, _util.unreachable)("Abstract method `ensure` called");
                }
                requestRange(begin, end) {
                  (0, _util.unreachable)("Abstract method `requestRange` called");
                }
                requestLoadedStream(noFetch = false) {
                  (0, _util.unreachable)("Abstract method `requestLoadedStream` called");
                }
                sendProgressiveData(chunk) {
                  (0, _util.unreachable)("Abstract method `sendProgressiveData` called");
                }
                updatePassword(password) {
                  this._password = password;
                }
                terminate(reason) {
                  (0, _util.unreachable)("Abstract method `terminate` called");
                }
              }
              class LocalPdfManager extends BasePdfManager {
                constructor(args) {
                  super(args);
                  const stream = new _stream.Stream(args.source);
                  this.pdfDocument = new _document.PDFDocument(this, stream);
                  this._loadedStreamPromise = Promise.resolve(stream);
                }
                async ensure(obj, prop, args) {
                  const value = obj[prop];
                  if (typeof value === "function") {
                    return value.apply(obj, args);
                  }
                  return value;
                }
                requestRange(begin, end) {
                  return Promise.resolve();
                }
                requestLoadedStream(noFetch = false) {
                  return this._loadedStreamPromise;
                }
                terminate(reason) {
                }
              }
              exports2.LocalPdfManager = LocalPdfManager;
              class NetworkPdfManager extends BasePdfManager {
                constructor(args) {
                  super(args);
                  this.streamManager = new _chunked_stream.ChunkedStreamManager(args.source, {
                    msgHandler: args.handler,
                    length: args.length,
                    disableAutoFetch: args.disableAutoFetch,
                    rangeChunkSize: args.rangeChunkSize
                  });
                  this.pdfDocument = new _document.PDFDocument(this, this.streamManager.getStream());
                }
                async ensure(obj, prop, args) {
                  try {
                    const value = obj[prop];
                    if (typeof value === "function") {
                      return value.apply(obj, args);
                    }
                    return value;
                  } catch (ex) {
                    if (!(ex instanceof _core_utils.MissingDataException)) {
                      throw ex;
                    }
                    await this.requestRange(ex.begin, ex.end);
                    return this.ensure(obj, prop, args);
                  }
                }
                requestRange(begin, end) {
                  return this.streamManager.requestRange(begin, end);
                }
                requestLoadedStream(noFetch = false) {
                  return this.streamManager.requestAllChunks(noFetch);
                }
                sendProgressiveData(chunk) {
                  this.streamManager.onReceiveData({
                    chunk
                  });
                }
                terminate(reason) {
                  this.streamManager.abort(reason);
                }
              }
              exports2.NetworkPdfManager = NetworkPdfManager;
            },
            /* 7 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ChunkedStreamManager = exports2.ChunkedStream = void 0;
              var _core_utils = __w_pdfjs_require__2(3);
              var _util = __w_pdfjs_require__2(2);
              var _stream = __w_pdfjs_require__2(8);
              class ChunkedStream extends _stream.Stream {
                constructor(length, chunkSize, manager) {
                  super(new Uint8Array(length), 0, length, null);
                  this.chunkSize = chunkSize;
                  this._loadedChunks = /* @__PURE__ */ new Set();
                  this.numChunks = Math.ceil(length / chunkSize);
                  this.manager = manager;
                  this.progressiveDataLength = 0;
                  this.lastSuccessfulEnsureByteChunk = -1;
                }
                getMissingChunks() {
                  const chunks = [];
                  for (let chunk = 0, n = this.numChunks; chunk < n; ++chunk) {
                    if (!this._loadedChunks.has(chunk)) {
                      chunks.push(chunk);
                    }
                  }
                  return chunks;
                }
                get numChunksLoaded() {
                  return this._loadedChunks.size;
                }
                get isDataLoaded() {
                  return this.numChunksLoaded === this.numChunks;
                }
                onReceiveData(begin, chunk) {
                  const chunkSize = this.chunkSize;
                  if (begin % chunkSize !== 0) {
                    throw new Error(`Bad begin offset: ${begin}`);
                  }
                  const end = begin + chunk.byteLength;
                  if (end % chunkSize !== 0 && end !== this.bytes.length) {
                    throw new Error(`Bad end offset: ${end}`);
                  }
                  this.bytes.set(new Uint8Array(chunk), begin);
                  const beginChunk = Math.floor(begin / chunkSize);
                  const endChunk = Math.floor((end - 1) / chunkSize) + 1;
                  for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
                    this._loadedChunks.add(curChunk);
                  }
                }
                onReceiveProgressiveData(data) {
                  let position = this.progressiveDataLength;
                  const beginChunk = Math.floor(position / this.chunkSize);
                  this.bytes.set(new Uint8Array(data), position);
                  position += data.byteLength;
                  this.progressiveDataLength = position;
                  const endChunk = position >= this.end ? this.numChunks : Math.floor(position / this.chunkSize);
                  for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
                    this._loadedChunks.add(curChunk);
                  }
                }
                ensureByte(pos) {
                  if (pos < this.progressiveDataLength) {
                    return;
                  }
                  const chunk = Math.floor(pos / this.chunkSize);
                  if (chunk > this.numChunks) {
                    return;
                  }
                  if (chunk === this.lastSuccessfulEnsureByteChunk) {
                    return;
                  }
                  if (!this._loadedChunks.has(chunk)) {
                    throw new _core_utils.MissingDataException(pos, pos + 1);
                  }
                  this.lastSuccessfulEnsureByteChunk = chunk;
                }
                ensureRange(begin, end) {
                  if (begin >= end) {
                    return;
                  }
                  if (end <= this.progressiveDataLength) {
                    return;
                  }
                  const beginChunk = Math.floor(begin / this.chunkSize);
                  if (beginChunk > this.numChunks) {
                    return;
                  }
                  const endChunk = Math.min(Math.floor((end - 1) / this.chunkSize) + 1, this.numChunks);
                  for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
                    if (!this._loadedChunks.has(chunk)) {
                      throw new _core_utils.MissingDataException(begin, end);
                    }
                  }
                }
                nextEmptyChunk(beginChunk) {
                  const numChunks = this.numChunks;
                  for (let i = 0; i < numChunks; ++i) {
                    const chunk = (beginChunk + i) % numChunks;
                    if (!this._loadedChunks.has(chunk)) {
                      return chunk;
                    }
                  }
                  return null;
                }
                hasChunk(chunk) {
                  return this._loadedChunks.has(chunk);
                }
                getByte() {
                  const pos = this.pos;
                  if (pos >= this.end) {
                    return -1;
                  }
                  if (pos >= this.progressiveDataLength) {
                    this.ensureByte(pos);
                  }
                  return this.bytes[this.pos++];
                }
                getBytes(length) {
                  const bytes = this.bytes;
                  const pos = this.pos;
                  const strEnd = this.end;
                  if (!length) {
                    if (strEnd > this.progressiveDataLength) {
                      this.ensureRange(pos, strEnd);
                    }
                    return bytes.subarray(pos, strEnd);
                  }
                  let end = pos + length;
                  if (end > strEnd) {
                    end = strEnd;
                  }
                  if (end > this.progressiveDataLength) {
                    this.ensureRange(pos, end);
                  }
                  this.pos = end;
                  return bytes.subarray(pos, end);
                }
                getByteRange(begin, end) {
                  if (begin < 0) {
                    begin = 0;
                  }
                  if (end > this.end) {
                    end = this.end;
                  }
                  if (end > this.progressiveDataLength) {
                    this.ensureRange(begin, end);
                  }
                  return this.bytes.subarray(begin, end);
                }
                makeSubStream(start, length, dict = null) {
                  if (length) {
                    if (start + length > this.progressiveDataLength) {
                      this.ensureRange(start, start + length);
                    }
                  } else if (start >= this.progressiveDataLength) {
                    this.ensureByte(start);
                  }
                  function ChunkedStreamSubstream() {
                  }
                  ChunkedStreamSubstream.prototype = Object.create(this);
                  ChunkedStreamSubstream.prototype.getMissingChunks = function() {
                    const chunkSize = this.chunkSize;
                    const beginChunk = Math.floor(this.start / chunkSize);
                    const endChunk = Math.floor((this.end - 1) / chunkSize) + 1;
                    const missingChunks = [];
                    for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
                      if (!this._loadedChunks.has(chunk)) {
                        missingChunks.push(chunk);
                      }
                    }
                    return missingChunks;
                  };
                  Object.defineProperty(ChunkedStreamSubstream.prototype, "isDataLoaded", {
                    get() {
                      if (this.numChunksLoaded === this.numChunks) {
                        return true;
                      }
                      return this.getMissingChunks().length === 0;
                    },
                    configurable: true
                  });
                  const subStream = new ChunkedStreamSubstream();
                  subStream.pos = subStream.start = start;
                  subStream.end = start + length || this.end;
                  subStream.dict = dict;
                  return subStream;
                }
                getBaseStreams() {
                  return [this];
                }
              }
              exports2.ChunkedStream = ChunkedStream;
              class ChunkedStreamManager {
                constructor(pdfNetworkStream, args) {
                  this.length = args.length;
                  this.chunkSize = args.rangeChunkSize;
                  this.stream = new ChunkedStream(this.length, this.chunkSize, this);
                  this.pdfNetworkStream = pdfNetworkStream;
                  this.disableAutoFetch = args.disableAutoFetch;
                  this.msgHandler = args.msgHandler;
                  this.currRequestId = 0;
                  this._chunksNeededByRequest = /* @__PURE__ */ new Map();
                  this._requestsByChunk = /* @__PURE__ */ new Map();
                  this._promisesByRequest = /* @__PURE__ */ new Map();
                  this.progressiveDataLength = 0;
                  this.aborted = false;
                  this._loadedStreamCapability = new _util.PromiseCapability();
                }
                sendRequest(begin, end) {
                  const rangeReader = this.pdfNetworkStream.getRangeReader(begin, end);
                  if (!rangeReader.isStreamingSupported) {
                    rangeReader.onProgress = this.onProgress.bind(this);
                  }
                  let chunks = [], loaded = 0;
                  return new Promise((resolve, reject) => {
                    const readChunk = ({
                      value,
                      done
                    }) => {
                      try {
                        if (done) {
                          const chunkData = (0, _core_utils.arrayBuffersToBytes)(chunks);
                          chunks = null;
                          resolve(chunkData);
                          return;
                        }
                        loaded += value.byteLength;
                        if (rangeReader.isStreamingSupported) {
                          this.onProgress({
                            loaded
                          });
                        }
                        chunks.push(value);
                        rangeReader.read().then(readChunk, reject);
                      } catch (e) {
                        reject(e);
                      }
                    };
                    rangeReader.read().then(readChunk, reject);
                  }).then((data) => {
                    if (this.aborted) {
                      return;
                    }
                    this.onReceiveData({
                      chunk: data,
                      begin
                    });
                  });
                }
                requestAllChunks(noFetch = false) {
                  if (!noFetch) {
                    const missingChunks = this.stream.getMissingChunks();
                    this._requestChunks(missingChunks);
                  }
                  return this._loadedStreamCapability.promise;
                }
                _requestChunks(chunks) {
                  const requestId = this.currRequestId++;
                  const chunksNeeded = /* @__PURE__ */ new Set();
                  this._chunksNeededByRequest.set(requestId, chunksNeeded);
                  for (const chunk of chunks) {
                    if (!this.stream.hasChunk(chunk)) {
                      chunksNeeded.add(chunk);
                    }
                  }
                  if (chunksNeeded.size === 0) {
                    return Promise.resolve();
                  }
                  const capability = new _util.PromiseCapability();
                  this._promisesByRequest.set(requestId, capability);
                  const chunksToRequest = [];
                  for (const chunk of chunksNeeded) {
                    let requestIds = this._requestsByChunk.get(chunk);
                    if (!requestIds) {
                      requestIds = [];
                      this._requestsByChunk.set(chunk, requestIds);
                      chunksToRequest.push(chunk);
                    }
                    requestIds.push(requestId);
                  }
                  if (chunksToRequest.length > 0) {
                    const groupedChunksToRequest = this.groupChunks(chunksToRequest);
                    for (const groupedChunk of groupedChunksToRequest) {
                      const begin = groupedChunk.beginChunk * this.chunkSize;
                      const end = Math.min(groupedChunk.endChunk * this.chunkSize, this.length);
                      this.sendRequest(begin, end).catch(capability.reject);
                    }
                  }
                  return capability.promise.catch((reason) => {
                    if (this.aborted) {
                      return;
                    }
                    throw reason;
                  });
                }
                getStream() {
                  return this.stream;
                }
                requestRange(begin, end) {
                  end = Math.min(end, this.length);
                  const beginChunk = this.getBeginChunk(begin);
                  const endChunk = this.getEndChunk(end);
                  const chunks = [];
                  for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
                    chunks.push(chunk);
                  }
                  return this._requestChunks(chunks);
                }
                requestRanges(ranges = []) {
                  const chunksToRequest = [];
                  for (const range of ranges) {
                    const beginChunk = this.getBeginChunk(range.begin);
                    const endChunk = this.getEndChunk(range.end);
                    for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
                      if (!chunksToRequest.includes(chunk)) {
                        chunksToRequest.push(chunk);
                      }
                    }
                  }
                  chunksToRequest.sort(function(a, b) {
                    return a - b;
                  });
                  return this._requestChunks(chunksToRequest);
                }
                groupChunks(chunks) {
                  const groupedChunks = [];
                  let beginChunk = -1;
                  let prevChunk = -1;
                  for (let i = 0, ii = chunks.length; i < ii; ++i) {
                    const chunk = chunks[i];
                    if (beginChunk < 0) {
                      beginChunk = chunk;
                    }
                    if (prevChunk >= 0 && prevChunk + 1 !== chunk) {
                      groupedChunks.push({
                        beginChunk,
                        endChunk: prevChunk + 1
                      });
                      beginChunk = chunk;
                    }
                    if (i + 1 === chunks.length) {
                      groupedChunks.push({
                        beginChunk,
                        endChunk: chunk + 1
                      });
                    }
                    prevChunk = chunk;
                  }
                  return groupedChunks;
                }
                onProgress(args) {
                  this.msgHandler.send("DocProgress", {
                    loaded: this.stream.numChunksLoaded * this.chunkSize + args.loaded,
                    total: this.length
                  });
                }
                onReceiveData(args) {
                  const chunk = args.chunk;
                  const isProgressive = args.begin === void 0;
                  const begin = isProgressive ? this.progressiveDataLength : args.begin;
                  const end = begin + chunk.byteLength;
                  const beginChunk = Math.floor(begin / this.chunkSize);
                  const endChunk = end < this.length ? Math.floor(end / this.chunkSize) : Math.ceil(end / this.chunkSize);
                  if (isProgressive) {
                    this.stream.onReceiveProgressiveData(chunk);
                    this.progressiveDataLength = end;
                  } else {
                    this.stream.onReceiveData(begin, chunk);
                  }
                  if (this.stream.isDataLoaded) {
                    this._loadedStreamCapability.resolve(this.stream);
                  }
                  const loadedRequests = [];
                  for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
                    const requestIds = this._requestsByChunk.get(curChunk);
                    if (!requestIds) {
                      continue;
                    }
                    this._requestsByChunk.delete(curChunk);
                    for (const requestId of requestIds) {
                      const chunksNeeded = this._chunksNeededByRequest.get(requestId);
                      if (chunksNeeded.has(curChunk)) {
                        chunksNeeded.delete(curChunk);
                      }
                      if (chunksNeeded.size > 0) {
                        continue;
                      }
                      loadedRequests.push(requestId);
                    }
                  }
                  if (!this.disableAutoFetch && this._requestsByChunk.size === 0) {
                    let nextEmptyChunk;
                    if (this.stream.numChunksLoaded === 1) {
                      const lastChunk = this.stream.numChunks - 1;
                      if (!this.stream.hasChunk(lastChunk)) {
                        nextEmptyChunk = lastChunk;
                      }
                    } else {
                      nextEmptyChunk = this.stream.nextEmptyChunk(endChunk);
                    }
                    if (Number.isInteger(nextEmptyChunk)) {
                      this._requestChunks([nextEmptyChunk]);
                    }
                  }
                  for (const requestId of loadedRequests) {
                    const capability = this._promisesByRequest.get(requestId);
                    this._promisesByRequest.delete(requestId);
                    capability.resolve();
                  }
                  this.msgHandler.send("DocProgress", {
                    loaded: this.stream.numChunksLoaded * this.chunkSize,
                    total: this.length
                  });
                }
                onError(err) {
                  this._loadedStreamCapability.reject(err);
                }
                getBeginChunk(begin) {
                  return Math.floor(begin / this.chunkSize);
                }
                getEndChunk(end) {
                  return Math.floor((end - 1) / this.chunkSize) + 1;
                }
                abort(reason) {
                  var _a;
                  this.aborted = true;
                  (_a = this.pdfNetworkStream) == null ? void 0 : _a.cancelAllRequests(reason);
                  for (const capability of this._promisesByRequest.values()) {
                    capability.reject(reason);
                  }
                }
              }
              exports2.ChunkedStreamManager = ChunkedStreamManager;
            },
            /* 8 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StringStream = exports2.Stream = exports2.NullStream = void 0;
              var _base_stream = __w_pdfjs_require__2(5);
              var _util = __w_pdfjs_require__2(2);
              class Stream extends _base_stream.BaseStream {
                constructor(arrayBuffer, start, length, dict) {
                  super();
                  this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
                  this.start = start || 0;
                  this.pos = this.start;
                  this.end = start + length || this.bytes.length;
                  this.dict = dict;
                }
                get length() {
                  return this.end - this.start;
                }
                get isEmpty() {
                  return this.length === 0;
                }
                getByte() {
                  if (this.pos >= this.end) {
                    return -1;
                  }
                  return this.bytes[this.pos++];
                }
                getBytes(length) {
                  const bytes = this.bytes;
                  const pos = this.pos;
                  const strEnd = this.end;
                  if (!length) {
                    return bytes.subarray(pos, strEnd);
                  }
                  let end = pos + length;
                  if (end > strEnd) {
                    end = strEnd;
                  }
                  this.pos = end;
                  return bytes.subarray(pos, end);
                }
                getByteRange(begin, end) {
                  if (begin < 0) {
                    begin = 0;
                  }
                  if (end > this.end) {
                    end = this.end;
                  }
                  return this.bytes.subarray(begin, end);
                }
                reset() {
                  this.pos = this.start;
                }
                moveStart() {
                  this.start = this.pos;
                }
                makeSubStream(start, length, dict = null) {
                  return new Stream(this.bytes.buffer, start, length, dict);
                }
              }
              exports2.Stream = Stream;
              class StringStream extends Stream {
                constructor(str) {
                  super((0, _util.stringToBytes)(str));
                }
              }
              exports2.StringStream = StringStream;
              class NullStream extends Stream {
                constructor() {
                  super(new Uint8Array(0));
                }
              }
              exports2.NullStream = NullStream;
            },
            /* 9 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var _replaceIdByRef, replaceIdByRef_fn, _collectFieldObjects, collectFieldObjects_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Page = exports2.PDFDocument = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _annotation = __w_pdfjs_require__2(10);
              var _core_utils = __w_pdfjs_require__2(3);
              var _primitives = __w_pdfjs_require__2(4);
              var _xfa_fonts = __w_pdfjs_require__2(51);
              var _base_stream = __w_pdfjs_require__2(5);
              var _crypto = __w_pdfjs_require__2(74);
              var _catalog = __w_pdfjs_require__2(66);
              var _cleanup_helper = __w_pdfjs_require__2(68);
              var _dataset_reader = __w_pdfjs_require__2(102);
              var _parser = __w_pdfjs_require__2(16);
              var _stream = __w_pdfjs_require__2(8);
              var _object_loader = __w_pdfjs_require__2(76);
              var _operator_list = __w_pdfjs_require__2(64);
              var _evaluator = __w_pdfjs_require__2(13);
              var _decode_stream = __w_pdfjs_require__2(18);
              var _struct_tree = __w_pdfjs_require__2(72);
              var _writer = __w_pdfjs_require__2(73);
              var _factory = __w_pdfjs_require__2(77);
              var _xref = __w_pdfjs_require__2(103);
              const DEFAULT_USER_UNIT = 1;
              const LETTER_SIZE_MEDIABOX = [0, 0, 612, 792];
              class Page {
                constructor({
                  pdfManager,
                  xref,
                  pageIndex,
                  pageDict,
                  ref,
                  globalIdFactory,
                  fontCache,
                  builtInCMapCache,
                  standardFontDataCache,
                  globalImageCache,
                  systemFontCache,
                  nonBlendModesSet,
                  xfaFactory
                }) {
                  __privateAdd(this, _replaceIdByRef);
                  this.pdfManager = pdfManager;
                  this.pageIndex = pageIndex;
                  this.pageDict = pageDict;
                  this.xref = xref;
                  this.ref = ref;
                  this.fontCache = fontCache;
                  this.builtInCMapCache = builtInCMapCache;
                  this.standardFontDataCache = standardFontDataCache;
                  this.globalImageCache = globalImageCache;
                  this.systemFontCache = systemFontCache;
                  this.nonBlendModesSet = nonBlendModesSet;
                  this.evaluatorOptions = pdfManager.evaluatorOptions;
                  this.resourcesPromise = null;
                  this.xfaFactory = xfaFactory;
                  const idCounters = {
                    obj: 0
                  };
                  this._localIdFactory = class extends globalIdFactory {
                    static createObjId() {
                      return `p${pageIndex}_${++idCounters.obj}`;
                    }
                    static getPageObjId() {
                      return `p${ref.toString()}`;
                    }
                  };
                }
                _getInheritableProperty(key, getArray = false) {
                  const value = (0, _core_utils.getInheritableProperty)({
                    dict: this.pageDict,
                    key,
                    getArray,
                    stopWhenFound: false
                  });
                  if (!Array.isArray(value)) {
                    return value;
                  }
                  if (value.length === 1 || !(value[0] instanceof _primitives.Dict)) {
                    return value[0];
                  }
                  return _primitives.Dict.merge({
                    xref: this.xref,
                    dictArray: value
                  });
                }
                get content() {
                  return this.pageDict.getArray("Contents");
                }
                get resources() {
                  const resources = this._getInheritableProperty("Resources");
                  return (0, _util.shadow)(this, "resources", resources instanceof _primitives.Dict ? resources : _primitives.Dict.empty);
                }
                _getBoundingBox(name) {
                  if (this.xfaData) {
                    return this.xfaData.bbox;
                  }
                  let box = this._getInheritableProperty(name, true);
                  if (Array.isArray(box) && box.length === 4) {
                    box = _util.Util.normalizeRect(box);
                    if (box[2] - box[0] > 0 && box[3] - box[1] > 0) {
                      return box;
                    }
                    (0, _util.warn)(`Empty, or invalid, /${name} entry.`);
                  }
                  return null;
                }
                get mediaBox() {
                  return (0, _util.shadow)(this, "mediaBox", this._getBoundingBox("MediaBox") || LETTER_SIZE_MEDIABOX);
                }
                get cropBox() {
                  return (0, _util.shadow)(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
                }
                get userUnit() {
                  let obj = this.pageDict.get("UserUnit");
                  if (typeof obj !== "number" || obj <= 0) {
                    obj = DEFAULT_USER_UNIT;
                  }
                  return (0, _util.shadow)(this, "userUnit", obj);
                }
                get view() {
                  const {
                    cropBox,
                    mediaBox
                  } = this;
                  if (cropBox !== mediaBox && !(0, _util.isArrayEqual)(cropBox, mediaBox)) {
                    const box = _util.Util.intersect(cropBox, mediaBox);
                    if (box && box[2] - box[0] > 0 && box[3] - box[1] > 0) {
                      return (0, _util.shadow)(this, "view", box);
                    }
                    (0, _util.warn)("Empty /CropBox and /MediaBox intersection.");
                  }
                  return (0, _util.shadow)(this, "view", mediaBox);
                }
                get rotate() {
                  let rotate = this._getInheritableProperty("Rotate") || 0;
                  if (rotate % 90 !== 0) {
                    rotate = 0;
                  } else if (rotate >= 360) {
                    rotate %= 360;
                  } else if (rotate < 0) {
                    rotate = (rotate % 360 + 360) % 360;
                  }
                  return (0, _util.shadow)(this, "rotate", rotate);
                }
                _onSubStreamError(reason, objId) {
                  if (this.evaluatorOptions.ignoreErrors) {
                    (0, _util.warn)(`getContentStream - ignoring sub-stream (${objId}): "${reason}".`);
                    return;
                  }
                  throw reason;
                }
                getContentStream() {
                  return this.pdfManager.ensure(this, "content").then((content) => {
                    if (content instanceof _base_stream.BaseStream) {
                      return content;
                    }
                    if (Array.isArray(content)) {
                      return new _decode_stream.StreamsSequenceStream(content, this._onSubStreamError.bind(this));
                    }
                    return new _stream.NullStream();
                  });
                }
                get xfaData() {
                  return (0, _util.shadow)(this, "xfaData", this.xfaFactory ? {
                    bbox: this.xfaFactory.getBoundingBox(this.pageIndex)
                  } : null);
                }
                async saveNewAnnotations(handler, task, annotations, imagePromises) {
                  if (this.xfaFactory) {
                    throw new Error("XFA: Cannot save new annotations.");
                  }
                  const partialEvaluator = new _evaluator.PartialEvaluator({
                    xref: this.xref,
                    handler,
                    pageIndex: this.pageIndex,
                    idFactory: this._localIdFactory,
                    fontCache: this.fontCache,
                    builtInCMapCache: this.builtInCMapCache,
                    standardFontDataCache: this.standardFontDataCache,
                    globalImageCache: this.globalImageCache,
                    systemFontCache: this.systemFontCache,
                    options: this.evaluatorOptions
                  });
                  const deletedAnnotations = new _primitives.RefSet();
                  const existingAnnotations = new _primitives.RefSet();
                  __privateMethod(this, _replaceIdByRef, replaceIdByRef_fn).call(this, annotations, deletedAnnotations, existingAnnotations);
                  const pageDict = this.pageDict;
                  const annotationsArray = this.annotations.filter((a) => !(a instanceof _primitives.Ref && deletedAnnotations.has(a)));
                  const newData = await _annotation.AnnotationFactory.saveNewAnnotations(partialEvaluator, task, annotations, imagePromises);
                  for (const {
                    ref
                  } of newData.annotations) {
                    if (ref instanceof _primitives.Ref && !existingAnnotations.has(ref)) {
                      annotationsArray.push(ref);
                    }
                  }
                  const savedDict = pageDict.get("Annots");
                  pageDict.set("Annots", annotationsArray);
                  const buffer = [];
                  await (0, _writer.writeObject)(this.ref, pageDict, buffer, this.xref);
                  if (savedDict) {
                    pageDict.set("Annots", savedDict);
                  }
                  const objects = newData.dependencies;
                  objects.push({
                    ref: this.ref,
                    data: buffer.join("")
                  }, ...newData.annotations);
                  return objects;
                }
                save(handler, task, annotationStorage) {
                  const partialEvaluator = new _evaluator.PartialEvaluator({
                    xref: this.xref,
                    handler,
                    pageIndex: this.pageIndex,
                    idFactory: this._localIdFactory,
                    fontCache: this.fontCache,
                    builtInCMapCache: this.builtInCMapCache,
                    standardFontDataCache: this.standardFontDataCache,
                    globalImageCache: this.globalImageCache,
                    systemFontCache: this.systemFontCache,
                    options: this.evaluatorOptions
                  });
                  return this._parsedAnnotations.then(function(annotations) {
                    const newRefsPromises = [];
                    for (const annotation of annotations) {
                      if (!annotation.mustBePrinted(annotationStorage)) {
                        continue;
                      }
                      newRefsPromises.push(annotation.save(partialEvaluator, task, annotationStorage).catch(function(reason) {
                        (0, _util.warn)(`save - ignoring annotation data during "${task.name}" task: "${reason}".`);
                        return null;
                      }));
                    }
                    return Promise.all(newRefsPromises).then(function(newRefs) {
                      return newRefs.filter((newRef) => !!newRef);
                    });
                  });
                }
                loadResources(keys) {
                  if (!this.resourcesPromise) {
                    this.resourcesPromise = this.pdfManager.ensure(this, "resources");
                  }
                  return this.resourcesPromise.then(() => {
                    const objectLoader = new _object_loader.ObjectLoader(this.resources, keys, this.xref);
                    return objectLoader.load();
                  });
                }
                getOperatorList({
                  handler,
                  sink,
                  task,
                  intent,
                  cacheKey,
                  annotationStorage = null
                }) {
                  const contentStreamPromise = this.getContentStream();
                  const resourcesPromise = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]);
                  const partialEvaluator = new _evaluator.PartialEvaluator({
                    xref: this.xref,
                    handler,
                    pageIndex: this.pageIndex,
                    idFactory: this._localIdFactory,
                    fontCache: this.fontCache,
                    builtInCMapCache: this.builtInCMapCache,
                    standardFontDataCache: this.standardFontDataCache,
                    globalImageCache: this.globalImageCache,
                    systemFontCache: this.systemFontCache,
                    options: this.evaluatorOptions
                  });
                  const newAnnotationsByPage = !this.xfaFactory ? (0, _core_utils.getNewAnnotationsMap)(annotationStorage) : null;
                  let deletedAnnotations = null;
                  let newAnnotationsPromise = Promise.resolve(null);
                  if (newAnnotationsByPage) {
                    const newAnnotations = newAnnotationsByPage.get(this.pageIndex);
                    if (newAnnotations) {
                      const annotationGlobalsPromise = this.pdfManager.ensureDoc("annotationGlobals");
                      let imagePromises;
                      const missingBitmaps = /* @__PURE__ */ new Set();
                      for (const {
                        bitmapId,
                        bitmap
                      } of newAnnotations) {
                        if (bitmapId && !bitmap && !missingBitmaps.has(bitmapId)) {
                          missingBitmaps.add(bitmapId);
                        }
                      }
                      const {
                        isOffscreenCanvasSupported
                      } = this.evaluatorOptions;
                      if (missingBitmaps.size > 0) {
                        const annotationWithBitmaps = newAnnotations.slice();
                        for (const [key, annotation] of annotationStorage) {
                          if (!key.startsWith(_util.AnnotationEditorPrefix)) {
                            continue;
                          }
                          if (annotation.bitmap && missingBitmaps.has(annotation.bitmapId)) {
                            annotationWithBitmaps.push(annotation);
                          }
                        }
                        imagePromises = _annotation.AnnotationFactory.generateImages(annotationWithBitmaps, this.xref, isOffscreenCanvasSupported);
                      } else {
                        imagePromises = _annotation.AnnotationFactory.generateImages(newAnnotations, this.xref, isOffscreenCanvasSupported);
                      }
                      deletedAnnotations = new _primitives.RefSet();
                      __privateMethod(this, _replaceIdByRef, replaceIdByRef_fn).call(this, newAnnotations, deletedAnnotations, null);
                      newAnnotationsPromise = annotationGlobalsPromise.then((annotationGlobals) => {
                        if (!annotationGlobals) {
                          return null;
                        }
                        return _annotation.AnnotationFactory.printNewAnnotations(annotationGlobals, partialEvaluator, task, newAnnotations, imagePromises);
                      });
                    }
                  }
                  const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
                  const pageListPromise = dataPromises.then(([contentStream]) => {
                    const opList = new _operator_list.OperatorList(intent, sink);
                    handler.send("StartRenderPage", {
                      transparency: partialEvaluator.hasBlendModes(this.resources, this.nonBlendModesSet),
                      pageIndex: this.pageIndex,
                      cacheKey
                    });
                    return partialEvaluator.getOperatorList({
                      stream: contentStream,
                      task,
                      resources: this.resources,
                      operatorList: opList
                    }).then(function() {
                      return opList;
                    });
                  });
                  return Promise.all([pageListPromise, this._parsedAnnotations, newAnnotationsPromise]).then(function([pageOpList, annotations, newAnnotations]) {
                    if (newAnnotations) {
                      annotations = annotations.filter((a) => !(a.ref && deletedAnnotations.has(a.ref)));
                      for (let i = 0, ii = newAnnotations.length; i < ii; i++) {
                        const newAnnotation = newAnnotations[i];
                        if (newAnnotation.refToReplace) {
                          const j = annotations.findIndex((a) => a.ref && (0, _primitives.isRefsEqual)(a.ref, newAnnotation.refToReplace));
                          if (j >= 0) {
                            annotations.splice(j, 1, newAnnotation);
                            newAnnotations.splice(i--, 1);
                            ii--;
                          }
                        }
                      }
                      annotations = annotations.concat(newAnnotations);
                    }
                    if (annotations.length === 0 || intent & _util.RenderingIntentFlag.ANNOTATIONS_DISABLE) {
                      pageOpList.flush(true);
                      return {
                        length: pageOpList.totalLength
                      };
                    }
                    const renderForms = !!(intent & _util.RenderingIntentFlag.ANNOTATIONS_FORMS), intentAny = !!(intent & _util.RenderingIntentFlag.ANY), intentDisplay = !!(intent & _util.RenderingIntentFlag.DISPLAY), intentPrint = !!(intent & _util.RenderingIntentFlag.PRINT);
                    const opListPromises = [];
                    for (const annotation of annotations) {
                      if (intentAny || intentDisplay && annotation.mustBeViewed(annotationStorage, renderForms) || intentPrint && annotation.mustBePrinted(annotationStorage)) {
                        opListPromises.push(annotation.getOperatorList(partialEvaluator, task, intent, renderForms, annotationStorage).catch(function(reason) {
                          (0, _util.warn)(`getOperatorList - ignoring annotation data during "${task.name}" task: "${reason}".`);
                          return {
                            opList: null,
                            separateForm: false,
                            separateCanvas: false
                          };
                        }));
                      }
                    }
                    return Promise.all(opListPromises).then(function(opLists) {
                      let form = false, canvas = false;
                      for (const {
                        opList,
                        separateForm,
                        separateCanvas
                      } of opLists) {
                        pageOpList.addOpList(opList);
                        form || (form = separateForm);
                        canvas || (canvas = separateCanvas);
                      }
                      pageOpList.flush(true, {
                        form,
                        canvas
                      });
                      return {
                        length: pageOpList.totalLength
                      };
                    });
                  });
                }
                extractTextContent({
                  handler,
                  task,
                  includeMarkedContent,
                  disableNormalization,
                  sink
                }) {
                  const contentStreamPromise = this.getContentStream();
                  const resourcesPromise = this.loadResources(["ExtGState", "Font", "Properties", "XObject"]);
                  const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
                  return dataPromises.then(([contentStream]) => {
                    const partialEvaluator = new _evaluator.PartialEvaluator({
                      xref: this.xref,
                      handler,
                      pageIndex: this.pageIndex,
                      idFactory: this._localIdFactory,
                      fontCache: this.fontCache,
                      builtInCMapCache: this.builtInCMapCache,
                      standardFontDataCache: this.standardFontDataCache,
                      globalImageCache: this.globalImageCache,
                      systemFontCache: this.systemFontCache,
                      options: this.evaluatorOptions
                    });
                    return partialEvaluator.getTextContent({
                      stream: contentStream,
                      task,
                      resources: this.resources,
                      includeMarkedContent,
                      disableNormalization,
                      sink,
                      viewBox: this.view
                    });
                  });
                }
                async getStructTree() {
                  const structTreeRoot = await this.pdfManager.ensureCatalog("structTreeRoot");
                  if (!structTreeRoot) {
                    return null;
                  }
                  await this._parsedAnnotations;
                  const structTree = await this.pdfManager.ensure(this, "_parseStructTree", [structTreeRoot]);
                  return structTree.serializable;
                }
                _parseStructTree(structTreeRoot) {
                  const tree = new _struct_tree.StructTreePage(structTreeRoot, this.pageDict);
                  tree.parse(this.ref);
                  return tree;
                }
                async getAnnotationsData(handler, task, intent) {
                  const annotations = await this._parsedAnnotations;
                  if (annotations.length === 0) {
                    return annotations;
                  }
                  const annotationsData = [], textContentPromises = [];
                  let partialEvaluator;
                  const intentAny = !!(intent & _util.RenderingIntentFlag.ANY), intentDisplay = !!(intent & _util.RenderingIntentFlag.DISPLAY), intentPrint = !!(intent & _util.RenderingIntentFlag.PRINT);
                  for (const annotation of annotations) {
                    const isVisible = intentAny || intentDisplay && annotation.viewable;
                    if (isVisible || intentPrint && annotation.printable) {
                      annotationsData.push(annotation.data);
                    }
                    if (annotation.hasTextContent && isVisible) {
                      partialEvaluator || (partialEvaluator = new _evaluator.PartialEvaluator({
                        xref: this.xref,
                        handler,
                        pageIndex: this.pageIndex,
                        idFactory: this._localIdFactory,
                        fontCache: this.fontCache,
                        builtInCMapCache: this.builtInCMapCache,
                        standardFontDataCache: this.standardFontDataCache,
                        globalImageCache: this.globalImageCache,
                        systemFontCache: this.systemFontCache,
                        options: this.evaluatorOptions
                      }));
                      textContentPromises.push(annotation.extractTextContent(partialEvaluator, task, [-Infinity, -Infinity, Infinity, Infinity]).catch(function(reason) {
                        (0, _util.warn)(`getAnnotationsData - ignoring textContent during "${task.name}" task: "${reason}".`);
                      }));
                    }
                  }
                  await Promise.all(textContentPromises);
                  return annotationsData;
                }
                get annotations() {
                  const annots = this._getInheritableProperty("Annots");
                  return (0, _util.shadow)(this, "annotations", Array.isArray(annots) ? annots : []);
                }
                get _parsedAnnotations() {
                  const promise = this.pdfManager.ensure(this, "annotations").then(async (annots) => {
                    if (annots.length === 0) {
                      return annots;
                    }
                    const annotationGlobals = await this.pdfManager.ensureDoc("annotationGlobals");
                    if (!annotationGlobals) {
                      return [];
                    }
                    const annotationPromises = [];
                    for (const annotationRef of annots) {
                      annotationPromises.push(_annotation.AnnotationFactory.create(this.xref, annotationRef, annotationGlobals, this._localIdFactory, false, this.ref).catch(function(reason) {
                        (0, _util.warn)(`_parsedAnnotations: "${reason}".`);
                        return null;
                      }));
                    }
                    const sortedAnnotations = [];
                    let popupAnnotations;
                    for (const annotation of await Promise.all(annotationPromises)) {
                      if (!annotation) {
                        continue;
                      }
                      if (annotation instanceof _annotation.PopupAnnotation) {
                        (popupAnnotations || (popupAnnotations = [])).push(annotation);
                        continue;
                      }
                      sortedAnnotations.push(annotation);
                    }
                    if (popupAnnotations) {
                      sortedAnnotations.push(...popupAnnotations);
                    }
                    return sortedAnnotations;
                  });
                  return (0, _util.shadow)(this, "_parsedAnnotations", promise);
                }
                get jsActions() {
                  const actions = (0, _core_utils.collectActions)(this.xref, this.pageDict, _util.PageActionEventType);
                  return (0, _util.shadow)(this, "jsActions", actions);
                }
              }
              _replaceIdByRef = new WeakSet();
              replaceIdByRef_fn = function(annotations, deletedAnnotations, existingAnnotations) {
                for (const annotation of annotations) {
                  if (annotation.id) {
                    const ref = _primitives.Ref.fromString(annotation.id);
                    if (!ref) {
                      (0, _util.warn)(`A non-linked annotation cannot be modified: ${annotation.id}`);
                      continue;
                    }
                    if (annotation.deleted) {
                      deletedAnnotations.put(ref);
                      continue;
                    }
                    existingAnnotations == null ? void 0 : existingAnnotations.put(ref);
                    annotation.ref = ref;
                    delete annotation.id;
                  }
                }
              };
              exports2.Page = Page;
              const PDF_HEADER_SIGNATURE = new Uint8Array([37, 80, 68, 70, 45]);
              const STARTXREF_SIGNATURE = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
              const ENDOBJ_SIGNATURE = new Uint8Array([101, 110, 100, 111, 98, 106]);
              const FINGERPRINT_FIRST_BYTES = 1024;
              const EMPTY_FINGERPRINT = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
              function find(stream, signature, limit = 1024, backwards = false) {
                const signatureLength = signature.length;
                const scanBytes = stream.peekBytes(limit);
                const scanLength = scanBytes.length - signatureLength;
                if (scanLength <= 0) {
                  return false;
                }
                if (backwards) {
                  const signatureEnd = signatureLength - 1;
                  let pos = scanBytes.length - 1;
                  while (pos >= signatureEnd) {
                    let j = 0;
                    while (j < signatureLength && scanBytes[pos - j] === signature[signatureEnd - j]) {
                      j++;
                    }
                    if (j >= signatureLength) {
                      stream.pos += pos - signatureEnd;
                      return true;
                    }
                    pos--;
                  }
                } else {
                  let pos = 0;
                  while (pos <= scanLength) {
                    let j = 0;
                    while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
                      j++;
                    }
                    if (j >= signatureLength) {
                      stream.pos += pos;
                      return true;
                    }
                    pos++;
                  }
                }
                return false;
              }
              class PDFDocument {
                constructor(pdfManager, stream) {
                  __privateAdd(this, _collectFieldObjects);
                  if (stream.length <= 0) {
                    throw new _util.InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
                  }
                  this.pdfManager = pdfManager;
                  this.stream = stream;
                  this.xref = new _xref.XRef(stream, pdfManager);
                  this._pagePromises = /* @__PURE__ */ new Map();
                  this._version = null;
                  const idCounters = {
                    font: 0
                  };
                  this._globalIdFactory = class {
                    static getDocId() {
                      return `g_${pdfManager.docId}`;
                    }
                    static createFontId() {
                      return `f${++idCounters.font}`;
                    }
                    static createObjId() {
                      (0, _util.unreachable)("Abstract method `createObjId` called.");
                    }
                    static getPageObjId() {
                      (0, _util.unreachable)("Abstract method `getPageObjId` called.");
                    }
                  };
                }
                parse(recoveryMode) {
                  this.xref.parse(recoveryMode);
                  this.catalog = new _catalog.Catalog(this.pdfManager, this.xref);
                }
                get linearization() {
                  let linearization = null;
                  try {
                    linearization = _parser.Linearization.create(this.stream);
                  } catch (err) {
                    if (err instanceof _core_utils.MissingDataException) {
                      throw err;
                    }
                    (0, _util.info)(err);
                  }
                  return (0, _util.shadow)(this, "linearization", linearization);
                }
                get startXRef() {
                  const stream = this.stream;
                  let startXRef = 0;
                  if (this.linearization) {
                    stream.reset();
                    if (find(stream, ENDOBJ_SIGNATURE)) {
                      startXRef = stream.pos + 6 - stream.start;
                    }
                  } else {
                    const step = 1024;
                    const startXRefLength = STARTXREF_SIGNATURE.length;
                    let found = false, pos = stream.end;
                    while (!found && pos > 0) {
                      pos -= step - startXRefLength;
                      if (pos < 0) {
                        pos = 0;
                      }
                      stream.pos = pos;
                      found = find(stream, STARTXREF_SIGNATURE, step, true);
                    }
                    if (found) {
                      stream.skip(9);
                      let ch;
                      do {
                        ch = stream.getByte();
                      } while ((0, _core_utils.isWhiteSpace)(ch));
                      let str = "";
                      while (ch >= 32 && ch <= 57) {
                        str += String.fromCharCode(ch);
                        ch = stream.getByte();
                      }
                      startXRef = parseInt(str, 10);
                      if (isNaN(startXRef)) {
                        startXRef = 0;
                      }
                    }
                  }
                  return (0, _util.shadow)(this, "startXRef", startXRef);
                }
                checkHeader() {
                  const stream = this.stream;
                  stream.reset();
                  if (!find(stream, PDF_HEADER_SIGNATURE)) {
                    return;
                  }
                  stream.moveStart();
                  stream.skip(PDF_HEADER_SIGNATURE.length);
                  let version = "", ch;
                  while ((ch = stream.getByte()) > 32 && version.length < 7) {
                    version += String.fromCharCode(ch);
                  }
                  if (_core_utils.PDF_VERSION_REGEXP.test(version)) {
                    this._version = version;
                  } else {
                    (0, _util.warn)(`Invalid PDF header version: ${version}`);
                  }
                }
                parseStartXRef() {
                  this.xref.setStartXRef(this.startXRef);
                }
                get numPages() {
                  let num = 0;
                  if (this.catalog.hasActualNumPages) {
                    num = this.catalog.numPages;
                  } else if (this.xfaFactory) {
                    num = this.xfaFactory.getNumPages();
                  } else if (this.linearization) {
                    num = this.linearization.numPages;
                  } else {
                    num = this.catalog.numPages;
                  }
                  return (0, _util.shadow)(this, "numPages", num);
                }
                _hasOnlyDocumentSignatures(fields, recursionDepth = 0) {
                  const RECURSION_LIMIT = 10;
                  if (!Array.isArray(fields)) {
                    return false;
                  }
                  return fields.every((field) => {
                    field = this.xref.fetchIfRef(field);
                    if (!(field instanceof _primitives.Dict)) {
                      return false;
                    }
                    if (field.has("Kids")) {
                      if (++recursionDepth > RECURSION_LIMIT) {
                        (0, _util.warn)("_hasOnlyDocumentSignatures: maximum recursion depth reached");
                        return false;
                      }
                      return this._hasOnlyDocumentSignatures(field.get("Kids"), recursionDepth);
                    }
                    const isSignature = (0, _primitives.isName)(field.get("FT"), "Sig");
                    const rectangle = field.get("Rect");
                    const isInvisible = Array.isArray(rectangle) && rectangle.every((value) => value === 0);
                    return isSignature && isInvisible;
                  });
                }
                get _xfaStreams() {
                  const acroForm = this.catalog.acroForm;
                  if (!acroForm) {
                    return null;
                  }
                  const xfa = acroForm.get("XFA");
                  const entries = {
                    "xdp:xdp": "",
                    template: "",
                    datasets: "",
                    config: "",
                    connectionSet: "",
                    localeSet: "",
                    stylesheet: "",
                    "/xdp:xdp": ""
                  };
                  if (xfa instanceof _base_stream.BaseStream && !xfa.isEmpty) {
                    entries["xdp:xdp"] = xfa;
                    return entries;
                  }
                  if (!Array.isArray(xfa) || xfa.length === 0) {
                    return null;
                  }
                  for (let i = 0, ii = xfa.length; i < ii; i += 2) {
                    let name;
                    if (i === 0) {
                      name = "xdp:xdp";
                    } else if (i === ii - 2) {
                      name = "/xdp:xdp";
                    } else {
                      name = xfa[i];
                    }
                    if (!entries.hasOwnProperty(name)) {
                      continue;
                    }
                    const data = this.xref.fetchIfRef(xfa[i + 1]);
                    if (!(data instanceof _base_stream.BaseStream) || data.isEmpty) {
                      continue;
                    }
                    entries[name] = data;
                  }
                  return entries;
                }
                get xfaDatasets() {
                  const streams = this._xfaStreams;
                  if (!streams) {
                    return (0, _util.shadow)(this, "xfaDatasets", null);
                  }
                  for (const key of ["datasets", "xdp:xdp"]) {
                    const stream = streams[key];
                    if (!stream) {
                      continue;
                    }
                    try {
                      const str = (0, _util.stringToUTF8String)(stream.getString());
                      const data = {
                        [key]: str
                      };
                      return (0, _util.shadow)(this, "xfaDatasets", new _dataset_reader.DatasetReader(data));
                    } catch {
                      (0, _util.warn)("XFA - Invalid utf-8 string.");
                      break;
                    }
                  }
                  return (0, _util.shadow)(this, "xfaDatasets", null);
                }
                get xfaData() {
                  const streams = this._xfaStreams;
                  if (!streams) {
                    return null;
                  }
                  const data = /* @__PURE__ */ Object.create(null);
                  for (const [key, stream] of Object.entries(streams)) {
                    if (!stream) {
                      continue;
                    }
                    try {
                      data[key] = (0, _util.stringToUTF8String)(stream.getString());
                    } catch {
                      (0, _util.warn)("XFA - Invalid utf-8 string.");
                      return null;
                    }
                  }
                  return data;
                }
                get xfaFactory() {
                  let data;
                  if (this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm) {
                    data = this.xfaData;
                  }
                  return (0, _util.shadow)(this, "xfaFactory", data ? new _factory.XFAFactory(data) : null);
                }
                get isPureXfa() {
                  return this.xfaFactory ? this.xfaFactory.isValid() : false;
                }
                get htmlForXfa() {
                  return this.xfaFactory ? this.xfaFactory.getPages() : null;
                }
                async loadXfaImages() {
                  const xfaImagesDict = await this.pdfManager.ensureCatalog("xfaImages");
                  if (!xfaImagesDict) {
                    return;
                  }
                  const keys = xfaImagesDict.getKeys();
                  const objectLoader = new _object_loader.ObjectLoader(xfaImagesDict, keys, this.xref);
                  await objectLoader.load();
                  const xfaImages = /* @__PURE__ */ new Map();
                  for (const key of keys) {
                    const stream = xfaImagesDict.get(key);
                    if (stream instanceof _base_stream.BaseStream) {
                      xfaImages.set(key, stream.getBytes());
                    }
                  }
                  this.xfaFactory.setImages(xfaImages);
                }
                async loadXfaFonts(handler, task) {
                  const acroForm = await this.pdfManager.ensureCatalog("acroForm");
                  if (!acroForm) {
                    return;
                  }
                  const resources = await acroForm.getAsync("DR");
                  if (!(resources instanceof _primitives.Dict)) {
                    return;
                  }
                  const objectLoader = new _object_loader.ObjectLoader(resources, ["Font"], this.xref);
                  await objectLoader.load();
                  const fontRes = resources.get("Font");
                  if (!(fontRes instanceof _primitives.Dict)) {
                    return;
                  }
                  const options = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions);
                  options.useSystemFonts = false;
                  const partialEvaluator = new _evaluator.PartialEvaluator({
                    xref: this.xref,
                    handler,
                    pageIndex: -1,
                    idFactory: this._globalIdFactory,
                    fontCache: this.catalog.fontCache,
                    builtInCMapCache: this.catalog.builtInCMapCache,
                    standardFontDataCache: this.catalog.standardFontDataCache,
                    options
                  });
                  const operatorList = new _operator_list.OperatorList();
                  const pdfFonts = [];
                  const initialState = {
                    get font() {
                      return pdfFonts.at(-1);
                    },
                    set font(font) {
                      pdfFonts.push(font);
                    },
                    clone() {
                      return this;
                    }
                  };
                  const fonts = /* @__PURE__ */ new Map();
                  fontRes.forEach((fontName, font) => {
                    fonts.set(fontName, font);
                  });
                  const promises = [];
                  for (const [fontName, font] of fonts) {
                    const descriptor = font.get("FontDescriptor");
                    if (!(descriptor instanceof _primitives.Dict)) {
                      continue;
                    }
                    let fontFamily = descriptor.get("FontFamily");
                    fontFamily = fontFamily.replaceAll(/[ ]+(\d)/g, "$1");
                    const fontWeight = descriptor.get("FontWeight");
                    const italicAngle = -descriptor.get("ItalicAngle");
                    const cssFontInfo = {
                      fontFamily,
                      fontWeight,
                      italicAngle
                    };
                    if (!(0, _core_utils.validateCSSFont)(cssFontInfo)) {
                      continue;
                    }
                    promises.push(partialEvaluator.handleSetFont(resources, [_primitives.Name.get(fontName), 1], null, operatorList, task, initialState, null, cssFontInfo).catch(function(reason) {
                      (0, _util.warn)(`loadXfaFonts: "${reason}".`);
                      return null;
                    }));
                  }
                  await Promise.all(promises);
                  const missingFonts = this.xfaFactory.setFonts(pdfFonts);
                  if (!missingFonts) {
                    return;
                  }
                  options.ignoreErrors = true;
                  promises.length = 0;
                  pdfFonts.length = 0;
                  const reallyMissingFonts = /* @__PURE__ */ new Set();
                  for (const missing of missingFonts) {
                    if (!(0, _xfa_fonts.getXfaFontName)(`${missing}-Regular`)) {
                      reallyMissingFonts.add(missing);
                    }
                  }
                  if (reallyMissingFonts.size) {
                    missingFonts.push("PdfJS-Fallback");
                  }
                  for (const missing of missingFonts) {
                    if (reallyMissingFonts.has(missing)) {
                      continue;
                    }
                    for (const fontInfo of [{
                      name: "Regular",
                      fontWeight: 400,
                      italicAngle: 0
                    }, {
                      name: "Bold",
                      fontWeight: 700,
                      italicAngle: 0
                    }, {
                      name: "Italic",
                      fontWeight: 400,
                      italicAngle: 12
                    }, {
                      name: "BoldItalic",
                      fontWeight: 700,
                      italicAngle: 12
                    }]) {
                      const name = `${missing}-${fontInfo.name}`;
                      const dict = (0, _xfa_fonts.getXfaFontDict)(name);
                      promises.push(partialEvaluator.handleSetFont(resources, [_primitives.Name.get(name), 1], null, operatorList, task, initialState, dict, {
                        fontFamily: missing,
                        fontWeight: fontInfo.fontWeight,
                        italicAngle: fontInfo.italicAngle
                      }).catch(function(reason) {
                        (0, _util.warn)(`loadXfaFonts: "${reason}".`);
                        return null;
                      }));
                    }
                  }
                  await Promise.all(promises);
                  this.xfaFactory.appendFonts(pdfFonts, reallyMissingFonts);
                }
                async serializeXfaData(annotationStorage) {
                  return this.xfaFactory ? this.xfaFactory.serializeData(annotationStorage) : null;
                }
                get version() {
                  return this.catalog.version || this._version;
                }
                get formInfo() {
                  const formInfo = {
                    hasFields: false,
                    hasAcroForm: false,
                    hasXfa: false,
                    hasSignatures: false
                  };
                  const acroForm = this.catalog.acroForm;
                  if (!acroForm) {
                    return (0, _util.shadow)(this, "formInfo", formInfo);
                  }
                  try {
                    const fields = acroForm.get("Fields");
                    const hasFields = Array.isArray(fields) && fields.length > 0;
                    formInfo.hasFields = hasFields;
                    const xfa = acroForm.get("XFA");
                    formInfo.hasXfa = Array.isArray(xfa) && xfa.length > 0 || xfa instanceof _base_stream.BaseStream && !xfa.isEmpty;
                    const sigFlags = acroForm.get("SigFlags");
                    const hasSignatures = !!(sigFlags & 1);
                    const hasOnlyDocumentSignatures = hasSignatures && this._hasOnlyDocumentSignatures(fields);
                    formInfo.hasAcroForm = hasFields && !hasOnlyDocumentSignatures;
                    formInfo.hasSignatures = hasSignatures;
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)(`Cannot fetch form information: "${ex}".`);
                  }
                  return (0, _util.shadow)(this, "formInfo", formInfo);
                }
                get documentInfo() {
                  const docInfo = {
                    PDFFormatVersion: this.version,
                    Language: this.catalog.lang,
                    EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null,
                    IsLinearized: !!this.linearization,
                    IsAcroFormPresent: this.formInfo.hasAcroForm,
                    IsXFAPresent: this.formInfo.hasXfa,
                    IsCollectionPresent: !!this.catalog.collection,
                    IsSignaturesPresent: this.formInfo.hasSignatures
                  };
                  let infoDict;
                  try {
                    infoDict = this.xref.trailer.get("Info");
                  } catch (err) {
                    if (err instanceof _core_utils.MissingDataException) {
                      throw err;
                    }
                    (0, _util.info)("The document information dictionary is invalid.");
                  }
                  if (!(infoDict instanceof _primitives.Dict)) {
                    return (0, _util.shadow)(this, "documentInfo", docInfo);
                  }
                  for (const key of infoDict.getKeys()) {
                    const value = infoDict.get(key);
                    switch (key) {
                      case "Title":
                      case "Author":
                      case "Subject":
                      case "Keywords":
                      case "Creator":
                      case "Producer":
                      case "CreationDate":
                      case "ModDate":
                        if (typeof value === "string") {
                          docInfo[key] = (0, _util.stringToPDFString)(value);
                          continue;
                        }
                        break;
                      case "Trapped":
                        if (value instanceof _primitives.Name) {
                          docInfo[key] = value;
                          continue;
                        }
                        break;
                      default:
                        let customValue;
                        switch (typeof value) {
                          case "string":
                            customValue = (0, _util.stringToPDFString)(value);
                            break;
                          case "number":
                          case "boolean":
                            customValue = value;
                            break;
                          default:
                            if (value instanceof _primitives.Name) {
                              customValue = value;
                            }
                            break;
                        }
                        if (customValue === void 0) {
                          (0, _util.warn)(`Bad value, for custom key "${key}", in Info: ${value}.`);
                          continue;
                        }
                        if (!docInfo.Custom) {
                          docInfo.Custom = /* @__PURE__ */ Object.create(null);
                        }
                        docInfo.Custom[key] = customValue;
                        continue;
                    }
                    (0, _util.warn)(`Bad value, for key "${key}", in Info: ${value}.`);
                  }
                  return (0, _util.shadow)(this, "documentInfo", docInfo);
                }
                get fingerprints() {
                  function validate(data) {
                    return typeof data === "string" && data.length > 0 && data !== EMPTY_FINGERPRINT;
                  }
                  function hexString(hash) {
                    const buf = [];
                    for (const num of hash) {
                      const hex = num.toString(16);
                      buf.push(hex.padStart(2, "0"));
                    }
                    return buf.join("");
                  }
                  const idArray = this.xref.trailer.get("ID");
                  let hashOriginal, hashModified;
                  if (Array.isArray(idArray) && validate(idArray[0])) {
                    hashOriginal = (0, _util.stringToBytes)(idArray[0]);
                    if (idArray[1] !== idArray[0] && validate(idArray[1])) {
                      hashModified = (0, _util.stringToBytes)(idArray[1]);
                    }
                  } else {
                    hashOriginal = (0, _crypto.calculateMD5)(this.stream.getByteRange(0, FINGERPRINT_FIRST_BYTES), 0, FINGERPRINT_FIRST_BYTES);
                  }
                  return (0, _util.shadow)(this, "fingerprints", [hexString(hashOriginal), hashModified ? hexString(hashModified) : null]);
                }
                async _getLinearizationPage(pageIndex) {
                  const {
                    catalog,
                    linearization,
                    xref
                  } = this;
                  const ref = _primitives.Ref.get(linearization.objectNumberFirst, 0);
                  try {
                    const obj = await xref.fetchAsync(ref);
                    if (obj instanceof _primitives.Dict) {
                      let type = obj.getRaw("Type");
                      if (type instanceof _primitives.Ref) {
                        type = await xref.fetchAsync(type);
                      }
                      if ((0, _primitives.isName)(type, "Page") || !obj.has("Type") && !obj.has("Kids")) {
                        if (!catalog.pageKidsCountCache.has(ref)) {
                          catalog.pageKidsCountCache.put(ref, 1);
                        }
                        if (!catalog.pageIndexCache.has(ref)) {
                          catalog.pageIndexCache.put(ref, 0);
                        }
                        return [obj, ref];
                      }
                    }
                    throw new _util.FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
                  } catch (reason) {
                    (0, _util.warn)(`_getLinearizationPage: "${reason.message}".`);
                    return catalog.getPageDict(pageIndex);
                  }
                }
                getPage(pageIndex) {
                  const cachedPromise = this._pagePromises.get(pageIndex);
                  if (cachedPromise) {
                    return cachedPromise;
                  }
                  const {
                    catalog,
                    linearization,
                    xfaFactory
                  } = this;
                  let promise;
                  if (xfaFactory) {
                    promise = Promise.resolve([_primitives.Dict.empty, null]);
                  } else if ((linearization == null ? void 0 : linearization.pageFirst) === pageIndex) {
                    promise = this._getLinearizationPage(pageIndex);
                  } else {
                    promise = catalog.getPageDict(pageIndex);
                  }
                  promise = promise.then(([pageDict, ref]) => {
                    return new Page({
                      pdfManager: this.pdfManager,
                      xref: this.xref,
                      pageIndex,
                      pageDict,
                      ref,
                      globalIdFactory: this._globalIdFactory,
                      fontCache: catalog.fontCache,
                      builtInCMapCache: catalog.builtInCMapCache,
                      standardFontDataCache: catalog.standardFontDataCache,
                      globalImageCache: catalog.globalImageCache,
                      systemFontCache: catalog.systemFontCache,
                      nonBlendModesSet: catalog.nonBlendModesSet,
                      xfaFactory
                    });
                  });
                  this._pagePromises.set(pageIndex, promise);
                  return promise;
                }
                async checkFirstPage(recoveryMode = false) {
                  if (recoveryMode) {
                    return;
                  }
                  try {
                    await this.getPage(0);
                  } catch (reason) {
                    if (reason instanceof _core_utils.XRefEntryException) {
                      this._pagePromises.delete(0);
                      await this.cleanup();
                      throw new _core_utils.XRefParseException();
                    }
                  }
                }
                async checkLastPage(recoveryMode = false) {
                  const {
                    catalog,
                    pdfManager
                  } = this;
                  catalog.setActualNumPages();
                  let numPages;
                  try {
                    await Promise.all([pdfManager.ensureDoc("xfaFactory"), pdfManager.ensureDoc("linearization"), pdfManager.ensureCatalog("numPages")]);
                    if (this.xfaFactory) {
                      return;
                    } else if (this.linearization) {
                      numPages = this.linearization.numPages;
                    } else {
                      numPages = catalog.numPages;
                    }
                    if (!Number.isInteger(numPages)) {
                      throw new _util.FormatError("Page count is not an integer.");
                    } else if (numPages <= 1) {
                      return;
                    }
                    await this.getPage(numPages - 1);
                  } catch (reason) {
                    this._pagePromises.delete(numPages - 1);
                    await this.cleanup();
                    if (reason instanceof _core_utils.XRefEntryException && !recoveryMode) {
                      throw new _core_utils.XRefParseException();
                    }
                    (0, _util.warn)(`checkLastPage - invalid /Pages tree /Count: ${numPages}.`);
                    let pagesTree;
                    try {
                      pagesTree = await catalog.getAllPageDicts(recoveryMode);
                    } catch (reasonAll) {
                      if (reasonAll instanceof _core_utils.XRefEntryException && !recoveryMode) {
                        throw new _core_utils.XRefParseException();
                      }
                      catalog.setActualNumPages(1);
                      return;
                    }
                    for (const [pageIndex, [pageDict, ref]] of pagesTree) {
                      let promise;
                      if (pageDict instanceof Error) {
                        promise = Promise.reject(pageDict);
                        promise.catch(() => {
                        });
                      } else {
                        promise = Promise.resolve(new Page({
                          pdfManager,
                          xref: this.xref,
                          pageIndex,
                          pageDict,
                          ref,
                          globalIdFactory: this._globalIdFactory,
                          fontCache: catalog.fontCache,
                          builtInCMapCache: catalog.builtInCMapCache,
                          standardFontDataCache: catalog.standardFontDataCache,
                          globalImageCache: catalog.globalImageCache,
                          systemFontCache: catalog.systemFontCache,
                          nonBlendModesSet: catalog.nonBlendModesSet,
                          xfaFactory: null
                        }));
                      }
                      this._pagePromises.set(pageIndex, promise);
                    }
                    catalog.setActualNumPages(pagesTree.size);
                  }
                }
                fontFallback(id, handler) {
                  return this.catalog.fontFallback(id, handler);
                }
                async cleanup(manuallyTriggered = false) {
                  return this.catalog ? this.catalog.cleanup(manuallyTriggered) : (0, _cleanup_helper.clearGlobalCaches)();
                }
                get fieldObjects() {
                  if (!this.formInfo.hasFields) {
                    return (0, _util.shadow)(this, "fieldObjects", Promise.resolve(null));
                  }
                  const promise = this.pdfManager.ensureDoc("annotationGlobals").then(async (annotationGlobals) => {
                    if (!annotationGlobals) {
                      return null;
                    }
                    const allFields = /* @__PURE__ */ Object.create(null);
                    const fieldPromises = /* @__PURE__ */ new Map();
                    for (const fieldRef of this.catalog.acroForm.get("Fields")) {
                      __privateMethod(this, _collectFieldObjects, collectFieldObjects_fn).call(this, "", fieldRef, fieldPromises, annotationGlobals);
                    }
                    const allPromises = [];
                    for (const [name, promises] of fieldPromises) {
                      allPromises.push(Promise.all(promises).then((fields) => {
                        fields = fields.filter((field) => !!field);
                        if (fields.length > 0) {
                          allFields[name] = fields;
                        }
                      }));
                    }
                    await Promise.all(allPromises);
                    return allFields;
                  });
                  return (0, _util.shadow)(this, "fieldObjects", promise);
                }
                get hasJSActions() {
                  const promise = this.pdfManager.ensureDoc("_parseHasJSActions");
                  return (0, _util.shadow)(this, "hasJSActions", promise);
                }
                async _parseHasJSActions() {
                  const [catalogJsActions, fieldObjects] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
                  if (catalogJsActions) {
                    return true;
                  }
                  if (fieldObjects) {
                    return Object.values(fieldObjects).some((fieldObject) => fieldObject.some((object) => object.actions !== null));
                  }
                  return false;
                }
                get calculationOrderIds() {
                  const acroForm = this.catalog.acroForm;
                  if (!(acroForm == null ? void 0 : acroForm.has("CO"))) {
                    return (0, _util.shadow)(this, "calculationOrderIds", null);
                  }
                  const calculationOrder = acroForm.get("CO");
                  if (!Array.isArray(calculationOrder) || calculationOrder.length === 0) {
                    return (0, _util.shadow)(this, "calculationOrderIds", null);
                  }
                  const ids = [];
                  for (const id of calculationOrder) {
                    if (id instanceof _primitives.Ref) {
                      ids.push(id.toString());
                    }
                  }
                  if (ids.length === 0) {
                    return (0, _util.shadow)(this, "calculationOrderIds", null);
                  }
                  return (0, _util.shadow)(this, "calculationOrderIds", ids);
                }
                get annotationGlobals() {
                  return (0, _util.shadow)(this, "annotationGlobals", _annotation.AnnotationFactory.createGlobals(this.pdfManager));
                }
              }
              _collectFieldObjects = new WeakSet();
              collectFieldObjects_fn = function(name, fieldRef, promises, annotationGlobals) {
                const field = this.xref.fetchIfRef(fieldRef);
                if (field.has("T")) {
                  const partName = (0, _util.stringToPDFString)(field.get("T"));
                  name = name === "" ? partName : `${name}.${partName}`;
                }
                if (!promises.has(name)) {
                  promises.set(name, []);
                }
                promises.get(name).push(_annotation.AnnotationFactory.create(this.xref, fieldRef, annotationGlobals, this._localIdFactory, true, null).then((annotation) => annotation == null ? void 0 : annotation.getFieldObject()).catch(function(reason) {
                  (0, _util.warn)(`#collectFieldObjects: "${reason}".`);
                  return null;
                }));
                if (field.has("Kids")) {
                  for (const kid of field.get("Kids")) {
                    __privateMethod(this, _collectFieldObjects, collectFieldObjects_fn).call(this, name, kid, promises, annotationGlobals);
                  }
                }
              };
              exports2.PDFDocument = PDFDocument;
            },
            /* 10 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PopupAnnotation = exports2.MarkupAnnotation = exports2.AnnotationFactory = exports2.AnnotationBorderStyle = exports2.Annotation = void 0;
              exports2.getQuadPoints = getQuadPoints;
              var _util = __w_pdfjs_require__2(2);
              var _core_utils = __w_pdfjs_require__2(3);
              var _default_appearance = __w_pdfjs_require__2(11);
              var _primitives = __w_pdfjs_require__2(4);
              var _stream = __w_pdfjs_require__2(8);
              var _base_stream = __w_pdfjs_require__2(5);
              var _bidi = __w_pdfjs_require__2(60);
              var _catalog = __w_pdfjs_require__2(66);
              var _colorspace = __w_pdfjs_require__2(12);
              var _file_spec = __w_pdfjs_require__2(69);
              var _jpeg_stream = __w_pdfjs_require__2(26);
              var _object_loader = __w_pdfjs_require__2(76);
              var _operator_list = __w_pdfjs_require__2(64);
              var _writer = __w_pdfjs_require__2(73);
              var _factory = __w_pdfjs_require__2(77);
              class AnnotationFactory {
                static createGlobals(pdfManager) {
                  return Promise.all([pdfManager.ensureCatalog("acroForm"), pdfManager.ensureDoc("xfaDatasets"), pdfManager.ensureCatalog("structTreeRoot"), pdfManager.ensureCatalog("baseUrl"), pdfManager.ensureCatalog("attachments")]).then(([acroForm, xfaDatasets, structTreeRoot, baseUrl, attachments]) => {
                    return {
                      pdfManager,
                      acroForm: acroForm instanceof _primitives.Dict ? acroForm : _primitives.Dict.empty,
                      xfaDatasets,
                      structTreeRoot,
                      baseUrl,
                      attachments
                    };
                  }, (reason) => {
                    (0, _util.warn)(`createGlobals: "${reason}".`);
                    return null;
                  });
                }
                static async create(xref, ref, annotationGlobals, idFactory, collectFields, pageRef) {
                  const pageIndex = collectFields ? await this._getPageIndex(xref, ref, annotationGlobals.pdfManager) : null;
                  return annotationGlobals.pdfManager.ensure(this, "_create", [xref, ref, annotationGlobals, idFactory, collectFields, pageIndex, pageRef]);
                }
                static _create(xref, ref, annotationGlobals, idFactory, collectFields = false, pageIndex = null, pageRef = null) {
                  const dict = xref.fetchIfRef(ref);
                  if (!(dict instanceof _primitives.Dict)) {
                    return void 0;
                  }
                  const {
                    acroForm,
                    pdfManager
                  } = annotationGlobals;
                  const id = ref instanceof _primitives.Ref ? ref.toString() : `annot_${idFactory.createObjId()}`;
                  let subtype = dict.get("Subtype");
                  subtype = subtype instanceof _primitives.Name ? subtype.name : null;
                  const parameters = {
                    xref,
                    ref,
                    dict,
                    subtype,
                    id,
                    annotationGlobals,
                    collectFields,
                    needAppearances: !collectFields && acroForm.get("NeedAppearances") === true,
                    pageIndex,
                    evaluatorOptions: pdfManager.evaluatorOptions,
                    pageRef
                  };
                  switch (subtype) {
                    case "Link":
                      return new LinkAnnotation(parameters);
                    case "Text":
                      return new TextAnnotation(parameters);
                    case "Widget":
                      let fieldType = (0, _core_utils.getInheritableProperty)({
                        dict,
                        key: "FT"
                      });
                      fieldType = fieldType instanceof _primitives.Name ? fieldType.name : null;
                      switch (fieldType) {
                        case "Tx":
                          return new TextWidgetAnnotation(parameters);
                        case "Btn":
                          return new ButtonWidgetAnnotation(parameters);
                        case "Ch":
                          return new ChoiceWidgetAnnotation(parameters);
                        case "Sig":
                          return new SignatureWidgetAnnotation(parameters);
                      }
                      (0, _util.warn)(`Unimplemented widget field type "${fieldType}", falling back to base field type.`);
                      return new WidgetAnnotation(parameters);
                    case "Popup":
                      return new PopupAnnotation(parameters);
                    case "FreeText":
                      return new FreeTextAnnotation(parameters);
                    case "Line":
                      return new LineAnnotation(parameters);
                    case "Square":
                      return new SquareAnnotation(parameters);
                    case "Circle":
                      return new CircleAnnotation(parameters);
                    case "PolyLine":
                      return new PolylineAnnotation(parameters);
                    case "Polygon":
                      return new PolygonAnnotation(parameters);
                    case "Caret":
                      return new CaretAnnotation(parameters);
                    case "Ink":
                      return new InkAnnotation(parameters);
                    case "Highlight":
                      return new HighlightAnnotation(parameters);
                    case "Underline":
                      return new UnderlineAnnotation(parameters);
                    case "Squiggly":
                      return new SquigglyAnnotation(parameters);
                    case "StrikeOut":
                      return new StrikeOutAnnotation(parameters);
                    case "Stamp":
                      return new StampAnnotation(parameters);
                    case "FileAttachment":
                      return new FileAttachmentAnnotation(parameters);
                    default:
                      if (!collectFields) {
                        if (!subtype) {
                          (0, _util.warn)("Annotation is missing the required /Subtype.");
                        } else {
                          (0, _util.warn)(`Unimplemented annotation type "${subtype}", falling back to base annotation.`);
                        }
                      }
                      return new Annotation(parameters);
                  }
                }
                static async _getPageIndex(xref, ref, pdfManager) {
                  try {
                    const annotDict = await xref.fetchIfRefAsync(ref);
                    if (!(annotDict instanceof _primitives.Dict)) {
                      return -1;
                    }
                    const pageRef = annotDict.getRaw("P");
                    if (pageRef instanceof _primitives.Ref) {
                      try {
                        const pageIndex = await pdfManager.ensureCatalog("getPageIndex", [pageRef]);
                        return pageIndex;
                      } catch (ex) {
                        (0, _util.info)(`_getPageIndex -- not a valid page reference: "${ex}".`);
                      }
                    }
                    if (annotDict.has("Kids")) {
                      return -1;
                    }
                    const numPages = await pdfManager.ensureDoc("numPages");
                    for (let pageIndex = 0; pageIndex < numPages; pageIndex++) {
                      const page = await pdfManager.getPage(pageIndex);
                      const annotations = await pdfManager.ensure(page, "annotations");
                      for (const annotRef of annotations) {
                        if (annotRef instanceof _primitives.Ref && (0, _primitives.isRefsEqual)(annotRef, ref)) {
                          return pageIndex;
                        }
                      }
                    }
                  } catch (ex) {
                    (0, _util.warn)(`_getPageIndex: "${ex}".`);
                  }
                  return -1;
                }
                static generateImages(annotations, xref, isOffscreenCanvasSupported) {
                  if (!isOffscreenCanvasSupported) {
                    (0, _util.warn)("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images.");
                    return null;
                  }
                  let imagePromises;
                  for (const {
                    bitmapId,
                    bitmap
                  } of annotations) {
                    if (!bitmap) {
                      continue;
                    }
                    imagePromises || (imagePromises = /* @__PURE__ */ new Map());
                    imagePromises.set(bitmapId, StampAnnotation.createImage(bitmap, xref));
                  }
                  return imagePromises;
                }
                static async saveNewAnnotations(evaluator, task, annotations, imagePromises) {
                  const xref = evaluator.xref;
                  let baseFontRef;
                  const dependencies = [];
                  const promises = [];
                  const {
                    isOffscreenCanvasSupported
                  } = evaluator.options;
                  for (const annotation of annotations) {
                    if (annotation.deleted) {
                      continue;
                    }
                    switch (annotation.annotationType) {
                      case _util.AnnotationEditorType.FREETEXT:
                        if (!baseFontRef) {
                          const baseFont = new _primitives.Dict(xref);
                          baseFont.set("BaseFont", _primitives.Name.get("Helvetica"));
                          baseFont.set("Type", _primitives.Name.get("Font"));
                          baseFont.set("Subtype", _primitives.Name.get("Type1"));
                          baseFont.set("Encoding", _primitives.Name.get("WinAnsiEncoding"));
                          const buffer = [];
                          baseFontRef = xref.getNewTemporaryRef();
                          await (0, _writer.writeObject)(baseFontRef, baseFont, buffer, xref);
                          dependencies.push({
                            ref: baseFontRef,
                            data: buffer.join("")
                          });
                        }
                        promises.push(FreeTextAnnotation.createNewAnnotation(xref, annotation, dependencies, {
                          evaluator,
                          task,
                          baseFontRef
                        }));
                        break;
                      case _util.AnnotationEditorType.INK:
                        promises.push(InkAnnotation.createNewAnnotation(xref, annotation, dependencies));
                        break;
                      case _util.AnnotationEditorType.STAMP:
                        if (!isOffscreenCanvasSupported) {
                          break;
                        }
                        const image = await imagePromises.get(annotation.bitmapId);
                        if (image.imageStream) {
                          const {
                            imageStream,
                            smaskStream
                          } = image;
                          const buffer = [];
                          if (smaskStream) {
                            const smaskRef = xref.getNewTemporaryRef();
                            await (0, _writer.writeObject)(smaskRef, smaskStream, buffer, xref);
                            dependencies.push({
                              ref: smaskRef,
                              data: buffer.join("")
                            });
                            imageStream.dict.set("SMask", smaskRef);
                            buffer.length = 0;
                          }
                          const imageRef = image.imageRef = xref.getNewTemporaryRef();
                          await (0, _writer.writeObject)(imageRef, imageStream, buffer, xref);
                          dependencies.push({
                            ref: imageRef,
                            data: buffer.join("")
                          });
                          image.imageStream = image.smaskStream = null;
                        }
                        promises.push(StampAnnotation.createNewAnnotation(xref, annotation, dependencies, {
                          image
                        }));
                        break;
                    }
                  }
                  return {
                    annotations: await Promise.all(promises),
                    dependencies
                  };
                }
                static async printNewAnnotations(annotationGlobals, evaluator, task, annotations, imagePromises) {
                  if (!annotations) {
                    return null;
                  }
                  const {
                    options,
                    xref
                  } = evaluator;
                  const promises = [];
                  for (const annotation of annotations) {
                    if (annotation.deleted) {
                      continue;
                    }
                    switch (annotation.annotationType) {
                      case _util.AnnotationEditorType.FREETEXT:
                        promises.push(FreeTextAnnotation.createNewPrintAnnotation(annotationGlobals, xref, annotation, {
                          evaluator,
                          task,
                          evaluatorOptions: options
                        }));
                        break;
                      case _util.AnnotationEditorType.INK:
                        promises.push(InkAnnotation.createNewPrintAnnotation(annotationGlobals, xref, annotation, {
                          evaluatorOptions: options
                        }));
                        break;
                      case _util.AnnotationEditorType.STAMP:
                        if (!options.isOffscreenCanvasSupported) {
                          break;
                        }
                        const image = await imagePromises.get(annotation.bitmapId);
                        if (image.imageStream) {
                          const {
                            imageStream,
                            smaskStream
                          } = image;
                          if (smaskStream) {
                            imageStream.dict.set("SMask", smaskStream);
                          }
                          image.imageRef = new _jpeg_stream.JpegStream(imageStream, imageStream.length);
                          image.imageStream = image.smaskStream = null;
                        }
                        promises.push(StampAnnotation.createNewPrintAnnotation(annotationGlobals, xref, annotation, {
                          image,
                          evaluatorOptions: options
                        }));
                        break;
                    }
                  }
                  return Promise.all(promises);
                }
              }
              exports2.AnnotationFactory = AnnotationFactory;
              function getRgbColor(color, defaultColor = new Uint8ClampedArray(3)) {
                if (!Array.isArray(color)) {
                  return defaultColor;
                }
                const rgbColor = defaultColor || new Uint8ClampedArray(3);
                switch (color.length) {
                  case 0:
                    return null;
                  case 1:
                    _colorspace.ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);
                    return rgbColor;
                  case 3:
                    _colorspace.ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);
                    return rgbColor;
                  case 4:
                    _colorspace.ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);
                    return rgbColor;
                  default:
                    return defaultColor;
                }
              }
              function getPdfColorArray(color) {
                return Array.from(color, (c) => c / 255);
              }
              function getQuadPoints(dict, rect) {
                const quadPoints = dict.getArray("QuadPoints");
                if (!Array.isArray(quadPoints) || quadPoints.length === 0 || quadPoints.length % 8 > 0) {
                  return null;
                }
                const quadPointsLists = [];
                for (let i = 0, ii = quadPoints.length / 8; i < ii; i++) {
                  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                  for (let j = i * 8, jj = i * 8 + 8; j < jj; j += 2) {
                    const x = quadPoints[j];
                    const y = quadPoints[j + 1];
                    minX = Math.min(x, minX);
                    maxX = Math.max(x, maxX);
                    minY = Math.min(y, minY);
                    maxY = Math.max(y, maxY);
                  }
                  if (rect !== null && (minX < rect[0] || maxX > rect[2] || minY < rect[1] || maxY > rect[3])) {
                    return null;
                  }
                  quadPointsLists.push([{
                    x: minX,
                    y: maxY
                  }, {
                    x: maxX,
                    y: maxY
                  }, {
                    x: minX,
                    y: minY
                  }, {
                    x: maxX,
                    y: minY
                  }]);
                }
                return quadPointsLists;
              }
              function getTransformMatrix(rect, bbox, matrix) {
                const [minX, minY, maxX, maxY] = _util.Util.getAxialAlignedBoundingBox(bbox, matrix);
                if (minX === maxX || minY === maxY) {
                  return [1, 0, 0, 1, rect[0], rect[1]];
                }
                const xRatio = (rect[2] - rect[0]) / (maxX - minX);
                const yRatio = (rect[3] - rect[1]) / (maxY - minY);
                return [xRatio, 0, 0, yRatio, rect[0] - minX * xRatio, rect[1] - minY * yRatio];
              }
              class Annotation {
                constructor(params) {
                  const {
                    dict,
                    xref,
                    annotationGlobals
                  } = params;
                  this.setTitle(dict.get("T"));
                  this.setContents(dict.get("Contents"));
                  this.setModificationDate(dict.get("M"));
                  this.setFlags(dict.get("F"));
                  this.setRectangle(dict.getArray("Rect"));
                  this.setColor(dict.getArray("C"));
                  this.setBorderStyle(dict);
                  this.setAppearance(dict);
                  this.setOptionalContent(dict);
                  const MK = dict.get("MK");
                  this.setBorderAndBackgroundColors(MK);
                  this.setRotation(MK, dict);
                  this.ref = params.ref instanceof _primitives.Ref ? params.ref : null;
                  this._streams = [];
                  if (this.appearance) {
                    this._streams.push(this.appearance);
                  }
                  const isLocked = !!(this.flags & _util.AnnotationFlag.LOCKED);
                  const isContentLocked = !!(this.flags & _util.AnnotationFlag.LOCKEDCONTENTS);
                  if (annotationGlobals.structTreeRoot) {
                    let structParent = dict.get("StructParent");
                    structParent = Number.isInteger(structParent) && structParent >= 0 ? structParent : -1;
                    annotationGlobals.structTreeRoot.addAnnotationIdToPage(params.pageRef, structParent);
                  }
                  this.data = {
                    annotationFlags: this.flags,
                    borderStyle: this.borderStyle,
                    color: this.color,
                    backgroundColor: this.backgroundColor,
                    borderColor: this.borderColor,
                    rotation: this.rotation,
                    contentsObj: this._contents,
                    hasAppearance: !!this.appearance,
                    id: params.id,
                    modificationDate: this.modificationDate,
                    rect: this.rectangle,
                    subtype: params.subtype,
                    hasOwnCanvas: false,
                    noRotate: !!(this.flags & _util.AnnotationFlag.NOROTATE),
                    noHTML: isLocked && isContentLocked
                  };
                  if (params.collectFields) {
                    const kids = dict.get("Kids");
                    if (Array.isArray(kids)) {
                      const kidIds = [];
                      for (const kid of kids) {
                        if (kid instanceof _primitives.Ref) {
                          kidIds.push(kid.toString());
                        }
                      }
                      if (kidIds.length !== 0) {
                        this.data.kidIds = kidIds;
                      }
                    }
                    this.data.actions = (0, _core_utils.collectActions)(xref, dict, _util.AnnotationActionEventType);
                    this.data.fieldName = this._constructFieldName(dict);
                    this.data.pageIndex = params.pageIndex;
                  }
                  this._isOffscreenCanvasSupported = params.evaluatorOptions.isOffscreenCanvasSupported;
                  this._fallbackFontDict = null;
                  this._needAppearances = false;
                }
                _hasFlag(flags, flag) {
                  return !!(flags & flag);
                }
                _isViewable(flags) {
                  return !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, _util.AnnotationFlag.NOVIEW);
                }
                _isPrintable(flags) {
                  return this._hasFlag(flags, _util.AnnotationFlag.PRINT) && !this._hasFlag(flags, _util.AnnotationFlag.HIDDEN) && !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE);
                }
                mustBeViewed(annotationStorage, _renderForms) {
                  var _a;
                  const noView = (_a = annotationStorage == null ? void 0 : annotationStorage.get(this.data.id)) == null ? void 0 : _a.noView;
                  if (noView !== void 0) {
                    return !noView;
                  }
                  return this.viewable && !this._hasFlag(this.flags, _util.AnnotationFlag.HIDDEN);
                }
                mustBePrinted(annotationStorage) {
                  var _a;
                  const noPrint = (_a = annotationStorage == null ? void 0 : annotationStorage.get(this.data.id)) == null ? void 0 : _a.noPrint;
                  if (noPrint !== void 0) {
                    return !noPrint;
                  }
                  return this.printable;
                }
                get viewable() {
                  if (this.data.quadPoints === null) {
                    return false;
                  }
                  if (this.flags === 0) {
                    return true;
                  }
                  return this._isViewable(this.flags);
                }
                get printable() {
                  if (this.data.quadPoints === null) {
                    return false;
                  }
                  if (this.flags === 0) {
                    return false;
                  }
                  return this._isPrintable(this.flags);
                }
                _parseStringHelper(data) {
                  const str = typeof data === "string" ? (0, _util.stringToPDFString)(data) : "";
                  const dir = str && (0, _bidi.bidi)(str).dir === "rtl" ? "rtl" : "ltr";
                  return {
                    str,
                    dir
                  };
                }
                setDefaultAppearance(params) {
                  const {
                    dict,
                    annotationGlobals
                  } = params;
                  const defaultAppearance = (0, _core_utils.getInheritableProperty)({
                    dict,
                    key: "DA"
                  }) || annotationGlobals.acroForm.get("DA");
                  this._defaultAppearance = typeof defaultAppearance === "string" ? defaultAppearance : "";
                  this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance);
                }
                setTitle(title) {
                  this._title = this._parseStringHelper(title);
                }
                setContents(contents) {
                  this._contents = this._parseStringHelper(contents);
                }
                setModificationDate(modificationDate) {
                  this.modificationDate = typeof modificationDate === "string" ? modificationDate : null;
                }
                setFlags(flags) {
                  this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
                }
                hasFlag(flag) {
                  return this._hasFlag(this.flags, flag);
                }
                setRectangle(rectangle) {
                  this.rectangle = Array.isArray(rectangle) && rectangle.length === 4 ? _util.Util.normalizeRect(rectangle) : [0, 0, 0, 0];
                }
                setColor(color) {
                  this.color = getRgbColor(color);
                }
                setLineEndings(lineEndings) {
                  this.lineEndings = ["None", "None"];
                  if (Array.isArray(lineEndings) && lineEndings.length === 2) {
                    for (let i = 0; i < 2; i++) {
                      const obj = lineEndings[i];
                      if (obj instanceof _primitives.Name) {
                        switch (obj.name) {
                          case "None":
                            continue;
                          case "Square":
                          case "Circle":
                          case "Diamond":
                          case "OpenArrow":
                          case "ClosedArrow":
                          case "Butt":
                          case "ROpenArrow":
                          case "RClosedArrow":
                          case "Slash":
                            this.lineEndings[i] = obj.name;
                            continue;
                        }
                      }
                      (0, _util.warn)(`Ignoring invalid lineEnding: ${obj}`);
                    }
                  }
                }
                setRotation(mk, dict) {
                  this.rotation = 0;
                  let angle = mk instanceof _primitives.Dict ? mk.get("R") || 0 : dict.get("Rotate") || 0;
                  if (Number.isInteger(angle) && angle !== 0) {
                    angle %= 360;
                    if (angle < 0) {
                      angle += 360;
                    }
                    if (angle % 90 === 0) {
                      this.rotation = angle;
                    }
                  }
                }
                setBorderAndBackgroundColors(mk) {
                  if (mk instanceof _primitives.Dict) {
                    this.borderColor = getRgbColor(mk.getArray("BC"), null);
                    this.backgroundColor = getRgbColor(mk.getArray("BG"), null);
                  } else {
                    this.borderColor = this.backgroundColor = null;
                  }
                }
                setBorderStyle(borderStyle) {
                  this.borderStyle = new AnnotationBorderStyle();
                  if (!(borderStyle instanceof _primitives.Dict)) {
                    return;
                  }
                  if (borderStyle.has("BS")) {
                    const dict = borderStyle.get("BS");
                    const dictType = dict.get("Type");
                    if (!dictType || (0, _primitives.isName)(dictType, "Border")) {
                      this.borderStyle.setWidth(dict.get("W"), this.rectangle);
                      this.borderStyle.setStyle(dict.get("S"));
                      this.borderStyle.setDashArray(dict.getArray("D"));
                    }
                  } else if (borderStyle.has("Border")) {
                    const array = borderStyle.getArray("Border");
                    if (Array.isArray(array) && array.length >= 3) {
                      this.borderStyle.setHorizontalCornerRadius(array[0]);
                      this.borderStyle.setVerticalCornerRadius(array[1]);
                      this.borderStyle.setWidth(array[2], this.rectangle);
                      if (array.length === 4) {
                        this.borderStyle.setDashArray(array[3], true);
                      }
                    }
                  } else {
                    this.borderStyle.setWidth(0);
                  }
                }
                setAppearance(dict) {
                  this.appearance = null;
                  const appearanceStates = dict.get("AP");
                  if (!(appearanceStates instanceof _primitives.Dict)) {
                    return;
                  }
                  const normalAppearanceState = appearanceStates.get("N");
                  if (normalAppearanceState instanceof _base_stream.BaseStream) {
                    this.appearance = normalAppearanceState;
                    return;
                  }
                  if (!(normalAppearanceState instanceof _primitives.Dict)) {
                    return;
                  }
                  const as = dict.get("AS");
                  if (!(as instanceof _primitives.Name) || !normalAppearanceState.has(as.name)) {
                    return;
                  }
                  const appearance = normalAppearanceState.get(as.name);
                  if (appearance instanceof _base_stream.BaseStream) {
                    this.appearance = appearance;
                  }
                }
                setOptionalContent(dict) {
                  this.oc = null;
                  const oc = dict.get("OC");
                  if (oc instanceof _primitives.Name) {
                    (0, _util.warn)("setOptionalContent: Support for /Name-entry is not implemented.");
                  } else if (oc instanceof _primitives.Dict) {
                    this.oc = oc;
                  }
                }
                loadResources(keys, appearance) {
                  return appearance.dict.getAsync("Resources").then((resources) => {
                    if (!resources) {
                      return void 0;
                    }
                    const objectLoader = new _object_loader.ObjectLoader(resources, keys, resources.xref);
                    return objectLoader.load().then(function() {
                      return resources;
                    });
                  });
                }
                async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) {
                  const data = this.data;
                  let appearance = this.appearance;
                  const isUsingOwnCanvas = !!(this.data.hasOwnCanvas && intent & _util.RenderingIntentFlag.DISPLAY);
                  if (!appearance) {
                    if (!isUsingOwnCanvas) {
                      return {
                        opList: new _operator_list.OperatorList(),
                        separateForm: false,
                        separateCanvas: false
                      };
                    }
                    appearance = new _stream.StringStream("");
                    appearance.dict = new _primitives.Dict();
                  }
                  const appearanceDict = appearance.dict;
                  const resources = await this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"], appearance);
                  const bbox = appearanceDict.getArray("BBox") || [0, 0, 1, 1];
                  const matrix = appearanceDict.getArray("Matrix") || [1, 0, 0, 1, 0, 0];
                  const transform = getTransformMatrix(data.rect, bbox, matrix);
                  const opList = new _operator_list.OperatorList();
                  let optionalContent;
                  if (this.oc) {
                    optionalContent = await evaluator.parseMarkedContentProps(this.oc, null);
                  }
                  if (optionalContent !== void 0) {
                    opList.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);
                  }
                  opList.addOp(_util.OPS.beginAnnotation, [data.id, data.rect, transform, matrix, isUsingOwnCanvas]);
                  await evaluator.getOperatorList({
                    stream: appearance,
                    task,
                    resources,
                    operatorList: opList,
                    fallbackFontDict: this._fallbackFontDict
                  });
                  opList.addOp(_util.OPS.endAnnotation, []);
                  if (optionalContent !== void 0) {
                    opList.addOp(_util.OPS.endMarkedContent, []);
                  }
                  this.reset();
                  return {
                    opList,
                    separateForm: false,
                    separateCanvas: isUsingOwnCanvas
                  };
                }
                async save(evaluator, task, annotationStorage) {
                  return null;
                }
                get hasTextContent() {
                  return false;
                }
                async extractTextContent(evaluator, task, viewBox) {
                  if (!this.appearance) {
                    return;
                  }
                  const resources = await this.loadResources(["ExtGState", "Font", "Properties", "XObject"], this.appearance);
                  const text = [];
                  const buffer = [];
                  let firstPosition = null;
                  const sink = {
                    desiredSize: Math.Infinity,
                    ready: true,
                    enqueue(chunk, size) {
                      for (const item of chunk.items) {
                        if (item.str === void 0) {
                          continue;
                        }
                        firstPosition || (firstPosition = item.transform.slice(-2));
                        buffer.push(item.str);
                        if (item.hasEOL) {
                          text.push(buffer.join(""));
                          buffer.length = 0;
                        }
                      }
                    }
                  };
                  await evaluator.getTextContent({
                    stream: this.appearance,
                    task,
                    resources,
                    includeMarkedContent: true,
                    sink,
                    viewBox
                  });
                  this.reset();
                  if (buffer.length) {
                    text.push(buffer.join(""));
                  }
                  if (text.length > 1 || text[0]) {
                    const appearanceDict = this.appearance.dict;
                    const bbox = appearanceDict.getArray("BBox") || [0, 0, 1, 1];
                    const matrix = appearanceDict.getArray("Matrix") || [1, 0, 0, 1, 0, 0];
                    const rect = this.data.rect;
                    const transform = getTransformMatrix(rect, bbox, matrix);
                    transform[4] -= rect[0];
                    transform[5] -= rect[1];
                    firstPosition = _util.Util.applyTransform(firstPosition, transform);
                    firstPosition = _util.Util.applyTransform(firstPosition, matrix);
                    this.data.textPosition = firstPosition;
                    this.data.textContent = text;
                  }
                }
                getFieldObject() {
                  if (this.data.kidIds) {
                    return {
                      id: this.data.id,
                      actions: this.data.actions,
                      name: this.data.fieldName,
                      strokeColor: this.data.borderColor,
                      fillColor: this.data.backgroundColor,
                      type: "",
                      kidIds: this.data.kidIds,
                      page: this.data.pageIndex,
                      rotation: this.rotation
                    };
                  }
                  return null;
                }
                reset() {
                  for (const stream of this._streams) {
                    stream.reset();
                  }
                }
                _constructFieldName(dict) {
                  if (!dict.has("T") && !dict.has("Parent")) {
                    (0, _util.warn)("Unknown field name, falling back to empty field name.");
                    return "";
                  }
                  if (!dict.has("Parent")) {
                    return (0, _util.stringToPDFString)(dict.get("T"));
                  }
                  const fieldName = [];
                  if (dict.has("T")) {
                    fieldName.unshift((0, _util.stringToPDFString)(dict.get("T")));
                  }
                  let loopDict = dict;
                  const visited = new _primitives.RefSet();
                  if (dict.objId) {
                    visited.put(dict.objId);
                  }
                  while (loopDict.has("Parent")) {
                    loopDict = loopDict.get("Parent");
                    if (!(loopDict instanceof _primitives.Dict) || loopDict.objId && visited.has(loopDict.objId)) {
                      break;
                    }
                    if (loopDict.objId) {
                      visited.put(loopDict.objId);
                    }
                    if (loopDict.has("T")) {
                      fieldName.unshift((0, _util.stringToPDFString)(loopDict.get("T")));
                    }
                  }
                  return fieldName.join(".");
                }
              }
              exports2.Annotation = Annotation;
              class AnnotationBorderStyle {
                constructor() {
                  this.width = 1;
                  this.style = _util.AnnotationBorderStyleType.SOLID;
                  this.dashArray = [3];
                  this.horizontalCornerRadius = 0;
                  this.verticalCornerRadius = 0;
                }
                setWidth(width, rect = [0, 0, 0, 0]) {
                  if (width instanceof _primitives.Name) {
                    this.width = 0;
                    return;
                  }
                  if (typeof width === "number") {
                    if (width > 0) {
                      const maxWidth = (rect[2] - rect[0]) / 2;
                      const maxHeight = (rect[3] - rect[1]) / 2;
                      if (maxWidth > 0 && maxHeight > 0 && (width > maxWidth || width > maxHeight)) {
                        (0, _util.warn)(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`);
                        width = 1;
                      }
                    }
                    this.width = width;
                  }
                }
                setStyle(style) {
                  if (!(style instanceof _primitives.Name)) {
                    return;
                  }
                  switch (style.name) {
                    case "S":
                      this.style = _util.AnnotationBorderStyleType.SOLID;
                      break;
                    case "D":
                      this.style = _util.AnnotationBorderStyleType.DASHED;
                      break;
                    case "B":
                      this.style = _util.AnnotationBorderStyleType.BEVELED;
                      break;
                    case "I":
                      this.style = _util.AnnotationBorderStyleType.INSET;
                      break;
                    case "U":
                      this.style = _util.AnnotationBorderStyleType.UNDERLINE;
                      break;
                    default:
                      break;
                  }
                }
                setDashArray(dashArray, forceStyle = false) {
                  if (Array.isArray(dashArray) && dashArray.length > 0) {
                    let isValid = true;
                    let allZeros = true;
                    for (const element of dashArray) {
                      const validNumber = +element >= 0;
                      if (!validNumber) {
                        isValid = false;
                        break;
                      } else if (element > 0) {
                        allZeros = false;
                      }
                    }
                    if (isValid && !allZeros) {
                      this.dashArray = dashArray;
                      if (forceStyle) {
                        this.setStyle(_primitives.Name.get("D"));
                      }
                    } else {
                      this.width = 0;
                    }
                  } else if (dashArray) {
                    this.width = 0;
                  }
                }
                setHorizontalCornerRadius(radius) {
                  if (Number.isInteger(radius)) {
                    this.horizontalCornerRadius = radius;
                  }
                }
                setVerticalCornerRadius(radius) {
                  if (Number.isInteger(radius)) {
                    this.verticalCornerRadius = radius;
                  }
                }
              }
              exports2.AnnotationBorderStyle = AnnotationBorderStyle;
              class MarkupAnnotation extends Annotation {
                constructor(params) {
                  super(params);
                  const {
                    dict
                  } = params;
                  if (dict.has("IRT")) {
                    const rawIRT = dict.getRaw("IRT");
                    this.data.inReplyTo = rawIRT instanceof _primitives.Ref ? rawIRT.toString() : null;
                    const rt = dict.get("RT");
                    this.data.replyType = rt instanceof _primitives.Name ? rt.name : _util.AnnotationReplyType.REPLY;
                  }
                  let popupRef = null;
                  if (this.data.replyType === _util.AnnotationReplyType.GROUP) {
                    const parent = dict.get("IRT");
                    this.setTitle(parent.get("T"));
                    this.data.titleObj = this._title;
                    this.setContents(parent.get("Contents"));
                    this.data.contentsObj = this._contents;
                    if (!parent.has("CreationDate")) {
                      this.data.creationDate = null;
                    } else {
                      this.setCreationDate(parent.get("CreationDate"));
                      this.data.creationDate = this.creationDate;
                    }
                    if (!parent.has("M")) {
                      this.data.modificationDate = null;
                    } else {
                      this.setModificationDate(parent.get("M"));
                      this.data.modificationDate = this.modificationDate;
                    }
                    popupRef = parent.getRaw("Popup");
                    if (!parent.has("C")) {
                      this.data.color = null;
                    } else {
                      this.setColor(parent.getArray("C"));
                      this.data.color = this.color;
                    }
                  } else {
                    this.data.titleObj = this._title;
                    this.setCreationDate(dict.get("CreationDate"));
                    this.data.creationDate = this.creationDate;
                    popupRef = dict.getRaw("Popup");
                    if (!dict.has("C")) {
                      this.data.color = null;
                    }
                  }
                  this.data.popupRef = popupRef instanceof _primitives.Ref ? popupRef.toString() : null;
                  if (dict.has("RC")) {
                    this.data.richText = _factory.XFAFactory.getRichTextAsHtml(dict.get("RC"));
                  }
                }
                setCreationDate(creationDate) {
                  this.creationDate = typeof creationDate === "string" ? creationDate : null;
                }
                _setDefaultAppearance({
                  xref,
                  extra,
                  strokeColor,
                  fillColor,
                  blendMode,
                  strokeAlpha,
                  fillAlpha,
                  pointsCallback
                }) {
                  let minX = Number.MAX_VALUE;
                  let minY = Number.MAX_VALUE;
                  let maxX = Number.MIN_VALUE;
                  let maxY = Number.MIN_VALUE;
                  const buffer = ["q"];
                  if (extra) {
                    buffer.push(extra);
                  }
                  if (strokeColor) {
                    buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`);
                  }
                  if (fillColor) {
                    buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`);
                  }
                  let pointsArray = this.data.quadPoints;
                  if (!pointsArray) {
                    pointsArray = [[{
                      x: this.rectangle[0],
                      y: this.rectangle[3]
                    }, {
                      x: this.rectangle[2],
                      y: this.rectangle[3]
                    }, {
                      x: this.rectangle[0],
                      y: this.rectangle[1]
                    }, {
                      x: this.rectangle[2],
                      y: this.rectangle[1]
                    }]];
                  }
                  for (const points of pointsArray) {
                    const [mX, MX, mY, MY] = pointsCallback(buffer, points);
                    minX = Math.min(minX, mX);
                    maxX = Math.max(maxX, MX);
                    minY = Math.min(minY, mY);
                    maxY = Math.max(maxY, MY);
                  }
                  buffer.push("Q");
                  const formDict = new _primitives.Dict(xref);
                  const appearanceStreamDict = new _primitives.Dict(xref);
                  appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
                  const appearanceStream = new _stream.StringStream(buffer.join(" "));
                  appearanceStream.dict = appearanceStreamDict;
                  formDict.set("Fm0", appearanceStream);
                  const gsDict = new _primitives.Dict(xref);
                  if (blendMode) {
                    gsDict.set("BM", _primitives.Name.get(blendMode));
                  }
                  if (typeof strokeAlpha === "number") {
                    gsDict.set("CA", strokeAlpha);
                  }
                  if (typeof fillAlpha === "number") {
                    gsDict.set("ca", fillAlpha);
                  }
                  const stateDict = new _primitives.Dict(xref);
                  stateDict.set("GS0", gsDict);
                  const resources = new _primitives.Dict(xref);
                  resources.set("ExtGState", stateDict);
                  resources.set("XObject", formDict);
                  const appearanceDict = new _primitives.Dict(xref);
                  appearanceDict.set("Resources", resources);
                  const bbox = this.data.rect = [minX, minY, maxX, maxY];
                  appearanceDict.set("BBox", bbox);
                  this.appearance = new _stream.StringStream("/GS0 gs /Fm0 Do");
                  this.appearance.dict = appearanceDict;
                  this._streams.push(this.appearance, appearanceStream);
                }
                static async createNewAnnotation(xref, annotation, dependencies, params) {
                  const annotationRef = annotation.ref || (annotation.ref = xref.getNewTemporaryRef());
                  const ap = await this.createNewAppearanceStream(annotation, xref, params);
                  const buffer = [];
                  let annotationDict;
                  if (ap) {
                    const apRef = xref.getNewTemporaryRef();
                    annotationDict = this.createNewDict(annotation, xref, {
                      apRef
                    });
                    await (0, _writer.writeObject)(apRef, ap, buffer, xref);
                    dependencies.push({
                      ref: apRef,
                      data: buffer.join("")
                    });
                  } else {
                    annotationDict = this.createNewDict(annotation, xref, {});
                  }
                  if (Number.isInteger(annotation.parentTreeId)) {
                    annotationDict.set("StructParent", annotation.parentTreeId);
                  }
                  buffer.length = 0;
                  await (0, _writer.writeObject)(annotationRef, annotationDict, buffer, xref);
                  return {
                    ref: annotationRef,
                    data: buffer.join("")
                  };
                }
                static async createNewPrintAnnotation(annotationGlobals, xref, annotation, params) {
                  const ap = await this.createNewAppearanceStream(annotation, xref, params);
                  const annotationDict = this.createNewDict(annotation, xref, {
                    ap
                  });
                  const newAnnotation = new this.prototype.constructor({
                    dict: annotationDict,
                    xref,
                    annotationGlobals,
                    evaluatorOptions: params.evaluatorOptions
                  });
                  if (annotation.ref) {
                    newAnnotation.ref = newAnnotation.refToReplace = annotation.ref;
                  }
                  return newAnnotation;
                }
              }
              exports2.MarkupAnnotation = MarkupAnnotation;
              class WidgetAnnotation extends Annotation {
                constructor(params) {
                  var _a;
                  super(params);
                  const {
                    dict,
                    xref,
                    annotationGlobals
                  } = params;
                  const data = this.data;
                  this._needAppearances = params.needAppearances;
                  data.annotationType = _util.AnnotationType.WIDGET;
                  if (data.fieldName === void 0) {
                    data.fieldName = this._constructFieldName(dict);
                  }
                  if (data.actions === void 0) {
                    data.actions = (0, _core_utils.collectActions)(xref, dict, _util.AnnotationActionEventType);
                  }
                  let fieldValue = (0, _core_utils.getInheritableProperty)({
                    dict,
                    key: "V",
                    getArray: true
                  });
                  data.fieldValue = this._decodeFormValue(fieldValue);
                  const defaultFieldValue = (0, _core_utils.getInheritableProperty)({
                    dict,
                    key: "DV",
                    getArray: true
                  });
                  data.defaultFieldValue = this._decodeFormValue(defaultFieldValue);
                  if (fieldValue === void 0 && annotationGlobals.xfaDatasets) {
                    const path = this._title.str;
                    if (path) {
                      this._hasValueFromXFA = true;
                      data.fieldValue = fieldValue = annotationGlobals.xfaDatasets.getValue(path);
                    }
                  }
                  if (fieldValue === void 0 && data.defaultFieldValue !== null) {
                    data.fieldValue = data.defaultFieldValue;
                  }
                  data.alternativeText = (0, _util.stringToPDFString)(dict.get("TU") || "");
                  this.setDefaultAppearance(params);
                  data.hasAppearance || (data.hasAppearance = this._needAppearances && data.fieldValue !== void 0 && data.fieldValue !== null);
                  const fieldType = (0, _core_utils.getInheritableProperty)({
                    dict,
                    key: "FT"
                  });
                  data.fieldType = fieldType instanceof _primitives.Name ? fieldType.name : null;
                  const localResources = (0, _core_utils.getInheritableProperty)({
                    dict,
                    key: "DR"
                  });
                  const acroFormResources = annotationGlobals.acroForm.get("DR");
                  const appearanceResources = (_a = this.appearance) == null ? void 0 : _a.dict.get("Resources");
                  this._fieldResources = {
                    localResources,
                    acroFormResources,
                    appearanceResources,
                    mergedResources: _primitives.Dict.merge({
                      xref,
                      dictArray: [localResources, appearanceResources, acroFormResources],
                      mergeSubDicts: true
                    })
                  };
                  data.fieldFlags = (0, _core_utils.getInheritableProperty)({
                    dict,
                    key: "Ff"
                  });
                  if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
                    data.fieldFlags = 0;
                  }
                  data.readOnly = this.hasFieldFlag(_util.AnnotationFieldFlag.READONLY);
                  data.required = this.hasFieldFlag(_util.AnnotationFieldFlag.REQUIRED);
                  data.hidden = this._hasFlag(data.annotationFlags, _util.AnnotationFlag.HIDDEN) || this._hasFlag(data.annotationFlags, _util.AnnotationFlag.NOVIEW);
                }
                _decodeFormValue(formValue) {
                  if (Array.isArray(formValue)) {
                    return formValue.filter((item) => typeof item === "string").map((item) => (0, _util.stringToPDFString)(item));
                  } else if (formValue instanceof _primitives.Name) {
                    return (0, _util.stringToPDFString)(formValue.name);
                  } else if (typeof formValue === "string") {
                    return (0, _util.stringToPDFString)(formValue);
                  }
                  return null;
                }
                hasFieldFlag(flag) {
                  return !!(this.data.fieldFlags & flag);
                }
                _isViewable(flags) {
                  return !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE);
                }
                mustBeViewed(annotationStorage, renderForms) {
                  if (renderForms) {
                    return this.viewable;
                  }
                  return super.mustBeViewed(annotationStorage, renderForms) && !this._hasFlag(this.flags, _util.AnnotationFlag.NOVIEW);
                }
                getRotationMatrix(annotationStorage) {
                  var _a;
                  let rotation = (_a = annotationStorage == null ? void 0 : annotationStorage.get(this.data.id)) == null ? void 0 : _a.rotation;
                  if (rotation === void 0) {
                    rotation = this.rotation;
                  }
                  if (rotation === 0) {
                    return _util.IDENTITY_MATRIX;
                  }
                  const width = this.data.rect[2] - this.data.rect[0];
                  const height = this.data.rect[3] - this.data.rect[1];
                  return (0, _core_utils.getRotationMatrix)(rotation, width, height);
                }
                getBorderAndBackgroundAppearances(annotationStorage) {
                  var _a;
                  let rotation = (_a = annotationStorage == null ? void 0 : annotationStorage.get(this.data.id)) == null ? void 0 : _a.rotation;
                  if (rotation === void 0) {
                    rotation = this.rotation;
                  }
                  if (!this.backgroundColor && !this.borderColor) {
                    return "";
                  }
                  const width = this.data.rect[2] - this.data.rect[0];
                  const height = this.data.rect[3] - this.data.rect[1];
                  const rect = rotation === 0 || rotation === 180 ? `0 0 ${width} ${height} re` : `0 0 ${height} ${width} re`;
                  let str = "";
                  if (this.backgroundColor) {
                    str = `${(0, _default_appearance.getPdfColor)(this.backgroundColor, true)} ${rect} f `;
                  }
                  if (this.borderColor) {
                    const borderWidth = this.borderStyle.width || 1;
                    str += `${borderWidth} w ${(0, _default_appearance.getPdfColor)(this.borderColor, false)} ${rect} S `;
                  }
                  return str;
                }
                async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) {
                  if (renderForms && !(this instanceof SignatureWidgetAnnotation) && !this.data.noHTML && !this.data.hasOwnCanvas) {
                    return {
                      opList: new _operator_list.OperatorList(),
                      separateForm: true,
                      separateCanvas: false
                    };
                  }
                  if (!this._hasText) {
                    return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage);
                  }
                  const content = await this._getAppearance(evaluator, task, intent, annotationStorage);
                  if (this.appearance && content === null) {
                    return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage);
                  }
                  const opList = new _operator_list.OperatorList();
                  if (!this._defaultAppearance || content === null) {
                    return {
                      opList,
                      separateForm: false,
                      separateCanvas: false
                    };
                  }
                  const isUsingOwnCanvas = !!(this.data.hasOwnCanvas && intent & _util.RenderingIntentFlag.DISPLAY);
                  const matrix = [1, 0, 0, 1, 0, 0];
                  const bbox = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]];
                  const transform = getTransformMatrix(this.data.rect, bbox, matrix);
                  let optionalContent;
                  if (this.oc) {
                    optionalContent = await evaluator.parseMarkedContentProps(this.oc, null);
                  }
                  if (optionalContent !== void 0) {
                    opList.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);
                  }
                  opList.addOp(_util.OPS.beginAnnotation, [this.data.id, this.data.rect, transform, this.getRotationMatrix(annotationStorage), isUsingOwnCanvas]);
                  const stream = new _stream.StringStream(content);
                  await evaluator.getOperatorList({
                    stream,
                    task,
                    resources: this._fieldResources.mergedResources,
                    operatorList: opList
                  });
                  opList.addOp(_util.OPS.endAnnotation, []);
                  if (optionalContent !== void 0) {
                    opList.addOp(_util.OPS.endMarkedContent, []);
                  }
                  return {
                    opList,
                    separateForm: false,
                    separateCanvas: isUsingOwnCanvas
                  };
                }
                _getMKDict(rotation) {
                  const mk = new _primitives.Dict(null);
                  if (rotation) {
                    mk.set("R", rotation);
                  }
                  if (this.borderColor) {
                    mk.set("BC", getPdfColorArray(this.borderColor));
                  }
                  if (this.backgroundColor) {
                    mk.set("BG", getPdfColorArray(this.backgroundColor));
                  }
                  return mk.size > 0 ? mk : null;
                }
                amendSavedDict(annotationStorage, dict) {
                }
                async save(evaluator, task, annotationStorage) {
                  const storageEntry = annotationStorage == null ? void 0 : annotationStorage.get(this.data.id);
                  let value = storageEntry == null ? void 0 : storageEntry.value, rotation = storageEntry == null ? void 0 : storageEntry.rotation;
                  if (value === this.data.fieldValue || value === void 0) {
                    if (!this._hasValueFromXFA && rotation === void 0) {
                      return null;
                    }
                    value || (value = this.data.fieldValue);
                  }
                  if (rotation === void 0 && !this._hasValueFromXFA && Array.isArray(value) && Array.isArray(this.data.fieldValue) && value.length === this.data.fieldValue.length && value.every((x, i) => x === this.data.fieldValue[i])) {
                    return null;
                  }
                  if (rotation === void 0) {
                    rotation = this.rotation;
                  }
                  let appearance = null;
                  if (!this._needAppearances) {
                    appearance = await this._getAppearance(evaluator, task, _util.RenderingIntentFlag.SAVE, annotationStorage);
                    if (appearance === null) {
                      return null;
                    }
                  } else {
                  }
                  let needAppearances = false;
                  if (appearance == null ? void 0 : appearance.needAppearances) {
                    needAppearances = true;
                    appearance = null;
                  }
                  const {
                    xref
                  } = evaluator;
                  const originalDict = xref.fetchIfRef(this.ref);
                  if (!(originalDict instanceof _primitives.Dict)) {
                    return null;
                  }
                  const dict = new _primitives.Dict(xref);
                  for (const key of originalDict.getKeys()) {
                    if (key !== "AP") {
                      dict.set(key, originalDict.getRaw(key));
                    }
                  }
                  const xfa = {
                    path: this.data.fieldName,
                    value
                  };
                  const encoder = (val) => {
                    return (0, _core_utils.isAscii)(val) ? val : (0, _core_utils.stringToUTF16String)(val, true);
                  };
                  dict.set("V", Array.isArray(value) ? value.map(encoder) : encoder(value));
                  this.amendSavedDict(annotationStorage, dict);
                  const maybeMK = this._getMKDict(rotation);
                  if (maybeMK) {
                    dict.set("MK", maybeMK);
                  }
                  const buffer = [];
                  const changes = [{
                    ref: this.ref,
                    data: "",
                    xfa,
                    needAppearances
                  }];
                  if (appearance !== null) {
                    const newRef = xref.getNewTemporaryRef();
                    const AP = new _primitives.Dict(xref);
                    dict.set("AP", AP);
                    AP.set("N", newRef);
                    const resources = this._getSaveFieldResources(xref);
                    const appearanceStream = new _stream.StringStream(appearance);
                    const appearanceDict = appearanceStream.dict = new _primitives.Dict(xref);
                    appearanceDict.set("Subtype", _primitives.Name.get("Form"));
                    appearanceDict.set("Resources", resources);
                    appearanceDict.set("BBox", [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]);
                    const rotationMatrix = this.getRotationMatrix(annotationStorage);
                    if (rotationMatrix !== _util.IDENTITY_MATRIX) {
                      appearanceDict.set("Matrix", rotationMatrix);
                    }
                    await (0, _writer.writeObject)(newRef, appearanceStream, buffer, xref);
                    changes.push({
                      ref: newRef,
                      data: buffer.join(""),
                      xfa: null,
                      needAppearances: false
                    });
                    buffer.length = 0;
                  }
                  dict.set("M", `D:${(0, _util.getModificationDate)()}`);
                  await (0, _writer.writeObject)(this.ref, dict, buffer, xref);
                  changes[0].data = buffer.join("");
                  return changes;
                }
                async _getAppearance(evaluator, task, intent, annotationStorage) {
                  const isPassword = this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD);
                  if (isPassword) {
                    return null;
                  }
                  const storageEntry = annotationStorage == null ? void 0 : annotationStorage.get(this.data.id);
                  let value, rotation;
                  if (storageEntry) {
                    value = storageEntry.formattedValue || storageEntry.value;
                    rotation = storageEntry.rotation;
                  }
                  if (rotation === void 0 && value === void 0 && !this._needAppearances) {
                    if (!this._hasValueFromXFA || this.appearance) {
                      return null;
                    }
                  }
                  const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
                  if (value === void 0) {
                    value = this.data.fieldValue;
                    if (!value) {
                      return `/Tx BMC q ${colors}Q EMC`;
                    }
                  }
                  if (Array.isArray(value) && value.length === 1) {
                    value = value[0];
                  }
                  (0, _util.assert)(typeof value === "string", "Expected `value` to be a string.");
                  value = value.trim();
                  if (this.data.combo) {
                    const option = this.data.options.find(({
                      exportValue
                    }) => value === exportValue);
                    value = (option == null ? void 0 : option.displayValue) || value;
                  }
                  if (value === "") {
                    return `/Tx BMC q ${colors}Q EMC`;
                  }
                  if (rotation === void 0) {
                    rotation = this.rotation;
                  }
                  let lineCount = -1;
                  let lines;
                  if (this.data.multiLine) {
                    lines = value.split(/\r\n?|\n/).map((line) => line.normalize("NFC"));
                    lineCount = lines.length;
                  } else {
                    lines = [value.replace(/\r\n?|\n/, "").normalize("NFC")];
                  }
                  const defaultPadding = 1;
                  const defaultHPadding = 2;
                  let totalHeight = this.data.rect[3] - this.data.rect[1];
                  let totalWidth = this.data.rect[2] - this.data.rect[0];
                  if (rotation === 90 || rotation === 270) {
                    [totalWidth, totalHeight] = [totalHeight, totalWidth];
                  }
                  if (!this._defaultAppearance) {
                    this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g");
                  }
                  let font = await WidgetAnnotation._getFontData(evaluator, task, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
                  let defaultAppearance, fontSize, lineHeight;
                  const encodedLines = [];
                  let encodingError = false;
                  for (const line of lines) {
                    const encodedString = font.encodeString(line);
                    if (encodedString.length > 1) {
                      encodingError = true;
                    }
                    encodedLines.push(encodedString.join(""));
                  }
                  if (encodingError && intent & _util.RenderingIntentFlag.SAVE) {
                    return {
                      needAppearances: true
                    };
                  }
                  if (encodingError && this._isOffscreenCanvasSupported) {
                    const fontFamily = this.data.comb ? "monospace" : "sans-serif";
                    const fakeUnicodeFont = new _default_appearance.FakeUnicodeFont(evaluator.xref, fontFamily);
                    const resources = fakeUnicodeFont.createFontResources(lines.join(""));
                    const newFont = resources.getRaw("Font");
                    if (this._fieldResources.mergedResources.has("Font")) {
                      const oldFont = this._fieldResources.mergedResources.get("Font");
                      for (const key of newFont.getKeys()) {
                        oldFont.set(key, newFont.getRaw(key));
                      }
                    } else {
                      this._fieldResources.mergedResources.set("Font", newFont);
                    }
                    const fontName = fakeUnicodeFont.fontName.name;
                    font = await WidgetAnnotation._getFontData(evaluator, task, {
                      fontName,
                      fontSize: 0
                    }, resources);
                    for (let i = 0, ii = encodedLines.length; i < ii; i++) {
                      encodedLines[i] = (0, _core_utils.stringToUTF16String)(lines[i]);
                    }
                    const savedDefaultAppearance = Object.assign(/* @__PURE__ */ Object.create(null), this.data.defaultAppearanceData);
                    this.data.defaultAppearanceData.fontSize = 0;
                    this.data.defaultAppearanceData.fontName = fontName;
                    [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(totalHeight - 2 * defaultPadding, totalWidth - 2 * defaultHPadding, value, font, lineCount);
                    this.data.defaultAppearanceData = savedDefaultAppearance;
                  } else {
                    if (!this._isOffscreenCanvasSupported) {
                      (0, _util.warn)("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly.");
                    }
                    [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(totalHeight - 2 * defaultPadding, totalWidth - 2 * defaultHPadding, value, font, lineCount);
                  }
                  let descent = font.descent;
                  if (isNaN(descent)) {
                    descent = _util.BASELINE_FACTOR * lineHeight;
                  } else {
                    descent = Math.max(_util.BASELINE_FACTOR * lineHeight, Math.abs(descent) * fontSize);
                  }
                  const defaultVPadding = Math.min(Math.floor((totalHeight - fontSize) / 2), defaultPadding);
                  const alignment = this.data.textAlignment;
                  if (this.data.multiLine) {
                    return this._getMultilineAppearance(defaultAppearance, encodedLines, font, fontSize, totalWidth, totalHeight, alignment, defaultHPadding, defaultVPadding, descent, lineHeight, annotationStorage);
                  }
                  if (this.data.comb) {
                    return this._getCombAppearance(defaultAppearance, font, encodedLines[0], fontSize, totalWidth, totalHeight, defaultHPadding, defaultVPadding, descent, lineHeight, annotationStorage);
                  }
                  const bottomPadding = defaultVPadding + descent;
                  if (alignment === 0 || alignment > 2) {
                    return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 ${(0, _core_utils.numberToString)(defaultHPadding)} ${(0, _core_utils.numberToString)(bottomPadding)} Tm (${(0, _core_utils.escapeString)(encodedLines[0])}) Tj ET Q EMC`;
                  }
                  const prevInfo = {
                    shift: 0
                  };
                  const renderedText = this._renderText(encodedLines[0], font, fontSize, totalWidth, alignment, prevInfo, defaultHPadding, bottomPadding);
                  return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 0 0 Tm ${renderedText} ET Q EMC`;
                }
                static async _getFontData(evaluator, task, appearanceData, resources) {
                  const operatorList = new _operator_list.OperatorList();
                  const initialState = {
                    font: null,
                    clone() {
                      return this;
                    }
                  };
                  const {
                    fontName,
                    fontSize
                  } = appearanceData;
                  await evaluator.handleSetFont(resources, [fontName && _primitives.Name.get(fontName), fontSize], null, operatorList, task, initialState, null);
                  return initialState.font;
                }
                _getTextWidth(text, font) {
                  return font.charsToGlyphs(text).reduce((width, glyph) => width + glyph.width, 0) / 1e3;
                }
                _computeFontSize(height, width, text, font, lineCount) {
                  let {
                    fontSize
                  } = this.data.defaultAppearanceData;
                  let lineHeight = (fontSize || 12) * _util.LINE_FACTOR, numberOfLines = Math.round(height / lineHeight);
                  if (!fontSize) {
                    const roundWithTwoDigits = (x) => Math.floor(x * 100) / 100;
                    if (lineCount === -1) {
                      const textWidth = this._getTextWidth(text, font);
                      fontSize = roundWithTwoDigits(Math.min(height / _util.LINE_FACTOR, textWidth > width ? width / textWidth : Infinity));
                      numberOfLines = 1;
                    } else {
                      const lines = text.split(/\r\n?|\n/);
                      const cachedLines = [];
                      for (const line of lines) {
                        const encoded = font.encodeString(line).join("");
                        const glyphs = font.charsToGlyphs(encoded);
                        const positions = font.getCharPositions(encoded);
                        cachedLines.push({
                          line: encoded,
                          glyphs,
                          positions
                        });
                      }
                      const isTooBig = (fsize) => {
                        let totalHeight = 0;
                        for (const cache of cachedLines) {
                          const chunks = this._splitLine(null, font, fsize, width, cache);
                          totalHeight += chunks.length * fsize;
                          if (totalHeight > height) {
                            return true;
                          }
                        }
                        return false;
                      };
                      numberOfLines = Math.max(numberOfLines, lineCount);
                      while (true) {
                        lineHeight = height / numberOfLines;
                        fontSize = roundWithTwoDigits(lineHeight / _util.LINE_FACTOR);
                        if (isTooBig(fontSize)) {
                          numberOfLines++;
                          continue;
                        }
                        break;
                      }
                    }
                    const {
                      fontName,
                      fontColor
                    } = this.data.defaultAppearanceData;
                    this._defaultAppearance = (0, _default_appearance.createDefaultAppearance)({
                      fontSize,
                      fontName,
                      fontColor
                    });
                  }
                  return [this._defaultAppearance, fontSize, height / numberOfLines];
                }
                _renderText(text, font, fontSize, totalWidth, alignment, prevInfo, hPadding, vPadding) {
                  let shift;
                  if (alignment === 1) {
                    const width = this._getTextWidth(text, font) * fontSize;
                    shift = (totalWidth - width) / 2;
                  } else if (alignment === 2) {
                    const width = this._getTextWidth(text, font) * fontSize;
                    shift = totalWidth - width - hPadding;
                  } else {
                    shift = hPadding;
                  }
                  const shiftStr = (0, _core_utils.numberToString)(shift - prevInfo.shift);
                  prevInfo.shift = shift;
                  vPadding = (0, _core_utils.numberToString)(vPadding);
                  return `${shiftStr} ${vPadding} Td (${(0, _core_utils.escapeString)(text)}) Tj`;
                }
                _getSaveFieldResources(xref) {
                  var _a;
                  const {
                    localResources,
                    appearanceResources,
                    acroFormResources
                  } = this._fieldResources;
                  const fontName = (_a = this.data.defaultAppearanceData) == null ? void 0 : _a.fontName;
                  if (!fontName) {
                    return localResources || _primitives.Dict.empty;
                  }
                  for (const resources of [localResources, appearanceResources]) {
                    if (resources instanceof _primitives.Dict) {
                      const localFont = resources.get("Font");
                      if (localFont instanceof _primitives.Dict && localFont.has(fontName)) {
                        return resources;
                      }
                    }
                  }
                  if (acroFormResources instanceof _primitives.Dict) {
                    const acroFormFont = acroFormResources.get("Font");
                    if (acroFormFont instanceof _primitives.Dict && acroFormFont.has(fontName)) {
                      const subFontDict = new _primitives.Dict(xref);
                      subFontDict.set(fontName, acroFormFont.getRaw(fontName));
                      const subResourcesDict = new _primitives.Dict(xref);
                      subResourcesDict.set("Font", subFontDict);
                      return _primitives.Dict.merge({
                        xref,
                        dictArray: [subResourcesDict, localResources],
                        mergeSubDicts: true
                      });
                    }
                  }
                  return localResources || _primitives.Dict.empty;
                }
                getFieldObject() {
                  return null;
                }
              }
              class TextWidgetAnnotation extends WidgetAnnotation {
                constructor(params) {
                  super(params);
                  this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
                  this._hasText = true;
                  const dict = params.dict;
                  if (typeof this.data.fieldValue !== "string") {
                    this.data.fieldValue = "";
                  }
                  let alignment = (0, _core_utils.getInheritableProperty)({
                    dict,
                    key: "Q"
                  });
                  if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
                    alignment = null;
                  }
                  this.data.textAlignment = alignment;
                  let maximumLength = (0, _core_utils.getInheritableProperty)({
                    dict,
                    key: "MaxLen"
                  });
                  if (!Number.isInteger(maximumLength) || maximumLength < 0) {
                    maximumLength = 0;
                  }
                  this.data.maxLen = maximumLength;
                  this.data.multiLine = this.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE);
                  this.data.comb = this.hasFieldFlag(_util.AnnotationFieldFlag.COMB) && !this.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(_util.AnnotationFieldFlag.FILESELECT) && this.data.maxLen !== 0;
                  this.data.doNotScroll = this.hasFieldFlag(_util.AnnotationFieldFlag.DONOTSCROLL);
                }
                get hasTextContent() {
                  return !!this.appearance && !this._needAppearances;
                }
                _getCombAppearance(defaultAppearance, font, text, fontSize, width, height, hPadding, vPadding, descent, lineHeight, annotationStorage) {
                  const combWidth = width / this.data.maxLen;
                  const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
                  const buf = [];
                  const positions = font.getCharPositions(text);
                  for (const [start, end] of positions) {
                    buf.push(`(${(0, _core_utils.escapeString)(text.substring(start, end))}) Tj`);
                  }
                  const renderedComb = buf.join(` ${(0, _core_utils.numberToString)(combWidth)} 0 Td `);
                  return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 ${(0, _core_utils.numberToString)(hPadding)} ${(0, _core_utils.numberToString)(vPadding + descent)} Tm ${renderedComb} ET Q EMC`;
                }
                _getMultilineAppearance(defaultAppearance, lines, font, fontSize, width, height, alignment, hPadding, vPadding, descent, lineHeight, annotationStorage) {
                  const buf = [];
                  const totalWidth = width - 2 * hPadding;
                  const prevInfo = {
                    shift: 0
                  };
                  for (let i = 0, ii = lines.length; i < ii; i++) {
                    const line = lines[i];
                    const chunks = this._splitLine(line, font, fontSize, totalWidth);
                    for (let j = 0, jj = chunks.length; j < jj; j++) {
                      const chunk = chunks[j];
                      const vShift = i === 0 && j === 0 ? -vPadding - (lineHeight - descent) : -lineHeight;
                      buf.push(this._renderText(chunk, font, fontSize, width, alignment, prevInfo, hPadding, vShift));
                    }
                  }
                  const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
                  const renderedText = buf.join("\n");
                  return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 0 ${(0, _core_utils.numberToString)(height)} Tm ${renderedText} ET Q EMC`;
                }
                _splitLine(line, font, fontSize, width, cache = {}) {
                  line = cache.line || line;
                  const glyphs = cache.glyphs || font.charsToGlyphs(line);
                  if (glyphs.length <= 1) {
                    return [line];
                  }
                  const positions = cache.positions || font.getCharPositions(line);
                  const scale = fontSize / 1e3;
                  const chunks = [];
                  let lastSpacePosInStringStart = -1, lastSpacePosInStringEnd = -1, lastSpacePos = -1, startChunk = 0, currentWidth = 0;
                  for (let i = 0, ii = glyphs.length; i < ii; i++) {
                    const [start, end] = positions[i];
                    const glyph = glyphs[i];
                    const glyphWidth = glyph.width * scale;
                    if (glyph.unicode === " ") {
                      if (currentWidth + glyphWidth > width) {
                        chunks.push(line.substring(startChunk, start));
                        startChunk = start;
                        currentWidth = glyphWidth;
                        lastSpacePosInStringStart = -1;
                        lastSpacePos = -1;
                      } else {
                        currentWidth += glyphWidth;
                        lastSpacePosInStringStart = start;
                        lastSpacePosInStringEnd = end;
                        lastSpacePos = i;
                      }
                    } else if (currentWidth + glyphWidth > width) {
                      if (lastSpacePosInStringStart !== -1) {
                        chunks.push(line.substring(startChunk, lastSpacePosInStringEnd));
                        startChunk = lastSpacePosInStringEnd;
                        i = lastSpacePos + 1;
                        lastSpacePosInStringStart = -1;
                        currentWidth = 0;
                      } else {
                        chunks.push(line.substring(startChunk, start));
                        startChunk = start;
                        currentWidth = glyphWidth;
                      }
                    } else {
                      currentWidth += glyphWidth;
                    }
                  }
                  if (startChunk < line.length) {
                    chunks.push(line.substring(startChunk, line.length));
                  }
                  return chunks;
                }
                getFieldObject() {
                  return {
                    id: this.data.id,
                    value: this.data.fieldValue,
                    defaultValue: this.data.defaultFieldValue || "",
                    multiline: this.data.multiLine,
                    password: this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD),
                    charLimit: this.data.maxLen,
                    comb: this.data.comb,
                    editable: !this.data.readOnly,
                    hidden: this.data.hidden,
                    name: this.data.fieldName,
                    rect: this.data.rect,
                    actions: this.data.actions,
                    page: this.data.pageIndex,
                    strokeColor: this.data.borderColor,
                    fillColor: this.data.backgroundColor,
                    rotation: this.rotation,
                    type: "text"
                  };
                }
              }
              class ButtonWidgetAnnotation extends WidgetAnnotation {
                constructor(params) {
                  super(params);
                  this.checkedAppearance = null;
                  this.uncheckedAppearance = null;
                  this.data.checkBox = !this.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
                  this.data.radioButton = this.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
                  this.data.pushButton = this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
                  this.data.isTooltipOnly = false;
                  if (this.data.checkBox) {
                    this._processCheckBox(params);
                  } else if (this.data.radioButton) {
                    this._processRadioButton(params);
                  } else if (this.data.pushButton) {
                    this.data.hasOwnCanvas = true;
                    this._processPushButton(params);
                  } else {
                    (0, _util.warn)("Invalid field flags for button widget annotation");
                  }
                }
                async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) {
                  if (this.data.pushButton) {
                    return super.getOperatorList(evaluator, task, intent, false, annotationStorage);
                  }
                  let value = null;
                  let rotation = null;
                  if (annotationStorage) {
                    const storageEntry = annotationStorage.get(this.data.id);
                    value = storageEntry ? storageEntry.value : null;
                    rotation = storageEntry ? storageEntry.rotation : null;
                  }
                  if (value === null && this.appearance) {
                    return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage);
                  }
                  if (value === null || value === void 0) {
                    value = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue;
                  }
                  const appearance = value ? this.checkedAppearance : this.uncheckedAppearance;
                  if (appearance) {
                    const savedAppearance = this.appearance;
                    const savedMatrix = appearance.dict.getArray("Matrix") || _util.IDENTITY_MATRIX;
                    if (rotation) {
                      appearance.dict.set("Matrix", this.getRotationMatrix(annotationStorage));
                    }
                    this.appearance = appearance;
                    const operatorList = super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage);
                    this.appearance = savedAppearance;
                    appearance.dict.set("Matrix", savedMatrix);
                    return operatorList;
                  }
                  return {
                    opList: new _operator_list.OperatorList(),
                    separateForm: false,
                    separateCanvas: false
                  };
                }
                async save(evaluator, task, annotationStorage) {
                  if (this.data.checkBox) {
                    return this._saveCheckbox(evaluator, task, annotationStorage);
                  }
                  if (this.data.radioButton) {
                    return this._saveRadioButton(evaluator, task, annotationStorage);
                  }
                  return null;
                }
                async _saveCheckbox(evaluator, task, annotationStorage) {
                  if (!annotationStorage) {
                    return null;
                  }
                  const storageEntry = annotationStorage.get(this.data.id);
                  let rotation = storageEntry == null ? void 0 : storageEntry.rotation, value = storageEntry == null ? void 0 : storageEntry.value;
                  if (rotation === void 0) {
                    if (value === void 0) {
                      return null;
                    }
                    const defaultValue = this.data.fieldValue === this.data.exportValue;
                    if (defaultValue === value) {
                      return null;
                    }
                  }
                  const dict = evaluator.xref.fetchIfRef(this.ref);
                  if (!(dict instanceof _primitives.Dict)) {
                    return null;
                  }
                  if (rotation === void 0) {
                    rotation = this.rotation;
                  }
                  if (value === void 0) {
                    value = this.data.fieldValue === this.data.exportValue;
                  }
                  const xfa = {
                    path: this.data.fieldName,
                    value: value ? this.data.exportValue : ""
                  };
                  const name = _primitives.Name.get(value ? this.data.exportValue : "Off");
                  dict.set("V", name);
                  dict.set("AS", name);
                  dict.set("M", `D:${(0, _util.getModificationDate)()}`);
                  const maybeMK = this._getMKDict(rotation);
                  if (maybeMK) {
                    dict.set("MK", maybeMK);
                  }
                  const buffer = [];
                  await (0, _writer.writeObject)(this.ref, dict, buffer, evaluator.xref);
                  return [{
                    ref: this.ref,
                    data: buffer.join(""),
                    xfa
                  }];
                }
                async _saveRadioButton(evaluator, task, annotationStorage) {
                  if (!annotationStorage) {
                    return null;
                  }
                  const storageEntry = annotationStorage.get(this.data.id);
                  let rotation = storageEntry == null ? void 0 : storageEntry.rotation, value = storageEntry == null ? void 0 : storageEntry.value;
                  if (rotation === void 0) {
                    if (value === void 0) {
                      return null;
                    }
                    const defaultValue = this.data.fieldValue === this.data.buttonValue;
                    if (defaultValue === value) {
                      return null;
                    }
                  }
                  const dict = evaluator.xref.fetchIfRef(this.ref);
                  if (!(dict instanceof _primitives.Dict)) {
                    return null;
                  }
                  if (value === void 0) {
                    value = this.data.fieldValue === this.data.buttonValue;
                  }
                  if (rotation === void 0) {
                    rotation = this.rotation;
                  }
                  const xfa = {
                    path: this.data.fieldName,
                    value: value ? this.data.buttonValue : ""
                  };
                  const name = _primitives.Name.get(value ? this.data.buttonValue : "Off");
                  const buffer = [];
                  let parentData = null;
                  if (value) {
                    if (this.parent instanceof _primitives.Ref) {
                      const parent = evaluator.xref.fetch(this.parent);
                      parent.set("V", name);
                      await (0, _writer.writeObject)(this.parent, parent, buffer, evaluator.xref);
                      parentData = buffer.join("");
                      buffer.length = 0;
                    } else if (this.parent instanceof _primitives.Dict) {
                      this.parent.set("V", name);
                    }
                  }
                  dict.set("AS", name);
                  dict.set("M", `D:${(0, _util.getModificationDate)()}`);
                  const maybeMK = this._getMKDict(rotation);
                  if (maybeMK) {
                    dict.set("MK", maybeMK);
                  }
                  await (0, _writer.writeObject)(this.ref, dict, buffer, evaluator.xref);
                  const newRefs = [{
                    ref: this.ref,
                    data: buffer.join(""),
                    xfa
                  }];
                  if (parentData) {
                    newRefs.push({
                      ref: this.parent,
                      data: parentData,
                      xfa: null
                    });
                  }
                  return newRefs;
                }
                _getDefaultCheckedAppearance(params, type) {
                  const width = this.data.rect[2] - this.data.rect[0];
                  const height = this.data.rect[3] - this.data.rect[1];
                  const bbox = [0, 0, width, height];
                  const FONT_RATIO = 0.8;
                  const fontSize = Math.min(width, height) * FONT_RATIO;
                  let metrics, char;
                  if (type === "check") {
                    metrics = {
                      width: 0.755 * fontSize,
                      height: 0.705 * fontSize
                    };
                    char = "3";
                  } else if (type === "disc") {
                    metrics = {
                      width: 0.791 * fontSize,
                      height: 0.705 * fontSize
                    };
                    char = "l";
                  } else {
                    (0, _util.unreachable)(`_getDefaultCheckedAppearance - unsupported type: ${type}`);
                  }
                  const xShift = (0, _core_utils.numberToString)((width - metrics.width) / 2);
                  const yShift = (0, _core_utils.numberToString)((height - metrics.height) / 2);
                  const appearance = `q BT /PdfJsZaDb ${fontSize} Tf 0 g ${xShift} ${yShift} Td (${char}) Tj ET Q`;
                  const appearanceStreamDict = new _primitives.Dict(params.xref);
                  appearanceStreamDict.set("FormType", 1);
                  appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
                  appearanceStreamDict.set("Type", _primitives.Name.get("XObject"));
                  appearanceStreamDict.set("BBox", bbox);
                  appearanceStreamDict.set("Matrix", [1, 0, 0, 1, 0, 0]);
                  appearanceStreamDict.set("Length", appearance.length);
                  const resources = new _primitives.Dict(params.xref);
                  const font = new _primitives.Dict(params.xref);
                  font.set("PdfJsZaDb", this.fallbackFontDict);
                  resources.set("Font", font);
                  appearanceStreamDict.set("Resources", resources);
                  this.checkedAppearance = new _stream.StringStream(appearance);
                  this.checkedAppearance.dict = appearanceStreamDict;
                  this._streams.push(this.checkedAppearance);
                }
                _processCheckBox(params) {
                  const customAppearance = params.dict.get("AP");
                  if (!(customAppearance instanceof _primitives.Dict)) {
                    return;
                  }
                  const normalAppearance = customAppearance.get("N");
                  if (!(normalAppearance instanceof _primitives.Dict)) {
                    return;
                  }
                  const asValue = this._decodeFormValue(params.dict.get("AS"));
                  if (typeof asValue === "string") {
                    this.data.fieldValue = asValue;
                  }
                  const yes = this.data.fieldValue !== null && this.data.fieldValue !== "Off" ? this.data.fieldValue : "Yes";
                  const exportValues = normalAppearance.getKeys();
                  if (exportValues.length === 0) {
                    exportValues.push("Off", yes);
                  } else if (exportValues.length === 1) {
                    if (exportValues[0] === "Off") {
                      exportValues.push(yes);
                    } else {
                      exportValues.unshift("Off");
                    }
                  } else if (exportValues.includes(yes)) {
                    exportValues.length = 0;
                    exportValues.push("Off", yes);
                  } else {
                    const otherYes = exportValues.find((v) => v !== "Off");
                    exportValues.length = 0;
                    exportValues.push("Off", otherYes);
                  }
                  if (!exportValues.includes(this.data.fieldValue)) {
                    this.data.fieldValue = "Off";
                  }
                  this.data.exportValue = exportValues[1];
                  const checkedAppearance = normalAppearance.get(this.data.exportValue);
                  this.checkedAppearance = checkedAppearance instanceof _base_stream.BaseStream ? checkedAppearance : null;
                  const uncheckedAppearance = normalAppearance.get("Off");
                  this.uncheckedAppearance = uncheckedAppearance instanceof _base_stream.BaseStream ? uncheckedAppearance : null;
                  if (this.checkedAppearance) {
                    this._streams.push(this.checkedAppearance);
                  } else {
                    this._getDefaultCheckedAppearance(params, "check");
                  }
                  if (this.uncheckedAppearance) {
                    this._streams.push(this.uncheckedAppearance);
                  }
                  this._fallbackFontDict = this.fallbackFontDict;
                  if (this.data.defaultFieldValue === null) {
                    this.data.defaultFieldValue = "Off";
                  }
                }
                _processRadioButton(params) {
                  this.data.fieldValue = this.data.buttonValue = null;
                  const fieldParent = params.dict.get("Parent");
                  if (fieldParent instanceof _primitives.Dict) {
                    this.parent = params.dict.getRaw("Parent");
                    const fieldParentValue = fieldParent.get("V");
                    if (fieldParentValue instanceof _primitives.Name) {
                      this.data.fieldValue = this._decodeFormValue(fieldParentValue);
                    }
                  }
                  const appearanceStates = params.dict.get("AP");
                  if (!(appearanceStates instanceof _primitives.Dict)) {
                    return;
                  }
                  const normalAppearance = appearanceStates.get("N");
                  if (!(normalAppearance instanceof _primitives.Dict)) {
                    return;
                  }
                  for (const key of normalAppearance.getKeys()) {
                    if (key !== "Off") {
                      this.data.buttonValue = this._decodeFormValue(key);
                      break;
                    }
                  }
                  const checkedAppearance = normalAppearance.get(this.data.buttonValue);
                  this.checkedAppearance = checkedAppearance instanceof _base_stream.BaseStream ? checkedAppearance : null;
                  const uncheckedAppearance = normalAppearance.get("Off");
                  this.uncheckedAppearance = uncheckedAppearance instanceof _base_stream.BaseStream ? uncheckedAppearance : null;
                  if (this.checkedAppearance) {
                    this._streams.push(this.checkedAppearance);
                  } else {
                    this._getDefaultCheckedAppearance(params, "disc");
                  }
                  if (this.uncheckedAppearance) {
                    this._streams.push(this.uncheckedAppearance);
                  }
                  this._fallbackFontDict = this.fallbackFontDict;
                  if (this.data.defaultFieldValue === null) {
                    this.data.defaultFieldValue = "Off";
                  }
                }
                _processPushButton(params) {
                  const {
                    dict,
                    annotationGlobals
                  } = params;
                  if (!dict.has("A") && !dict.has("AA") && !this.data.alternativeText) {
                    (0, _util.warn)("Push buttons without action dictionaries are not supported");
                    return;
                  }
                  this.data.isTooltipOnly = !dict.has("A") && !dict.has("AA");
                  _catalog.Catalog.parseDestDictionary({
                    destDict: dict,
                    resultObj: this.data,
                    docBaseUrl: annotationGlobals.baseUrl,
                    docAttachments: annotationGlobals.attachments
                  });
                }
                getFieldObject() {
                  let type = "button";
                  let exportValues;
                  if (this.data.checkBox) {
                    type = "checkbox";
                    exportValues = this.data.exportValue;
                  } else if (this.data.radioButton) {
                    type = "radiobutton";
                    exportValues = this.data.buttonValue;
                  }
                  return {
                    id: this.data.id,
                    value: this.data.fieldValue || "Off",
                    defaultValue: this.data.defaultFieldValue,
                    exportValues,
                    editable: !this.data.readOnly,
                    name: this.data.fieldName,
                    rect: this.data.rect,
                    hidden: this.data.hidden,
                    actions: this.data.actions,
                    page: this.data.pageIndex,
                    strokeColor: this.data.borderColor,
                    fillColor: this.data.backgroundColor,
                    rotation: this.rotation,
                    type
                  };
                }
                get fallbackFontDict() {
                  const dict = new _primitives.Dict();
                  dict.set("BaseFont", _primitives.Name.get("ZapfDingbats"));
                  dict.set("Type", _primitives.Name.get("FallbackType"));
                  dict.set("Subtype", _primitives.Name.get("FallbackType"));
                  dict.set("Encoding", _primitives.Name.get("ZapfDingbatsEncoding"));
                  return (0, _util.shadow)(this, "fallbackFontDict", dict);
                }
              }
              class ChoiceWidgetAnnotation extends WidgetAnnotation {
                constructor(params) {
                  super(params);
                  const {
                    dict,
                    xref
                  } = params;
                  this.indices = dict.getArray("I");
                  this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
                  this.data.options = [];
                  const options = (0, _core_utils.getInheritableProperty)({
                    dict,
                    key: "Opt"
                  });
                  if (Array.isArray(options)) {
                    for (let i = 0, ii = options.length; i < ii; i++) {
                      const option = xref.fetchIfRef(options[i]);
                      const isOptionArray = Array.isArray(option);
                      this.data.options[i] = {
                        exportValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[0]) : option),
                        displayValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[1]) : option)
                      };
                    }
                  }
                  if (!this.hasIndices) {
                    if (typeof this.data.fieldValue === "string") {
                      this.data.fieldValue = [this.data.fieldValue];
                    } else if (!this.data.fieldValue) {
                      this.data.fieldValue = [];
                    }
                  } else {
                    this.data.fieldValue = [];
                    const ii = this.data.options.length;
                    for (const i of this.indices) {
                      if (Number.isInteger(i) && i >= 0 && i < ii) {
                        this.data.fieldValue.push(this.data.options[i].exportValue);
                      }
                    }
                  }
                  this.data.combo = this.hasFieldFlag(_util.AnnotationFieldFlag.COMBO);
                  this.data.multiSelect = this.hasFieldFlag(_util.AnnotationFieldFlag.MULTISELECT);
                  this._hasText = true;
                }
                getFieldObject() {
                  const type = this.data.combo ? "combobox" : "listbox";
                  const value = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
                  return {
                    id: this.data.id,
                    value,
                    defaultValue: this.data.defaultFieldValue,
                    editable: !this.data.readOnly,
                    name: this.data.fieldName,
                    rect: this.data.rect,
                    numItems: this.data.fieldValue.length,
                    multipleSelection: this.data.multiSelect,
                    hidden: this.data.hidden,
                    actions: this.data.actions,
                    items: this.data.options,
                    page: this.data.pageIndex,
                    strokeColor: this.data.borderColor,
                    fillColor: this.data.backgroundColor,
                    rotation: this.rotation,
                    type
                  };
                }
                amendSavedDict(annotationStorage, dict) {
                  var _a;
                  if (!this.hasIndices) {
                    return;
                  }
                  let values = (_a = annotationStorage == null ? void 0 : annotationStorage.get(this.data.id)) == null ? void 0 : _a.value;
                  if (!Array.isArray(values)) {
                    values = [values];
                  }
                  const indices = [];
                  const {
                    options
                  } = this.data;
                  for (let i = 0, j = 0, ii = options.length; i < ii; i++) {
                    if (options[i].exportValue === values[j]) {
                      indices.push(i);
                      j += 1;
                    }
                  }
                  dict.set("I", indices);
                }
                async _getAppearance(evaluator, task, intent, annotationStorage) {
                  if (this.data.combo) {
                    return super._getAppearance(evaluator, task, intent, annotationStorage);
                  }
                  let exportedValue, rotation;
                  const storageEntry = annotationStorage == null ? void 0 : annotationStorage.get(this.data.id);
                  if (storageEntry) {
                    rotation = storageEntry.rotation;
                    exportedValue = storageEntry.value;
                  }
                  if (rotation === void 0 && exportedValue === void 0 && !this._needAppearances) {
                    return null;
                  }
                  if (exportedValue === void 0) {
                    exportedValue = this.data.fieldValue;
                  } else if (!Array.isArray(exportedValue)) {
                    exportedValue = [exportedValue];
                  }
                  const defaultPadding = 1;
                  const defaultHPadding = 2;
                  let totalHeight = this.data.rect[3] - this.data.rect[1];
                  let totalWidth = this.data.rect[2] - this.data.rect[0];
                  if (rotation === 90 || rotation === 270) {
                    [totalWidth, totalHeight] = [totalHeight, totalWidth];
                  }
                  const lineCount = this.data.options.length;
                  const valueIndices = [];
                  for (let i = 0; i < lineCount; i++) {
                    const {
                      exportValue
                    } = this.data.options[i];
                    if (exportedValue.includes(exportValue)) {
                      valueIndices.push(i);
                    }
                  }
                  if (!this._defaultAppearance) {
                    this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g");
                  }
                  const font = await WidgetAnnotation._getFontData(evaluator, task, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
                  let defaultAppearance;
                  let {
                    fontSize
                  } = this.data.defaultAppearanceData;
                  if (!fontSize) {
                    const lineHeight2 = (totalHeight - defaultPadding) / lineCount;
                    let lineWidth = -1;
                    let value;
                    for (const {
                      displayValue
                    } of this.data.options) {
                      const width = this._getTextWidth(displayValue, font);
                      if (width > lineWidth) {
                        lineWidth = width;
                        value = displayValue;
                      }
                    }
                    [defaultAppearance, fontSize] = this._computeFontSize(lineHeight2, totalWidth - 2 * defaultHPadding, value, font, -1);
                  } else {
                    defaultAppearance = this._defaultAppearance;
                  }
                  const lineHeight = fontSize * _util.LINE_FACTOR;
                  const vPadding = (lineHeight - fontSize) / 2;
                  const numberOfVisibleLines = Math.floor(totalHeight / lineHeight);
                  let firstIndex = 0;
                  if (valueIndices.length > 0) {
                    const minIndex = Math.min(...valueIndices);
                    const maxIndex = Math.max(...valueIndices);
                    firstIndex = Math.max(0, maxIndex - numberOfVisibleLines + 1);
                    if (firstIndex > minIndex) {
                      firstIndex = minIndex;
                    }
                  }
                  const end = Math.min(firstIndex + numberOfVisibleLines + 1, lineCount);
                  const buf = ["/Tx BMC q", `1 1 ${totalWidth} ${totalHeight} re W n`];
                  if (valueIndices.length) {
                    buf.push("0.600006 0.756866 0.854904 rg");
                    for (const index of valueIndices) {
                      if (firstIndex <= index && index < end) {
                        buf.push(`1 ${totalHeight - (index - firstIndex + 1) * lineHeight} ${totalWidth} ${lineHeight} re f`);
                      }
                    }
                  }
                  buf.push("BT", defaultAppearance, `1 0 0 1 0 ${totalHeight} Tm`);
                  const prevInfo = {
                    shift: 0
                  };
                  for (let i = firstIndex; i < end; i++) {
                    const {
                      displayValue
                    } = this.data.options[i];
                    const vpadding = i === firstIndex ? vPadding : 0;
                    buf.push(this._renderText(displayValue, font, fontSize, totalWidth, 0, prevInfo, defaultHPadding, -lineHeight + vpadding));
                  }
                  buf.push("ET Q EMC");
                  return buf.join("\n");
                }
              }
              class SignatureWidgetAnnotation extends WidgetAnnotation {
                constructor(params) {
                  super(params);
                  this.data.fieldValue = null;
                  this.data.hasOwnCanvas = this.data.noRotate;
                }
                getFieldObject() {
                  return {
                    id: this.data.id,
                    value: null,
                    page: this.data.pageIndex,
                    type: "signature"
                  };
                }
              }
              class TextAnnotation extends MarkupAnnotation {
                constructor(params) {
                  const DEFAULT_ICON_SIZE = 22;
                  super(params);
                  this.data.noRotate = true;
                  this.data.hasOwnCanvas = this.data.noRotate;
                  const {
                    dict
                  } = params;
                  this.data.annotationType = _util.AnnotationType.TEXT;
                  if (this.data.hasAppearance) {
                    this.data.name = "NoIcon";
                  } else {
                    this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
                    this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
                    this.data.name = dict.has("Name") ? dict.get("Name").name : "Note";
                  }
                  if (dict.has("State")) {
                    this.data.state = dict.get("State") || null;
                    this.data.stateModel = dict.get("StateModel") || null;
                  } else {
                    this.data.state = null;
                    this.data.stateModel = null;
                  }
                }
              }
              class LinkAnnotation extends Annotation {
                constructor(params) {
                  var _a;
                  super(params);
                  const {
                    dict,
                    annotationGlobals
                  } = params;
                  this.data.annotationType = _util.AnnotationType.LINK;
                  const quadPoints = getQuadPoints(dict, this.rectangle);
                  if (quadPoints) {
                    this.data.quadPoints = quadPoints;
                  }
                  (_a = this.data).borderColor || (_a.borderColor = this.data.color);
                  _catalog.Catalog.parseDestDictionary({
                    destDict: dict,
                    resultObj: this.data,
                    docBaseUrl: annotationGlobals.baseUrl,
                    docAttachments: annotationGlobals.attachments
                  });
                }
              }
              class PopupAnnotation extends Annotation {
                constructor(params) {
                  super(params);
                  const {
                    dict
                  } = params;
                  this.data.annotationType = _util.AnnotationType.POPUP;
                  if (this.data.rect[0] === this.data.rect[2] || this.data.rect[1] === this.data.rect[3]) {
                    this.data.rect = null;
                  }
                  let parentItem = dict.get("Parent");
                  if (!parentItem) {
                    (0, _util.warn)("Popup annotation has a missing or invalid parent annotation.");
                    return;
                  }
                  const parentRect = parentItem.getArray("Rect");
                  this.data.parentRect = Array.isArray(parentRect) && parentRect.length === 4 ? _util.Util.normalizeRect(parentRect) : null;
                  const rt = parentItem.get("RT");
                  if ((0, _primitives.isName)(rt, _util.AnnotationReplyType.GROUP)) {
                    parentItem = parentItem.get("IRT");
                  }
                  if (!parentItem.has("M")) {
                    this.data.modificationDate = null;
                  } else {
                    this.setModificationDate(parentItem.get("M"));
                    this.data.modificationDate = this.modificationDate;
                  }
                  if (!parentItem.has("C")) {
                    this.data.color = null;
                  } else {
                    this.setColor(parentItem.getArray("C"));
                    this.data.color = this.color;
                  }
                  if (!this.viewable) {
                    const parentFlags = parentItem.get("F");
                    if (this._isViewable(parentFlags)) {
                      this.setFlags(parentFlags);
                    }
                  }
                  this.setTitle(parentItem.get("T"));
                  this.data.titleObj = this._title;
                  this.setContents(parentItem.get("Contents"));
                  this.data.contentsObj = this._contents;
                  if (parentItem.has("RC")) {
                    this.data.richText = _factory.XFAFactory.getRichTextAsHtml(parentItem.get("RC"));
                  }
                  this.data.open = !!dict.get("Open");
                }
              }
              exports2.PopupAnnotation = PopupAnnotation;
              class FreeTextAnnotation extends MarkupAnnotation {
                constructor(params) {
                  var _a;
                  super(params);
                  this.data.hasOwnCanvas = true;
                  const {
                    evaluatorOptions,
                    xref
                  } = params;
                  this.data.annotationType = _util.AnnotationType.FREETEXT;
                  this.setDefaultAppearance(params);
                  if (this.appearance) {
                    const {
                      fontColor,
                      fontSize
                    } = (0, _default_appearance.parseAppearanceStream)(this.appearance, evaluatorOptions, xref);
                    this.data.defaultAppearanceData.fontColor = fontColor;
                    this.data.defaultAppearanceData.fontSize = fontSize || 10;
                  } else if (this._isOffscreenCanvasSupported) {
                    const strokeAlpha = params.dict.get("CA");
                    const fakeUnicodeFont = new _default_appearance.FakeUnicodeFont(xref, "sans-serif");
                    (_a = this.data.defaultAppearanceData).fontSize || (_a.fontSize = 10);
                    const {
                      fontColor,
                      fontSize
                    } = this.data.defaultAppearanceData;
                    this.appearance = fakeUnicodeFont.createAppearance(this._contents.str, this.rectangle, this.rotation, fontSize, fontColor, strokeAlpha);
                    this._streams.push(this.appearance, _default_appearance.FakeUnicodeFont.toUnicodeStream);
                  } else {
                    (0, _util.warn)("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
                  }
                }
                get hasTextContent() {
                  return !!this.appearance;
                }
                static createNewDict(annotation, xref, {
                  apRef,
                  ap
                }) {
                  const {
                    color,
                    fontSize,
                    rect,
                    rotation,
                    user,
                    value
                  } = annotation;
                  const freetext = new _primitives.Dict(xref);
                  freetext.set("Type", _primitives.Name.get("Annot"));
                  freetext.set("Subtype", _primitives.Name.get("FreeText"));
                  freetext.set("CreationDate", `D:${(0, _util.getModificationDate)()}`);
                  freetext.set("Rect", rect);
                  const da = `/Helv ${fontSize} Tf ${(0, _default_appearance.getPdfColor)(color, true)}`;
                  freetext.set("DA", da);
                  freetext.set("Contents", (0, _core_utils.isAscii)(value) ? value : (0, _core_utils.stringToUTF16String)(value, true));
                  freetext.set("F", 4);
                  freetext.set("Border", [0, 0, 0]);
                  freetext.set("Rotate", rotation);
                  if (user) {
                    freetext.set("T", (0, _core_utils.isAscii)(user) ? user : (0, _core_utils.stringToUTF16String)(user, true));
                  }
                  if (apRef || ap) {
                    const n = new _primitives.Dict(xref);
                    freetext.set("AP", n);
                    if (apRef) {
                      n.set("N", apRef);
                    } else {
                      n.set("N", ap);
                    }
                  }
                  return freetext;
                }
                static async createNewAppearanceStream(annotation, xref, params) {
                  const {
                    baseFontRef,
                    evaluator,
                    task
                  } = params;
                  const {
                    color,
                    fontSize,
                    rect,
                    rotation,
                    value
                  } = annotation;
                  const resources = new _primitives.Dict(xref);
                  const font = new _primitives.Dict(xref);
                  if (baseFontRef) {
                    font.set("Helv", baseFontRef);
                  } else {
                    const baseFont = new _primitives.Dict(xref);
                    baseFont.set("BaseFont", _primitives.Name.get("Helvetica"));
                    baseFont.set("Type", _primitives.Name.get("Font"));
                    baseFont.set("Subtype", _primitives.Name.get("Type1"));
                    baseFont.set("Encoding", _primitives.Name.get("WinAnsiEncoding"));
                    font.set("Helv", baseFont);
                  }
                  resources.set("Font", font);
                  const helv = await WidgetAnnotation._getFontData(evaluator, task, {
                    fontName: "Helv",
                    fontSize
                  }, resources);
                  const [x1, y1, x2, y2] = rect;
                  let w = x2 - x1;
                  let h = y2 - y1;
                  if (rotation % 180 !== 0) {
                    [w, h] = [h, w];
                  }
                  const lines = value.split("\n");
                  const scale = fontSize / 1e3;
                  let totalWidth = -Infinity;
                  const encodedLines = [];
                  for (let line of lines) {
                    const encoded = helv.encodeString(line);
                    if (encoded.length > 1) {
                      return null;
                    }
                    line = encoded.join("");
                    encodedLines.push(line);
                    let lineWidth = 0;
                    const glyphs = helv.charsToGlyphs(line);
                    for (const glyph of glyphs) {
                      lineWidth += glyph.width * scale;
                    }
                    totalWidth = Math.max(totalWidth, lineWidth);
                  }
                  let hscale = 1;
                  if (totalWidth > w) {
                    hscale = w / totalWidth;
                  }
                  let vscale = 1;
                  const lineHeight = _util.LINE_FACTOR * fontSize;
                  const lineAscent = (_util.LINE_FACTOR - _util.LINE_DESCENT_FACTOR) * fontSize;
                  const totalHeight = lineHeight * lines.length;
                  if (totalHeight > h) {
                    vscale = h / totalHeight;
                  }
                  const fscale = Math.min(hscale, vscale);
                  const newFontSize = fontSize * fscale;
                  let firstPoint, clipBox, matrix;
                  switch (rotation) {
                    case 0:
                      matrix = [1, 0, 0, 1];
                      clipBox = [rect[0], rect[1], w, h];
                      firstPoint = [rect[0], rect[3] - lineAscent];
                      break;
                    case 90:
                      matrix = [0, 1, -1, 0];
                      clipBox = [rect[1], -rect[2], w, h];
                      firstPoint = [rect[1], -rect[0] - lineAscent];
                      break;
                    case 180:
                      matrix = [-1, 0, 0, -1];
                      clipBox = [-rect[2], -rect[3], w, h];
                      firstPoint = [-rect[2], -rect[1] - lineAscent];
                      break;
                    case 270:
                      matrix = [0, -1, 1, 0];
                      clipBox = [-rect[3], rect[0], w, h];
                      firstPoint = [-rect[3], rect[2] - lineAscent];
                      break;
                  }
                  const buffer = ["q", `${matrix.join(" ")} 0 0 cm`, `${clipBox.join(" ")} re W n`, `BT`, `${(0, _default_appearance.getPdfColor)(color, true)}`, `0 Tc /Helv ${(0, _core_utils.numberToString)(newFontSize)} Tf`];
                  buffer.push(`${firstPoint.join(" ")} Td (${(0, _core_utils.escapeString)(encodedLines[0])}) Tj`);
                  const vShift = (0, _core_utils.numberToString)(lineHeight);
                  for (let i = 1, ii = encodedLines.length; i < ii; i++) {
                    const line = encodedLines[i];
                    buffer.push(`0 -${vShift} Td (${(0, _core_utils.escapeString)(line)}) Tj`);
                  }
                  buffer.push("ET", "Q");
                  const appearance = buffer.join("\n");
                  const appearanceStreamDict = new _primitives.Dict(xref);
                  appearanceStreamDict.set("FormType", 1);
                  appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
                  appearanceStreamDict.set("Type", _primitives.Name.get("XObject"));
                  appearanceStreamDict.set("BBox", rect);
                  appearanceStreamDict.set("Resources", resources);
                  appearanceStreamDict.set("Matrix", [1, 0, 0, 1, -rect[0], -rect[1]]);
                  const ap = new _stream.StringStream(appearance);
                  ap.dict = appearanceStreamDict;
                  return ap;
                }
              }
              class LineAnnotation extends MarkupAnnotation {
                constructor(params) {
                  super(params);
                  const {
                    dict,
                    xref
                  } = params;
                  this.data.annotationType = _util.AnnotationType.LINE;
                  this.data.hasOwnCanvas = this.data.noRotate;
                  const lineCoordinates = dict.getArray("L");
                  this.data.lineCoordinates = _util.Util.normalizeRect(lineCoordinates);
                  this.setLineEndings(dict.getArray("LE"));
                  this.data.lineEndings = this.lineEndings;
                  if (!this.appearance) {
                    const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
                    const strokeAlpha = dict.get("CA");
                    const interiorColor = getRgbColor(dict.getArray("IC"), null);
                    const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
                    const fillAlpha = fillColor ? strokeAlpha : null;
                    const borderWidth = this.borderStyle.width || 1, borderAdjust = 2 * borderWidth;
                    const bbox = [this.data.lineCoordinates[0] - borderAdjust, this.data.lineCoordinates[1] - borderAdjust, this.data.lineCoordinates[2] + borderAdjust, this.data.lineCoordinates[3] + borderAdjust];
                    if (!_util.Util.intersect(this.rectangle, bbox)) {
                      this.rectangle = bbox;
                    }
                    this._setDefaultAppearance({
                      xref,
                      extra: `${borderWidth} w`,
                      strokeColor,
                      fillColor,
                      strokeAlpha,
                      fillAlpha,
                      pointsCallback: (buffer, points) => {
                        buffer.push(`${lineCoordinates[0]} ${lineCoordinates[1]} m`, `${lineCoordinates[2]} ${lineCoordinates[3]} l`, "S");
                        return [points[0].x - borderWidth, points[1].x + borderWidth, points[3].y - borderWidth, points[1].y + borderWidth];
                      }
                    });
                  }
                }
              }
              class SquareAnnotation extends MarkupAnnotation {
                constructor(params) {
                  super(params);
                  const {
                    dict,
                    xref
                  } = params;
                  this.data.annotationType = _util.AnnotationType.SQUARE;
                  this.data.hasOwnCanvas = this.data.noRotate;
                  if (!this.appearance) {
                    const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
                    const strokeAlpha = dict.get("CA");
                    const interiorColor = getRgbColor(dict.getArray("IC"), null);
                    const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
                    const fillAlpha = fillColor ? strokeAlpha : null;
                    if (this.borderStyle.width === 0 && !fillColor) {
                      return;
                    }
                    this._setDefaultAppearance({
                      xref,
                      extra: `${this.borderStyle.width} w`,
                      strokeColor,
                      fillColor,
                      strokeAlpha,
                      fillAlpha,
                      pointsCallback: (buffer, points) => {
                        const x = points[2].x + this.borderStyle.width / 2;
                        const y = points[2].y + this.borderStyle.width / 2;
                        const width = points[3].x - points[2].x - this.borderStyle.width;
                        const height = points[1].y - points[3].y - this.borderStyle.width;
                        buffer.push(`${x} ${y} ${width} ${height} re`);
                        if (fillColor) {
                          buffer.push("B");
                        } else {
                          buffer.push("S");
                        }
                        return [points[0].x, points[1].x, points[3].y, points[1].y];
                      }
                    });
                  }
                }
              }
              class CircleAnnotation extends MarkupAnnotation {
                constructor(params) {
                  super(params);
                  const {
                    dict,
                    xref
                  } = params;
                  this.data.annotationType = _util.AnnotationType.CIRCLE;
                  if (!this.appearance) {
                    const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
                    const strokeAlpha = dict.get("CA");
                    const interiorColor = getRgbColor(dict.getArray("IC"), null);
                    const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
                    const fillAlpha = fillColor ? strokeAlpha : null;
                    if (this.borderStyle.width === 0 && !fillColor) {
                      return;
                    }
                    const controlPointsDistance = 4 / 3 * Math.tan(Math.PI / (2 * 4));
                    this._setDefaultAppearance({
                      xref,
                      extra: `${this.borderStyle.width} w`,
                      strokeColor,
                      fillColor,
                      strokeAlpha,
                      fillAlpha,
                      pointsCallback: (buffer, points) => {
                        const x0 = points[0].x + this.borderStyle.width / 2;
                        const y0 = points[0].y - this.borderStyle.width / 2;
                        const x1 = points[3].x - this.borderStyle.width / 2;
                        const y1 = points[3].y + this.borderStyle.width / 2;
                        const xMid = x0 + (x1 - x0) / 2;
                        const yMid = y0 + (y1 - y0) / 2;
                        const xOffset = (x1 - x0) / 2 * controlPointsDistance;
                        const yOffset = (y1 - y0) / 2 * controlPointsDistance;
                        buffer.push(`${xMid} ${y1} m`, `${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`, `${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`, `${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`, `${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`, "h");
                        if (fillColor) {
                          buffer.push("B");
                        } else {
                          buffer.push("S");
                        }
                        return [points[0].x, points[1].x, points[3].y, points[1].y];
                      }
                    });
                  }
                }
              }
              class PolylineAnnotation extends MarkupAnnotation {
                constructor(params) {
                  super(params);
                  const {
                    dict,
                    xref
                  } = params;
                  this.data.annotationType = _util.AnnotationType.POLYLINE;
                  this.data.hasOwnCanvas = this.data.noRotate;
                  this.data.vertices = [];
                  if (!(this instanceof PolygonAnnotation)) {
                    this.setLineEndings(dict.getArray("LE"));
                    this.data.lineEndings = this.lineEndings;
                  }
                  const rawVertices = dict.getArray("Vertices");
                  if (!Array.isArray(rawVertices)) {
                    return;
                  }
                  for (let i = 0, ii = rawVertices.length; i < ii; i += 2) {
                    this.data.vertices.push({
                      x: rawVertices[i],
                      y: rawVertices[i + 1]
                    });
                  }
                  if (!this.appearance) {
                    const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
                    const strokeAlpha = dict.get("CA");
                    const borderWidth = this.borderStyle.width || 1, borderAdjust = 2 * borderWidth;
                    const bbox = [Infinity, Infinity, -Infinity, -Infinity];
                    for (const vertex of this.data.vertices) {
                      bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);
                      bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);
                      bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);
                      bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);
                    }
                    if (!_util.Util.intersect(this.rectangle, bbox)) {
                      this.rectangle = bbox;
                    }
                    this._setDefaultAppearance({
                      xref,
                      extra: `${borderWidth} w`,
                      strokeColor,
                      strokeAlpha,
                      pointsCallback: (buffer, points) => {
                        const vertices = this.data.vertices;
                        for (let i = 0, ii = vertices.length; i < ii; i++) {
                          buffer.push(`${vertices[i].x} ${vertices[i].y} ${i === 0 ? "m" : "l"}`);
                        }
                        buffer.push("S");
                        return [points[0].x, points[1].x, points[3].y, points[1].y];
                      }
                    });
                  }
                }
              }
              class PolygonAnnotation extends PolylineAnnotation {
                constructor(params) {
                  super(params);
                  this.data.annotationType = _util.AnnotationType.POLYGON;
                }
              }
              class CaretAnnotation extends MarkupAnnotation {
                constructor(params) {
                  super(params);
                  this.data.annotationType = _util.AnnotationType.CARET;
                }
              }
              class InkAnnotation extends MarkupAnnotation {
                constructor(params) {
                  super(params);
                  this.data.hasOwnCanvas = this.data.noRotate;
                  const {
                    dict,
                    xref
                  } = params;
                  this.data.annotationType = _util.AnnotationType.INK;
                  this.data.inkLists = [];
                  const rawInkLists = dict.getArray("InkList");
                  if (!Array.isArray(rawInkLists)) {
                    return;
                  }
                  for (let i = 0, ii = rawInkLists.length; i < ii; ++i) {
                    this.data.inkLists.push([]);
                    for (let j = 0, jj = rawInkLists[i].length; j < jj; j += 2) {
                      this.data.inkLists[i].push({
                        x: xref.fetchIfRef(rawInkLists[i][j]),
                        y: xref.fetchIfRef(rawInkLists[i][j + 1])
                      });
                    }
                  }
                  if (!this.appearance) {
                    const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
                    const strokeAlpha = dict.get("CA");
                    const borderWidth = this.borderStyle.width || 1, borderAdjust = 2 * borderWidth;
                    const bbox = [Infinity, Infinity, -Infinity, -Infinity];
                    for (const inkLists of this.data.inkLists) {
                      for (const vertex of inkLists) {
                        bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);
                        bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);
                        bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);
                        bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);
                      }
                    }
                    if (!_util.Util.intersect(this.rectangle, bbox)) {
                      this.rectangle = bbox;
                    }
                    this._setDefaultAppearance({
                      xref,
                      extra: `${borderWidth} w`,
                      strokeColor,
                      strokeAlpha,
                      pointsCallback: (buffer, points) => {
                        for (const inkList of this.data.inkLists) {
                          for (let i = 0, ii = inkList.length; i < ii; i++) {
                            buffer.push(`${inkList[i].x} ${inkList[i].y} ${i === 0 ? "m" : "l"}`);
                          }
                          buffer.push("S");
                        }
                        return [points[0].x, points[1].x, points[3].y, points[1].y];
                      }
                    });
                  }
                }
                static createNewDict(annotation, xref, {
                  apRef,
                  ap
                }) {
                  const {
                    color,
                    opacity,
                    paths,
                    rect,
                    rotation,
                    thickness
                  } = annotation;
                  const ink = new _primitives.Dict(xref);
                  ink.set("Type", _primitives.Name.get("Annot"));
                  ink.set("Subtype", _primitives.Name.get("Ink"));
                  ink.set("CreationDate", `D:${(0, _util.getModificationDate)()}`);
                  ink.set("Rect", rect);
                  ink.set("InkList", paths.map((p) => p.points));
                  ink.set("F", 4);
                  ink.set("Rotate", rotation);
                  const bs = new _primitives.Dict(xref);
                  ink.set("BS", bs);
                  bs.set("W", thickness);
                  ink.set("C", Array.from(color, (c) => c / 255));
                  ink.set("CA", opacity);
                  const n = new _primitives.Dict(xref);
                  ink.set("AP", n);
                  if (apRef) {
                    n.set("N", apRef);
                  } else {
                    n.set("N", ap);
                  }
                  return ink;
                }
                static async createNewAppearanceStream(annotation, xref, params) {
                  const {
                    color,
                    rect,
                    paths,
                    thickness,
                    opacity
                  } = annotation;
                  const appearanceBuffer = [`${thickness} w 1 J 1 j`, `${(0, _default_appearance.getPdfColor)(color, false)}`];
                  if (opacity !== 1) {
                    appearanceBuffer.push("/R0 gs");
                  }
                  const buffer = [];
                  for (const {
                    bezier
                  } of paths) {
                    buffer.length = 0;
                    buffer.push(`${(0, _core_utils.numberToString)(bezier[0])} ${(0, _core_utils.numberToString)(bezier[1])} m`);
                    for (let i = 2, ii = bezier.length; i < ii; i += 6) {
                      const curve = bezier.slice(i, i + 6).map(_core_utils.numberToString).join(" ");
                      buffer.push(`${curve} c`);
                    }
                    buffer.push("S");
                    appearanceBuffer.push(buffer.join("\n"));
                  }
                  const appearance = appearanceBuffer.join("\n");
                  const appearanceStreamDict = new _primitives.Dict(xref);
                  appearanceStreamDict.set("FormType", 1);
                  appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
                  appearanceStreamDict.set("Type", _primitives.Name.get("XObject"));
                  appearanceStreamDict.set("BBox", rect);
                  appearanceStreamDict.set("Length", appearance.length);
                  if (opacity !== 1) {
                    const resources = new _primitives.Dict(xref);
                    const extGState = new _primitives.Dict(xref);
                    const r0 = new _primitives.Dict(xref);
                    r0.set("CA", opacity);
                    r0.set("Type", _primitives.Name.get("ExtGState"));
                    extGState.set("R0", r0);
                    resources.set("ExtGState", extGState);
                    appearanceStreamDict.set("Resources", resources);
                  }
                  const ap = new _stream.StringStream(appearance);
                  ap.dict = appearanceStreamDict;
                  return ap;
                }
              }
              class HighlightAnnotation extends MarkupAnnotation {
                constructor(params) {
                  var _a;
                  super(params);
                  const {
                    dict,
                    xref
                  } = params;
                  this.data.annotationType = _util.AnnotationType.HIGHLIGHT;
                  const quadPoints = this.data.quadPoints = getQuadPoints(dict, null);
                  if (quadPoints) {
                    const resources = (_a = this.appearance) == null ? void 0 : _a.dict.get("Resources");
                    if (!this.appearance || !(resources == null ? void 0 : resources.has("ExtGState"))) {
                      if (this.appearance) {
                        (0, _util.warn)("HighlightAnnotation - ignoring built-in appearance stream.");
                      }
                      const fillColor = this.color ? getPdfColorArray(this.color) : [1, 1, 0];
                      const fillAlpha = dict.get("CA");
                      this._setDefaultAppearance({
                        xref,
                        fillColor,
                        blendMode: "Multiply",
                        fillAlpha,
                        pointsCallback: (buffer, points) => {
                          buffer.push(`${points[0].x} ${points[0].y} m`, `${points[1].x} ${points[1].y} l`, `${points[3].x} ${points[3].y} l`, `${points[2].x} ${points[2].y} l`, "f");
                          return [points[0].x, points[1].x, points[3].y, points[1].y];
                        }
                      });
                    }
                  } else {
                    this.data.popupRef = null;
                  }
                }
              }
              class UnderlineAnnotation extends MarkupAnnotation {
                constructor(params) {
                  super(params);
                  const {
                    dict,
                    xref
                  } = params;
                  this.data.annotationType = _util.AnnotationType.UNDERLINE;
                  const quadPoints = this.data.quadPoints = getQuadPoints(dict, null);
                  if (quadPoints) {
                    if (!this.appearance) {
                      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
                      const strokeAlpha = dict.get("CA");
                      this._setDefaultAppearance({
                        xref,
                        extra: "[] 0 d 0.571 w",
                        strokeColor,
                        strokeAlpha,
                        pointsCallback: (buffer, points) => {
                          buffer.push(`${points[2].x} ${points[2].y + 1.3} m`, `${points[3].x} ${points[3].y + 1.3} l`, "S");
                          return [points[0].x, points[1].x, points[3].y, points[1].y];
                        }
                      });
                    }
                  } else {
                    this.data.popupRef = null;
                  }
                }
              }
              class SquigglyAnnotation extends MarkupAnnotation {
                constructor(params) {
                  super(params);
                  const {
                    dict,
                    xref
                  } = params;
                  this.data.annotationType = _util.AnnotationType.SQUIGGLY;
                  const quadPoints = this.data.quadPoints = getQuadPoints(dict, null);
                  if (quadPoints) {
                    if (!this.appearance) {
                      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
                      const strokeAlpha = dict.get("CA");
                      this._setDefaultAppearance({
                        xref,
                        extra: "[] 0 d 1 w",
                        strokeColor,
                        strokeAlpha,
                        pointsCallback: (buffer, points) => {
                          const dy = (points[0].y - points[2].y) / 6;
                          let shift = dy;
                          let x = points[2].x;
                          const y = points[2].y;
                          const xEnd = points[3].x;
                          buffer.push(`${x} ${y + shift} m`);
                          do {
                            x += 2;
                            shift = shift === 0 ? dy : 0;
                            buffer.push(`${x} ${y + shift} l`);
                          } while (x < xEnd);
                          buffer.push("S");
                          return [points[2].x, xEnd, y - 2 * dy, y + 2 * dy];
                        }
                      });
                    }
                  } else {
                    this.data.popupRef = null;
                  }
                }
              }
              class StrikeOutAnnotation extends MarkupAnnotation {
                constructor(params) {
                  super(params);
                  const {
                    dict,
                    xref
                  } = params;
                  this.data.annotationType = _util.AnnotationType.STRIKEOUT;
                  const quadPoints = this.data.quadPoints = getQuadPoints(dict, null);
                  if (quadPoints) {
                    if (!this.appearance) {
                      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
                      const strokeAlpha = dict.get("CA");
                      this._setDefaultAppearance({
                        xref,
                        extra: "[] 0 d 1 w",
                        strokeColor,
                        strokeAlpha,
                        pointsCallback: (buffer, points) => {
                          buffer.push(`${(points[0].x + points[2].x) / 2} ${(points[0].y + points[2].y) / 2} m`, `${(points[1].x + points[3].x) / 2} ${(points[1].y + points[3].y) / 2} l`, "S");
                          return [points[0].x, points[1].x, points[3].y, points[1].y];
                        }
                      });
                    }
                  } else {
                    this.data.popupRef = null;
                  }
                }
              }
              class StampAnnotation extends MarkupAnnotation {
                constructor(params) {
                  super(params);
                  this.data.annotationType = _util.AnnotationType.STAMP;
                  this.data.hasOwnCanvas = this.data.noRotate;
                }
                static async createImage(bitmap, xref) {
                  const {
                    width,
                    height
                  } = bitmap;
                  const canvas = new OffscreenCanvas(width, height);
                  const ctx = canvas.getContext("2d", {
                    alpha: true
                  });
                  ctx.drawImage(bitmap, 0, 0);
                  const data = ctx.getImageData(0, 0, width, height).data;
                  const buf32 = new Uint32Array(data.buffer);
                  const hasAlpha = buf32.some(_util.FeatureTest.isLittleEndian ? (x) => x >>> 24 !== 255 : (x) => (x & 255) !== 255);
                  if (hasAlpha) {
                    ctx.fillStyle = "white";
                    ctx.fillRect(0, 0, width, height);
                    ctx.drawImage(bitmap, 0, 0);
                  }
                  const jpegBufferPromise = canvas.convertToBlob({
                    type: "image/jpeg",
                    quality: 1
                  }).then((blob) => {
                    return blob.arrayBuffer();
                  });
                  const xobjectName = _primitives.Name.get("XObject");
                  const imageName = _primitives.Name.get("Image");
                  const image = new _primitives.Dict(xref);
                  image.set("Type", xobjectName);
                  image.set("Subtype", imageName);
                  image.set("BitsPerComponent", 8);
                  image.set("ColorSpace", _primitives.Name.get("DeviceRGB"));
                  image.set("Filter", _primitives.Name.get("DCTDecode"));
                  image.set("BBox", [0, 0, width, height]);
                  image.set("Width", width);
                  image.set("Height", height);
                  let smaskStream = null;
                  if (hasAlpha) {
                    const alphaBuffer = new Uint8Array(buf32.length);
                    if (_util.FeatureTest.isLittleEndian) {
                      for (let i = 0, ii = buf32.length; i < ii; i++) {
                        alphaBuffer[i] = buf32[i] >>> 24;
                      }
                    } else {
                      for (let i = 0, ii = buf32.length; i < ii; i++) {
                        alphaBuffer[i] = buf32[i] & 255;
                      }
                    }
                    const smask = new _primitives.Dict(xref);
                    smask.set("Type", xobjectName);
                    smask.set("Subtype", imageName);
                    smask.set("BitsPerComponent", 8);
                    smask.set("ColorSpace", _primitives.Name.get("DeviceGray"));
                    smask.set("Width", width);
                    smask.set("Height", height);
                    smaskStream = new _stream.Stream(alphaBuffer, 0, 0, smask);
                  }
                  const imageStream = new _stream.Stream(await jpegBufferPromise, 0, 0, image);
                  return {
                    imageStream,
                    smaskStream,
                    width,
                    height
                  };
                }
                static createNewDict(annotation, xref, {
                  apRef,
                  ap
                }) {
                  const {
                    rect,
                    rotation,
                    user
                  } = annotation;
                  const stamp = new _primitives.Dict(xref);
                  stamp.set("Type", _primitives.Name.get("Annot"));
                  stamp.set("Subtype", _primitives.Name.get("Stamp"));
                  stamp.set("CreationDate", `D:${(0, _util.getModificationDate)()}`);
                  stamp.set("Rect", rect);
                  stamp.set("F", 4);
                  stamp.set("Border", [0, 0, 0]);
                  stamp.set("Rotate", rotation);
                  if (user) {
                    stamp.set("T", (0, _core_utils.isAscii)(user) ? user : (0, _core_utils.stringToUTF16String)(user, true));
                  }
                  if (apRef || ap) {
                    const n = new _primitives.Dict(xref);
                    stamp.set("AP", n);
                    if (apRef) {
                      n.set("N", apRef);
                    } else {
                      n.set("N", ap);
                    }
                  }
                  return stamp;
                }
                static async createNewAppearanceStream(annotation, xref, params) {
                  const {
                    rotation
                  } = annotation;
                  const {
                    imageRef,
                    width,
                    height
                  } = params.image;
                  const resources = new _primitives.Dict(xref);
                  const xobject = new _primitives.Dict(xref);
                  resources.set("XObject", xobject);
                  xobject.set("Im0", imageRef);
                  const appearance = `q ${width} 0 0 ${height} 0 0 cm /Im0 Do Q`;
                  const appearanceStreamDict = new _primitives.Dict(xref);
                  appearanceStreamDict.set("FormType", 1);
                  appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
                  appearanceStreamDict.set("Type", _primitives.Name.get("XObject"));
                  appearanceStreamDict.set("BBox", [0, 0, width, height]);
                  appearanceStreamDict.set("Resources", resources);
                  if (rotation) {
                    const matrix = (0, _core_utils.getRotationMatrix)(rotation, width, height);
                    appearanceStreamDict.set("Matrix", matrix);
                  }
                  const ap = new _stream.StringStream(appearance);
                  ap.dict = appearanceStreamDict;
                  return ap;
                }
              }
              class FileAttachmentAnnotation extends MarkupAnnotation {
                constructor(params) {
                  super(params);
                  const {
                    dict,
                    xref
                  } = params;
                  const file = new _file_spec.FileSpec(dict.get("FS"), xref);
                  this.data.annotationType = _util.AnnotationType.FILEATTACHMENT;
                  this.data.hasOwnCanvas = this.data.noRotate;
                  this.data.file = file.serializable;
                  const name = dict.get("Name");
                  this.data.name = name instanceof _primitives.Name ? (0, _util.stringToPDFString)(name.name) : "PushPin";
                  const fillAlpha = dict.get("ca");
                  this.data.fillAlpha = typeof fillAlpha === "number" && fillAlpha >= 0 && fillAlpha <= 1 ? fillAlpha : null;
                }
              }
            },
            /* 11 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FakeUnicodeFont = void 0;
              exports2.createDefaultAppearance = createDefaultAppearance;
              exports2.getPdfColor = getPdfColor;
              exports2.parseAppearanceStream = parseAppearanceStream;
              exports2.parseDefaultAppearance = parseDefaultAppearance;
              var _primitives = __w_pdfjs_require__2(4);
              var _core_utils = __w_pdfjs_require__2(3);
              var _util = __w_pdfjs_require__2(2);
              var _colorspace = __w_pdfjs_require__2(12);
              var _evaluator = __w_pdfjs_require__2(13);
              var _image_utils = __w_pdfjs_require__2(59);
              var _function = __w_pdfjs_require__2(57);
              var _stream = __w_pdfjs_require__2(8);
              class DefaultAppearanceEvaluator extends _evaluator.EvaluatorPreprocessor {
                constructor(str) {
                  super(new _stream.StringStream(str));
                }
                parse() {
                  const operation = {
                    fn: 0,
                    args: []
                  };
                  const result = {
                    fontSize: 0,
                    fontName: "",
                    fontColor: new Uint8ClampedArray(3)
                  };
                  try {
                    while (true) {
                      operation.args.length = 0;
                      if (!this.read(operation)) {
                        break;
                      }
                      if (this.savedStatesDepth !== 0) {
                        continue;
                      }
                      const {
                        fn,
                        args
                      } = operation;
                      switch (fn | 0) {
                        case _util.OPS.setFont:
                          const [fontName, fontSize] = args;
                          if (fontName instanceof _primitives.Name) {
                            result.fontName = fontName.name;
                          }
                          if (typeof fontSize === "number" && fontSize > 0) {
                            result.fontSize = fontSize;
                          }
                          break;
                        case _util.OPS.setFillRGBColor:
                          _colorspace.ColorSpace.singletons.rgb.getRgbItem(args, 0, result.fontColor, 0);
                          break;
                        case _util.OPS.setFillGray:
                          _colorspace.ColorSpace.singletons.gray.getRgbItem(args, 0, result.fontColor, 0);
                          break;
                        case _util.OPS.setFillCMYKColor:
                          _colorspace.ColorSpace.singletons.cmyk.getRgbItem(args, 0, result.fontColor, 0);
                          break;
                      }
                    }
                  } catch (reason) {
                    (0, _util.warn)(`parseDefaultAppearance - ignoring errors: "${reason}".`);
                  }
                  return result;
                }
              }
              function parseDefaultAppearance(str) {
                return new DefaultAppearanceEvaluator(str).parse();
              }
              class AppearanceStreamEvaluator extends _evaluator.EvaluatorPreprocessor {
                constructor(stream, evaluatorOptions, xref) {
                  var _a;
                  super(stream);
                  this.stream = stream;
                  this.evaluatorOptions = evaluatorOptions;
                  this.xref = xref;
                  this.resources = (_a = stream.dict) == null ? void 0 : _a.get("Resources");
                }
                parse() {
                  const operation = {
                    fn: 0,
                    args: []
                  };
                  let result = {
                    scaleFactor: 1,
                    fontSize: 0,
                    fontName: "",
                    fontColor: new Uint8ClampedArray(3),
                    fillColorSpace: _colorspace.ColorSpace.singletons.gray
                  };
                  let breakLoop = false;
                  const stack = [];
                  try {
                    while (true) {
                      operation.args.length = 0;
                      if (breakLoop || !this.read(operation)) {
                        break;
                      }
                      const {
                        fn,
                        args
                      } = operation;
                      switch (fn | 0) {
                        case _util.OPS.save:
                          stack.push({
                            scaleFactor: result.scaleFactor,
                            fontSize: result.fontSize,
                            fontName: result.fontName,
                            fontColor: result.fontColor.slice(),
                            fillColorSpace: result.fillColorSpace
                          });
                          break;
                        case _util.OPS.restore:
                          result = stack.pop() || result;
                          break;
                        case _util.OPS.setTextMatrix:
                          result.scaleFactor *= Math.hypot(args[0], args[1]);
                          break;
                        case _util.OPS.setFont:
                          const [fontName, fontSize] = args;
                          if (fontName instanceof _primitives.Name) {
                            result.fontName = fontName.name;
                          }
                          if (typeof fontSize === "number" && fontSize > 0) {
                            result.fontSize = fontSize * result.scaleFactor;
                          }
                          break;
                        case _util.OPS.setFillColorSpace:
                          result.fillColorSpace = _colorspace.ColorSpace.parse({
                            cs: args[0],
                            xref: this.xref,
                            resources: this.resources,
                            pdfFunctionFactory: this._pdfFunctionFactory,
                            localColorSpaceCache: this._localColorSpaceCache
                          });
                          break;
                        case _util.OPS.setFillColor:
                          const cs = result.fillColorSpace;
                          cs.getRgbItem(args, 0, result.fontColor, 0);
                          break;
                        case _util.OPS.setFillRGBColor:
                          _colorspace.ColorSpace.singletons.rgb.getRgbItem(args, 0, result.fontColor, 0);
                          break;
                        case _util.OPS.setFillGray:
                          _colorspace.ColorSpace.singletons.gray.getRgbItem(args, 0, result.fontColor, 0);
                          break;
                        case _util.OPS.setFillCMYKColor:
                          _colorspace.ColorSpace.singletons.cmyk.getRgbItem(args, 0, result.fontColor, 0);
                          break;
                        case _util.OPS.showText:
                        case _util.OPS.showSpacedText:
                        case _util.OPS.nextLineShowText:
                        case _util.OPS.nextLineSetSpacingShowText:
                          breakLoop = true;
                          break;
                      }
                    }
                  } catch (reason) {
                    (0, _util.warn)(`parseAppearanceStream - ignoring errors: "${reason}".`);
                  }
                  this.stream.reset();
                  delete result.scaleFactor;
                  delete result.fillColorSpace;
                  return result;
                }
                get _localColorSpaceCache() {
                  return (0, _util.shadow)(this, "_localColorSpaceCache", new _image_utils.LocalColorSpaceCache());
                }
                get _pdfFunctionFactory() {
                  const pdfFunctionFactory = new _function.PDFFunctionFactory({
                    xref: this.xref,
                    isEvalSupported: this.evaluatorOptions.isEvalSupported
                  });
                  return (0, _util.shadow)(this, "_pdfFunctionFactory", pdfFunctionFactory);
                }
              }
              function parseAppearanceStream(stream, evaluatorOptions, xref) {
                return new AppearanceStreamEvaluator(stream, evaluatorOptions, xref).parse();
              }
              function getPdfColor(color, isFill) {
                if (color[0] === color[1] && color[1] === color[2]) {
                  const gray = color[0] / 255;
                  return `${(0, _core_utils.numberToString)(gray)} ${isFill ? "g" : "G"}`;
                }
                return Array.from(color, (c) => (0, _core_utils.numberToString)(c / 255)).join(" ") + ` ${isFill ? "rg" : "RG"}`;
              }
              function createDefaultAppearance({
                fontSize,
                fontName,
                fontColor
              }) {
                return `/${(0, _core_utils.escapePDFName)(fontName)} ${fontSize} Tf ${getPdfColor(fontColor, true)}`;
              }
              class FakeUnicodeFont {
                constructor(xref, fontFamily) {
                  this.xref = xref;
                  this.widths = null;
                  this.firstChar = Infinity;
                  this.lastChar = -Infinity;
                  this.fontFamily = fontFamily;
                  const canvas = new OffscreenCanvas(1, 1);
                  this.ctxMeasure = canvas.getContext("2d");
                  if (!FakeUnicodeFont._fontNameId) {
                    FakeUnicodeFont._fontNameId = 1;
                  }
                  this.fontName = _primitives.Name.get(`InvalidPDFjsFont_${fontFamily}_${FakeUnicodeFont._fontNameId++}`);
                }
                get toUnicodeRef() {
                  if (!FakeUnicodeFont._toUnicodeRef) {
                    const toUnicode = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo
<< /Registry (Adobe)
/Ordering (UCS) /Supplement 0 >> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000> <FFFF>
endcodespacerange
1 beginbfrange
<0000> <FFFF> <0000>
endbfrange
endcmap CMapName currentdict /CMap defineresource pop end end`;
                    const toUnicodeStream = FakeUnicodeFont.toUnicodeStream = new _stream.StringStream(toUnicode);
                    const toUnicodeDict = new _primitives.Dict(this.xref);
                    toUnicodeStream.dict = toUnicodeDict;
                    toUnicodeDict.set("Length", toUnicode.length);
                    FakeUnicodeFont._toUnicodeRef = this.xref.getNewPersistentRef(toUnicodeStream);
                  }
                  return FakeUnicodeFont._toUnicodeRef;
                }
                get fontDescriptorRef() {
                  if (!FakeUnicodeFont._fontDescriptorRef) {
                    const fontDescriptor = new _primitives.Dict(this.xref);
                    fontDescriptor.set("Type", _primitives.Name.get("FontDescriptor"));
                    fontDescriptor.set("FontName", this.fontName);
                    fontDescriptor.set("FontFamily", "MyriadPro Regular");
                    fontDescriptor.set("FontBBox", [0, 0, 0, 0]);
                    fontDescriptor.set("FontStretch", _primitives.Name.get("Normal"));
                    fontDescriptor.set("FontWeight", 400);
                    fontDescriptor.set("ItalicAngle", 0);
                    FakeUnicodeFont._fontDescriptorRef = this.xref.getNewPersistentRef(fontDescriptor);
                  }
                  return FakeUnicodeFont._fontDescriptorRef;
                }
                get descendantFontRef() {
                  const descendantFont = new _primitives.Dict(this.xref);
                  descendantFont.set("BaseFont", this.fontName);
                  descendantFont.set("Type", _primitives.Name.get("Font"));
                  descendantFont.set("Subtype", _primitives.Name.get("CIDFontType0"));
                  descendantFont.set("CIDToGIDMap", _primitives.Name.get("Identity"));
                  descendantFont.set("FirstChar", this.firstChar);
                  descendantFont.set("LastChar", this.lastChar);
                  descendantFont.set("FontDescriptor", this.fontDescriptorRef);
                  descendantFont.set("DW", 1e3);
                  const widths = [];
                  const chars = [...this.widths.entries()].sort();
                  let currentChar = null;
                  let currentWidths = null;
                  for (const [char, width] of chars) {
                    if (!currentChar) {
                      currentChar = char;
                      currentWidths = [width];
                      continue;
                    }
                    if (char === currentChar + currentWidths.length) {
                      currentWidths.push(width);
                    } else {
                      widths.push(currentChar, currentWidths);
                      currentChar = char;
                      currentWidths = [width];
                    }
                  }
                  if (currentChar) {
                    widths.push(currentChar, currentWidths);
                  }
                  descendantFont.set("W", widths);
                  const cidSystemInfo = new _primitives.Dict(this.xref);
                  cidSystemInfo.set("Ordering", "Identity");
                  cidSystemInfo.set("Registry", "Adobe");
                  cidSystemInfo.set("Supplement", 0);
                  descendantFont.set("CIDSystemInfo", cidSystemInfo);
                  return this.xref.getNewPersistentRef(descendantFont);
                }
                get baseFontRef() {
                  const baseFont = new _primitives.Dict(this.xref);
                  baseFont.set("BaseFont", this.fontName);
                  baseFont.set("Type", _primitives.Name.get("Font"));
                  baseFont.set("Subtype", _primitives.Name.get("Type0"));
                  baseFont.set("Encoding", _primitives.Name.get("Identity-H"));
                  baseFont.set("DescendantFonts", [this.descendantFontRef]);
                  baseFont.set("ToUnicode", this.toUnicodeRef);
                  return this.xref.getNewPersistentRef(baseFont);
                }
                get resources() {
                  const resources = new _primitives.Dict(this.xref);
                  const font = new _primitives.Dict(this.xref);
                  font.set(this.fontName.name, this.baseFontRef);
                  resources.set("Font", font);
                  return resources;
                }
                _createContext() {
                  this.widths = /* @__PURE__ */ new Map();
                  this.ctxMeasure.font = `1000px ${this.fontFamily}`;
                  return this.ctxMeasure;
                }
                createFontResources(text) {
                  const ctx = this._createContext();
                  for (const line of text.split(/\r\n?|\n/)) {
                    for (const char of line.split("")) {
                      const code = char.charCodeAt(0);
                      if (this.widths.has(code)) {
                        continue;
                      }
                      const metrics = ctx.measureText(char);
                      const width = Math.ceil(metrics.width);
                      this.widths.set(code, width);
                      this.firstChar = Math.min(code, this.firstChar);
                      this.lastChar = Math.max(code, this.lastChar);
                    }
                  }
                  return this.resources;
                }
                createAppearance(text, rect, rotation, fontSize, bgColor, strokeAlpha) {
                  const ctx = this._createContext();
                  const lines = [];
                  let maxWidth = -Infinity;
                  for (const line of text.split(/\r\n?|\n/)) {
                    lines.push(line);
                    const lineWidth = ctx.measureText(line).width;
                    maxWidth = Math.max(maxWidth, lineWidth);
                    for (const char of line.split("")) {
                      const code = char.charCodeAt(0);
                      let width = this.widths.get(code);
                      if (width === void 0) {
                        const metrics = ctx.measureText(char);
                        width = Math.ceil(metrics.width);
                        this.widths.set(code, width);
                        this.firstChar = Math.min(code, this.firstChar);
                        this.lastChar = Math.max(code, this.lastChar);
                      }
                    }
                  }
                  maxWidth *= fontSize / 1e3;
                  const [x1, y1, x2, y2] = rect;
                  let w = x2 - x1;
                  let h = y2 - y1;
                  if (rotation % 180 !== 0) {
                    [w, h] = [h, w];
                  }
                  let hscale = 1;
                  if (maxWidth > w) {
                    hscale = w / maxWidth;
                  }
                  let vscale = 1;
                  const lineHeight = _util.LINE_FACTOR * fontSize;
                  const lineDescent = _util.LINE_DESCENT_FACTOR * fontSize;
                  const maxHeight = lineHeight * lines.length;
                  if (maxHeight > h) {
                    vscale = h / maxHeight;
                  }
                  const fscale = Math.min(hscale, vscale);
                  const newFontSize = fontSize * fscale;
                  const buffer = ["q", `0 0 ${(0, _core_utils.numberToString)(w)} ${(0, _core_utils.numberToString)(h)} re W n`, `BT`, `1 0 0 1 0 ${(0, _core_utils.numberToString)(h + lineDescent)} Tm 0 Tc ${getPdfColor(bgColor, true)}`, `/${this.fontName.name} ${(0, _core_utils.numberToString)(newFontSize)} Tf`];
                  const {
                    resources
                  } = this;
                  strokeAlpha = typeof strokeAlpha === "number" && strokeAlpha >= 0 && strokeAlpha <= 1 ? strokeAlpha : 1;
                  if (strokeAlpha !== 1) {
                    buffer.push("/R0 gs");
                    const extGState = new _primitives.Dict(this.xref);
                    const r0 = new _primitives.Dict(this.xref);
                    r0.set("ca", strokeAlpha);
                    r0.set("CA", strokeAlpha);
                    r0.set("Type", _primitives.Name.get("ExtGState"));
                    extGState.set("R0", r0);
                    resources.set("ExtGState", extGState);
                  }
                  const vShift = (0, _core_utils.numberToString)(lineHeight);
                  for (const line of lines) {
                    buffer.push(`0 -${vShift} Td <${(0, _core_utils.stringToUTF16HexString)(line)}> Tj`);
                  }
                  buffer.push("ET", "Q");
                  const appearance = buffer.join("\n");
                  const appearanceStreamDict = new _primitives.Dict(this.xref);
                  appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
                  appearanceStreamDict.set("Type", _primitives.Name.get("XObject"));
                  appearanceStreamDict.set("BBox", [0, 0, w, h]);
                  appearanceStreamDict.set("Length", appearance.length);
                  appearanceStreamDict.set("Resources", resources);
                  if (rotation) {
                    const matrix = (0, _core_utils.getRotationMatrix)(rotation, w, h);
                    appearanceStreamDict.set("Matrix", matrix);
                  }
                  const ap = new _stream.StringStream(appearance);
                  ap.dict = appearanceStreamDict;
                  return ap;
                }
              }
              exports2.FakeUnicodeFont = FakeUnicodeFont;
            },
            /* 12 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var _toRgb, toRgb_fn, _toRgb2, toRgb_fn2, _BRADFORD_SCALE_MATRIX, _BRADFORD_SCALE_INVERSE_MATRIX, _SRGB_D65_XYZ_TO_RGB_MATRIX, _FLAT_WHITEPOINT_MATRIX, _tempNormalizeMatrix, _tempConvertMatrix1, _tempConvertMatrix2, _DECODE_L_CONSTANT, _matrixProduct, matrixProduct_fn, _toFlat, toFlat_fn, _toD65, toD65_fn, _sRGBTransferFunction, sRGBTransferFunction_fn, _adjustToRange, adjustToRange_fn, _decodeL, decodeL_fn, _compensateBlackPoint, compensateBlackPoint_fn, _normalizeWhitePointToFlat, normalizeWhitePointToFlat_fn, _normalizeWhitePointToD65, normalizeWhitePointToD65_fn, _toRgb3, toRgb_fn3, _fn_g, fn_g_fn, _decode, decode_fn, _toRgb4, toRgb_fn4;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ColorSpace = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(4);
              var _base_stream = __w_pdfjs_require__2(5);
              var _core_utils = __w_pdfjs_require__2(3);
              function resizeRgbImage(src, dest, w1, h1, w2, h2, alpha01) {
                const COMPONENTS = 3;
                alpha01 = alpha01 !== 1 ? 0 : alpha01;
                const xRatio = w1 / w2;
                const yRatio = h1 / h2;
                let newIndex = 0, oldIndex;
                const xScaled = new Uint16Array(w2);
                const w1Scanline = w1 * COMPONENTS;
                for (let i = 0; i < w2; i++) {
                  xScaled[i] = Math.floor(i * xRatio) * COMPONENTS;
                }
                for (let i = 0; i < h2; i++) {
                  const py = Math.floor(i * yRatio) * w1Scanline;
                  for (let j = 0; j < w2; j++) {
                    oldIndex = py + xScaled[j];
                    dest[newIndex++] = src[oldIndex++];
                    dest[newIndex++] = src[oldIndex++];
                    dest[newIndex++] = src[oldIndex++];
                    newIndex += alpha01;
                  }
                }
              }
              class ColorSpace {
                constructor(name, numComps) {
                  if (this.constructor === ColorSpace) {
                    (0, _util.unreachable)("Cannot initialize ColorSpace.");
                  }
                  this.name = name;
                  this.numComps = numComps;
                }
                getRgb(src, srcOffset) {
                  const rgb = new Uint8ClampedArray(3);
                  this.getRgbItem(src, srcOffset, rgb, 0);
                  return rgb;
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  (0, _util.unreachable)("Should not call ColorSpace.getRgbItem");
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  (0, _util.unreachable)("Should not call ColorSpace.getRgbBuffer");
                }
                getOutputLength(inputLength, alpha01) {
                  (0, _util.unreachable)("Should not call ColorSpace.getOutputLength");
                }
                isPassthrough(bits) {
                  return false;
                }
                isDefaultDecode(decodeMap, bpc) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                }
                fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) {
                  const count = originalWidth * originalHeight;
                  let rgbBuf = null;
                  const numComponentColors = 1 << bpc;
                  const needsResizing = originalHeight !== height || originalWidth !== width;
                  if (this.isPassthrough(bpc)) {
                    rgbBuf = comps;
                  } else if (this.numComps === 1 && count > numComponentColors && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
                    const allColors = bpc <= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors);
                    for (let i = 0; i < numComponentColors; i++) {
                      allColors[i] = i;
                    }
                    const colorMap = new Uint8ClampedArray(numComponentColors * 3);
                    this.getRgbBuffer(allColors, 0, numComponentColors, colorMap, 0, bpc, 0);
                    if (!needsResizing) {
                      let destPos = 0;
                      for (let i = 0; i < count; ++i) {
                        const key = comps[i] * 3;
                        dest[destPos++] = colorMap[key];
                        dest[destPos++] = colorMap[key + 1];
                        dest[destPos++] = colorMap[key + 2];
                        destPos += alpha01;
                      }
                    } else {
                      rgbBuf = new Uint8Array(count * 3);
                      let rgbPos = 0;
                      for (let i = 0; i < count; ++i) {
                        const key = comps[i] * 3;
                        rgbBuf[rgbPos++] = colorMap[key];
                        rgbBuf[rgbPos++] = colorMap[key + 1];
                        rgbBuf[rgbPos++] = colorMap[key + 2];
                      }
                    }
                  } else if (!needsResizing) {
                    this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01);
                  } else {
                    rgbBuf = new Uint8ClampedArray(count * 3);
                    this.getRgbBuffer(comps, 0, count, rgbBuf, 0, bpc, 0);
                  }
                  if (rgbBuf) {
                    if (needsResizing) {
                      resizeRgbImage(rgbBuf, dest, originalWidth, originalHeight, width, height, alpha01);
                    } else {
                      let destPos = 0, rgbPos = 0;
                      for (let i = 0, ii = width * actualHeight; i < ii; i++) {
                        dest[destPos++] = rgbBuf[rgbPos++];
                        dest[destPos++] = rgbBuf[rgbPos++];
                        dest[destPos++] = rgbBuf[rgbPos++];
                        destPos += alpha01;
                      }
                    }
                  }
                }
                get usesZeroToOneRange() {
                  return (0, _util.shadow)(this, "usesZeroToOneRange", true);
                }
                static _cache(cacheKey, xref, localColorSpaceCache, parsedColorSpace) {
                  if (!localColorSpaceCache) {
                    throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
                  }
                  if (!parsedColorSpace) {
                    throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
                  }
                  let csName, csRef;
                  if (cacheKey instanceof _primitives.Ref) {
                    csRef = cacheKey;
                    cacheKey = xref.fetch(cacheKey);
                  }
                  if (cacheKey instanceof _primitives.Name) {
                    csName = cacheKey.name;
                  }
                  if (csName || csRef) {
                    localColorSpaceCache.set(csName, csRef, parsedColorSpace);
                  }
                }
                static getCached(cacheKey, xref, localColorSpaceCache) {
                  if (!localColorSpaceCache) {
                    throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
                  }
                  if (cacheKey instanceof _primitives.Ref) {
                    const localColorSpace = localColorSpaceCache.getByRef(cacheKey);
                    if (localColorSpace) {
                      return localColorSpace;
                    }
                    try {
                      cacheKey = xref.fetch(cacheKey);
                    } catch (ex) {
                      if (ex instanceof _core_utils.MissingDataException) {
                        throw ex;
                      }
                    }
                  }
                  if (cacheKey instanceof _primitives.Name) {
                    const localColorSpace = localColorSpaceCache.getByName(cacheKey.name);
                    if (localColorSpace) {
                      return localColorSpace;
                    }
                  }
                  return null;
                }
                static async parseAsync({
                  cs,
                  xref,
                  resources = null,
                  pdfFunctionFactory,
                  localColorSpaceCache
                }) {
                  const parsedColorSpace = this._parse(cs, xref, resources, pdfFunctionFactory);
                  this._cache(cs, xref, localColorSpaceCache, parsedColorSpace);
                  return parsedColorSpace;
                }
                static parse({
                  cs,
                  xref,
                  resources = null,
                  pdfFunctionFactory,
                  localColorSpaceCache
                }) {
                  const cachedColorSpace = this.getCached(cs, xref, localColorSpaceCache);
                  if (cachedColorSpace) {
                    return cachedColorSpace;
                  }
                  const parsedColorSpace = this._parse(cs, xref, resources, pdfFunctionFactory);
                  this._cache(cs, xref, localColorSpaceCache, parsedColorSpace);
                  return parsedColorSpace;
                }
                static _parse(cs, xref, resources = null, pdfFunctionFactory) {
                  cs = xref.fetchIfRef(cs);
                  if (cs instanceof _primitives.Name) {
                    switch (cs.name) {
                      case "G":
                      case "DeviceGray":
                        return this.singletons.gray;
                      case "RGB":
                      case "DeviceRGB":
                        return this.singletons.rgb;
                      case "CMYK":
                      case "DeviceCMYK":
                        return this.singletons.cmyk;
                      case "Pattern":
                        return new PatternCS(null);
                      default:
                        if (resources instanceof _primitives.Dict) {
                          const colorSpaces = resources.get("ColorSpace");
                          if (colorSpaces instanceof _primitives.Dict) {
                            const resourcesCS = colorSpaces.get(cs.name);
                            if (resourcesCS) {
                              if (resourcesCS instanceof _primitives.Name) {
                                return this._parse(resourcesCS, xref, resources, pdfFunctionFactory);
                              }
                              cs = resourcesCS;
                              break;
                            }
                          }
                        }
                        throw new _util.FormatError(`Unrecognized ColorSpace: ${cs.name}`);
                    }
                  }
                  if (Array.isArray(cs)) {
                    const mode = xref.fetchIfRef(cs[0]).name;
                    let params, numComps, baseCS, whitePoint, blackPoint, gamma;
                    switch (mode) {
                      case "G":
                      case "DeviceGray":
                        return this.singletons.gray;
                      case "RGB":
                      case "DeviceRGB":
                        return this.singletons.rgb;
                      case "CMYK":
                      case "DeviceCMYK":
                        return this.singletons.cmyk;
                      case "CalGray":
                        params = xref.fetchIfRef(cs[1]);
                        whitePoint = params.getArray("WhitePoint");
                        blackPoint = params.getArray("BlackPoint");
                        gamma = params.get("Gamma");
                        return new CalGrayCS(whitePoint, blackPoint, gamma);
                      case "CalRGB":
                        params = xref.fetchIfRef(cs[1]);
                        whitePoint = params.getArray("WhitePoint");
                        blackPoint = params.getArray("BlackPoint");
                        gamma = params.getArray("Gamma");
                        const matrix = params.getArray("Matrix");
                        return new CalRGBCS(whitePoint, blackPoint, gamma, matrix);
                      case "ICCBased":
                        const stream = xref.fetchIfRef(cs[1]);
                        const dict = stream.dict;
                        numComps = dict.get("N");
                        const alt = dict.get("Alternate");
                        if (alt) {
                          const altCS = this._parse(alt, xref, resources, pdfFunctionFactory);
                          if (altCS.numComps === numComps) {
                            return altCS;
                          }
                          (0, _util.warn)("ICCBased color space: Ignoring incorrect /Alternate entry.");
                        }
                        if (numComps === 1) {
                          return this.singletons.gray;
                        } else if (numComps === 3) {
                          return this.singletons.rgb;
                        } else if (numComps === 4) {
                          return this.singletons.cmyk;
                        }
                        break;
                      case "Pattern":
                        baseCS = cs[1] || null;
                        if (baseCS) {
                          baseCS = this._parse(baseCS, xref, resources, pdfFunctionFactory);
                        }
                        return new PatternCS(baseCS);
                      case "I":
                      case "Indexed":
                        baseCS = this._parse(cs[1], xref, resources, pdfFunctionFactory);
                        const hiVal = xref.fetchIfRef(cs[2]) + 1;
                        const lookup = xref.fetchIfRef(cs[3]);
                        return new IndexedCS(baseCS, hiVal, lookup);
                      case "Separation":
                      case "DeviceN":
                        const name = xref.fetchIfRef(cs[1]);
                        numComps = Array.isArray(name) ? name.length : 1;
                        baseCS = this._parse(cs[2], xref, resources, pdfFunctionFactory);
                        const tintFn = pdfFunctionFactory.create(cs[3]);
                        return new AlternateCS(numComps, baseCS, tintFn);
                      case "Lab":
                        params = xref.fetchIfRef(cs[1]);
                        whitePoint = params.getArray("WhitePoint");
                        blackPoint = params.getArray("BlackPoint");
                        const range = params.getArray("Range");
                        return new LabCS(whitePoint, blackPoint, range);
                      default:
                        throw new _util.FormatError(`Unimplemented ColorSpace object: ${mode}`);
                    }
                  }
                  throw new _util.FormatError(`Unrecognized ColorSpace object: ${cs}`);
                }
                static isDefaultDecode(decode, numComps) {
                  if (!Array.isArray(decode)) {
                    return true;
                  }
                  if (numComps * 2 !== decode.length) {
                    (0, _util.warn)("The decode map is not the correct length");
                    return true;
                  }
                  for (let i = 0, ii = decode.length; i < ii; i += 2) {
                    if (decode[i] !== 0 || decode[i + 1] !== 1) {
                      return false;
                    }
                  }
                  return true;
                }
                static get singletons() {
                  return (0, _util.shadow)(this, "singletons", {
                    get gray() {
                      return (0, _util.shadow)(this, "gray", new DeviceGrayCS());
                    },
                    get rgb() {
                      return (0, _util.shadow)(this, "rgb", new DeviceRgbCS());
                    },
                    get cmyk() {
                      return (0, _util.shadow)(this, "cmyk", new DeviceCmykCS());
                    }
                  });
                }
              }
              exports2.ColorSpace = ColorSpace;
              class AlternateCS extends ColorSpace {
                constructor(numComps, base, tintFn) {
                  super("Alternate", numComps);
                  this.base = base;
                  this.tintFn = tintFn;
                  this.tmpBuf = new Float32Array(base.numComps);
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  const tmpBuf = this.tmpBuf;
                  this.tintFn(src, srcOffset, tmpBuf, 0);
                  this.base.getRgbItem(tmpBuf, 0, dest, destOffset);
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  const tintFn = this.tintFn;
                  const base = this.base;
                  const scale = 1 / ((1 << bits) - 1);
                  const baseNumComps = base.numComps;
                  const usesZeroToOneRange = base.usesZeroToOneRange;
                  const isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) && alpha01 === 0;
                  let pos = isPassthrough ? destOffset : 0;
                  const baseBuf = isPassthrough ? dest : new Uint8ClampedArray(baseNumComps * count);
                  const numComps = this.numComps;
                  const scaled = new Float32Array(numComps);
                  const tinted = new Float32Array(baseNumComps);
                  let i, j;
                  for (i = 0; i < count; i++) {
                    for (j = 0; j < numComps; j++) {
                      scaled[j] = src[srcOffset++] * scale;
                    }
                    tintFn(scaled, 0, tinted, 0);
                    if (usesZeroToOneRange) {
                      for (j = 0; j < baseNumComps; j++) {
                        baseBuf[pos++] = tinted[j] * 255;
                      }
                    } else {
                      base.getRgbItem(tinted, 0, baseBuf, pos);
                      pos += baseNumComps;
                    }
                  }
                  if (!isPassthrough) {
                    base.getRgbBuffer(baseBuf, 0, count, dest, destOffset, 8, alpha01);
                  }
                }
                getOutputLength(inputLength, alpha01) {
                  return this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01);
                }
              }
              class PatternCS extends ColorSpace {
                constructor(baseCS) {
                  super("Pattern", null);
                  this.base = baseCS;
                }
                isDefaultDecode(decodeMap, bpc) {
                  (0, _util.unreachable)("Should not call PatternCS.isDefaultDecode");
                }
              }
              class IndexedCS extends ColorSpace {
                constructor(base, highVal, lookup) {
                  super("Indexed", 1);
                  this.base = base;
                  this.highVal = highVal;
                  const length = base.numComps * highVal;
                  this.lookup = new Uint8Array(length);
                  if (lookup instanceof _base_stream.BaseStream) {
                    const bytes = lookup.getBytes(length);
                    this.lookup.set(bytes);
                  } else if (typeof lookup === "string") {
                    for (let i = 0; i < length; ++i) {
                      this.lookup[i] = lookup.charCodeAt(i) & 255;
                    }
                  } else {
                    throw new _util.FormatError(`IndexedCS - unrecognized lookup table: ${lookup}`);
                  }
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  const numComps = this.base.numComps;
                  const start = src[srcOffset] * numComps;
                  this.base.getRgbBuffer(this.lookup, start, 1, dest, destOffset, 8, 0);
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  const base = this.base;
                  const numComps = base.numComps;
                  const outputDelta = base.getOutputLength(numComps, alpha01);
                  const lookup = this.lookup;
                  for (let i = 0; i < count; ++i) {
                    const lookupPos = src[srcOffset++] * numComps;
                    base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);
                    destOffset += outputDelta;
                  }
                }
                getOutputLength(inputLength, alpha01) {
                  return this.base.getOutputLength(inputLength * this.base.numComps, alpha01);
                }
                isDefaultDecode(decodeMap, bpc) {
                  if (!Array.isArray(decodeMap)) {
                    return true;
                  }
                  if (decodeMap.length !== 2) {
                    (0, _util.warn)("Decode map length is not correct");
                    return true;
                  }
                  if (!Number.isInteger(bpc) || bpc < 1) {
                    (0, _util.warn)("Bits per component is not correct");
                    return true;
                  }
                  return decodeMap[0] === 0 && decodeMap[1] === (1 << bpc) - 1;
                }
              }
              class DeviceGrayCS extends ColorSpace {
                constructor() {
                  super("DeviceGray", 1);
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  const c = src[srcOffset] * 255;
                  dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c;
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  const scale = 255 / ((1 << bits) - 1);
                  let j = srcOffset, q = destOffset;
                  for (let i = 0; i < count; ++i) {
                    const c = scale * src[j++];
                    dest[q++] = c;
                    dest[q++] = c;
                    dest[q++] = c;
                    q += alpha01;
                  }
                }
                getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01);
                }
              }
              class DeviceRgbCS extends ColorSpace {
                constructor() {
                  super("DeviceRGB", 3);
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  dest[destOffset] = src[srcOffset] * 255;
                  dest[destOffset + 1] = src[srcOffset + 1] * 255;
                  dest[destOffset + 2] = src[srcOffset + 2] * 255;
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  if (bits === 8 && alpha01 === 0) {
                    dest.set(src.subarray(srcOffset, srcOffset + count * 3), destOffset);
                    return;
                  }
                  const scale = 255 / ((1 << bits) - 1);
                  let j = srcOffset, q = destOffset;
                  for (let i = 0; i < count; ++i) {
                    dest[q++] = scale * src[j++];
                    dest[q++] = scale * src[j++];
                    dest[q++] = scale * src[j++];
                    q += alpha01;
                  }
                }
                getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01) / 3 | 0;
                }
                isPassthrough(bits) {
                  return bits === 8;
                }
              }
              class DeviceCmykCS extends ColorSpace {
                constructor() {
                  super("DeviceCMYK", 4);
                  __privateAdd(this, _toRgb);
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  __privateMethod(this, _toRgb, toRgb_fn).call(this, src, srcOffset, 1, dest, destOffset);
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  const scale = 1 / ((1 << bits) - 1);
                  for (let i = 0; i < count; i++) {
                    __privateMethod(this, _toRgb, toRgb_fn).call(this, src, srcOffset, scale, dest, destOffset);
                    srcOffset += 4;
                    destOffset += 3 + alpha01;
                  }
                }
                getOutputLength(inputLength, alpha01) {
                  return inputLength / 4 * (3 + alpha01) | 0;
                }
              }
              _toRgb = new WeakSet();
              toRgb_fn = function(src, srcOffset, srcScale, dest, destOffset) {
                const c = src[srcOffset] * srcScale;
                const m = src[srcOffset + 1] * srcScale;
                const y = src[srcOffset + 2] * srcScale;
                const k = src[srcOffset + 3] * srcScale;
                dest[destOffset] = 255 + c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747);
                dest[destOffset + 1] = 255 + c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) + k * (-20.737325471181034 * k - 187.80453709719578);
                dest[destOffset + 2] = 255 + c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505) + k * (-22.33816807309886 * k - 180.12613974708367);
              };
              class CalGrayCS extends ColorSpace {
                constructor(whitePoint, blackPoint, gamma) {
                  super("CalGray", 1);
                  __privateAdd(this, _toRgb2);
                  if (!whitePoint) {
                    throw new _util.FormatError("WhitePoint missing - required for color space CalGray");
                  }
                  [this.XW, this.YW, this.ZW] = whitePoint;
                  [this.XB, this.YB, this.ZB] = blackPoint || [0, 0, 0];
                  this.G = gamma || 1;
                  if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
                    throw new _util.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
                  }
                  if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
                    (0, _util.info)(`Invalid BlackPoint for ${this.name}, falling back to default.`);
                    this.XB = this.YB = this.ZB = 0;
                  }
                  if (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) {
                    (0, _util.warn)(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`);
                  }
                  if (this.G < 1) {
                    (0, _util.info)(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`);
                    this.G = 1;
                  }
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  __privateMethod(this, _toRgb2, toRgb_fn2).call(this, src, srcOffset, dest, destOffset, 1);
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  const scale = 1 / ((1 << bits) - 1);
                  for (let i = 0; i < count; ++i) {
                    __privateMethod(this, _toRgb2, toRgb_fn2).call(this, src, srcOffset, dest, destOffset, scale);
                    srcOffset += 1;
                    destOffset += 3 + alpha01;
                  }
                }
                getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01);
                }
              }
              _toRgb2 = new WeakSet();
              toRgb_fn2 = function(src, srcOffset, dest, destOffset, scale) {
                const A = src[srcOffset] * scale;
                const AG = A ** this.G;
                const L = this.YW * AG;
                const val = Math.max(295.8 * L ** 0.3333333333333333 - 40.8, 0);
                dest[destOffset] = val;
                dest[destOffset + 1] = val;
                dest[destOffset + 2] = val;
              };
              const _CalRGBCS = class _CalRGBCS extends ColorSpace {
                constructor(whitePoint, blackPoint, gamma, matrix) {
                  super("CalRGB", 3);
                  __privateAdd(this, _matrixProduct);
                  __privateAdd(this, _toFlat);
                  __privateAdd(this, _toD65);
                  __privateAdd(this, _sRGBTransferFunction);
                  __privateAdd(this, _adjustToRange);
                  __privateAdd(this, _decodeL);
                  __privateAdd(this, _compensateBlackPoint);
                  __privateAdd(this, _normalizeWhitePointToFlat);
                  __privateAdd(this, _normalizeWhitePointToD65);
                  __privateAdd(this, _toRgb3);
                  if (!whitePoint) {
                    throw new _util.FormatError("WhitePoint missing - required for color space CalRGB");
                  }
                  const [XW, YW, ZW] = this.whitePoint = whitePoint;
                  const [XB, YB, ZB] = this.blackPoint = blackPoint || new Float32Array(3);
                  [this.GR, this.GG, this.GB] = gamma || new Float32Array([1, 1, 1]);
                  [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = matrix || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                  if (XW < 0 || ZW < 0 || YW !== 1) {
                    throw new _util.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
                  }
                  if (XB < 0 || YB < 0 || ZB < 0) {
                    (0, _util.info)(`Invalid BlackPoint for ${this.name} [${XB}, ${YB}, ${ZB}], falling back to default.`);
                    this.blackPoint = new Float32Array(3);
                  }
                  if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
                    (0, _util.info)(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`);
                    this.GR = this.GG = this.GB = 1;
                  }
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  __privateMethod(this, _toRgb3, toRgb_fn3).call(this, src, srcOffset, dest, destOffset, 1);
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  const scale = 1 / ((1 << bits) - 1);
                  for (let i = 0; i < count; ++i) {
                    __privateMethod(this, _toRgb3, toRgb_fn3).call(this, src, srcOffset, dest, destOffset, scale);
                    srcOffset += 3;
                    destOffset += 3 + alpha01;
                  }
                }
                getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01) / 3 | 0;
                }
              };
              _BRADFORD_SCALE_MATRIX = new WeakMap();
              _BRADFORD_SCALE_INVERSE_MATRIX = new WeakMap();
              _SRGB_D65_XYZ_TO_RGB_MATRIX = new WeakMap();
              _FLAT_WHITEPOINT_MATRIX = new WeakMap();
              _tempNormalizeMatrix = new WeakMap();
              _tempConvertMatrix1 = new WeakMap();
              _tempConvertMatrix2 = new WeakMap();
              _DECODE_L_CONSTANT = new WeakMap();
              _matrixProduct = new WeakSet();
              matrixProduct_fn = function(a, b, result) {
                result[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
                result[1] = a[3] * b[0] + a[4] * b[1] + a[5] * b[2];
                result[2] = a[6] * b[0] + a[7] * b[1] + a[8] * b[2];
              };
              _toFlat = new WeakSet();
              toFlat_fn = function(sourceWhitePoint, LMS, result) {
                result[0] = LMS[0] * 1 / sourceWhitePoint[0];
                result[1] = LMS[1] * 1 / sourceWhitePoint[1];
                result[2] = LMS[2] * 1 / sourceWhitePoint[2];
              };
              _toD65 = new WeakSet();
              toD65_fn = function(sourceWhitePoint, LMS, result) {
                const D65X = 0.95047;
                const D65Y = 1;
                const D65Z = 1.08883;
                result[0] = LMS[0] * D65X / sourceWhitePoint[0];
                result[1] = LMS[1] * D65Y / sourceWhitePoint[1];
                result[2] = LMS[2] * D65Z / sourceWhitePoint[2];
              };
              _sRGBTransferFunction = new WeakSet();
              sRGBTransferFunction_fn = function(color) {
                if (color <= 31308e-7) {
                  return __privateMethod(this, _adjustToRange, adjustToRange_fn).call(this, 0, 1, 12.92 * color);
                }
                if (color >= 0.99554525) {
                  return 1;
                }
                return __privateMethod(this, _adjustToRange, adjustToRange_fn).call(this, 0, 1, (1 + 0.055) * color ** (1 / 2.4) - 0.055);
              };
              _adjustToRange = new WeakSet();
              adjustToRange_fn = function(min, max, value) {
                return Math.max(min, Math.min(max, value));
              };
              _decodeL = new WeakSet();
              decodeL_fn = function(L) {
                if (L < 0) {
                  return -__privateMethod(this, _decodeL, decodeL_fn).call(this, -L);
                }
                if (L > 8) {
                  return ((L + 16) / 116) ** 3;
                }
                return L * __privateGet(_CalRGBCS, _DECODE_L_CONSTANT);
              };
              _compensateBlackPoint = new WeakSet();
              compensateBlackPoint_fn = function(sourceBlackPoint, XYZ_Flat, result) {
                if (sourceBlackPoint[0] === 0 && sourceBlackPoint[1] === 0 && sourceBlackPoint[2] === 0) {
                  result[0] = XYZ_Flat[0];
                  result[1] = XYZ_Flat[1];
                  result[2] = XYZ_Flat[2];
                  return;
                }
                const zeroDecodeL = __privateMethod(this, _decodeL, decodeL_fn).call(this, 0);
                const X_DST = zeroDecodeL;
                const X_SRC = __privateMethod(this, _decodeL, decodeL_fn).call(this, sourceBlackPoint[0]);
                const Y_DST = zeroDecodeL;
                const Y_SRC = __privateMethod(this, _decodeL, decodeL_fn).call(this, sourceBlackPoint[1]);
                const Z_DST = zeroDecodeL;
                const Z_SRC = __privateMethod(this, _decodeL, decodeL_fn).call(this, sourceBlackPoint[2]);
                const X_Scale = (1 - X_DST) / (1 - X_SRC);
                const X_Offset = 1 - X_Scale;
                const Y_Scale = (1 - Y_DST) / (1 - Y_SRC);
                const Y_Offset = 1 - Y_Scale;
                const Z_Scale = (1 - Z_DST) / (1 - Z_SRC);
                const Z_Offset = 1 - Z_Scale;
                result[0] = XYZ_Flat[0] * X_Scale + X_Offset;
                result[1] = XYZ_Flat[1] * Y_Scale + Y_Offset;
                result[2] = XYZ_Flat[2] * Z_Scale + Z_Offset;
              };
              _normalizeWhitePointToFlat = new WeakSet();
              normalizeWhitePointToFlat_fn = function(sourceWhitePoint, XYZ_In, result) {
                if (sourceWhitePoint[0] === 1 && sourceWhitePoint[2] === 1) {
                  result[0] = XYZ_In[0];
                  result[1] = XYZ_In[1];
                  result[2] = XYZ_In[2];
                  return;
                }
                const LMS = result;
                __privateMethod(this, _matrixProduct, matrixProduct_fn).call(this, __privateGet(_CalRGBCS, _BRADFORD_SCALE_MATRIX), XYZ_In, LMS);
                const LMS_Flat = __privateGet(_CalRGBCS, _tempNormalizeMatrix);
                __privateMethod(this, _toFlat, toFlat_fn).call(this, sourceWhitePoint, LMS, LMS_Flat);
                __privateMethod(this, _matrixProduct, matrixProduct_fn).call(this, __privateGet(_CalRGBCS, _BRADFORD_SCALE_INVERSE_MATRIX), LMS_Flat, result);
              };
              _normalizeWhitePointToD65 = new WeakSet();
              normalizeWhitePointToD65_fn = function(sourceWhitePoint, XYZ_In, result) {
                const LMS = result;
                __privateMethod(this, _matrixProduct, matrixProduct_fn).call(this, __privateGet(_CalRGBCS, _BRADFORD_SCALE_MATRIX), XYZ_In, LMS);
                const LMS_D65 = __privateGet(_CalRGBCS, _tempNormalizeMatrix);
                __privateMethod(this, _toD65, toD65_fn).call(this, sourceWhitePoint, LMS, LMS_D65);
                __privateMethod(this, _matrixProduct, matrixProduct_fn).call(this, __privateGet(_CalRGBCS, _BRADFORD_SCALE_INVERSE_MATRIX), LMS_D65, result);
              };
              _toRgb3 = new WeakSet();
              toRgb_fn3 = function(src, srcOffset, dest, destOffset, scale) {
                const A = __privateMethod(this, _adjustToRange, adjustToRange_fn).call(this, 0, 1, src[srcOffset] * scale);
                const B = __privateMethod(this, _adjustToRange, adjustToRange_fn).call(this, 0, 1, src[srcOffset + 1] * scale);
                const C = __privateMethod(this, _adjustToRange, adjustToRange_fn).call(this, 0, 1, src[srcOffset + 2] * scale);
                const AGR = A === 1 ? 1 : A ** this.GR;
                const BGG = B === 1 ? 1 : B ** this.GG;
                const CGB = C === 1 ? 1 : C ** this.GB;
                const X = this.MXA * AGR + this.MXB * BGG + this.MXC * CGB;
                const Y = this.MYA * AGR + this.MYB * BGG + this.MYC * CGB;
                const Z = this.MZA * AGR + this.MZB * BGG + this.MZC * CGB;
                const XYZ = __privateGet(_CalRGBCS, _tempConvertMatrix1);
                XYZ[0] = X;
                XYZ[1] = Y;
                XYZ[2] = Z;
                const XYZ_Flat = __privateGet(_CalRGBCS, _tempConvertMatrix2);
                __privateMethod(this, _normalizeWhitePointToFlat, normalizeWhitePointToFlat_fn).call(this, this.whitePoint, XYZ, XYZ_Flat);
                const XYZ_Black = __privateGet(_CalRGBCS, _tempConvertMatrix1);
                __privateMethod(this, _compensateBlackPoint, compensateBlackPoint_fn).call(this, this.blackPoint, XYZ_Flat, XYZ_Black);
                const XYZ_D65 = __privateGet(_CalRGBCS, _tempConvertMatrix2);
                __privateMethod(this, _normalizeWhitePointToD65, normalizeWhitePointToD65_fn).call(this, __privateGet(_CalRGBCS, _FLAT_WHITEPOINT_MATRIX), XYZ_Black, XYZ_D65);
                const SRGB = __privateGet(_CalRGBCS, _tempConvertMatrix1);
                __privateMethod(this, _matrixProduct, matrixProduct_fn).call(this, __privateGet(_CalRGBCS, _SRGB_D65_XYZ_TO_RGB_MATRIX), XYZ_D65, SRGB);
                dest[destOffset] = __privateMethod(this, _sRGBTransferFunction, sRGBTransferFunction_fn).call(this, SRGB[0]) * 255;
                dest[destOffset + 1] = __privateMethod(this, _sRGBTransferFunction, sRGBTransferFunction_fn).call(this, SRGB[1]) * 255;
                dest[destOffset + 2] = __privateMethod(this, _sRGBTransferFunction, sRGBTransferFunction_fn).call(this, SRGB[2]) * 255;
              };
              __privateAdd(_CalRGBCS, _BRADFORD_SCALE_MATRIX, new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]));
              __privateAdd(_CalRGBCS, _BRADFORD_SCALE_INVERSE_MATRIX, new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]));
              __privateAdd(_CalRGBCS, _SRGB_D65_XYZ_TO_RGB_MATRIX, new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]));
              __privateAdd(_CalRGBCS, _FLAT_WHITEPOINT_MATRIX, new Float32Array([1, 1, 1]));
              __privateAdd(_CalRGBCS, _tempNormalizeMatrix, new Float32Array(3));
              __privateAdd(_CalRGBCS, _tempConvertMatrix1, new Float32Array(3));
              __privateAdd(_CalRGBCS, _tempConvertMatrix2, new Float32Array(3));
              __privateAdd(_CalRGBCS, _DECODE_L_CONSTANT, ((8 + 16) / 116) ** 3 / 8);
              let CalRGBCS = _CalRGBCS;
              class LabCS extends ColorSpace {
                constructor(whitePoint, blackPoint, range) {
                  super("Lab", 3);
                  __privateAdd(this, _fn_g);
                  __privateAdd(this, _decode);
                  __privateAdd(this, _toRgb4);
                  if (!whitePoint) {
                    throw new _util.FormatError("WhitePoint missing - required for color space Lab");
                  }
                  [this.XW, this.YW, this.ZW] = whitePoint;
                  [this.amin, this.amax, this.bmin, this.bmax] = range || [-100, 100, -100, 100];
                  [this.XB, this.YB, this.ZB] = blackPoint || [0, 0, 0];
                  if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
                    throw new _util.FormatError("Invalid WhitePoint components, no fallback available");
                  }
                  if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
                    (0, _util.info)("Invalid BlackPoint, falling back to default");
                    this.XB = this.YB = this.ZB = 0;
                  }
                  if (this.amin > this.amax || this.bmin > this.bmax) {
                    (0, _util.info)("Invalid Range, falling back to defaults");
                    this.amin = -100;
                    this.amax = 100;
                    this.bmin = -100;
                    this.bmax = 100;
                  }
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  __privateMethod(this, _toRgb4, toRgb_fn4).call(this, src, srcOffset, false, dest, destOffset);
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  const maxVal = (1 << bits) - 1;
                  for (let i = 0; i < count; i++) {
                    __privateMethod(this, _toRgb4, toRgb_fn4).call(this, src, srcOffset, maxVal, dest, destOffset);
                    srcOffset += 3;
                    destOffset += 3 + alpha01;
                  }
                }
                getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01) / 3 | 0;
                }
                isDefaultDecode(decodeMap, bpc) {
                  return true;
                }
                get usesZeroToOneRange() {
                  return (0, _util.shadow)(this, "usesZeroToOneRange", false);
                }
              }
              _fn_g = new WeakSet();
              fn_g_fn = function(x) {
                return x >= 6 / 29 ? x ** 3 : 108 / 841 * (x - 4 / 29);
              };
              _decode = new WeakSet();
              decode_fn = function(value, high1, low2, high2) {
                return low2 + value * (high2 - low2) / high1;
              };
              _toRgb4 = new WeakSet();
              toRgb_fn4 = function(src, srcOffset, maxVal, dest, destOffset) {
                let Ls = src[srcOffset];
                let as = src[srcOffset + 1];
                let bs = src[srcOffset + 2];
                if (maxVal !== false) {
                  Ls = __privateMethod(this, _decode, decode_fn).call(this, Ls, maxVal, 0, 100);
                  as = __privateMethod(this, _decode, decode_fn).call(this, as, maxVal, this.amin, this.amax);
                  bs = __privateMethod(this, _decode, decode_fn).call(this, bs, maxVal, this.bmin, this.bmax);
                }
                if (as > this.amax) {
                  as = this.amax;
                } else if (as < this.amin) {
                  as = this.amin;
                }
                if (bs > this.bmax) {
                  bs = this.bmax;
                } else if (bs < this.bmin) {
                  bs = this.bmin;
                }
                const M = (Ls + 16) / 116;
                const L = M + as / 500;
                const N = M - bs / 200;
                const X = this.XW * __privateMethod(this, _fn_g, fn_g_fn).call(this, L);
                const Y = this.YW * __privateMethod(this, _fn_g, fn_g_fn).call(this, M);
                const Z = this.ZW * __privateMethod(this, _fn_g, fn_g_fn).call(this, N);
                let r, g, b;
                if (this.ZW < 1) {
                  r = X * 3.1339 + Y * -1.617 + Z * -0.4906;
                  g = X * -0.9785 + Y * 1.916 + Z * 0.0333;
                  b = X * 0.072 + Y * -0.229 + Z * 1.4057;
                } else {
                  r = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
                  g = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
                  b = X * 0.0557 + Y * -0.204 + Z * 1.057;
                }
                dest[destOffset] = Math.sqrt(r) * 255;
                dest[destOffset + 1] = Math.sqrt(g) * 255;
                dest[destOffset + 2] = Math.sqrt(b) * 255;
              };
            },
            /* 13 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PartialEvaluator = exports2.EvaluatorPreprocessor = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _cmap = __w_pdfjs_require__2(14);
              var _primitives = __w_pdfjs_require__2(4);
              var _fonts = __w_pdfjs_require__2(34);
              var _encodings = __w_pdfjs_require__2(37);
              var _standard_fonts = __w_pdfjs_require__2(41);
              var _pattern = __w_pdfjs_require__2(50);
              var _xfa_fonts = __w_pdfjs_require__2(51);
              var _to_unicode_map = __w_pdfjs_require__2(42);
              var _function = __w_pdfjs_require__2(57);
              var _parser = __w_pdfjs_require__2(16);
              var _image_utils = __w_pdfjs_require__2(59);
              var _stream = __w_pdfjs_require__2(8);
              var _base_stream = __w_pdfjs_require__2(5);
              var _bidi = __w_pdfjs_require__2(60);
              var _colorspace = __w_pdfjs_require__2(12);
              var _decode_stream = __w_pdfjs_require__2(18);
              var _fonts_utils = __w_pdfjs_require__2(38);
              var _font_substitutions = __w_pdfjs_require__2(61);
              var _glyphlist = __w_pdfjs_require__2(39);
              var _metrics = __w_pdfjs_require__2(45);
              var _unicode = __w_pdfjs_require__2(40);
              var _image_resizer = __w_pdfjs_require__2(62);
              var _murmurhash = __w_pdfjs_require__2(63);
              var _operator_list = __w_pdfjs_require__2(64);
              var _image = __w_pdfjs_require__2(65);
              const DefaultPartialEvaluatorOptions = Object.freeze({
                maxImageSize: -1,
                disableFontFace: false,
                ignoreErrors: false,
                isEvalSupported: true,
                isOffscreenCanvasSupported: false,
                canvasMaxAreaInBytes: -1,
                fontExtraProperties: false,
                useSystemFonts: true,
                cMapUrl: null,
                standardFontDataUrl: null
              });
              const PatternType = {
                TILING: 1,
                SHADING: 2
              };
              const TEXT_CHUNK_BATCH_SIZE = 10;
              const deferred = Promise.resolve();
              function normalizeBlendMode(value, parsingArray = false) {
                if (Array.isArray(value)) {
                  for (const val of value) {
                    const maybeBM = normalizeBlendMode(val, true);
                    if (maybeBM) {
                      return maybeBM;
                    }
                  }
                  (0, _util.warn)(`Unsupported blend mode Array: ${value}`);
                  return "source-over";
                }
                if (!(value instanceof _primitives.Name)) {
                  if (parsingArray) {
                    return null;
                  }
                  return "source-over";
                }
                switch (value.name) {
                  case "Normal":
                  case "Compatible":
                    return "source-over";
                  case "Multiply":
                    return "multiply";
                  case "Screen":
                    return "screen";
                  case "Overlay":
                    return "overlay";
                  case "Darken":
                    return "darken";
                  case "Lighten":
                    return "lighten";
                  case "ColorDodge":
                    return "color-dodge";
                  case "ColorBurn":
                    return "color-burn";
                  case "HardLight":
                    return "hard-light";
                  case "SoftLight":
                    return "soft-light";
                  case "Difference":
                    return "difference";
                  case "Exclusion":
                    return "exclusion";
                  case "Hue":
                    return "hue";
                  case "Saturation":
                    return "saturation";
                  case "Color":
                    return "color";
                  case "Luminosity":
                    return "luminosity";
                }
                if (parsingArray) {
                  return null;
                }
                (0, _util.warn)(`Unsupported blend mode: ${value.name}`);
                return "source-over";
              }
              function incrementCachedImageMaskCount(data) {
                var _a;
                if (data.fn === _util.OPS.paintImageMaskXObject && ((_a = data.args[0]) == null ? void 0 : _a.count) > 0) {
                  data.args[0].count++;
                }
              }
              const _TimeSlotManager = class _TimeSlotManager {
                constructor() {
                  this.reset();
                }
                check() {
                  if (++this.checked < _TimeSlotManager.CHECK_TIME_EVERY) {
                    return false;
                  }
                  this.checked = 0;
                  return this.endTime <= Date.now();
                }
                reset() {
                  this.endTime = Date.now() + _TimeSlotManager.TIME_SLOT_DURATION_MS;
                  this.checked = 0;
                }
              };
              __publicField(_TimeSlotManager, "TIME_SLOT_DURATION_MS", 20);
              __publicField(_TimeSlotManager, "CHECK_TIME_EVERY", 100);
              let TimeSlotManager = _TimeSlotManager;
              class PartialEvaluator {
                constructor({
                  xref,
                  handler,
                  pageIndex,
                  idFactory,
                  fontCache,
                  builtInCMapCache,
                  standardFontDataCache,
                  globalImageCache,
                  systemFontCache,
                  options = null
                }) {
                  this.xref = xref;
                  this.handler = handler;
                  this.pageIndex = pageIndex;
                  this.idFactory = idFactory;
                  this.fontCache = fontCache;
                  this.builtInCMapCache = builtInCMapCache;
                  this.standardFontDataCache = standardFontDataCache;
                  this.globalImageCache = globalImageCache;
                  this.systemFontCache = systemFontCache;
                  this.options = options || DefaultPartialEvaluatorOptions;
                  this.parsingType3Font = false;
                  this._regionalImageCache = new _image_utils.RegionalImageCache();
                  this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
                  _image_resizer.ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);
                }
                get _pdfFunctionFactory() {
                  const pdfFunctionFactory = new _function.PDFFunctionFactory({
                    xref: this.xref,
                    isEvalSupported: this.options.isEvalSupported
                  });
                  return (0, _util.shadow)(this, "_pdfFunctionFactory", pdfFunctionFactory);
                }
                clone(newOptions = null) {
                  const newEvaluator = Object.create(this);
                  newEvaluator.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, newOptions);
                  return newEvaluator;
                }
                hasBlendModes(resources, nonBlendModesSet) {
                  if (!(resources instanceof _primitives.Dict)) {
                    return false;
                  }
                  if (resources.objId && nonBlendModesSet.has(resources.objId)) {
                    return false;
                  }
                  const processed = new _primitives.RefSet(nonBlendModesSet);
                  if (resources.objId) {
                    processed.put(resources.objId);
                  }
                  const nodes = [resources], xref = this.xref;
                  while (nodes.length) {
                    const node = nodes.shift();
                    const graphicStates = node.get("ExtGState");
                    if (graphicStates instanceof _primitives.Dict) {
                      for (let graphicState of graphicStates.getRawValues()) {
                        if (graphicState instanceof _primitives.Ref) {
                          if (processed.has(graphicState)) {
                            continue;
                          }
                          try {
                            graphicState = xref.fetch(graphicState);
                          } catch (ex) {
                            processed.put(graphicState);
                            (0, _util.info)(`hasBlendModes - ignoring ExtGState: "${ex}".`);
                            continue;
                          }
                        }
                        if (!(graphicState instanceof _primitives.Dict)) {
                          continue;
                        }
                        if (graphicState.objId) {
                          processed.put(graphicState.objId);
                        }
                        const bm = graphicState.get("BM");
                        if (bm instanceof _primitives.Name) {
                          if (bm.name !== "Normal") {
                            return true;
                          }
                          continue;
                        }
                        if (bm !== void 0 && Array.isArray(bm)) {
                          for (const element of bm) {
                            if (element instanceof _primitives.Name && element.name !== "Normal") {
                              return true;
                            }
                          }
                        }
                      }
                    }
                    const xObjects = node.get("XObject");
                    if (!(xObjects instanceof _primitives.Dict)) {
                      continue;
                    }
                    for (let xObject of xObjects.getRawValues()) {
                      if (xObject instanceof _primitives.Ref) {
                        if (processed.has(xObject)) {
                          continue;
                        }
                        try {
                          xObject = xref.fetch(xObject);
                        } catch (ex) {
                          processed.put(xObject);
                          (0, _util.info)(`hasBlendModes - ignoring XObject: "${ex}".`);
                          continue;
                        }
                      }
                      if (!(xObject instanceof _base_stream.BaseStream)) {
                        continue;
                      }
                      if (xObject.dict.objId) {
                        processed.put(xObject.dict.objId);
                      }
                      const xResources = xObject.dict.get("Resources");
                      if (!(xResources instanceof _primitives.Dict)) {
                        continue;
                      }
                      if (xResources.objId && processed.has(xResources.objId)) {
                        continue;
                      }
                      nodes.push(xResources);
                      if (xResources.objId) {
                        processed.put(xResources.objId);
                      }
                    }
                  }
                  for (const ref of processed) {
                    nonBlendModesSet.put(ref);
                  }
                  return false;
                }
                async fetchBuiltInCMap(name) {
                  const cachedData = this.builtInCMapCache.get(name);
                  if (cachedData) {
                    return cachedData;
                  }
                  let data;
                  if (this.options.cMapUrl !== null) {
                    const url = `${this.options.cMapUrl}${name}.bcmap`;
                    const response = await fetch(url);
                    if (!response.ok) {
                      throw new Error(`fetchBuiltInCMap: failed to fetch file "${url}" with "${response.statusText}".`);
                    }
                    data = {
                      cMapData: new Uint8Array(await response.arrayBuffer()),
                      compressionType: _util.CMapCompressionType.BINARY
                    };
                  } else {
                    data = await this.handler.sendWithPromise("FetchBuiltInCMap", {
                      name
                    });
                  }
                  if (data.compressionType !== _util.CMapCompressionType.NONE) {
                    this.builtInCMapCache.set(name, data);
                  }
                  return data;
                }
                async fetchStandardFontData(name) {
                  const cachedData = this.standardFontDataCache.get(name);
                  if (cachedData) {
                    return new _stream.Stream(cachedData);
                  }
                  if (this.options.useSystemFonts && name !== "Symbol" && name !== "ZapfDingbats") {
                    return null;
                  }
                  const standardFontNameToFileName = (0, _standard_fonts.getFontNameToFileMap)(), filename = standardFontNameToFileName[name];
                  let data;
                  if (this.options.standardFontDataUrl !== null) {
                    const url = `${this.options.standardFontDataUrl}${filename}`;
                    const response = await fetch(url);
                    if (!response.ok) {
                      (0, _util.warn)(`fetchStandardFontData: failed to fetch file "${url}" with "${response.statusText}".`);
                    } else {
                      data = await response.arrayBuffer();
                    }
                  } else {
                    try {
                      data = await this.handler.sendWithPromise("FetchStandardFontData", {
                        filename
                      });
                    } catch (e) {
                      (0, _util.warn)(`fetchStandardFontData: failed to fetch file "${filename}" with "${e}".`);
                    }
                  }
                  if (!data) {
                    return null;
                  }
                  this.standardFontDataCache.set(name, data);
                  return new _stream.Stream(data);
                }
                async buildFormXObject(resources, xobj, smask, operatorList, task, initialState, localColorSpaceCache) {
                  const dict = xobj.dict;
                  const matrix = dict.getArray("Matrix");
                  let bbox = dict.getArray("BBox");
                  bbox = Array.isArray(bbox) && bbox.length === 4 ? _util.Util.normalizeRect(bbox) : null;
                  let optionalContent, groupOptions;
                  if (dict.has("OC")) {
                    optionalContent = await this.parseMarkedContentProps(dict.get("OC"), resources);
                  }
                  if (optionalContent !== void 0) {
                    operatorList.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);
                  }
                  const group = dict.get("Group");
                  if (group) {
                    groupOptions = {
                      matrix,
                      bbox,
                      smask,
                      isolated: false,
                      knockout: false
                    };
                    const groupSubtype = group.get("S");
                    let colorSpace = null;
                    if ((0, _primitives.isName)(groupSubtype, "Transparency")) {
                      groupOptions.isolated = group.get("I") || false;
                      groupOptions.knockout = group.get("K") || false;
                      if (group.has("CS")) {
                        const cs = group.getRaw("CS");
                        const cachedColorSpace = _colorspace.ColorSpace.getCached(cs, this.xref, localColorSpaceCache);
                        if (cachedColorSpace) {
                          colorSpace = cachedColorSpace;
                        } else {
                          colorSpace = await this.parseColorSpace({
                            cs,
                            resources,
                            localColorSpaceCache
                          });
                        }
                      }
                    }
                    if (smask == null ? void 0 : smask.backdrop) {
                      colorSpace || (colorSpace = _colorspace.ColorSpace.singletons.rgb);
                      smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
                    }
                    operatorList.addOp(_util.OPS.beginGroup, [groupOptions]);
                  }
                  const args = group ? [matrix, null] : [matrix, bbox];
                  operatorList.addOp(_util.OPS.paintFormXObjectBegin, args);
                  return this.getOperatorList({
                    stream: xobj,
                    task,
                    resources: dict.get("Resources") || resources,
                    operatorList,
                    initialState
                  }).then(function() {
                    operatorList.addOp(_util.OPS.paintFormXObjectEnd, []);
                    if (group) {
                      operatorList.addOp(_util.OPS.endGroup, [groupOptions]);
                    }
                    if (optionalContent !== void 0) {
                      operatorList.addOp(_util.OPS.endMarkedContent, []);
                    }
                  });
                }
                _sendImgData(objId, imgData, cacheGlobally = false) {
                  const transfers = imgData ? [imgData.bitmap || imgData.data.buffer] : null;
                  if (this.parsingType3Font || cacheGlobally) {
                    return this.handler.send("commonobj", [objId, "Image", imgData], transfers);
                  }
                  return this.handler.send("obj", [objId, this.pageIndex, "Image", imgData], transfers);
                }
                async buildPaintImageXObject({
                  resources,
                  image,
                  isInline = false,
                  operatorList,
                  cacheKey,
                  localImageCache,
                  localColorSpaceCache
                }) {
                  const dict = image.dict;
                  const imageRef = dict.objId;
                  const w = dict.get("W", "Width");
                  const h = dict.get("H", "Height");
                  if (!(w && typeof w === "number") || !(h && typeof h === "number")) {
                    (0, _util.warn)("Image dimensions are missing, or not numbers.");
                    return;
                  }
                  const maxImageSize = this.options.maxImageSize;
                  if (maxImageSize !== -1 && w * h > maxImageSize) {
                    const msg = "Image exceeded maximum allowed size and was removed.";
                    if (this.options.ignoreErrors) {
                      (0, _util.warn)(msg);
                      return;
                    }
                    throw new Error(msg);
                  }
                  let optionalContent;
                  if (dict.has("OC")) {
                    optionalContent = await this.parseMarkedContentProps(dict.get("OC"), resources);
                  }
                  const imageMask = dict.get("IM", "ImageMask") || false;
                  let imgData, args;
                  if (imageMask) {
                    const interpolate = dict.get("I", "Interpolate");
                    const bitStrideLength = w + 7 >> 3;
                    const imgArray = image.getBytes(bitStrideLength * h);
                    const decode = dict.getArray("D", "Decode");
                    if (this.parsingType3Font) {
                      imgData = _image.PDFImage.createRawMask({
                        imgArray,
                        width: w,
                        height: h,
                        imageIsFromDecodeStream: image instanceof _decode_stream.DecodeStream,
                        inverseDecode: (decode == null ? void 0 : decode[0]) > 0,
                        interpolate
                      });
                      imgData.cached = !!cacheKey;
                      args = [imgData];
                      operatorList.addImageOps(_util.OPS.paintImageMaskXObject, args, optionalContent);
                      if (cacheKey) {
                        const cacheData = {
                          fn: _util.OPS.paintImageMaskXObject,
                          args,
                          optionalContent
                        };
                        localImageCache.set(cacheKey, imageRef, cacheData);
                        if (imageRef) {
                          this._regionalImageCache.set(null, imageRef, cacheData);
                        }
                      }
                      return;
                    }
                    imgData = await _image.PDFImage.createMask({
                      imgArray,
                      width: w,
                      height: h,
                      imageIsFromDecodeStream: image instanceof _decode_stream.DecodeStream,
                      inverseDecode: (decode == null ? void 0 : decode[0]) > 0,
                      interpolate,
                      isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported
                    });
                    if (imgData.isSingleOpaquePixel) {
                      operatorList.addImageOps(_util.OPS.paintSolidColorImageMask, [], optionalContent);
                      if (cacheKey) {
                        const cacheData = {
                          fn: _util.OPS.paintSolidColorImageMask,
                          args: [],
                          optionalContent
                        };
                        localImageCache.set(cacheKey, imageRef, cacheData);
                        if (imageRef) {
                          this._regionalImageCache.set(null, imageRef, cacheData);
                        }
                      }
                      return;
                    }
                    const objId2 = `mask_${this.idFactory.createObjId()}`;
                    operatorList.addDependency(objId2);
                    this._sendImgData(objId2, imgData);
                    args = [{
                      data: objId2,
                      width: imgData.width,
                      height: imgData.height,
                      interpolate: imgData.interpolate,
                      count: 1
                    }];
                    operatorList.addImageOps(_util.OPS.paintImageMaskXObject, args, optionalContent);
                    if (cacheKey) {
                      const cacheData = {
                        fn: _util.OPS.paintImageMaskXObject,
                        args,
                        optionalContent
                      };
                      localImageCache.set(cacheKey, imageRef, cacheData);
                      if (imageRef) {
                        this._regionalImageCache.set(null, imageRef, cacheData);
                      }
                    }
                    return;
                  }
                  const SMALL_IMAGE_DIMENSIONS = 200;
                  if (isInline && !dict.has("SMask") && !dict.has("Mask") && w + h < SMALL_IMAGE_DIMENSIONS) {
                    const imageObj = new _image.PDFImage({
                      xref: this.xref,
                      res: resources,
                      image,
                      isInline,
                      pdfFunctionFactory: this._pdfFunctionFactory,
                      localColorSpaceCache
                    });
                    imgData = await imageObj.createImageData(true, false);
                    operatorList.isOffscreenCanvasSupported = this.options.isOffscreenCanvasSupported;
                    operatorList.addImageOps(_util.OPS.paintInlineImageXObject, [imgData], optionalContent);
                    return;
                  }
                  let objId = `img_${this.idFactory.createObjId()}`, cacheGlobally = false;
                  if (this.parsingType3Font) {
                    objId = `${this.idFactory.getDocId()}_type3_${objId}`;
                  } else if (imageRef) {
                    cacheGlobally = this.globalImageCache.shouldCache(imageRef, this.pageIndex);
                    if (cacheGlobally) {
                      objId = `${this.idFactory.getDocId()}_${objId}`;
                    }
                  }
                  operatorList.addDependency(objId);
                  args = [objId, w, h];
                  _image.PDFImage.buildImage({
                    xref: this.xref,
                    res: resources,
                    image,
                    isInline,
                    pdfFunctionFactory: this._pdfFunctionFactory,
                    localColorSpaceCache
                  }).then(async (imageObj) => {
                    imgData = await imageObj.createImageData(false, this.options.isOffscreenCanvasSupported);
                    if (cacheKey && imageRef && cacheGlobally) {
                      const length = imgData.bitmap ? imgData.width * imgData.height * 4 : imgData.data.length;
                      this.globalImageCache.addByteSize(imageRef, length);
                    }
                    return this._sendImgData(objId, imgData, cacheGlobally);
                  }).catch((reason) => {
                    (0, _util.warn)(`Unable to decode image "${objId}": "${reason}".`);
                    return this._sendImgData(objId, null, cacheGlobally);
                  });
                  operatorList.addImageOps(_util.OPS.paintImageXObject, args, optionalContent);
                  if (cacheKey) {
                    const cacheData = {
                      fn: _util.OPS.paintImageXObject,
                      args,
                      optionalContent
                    };
                    localImageCache.set(cacheKey, imageRef, cacheData);
                    if (imageRef) {
                      this._regionalImageCache.set(null, imageRef, cacheData);
                      if (cacheGlobally) {
                        (0, _util.assert)(!isInline, "Cannot cache an inline image globally.");
                        this.globalImageCache.setData(imageRef, {
                          objId,
                          fn: _util.OPS.paintImageXObject,
                          args,
                          optionalContent,
                          byteSize: 0
                        });
                      }
                    }
                  }
                }
                handleSMask(smask, resources, operatorList, task, stateManager, localColorSpaceCache) {
                  const smaskContent = smask.get("G");
                  const smaskOptions = {
                    subtype: smask.get("S").name,
                    backdrop: smask.get("BC")
                  };
                  const transferObj = smask.get("TR");
                  if ((0, _function.isPDFFunction)(transferObj)) {
                    const transferFn = this._pdfFunctionFactory.create(transferObj);
                    const transferMap = new Uint8Array(256);
                    const tmp = new Float32Array(1);
                    for (let i = 0; i < 256; i++) {
                      tmp[0] = i / 255;
                      transferFn(tmp, 0, tmp, 0);
                      transferMap[i] = tmp[0] * 255 | 0;
                    }
                    smaskOptions.transferMap = transferMap;
                  }
                  return this.buildFormXObject(resources, smaskContent, smaskOptions, operatorList, task, stateManager.state.clone(), localColorSpaceCache);
                }
                handleTransferFunction(tr) {
                  let transferArray;
                  if (Array.isArray(tr)) {
                    transferArray = tr;
                  } else if ((0, _function.isPDFFunction)(tr)) {
                    transferArray = [tr];
                  } else {
                    return null;
                  }
                  const transferMaps = [];
                  let numFns = 0, numEffectfulFns = 0;
                  for (const entry of transferArray) {
                    const transferObj = this.xref.fetchIfRef(entry);
                    numFns++;
                    if ((0, _primitives.isName)(transferObj, "Identity")) {
                      transferMaps.push(null);
                      continue;
                    } else if (!(0, _function.isPDFFunction)(transferObj)) {
                      return null;
                    }
                    const transferFn = this._pdfFunctionFactory.create(transferObj);
                    const transferMap = new Uint8Array(256), tmp = new Float32Array(1);
                    for (let j = 0; j < 256; j++) {
                      tmp[0] = j / 255;
                      transferFn(tmp, 0, tmp, 0);
                      transferMap[j] = tmp[0] * 255 | 0;
                    }
                    transferMaps.push(transferMap);
                    numEffectfulFns++;
                  }
                  if (!(numFns === 1 || numFns === 4)) {
                    return null;
                  }
                  if (numEffectfulFns === 0) {
                    return null;
                  }
                  return transferMaps;
                }
                handleTilingType(fn, color, resources, pattern, patternDict, operatorList, task, localTilingPatternCache) {
                  const tilingOpList = new _operator_list.OperatorList();
                  const patternResources = _primitives.Dict.merge({
                    xref: this.xref,
                    dictArray: [patternDict.get("Resources"), resources]
                  });
                  return this.getOperatorList({
                    stream: pattern,
                    task,
                    resources: patternResources,
                    operatorList: tilingOpList
                  }).then(function() {
                    const operatorListIR = tilingOpList.getIR();
                    const tilingPatternIR = (0, _pattern.getTilingPatternIR)(operatorListIR, patternDict, color);
                    operatorList.addDependencies(tilingOpList.dependencies);
                    operatorList.addOp(fn, tilingPatternIR);
                    if (patternDict.objId) {
                      localTilingPatternCache.set(null, patternDict.objId, {
                        operatorListIR,
                        dict: patternDict
                      });
                    }
                  }).catch((reason) => {
                    if (reason instanceof _util.AbortException) {
                      return;
                    }
                    if (this.options.ignoreErrors) {
                      (0, _util.warn)(`handleTilingType - ignoring pattern: "${reason}".`);
                      return;
                    }
                    throw reason;
                  });
                }
                handleSetFont(resources, fontArgs, fontRef, operatorList, task, state, fallbackFontDict = null, cssFontInfo = null) {
                  const fontName = (fontArgs == null ? void 0 : fontArgs[0]) instanceof _primitives.Name ? fontArgs[0].name : null;
                  return this.loadFont(fontName, fontRef, resources, fallbackFontDict, cssFontInfo).then((translated) => {
                    if (!translated.font.isType3Font) {
                      return translated;
                    }
                    return translated.loadType3Data(this, resources, task).then(function() {
                      operatorList.addDependencies(translated.type3Dependencies);
                      return translated;
                    }).catch((reason) => {
                      return new TranslatedFont({
                        loadedName: "g_font_error",
                        font: new _fonts.ErrorFont(`Type3 font load error: ${reason}`),
                        dict: translated.font,
                        evaluatorOptions: this.options
                      });
                    });
                  }).then((translated) => {
                    state.font = translated.font;
                    translated.send(this.handler);
                    return translated.loadedName;
                  });
                }
                handleText(chars, state) {
                  const font = state.font;
                  const glyphs = font.charsToGlyphs(chars);
                  if (font.data) {
                    const isAddToPathSet = !!(state.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
                    if (isAddToPathSet || state.fillColorSpace.name === "Pattern" || font.disableFontFace || this.options.disableFontFace) {
                      PartialEvaluator.buildFontPaths(font, glyphs, this.handler, this.options);
                    }
                  }
                  return glyphs;
                }
                ensureStateFont(state) {
                  if (state.font) {
                    return;
                  }
                  const reason = new _util.FormatError("Missing setFont (Tf) operator before text rendering operator.");
                  if (this.options.ignoreErrors) {
                    (0, _util.warn)(`ensureStateFont: "${reason}".`);
                    return;
                  }
                  throw reason;
                }
                async setGState({
                  resources,
                  gState,
                  operatorList,
                  cacheKey,
                  task,
                  stateManager,
                  localGStateCache,
                  localColorSpaceCache
                }) {
                  const gStateRef = gState.objId;
                  let isSimpleGState = true;
                  const gStateObj = [];
                  let promise = Promise.resolve();
                  for (const key of gState.getKeys()) {
                    const value = gState.get(key);
                    switch (key) {
                      case "Type":
                        break;
                      case "LW":
                      case "LC":
                      case "LJ":
                      case "ML":
                      case "D":
                      case "RI":
                      case "FL":
                      case "CA":
                      case "ca":
                        gStateObj.push([key, value]);
                        break;
                      case "Font":
                        isSimpleGState = false;
                        promise = promise.then(() => {
                          return this.handleSetFont(resources, null, value[0], operatorList, task, stateManager.state).then(function(loadedName) {
                            operatorList.addDependency(loadedName);
                            gStateObj.push([key, [loadedName, value[1]]]);
                          });
                        });
                        break;
                      case "BM":
                        gStateObj.push([key, normalizeBlendMode(value)]);
                        break;
                      case "SMask":
                        if ((0, _primitives.isName)(value, "None")) {
                          gStateObj.push([key, false]);
                          break;
                        }
                        if (value instanceof _primitives.Dict) {
                          isSimpleGState = false;
                          promise = promise.then(() => {
                            return this.handleSMask(value, resources, operatorList, task, stateManager, localColorSpaceCache);
                          });
                          gStateObj.push([key, true]);
                        } else {
                          (0, _util.warn)("Unsupported SMask type");
                        }
                        break;
                      case "TR":
                        const transferMaps = this.handleTransferFunction(value);
                        gStateObj.push([key, transferMaps]);
                        break;
                      case "OP":
                      case "op":
                      case "OPM":
                      case "BG":
                      case "BG2":
                      case "UCR":
                      case "UCR2":
                      case "TR2":
                      case "HT":
                      case "SM":
                      case "SA":
                      case "AIS":
                      case "TK":
                        (0, _util.info)("graphic state operator " + key);
                        break;
                      default:
                        (0, _util.info)("Unknown graphic state operator " + key);
                        break;
                    }
                  }
                  return promise.then(function() {
                    if (gStateObj.length > 0) {
                      operatorList.addOp(_util.OPS.setGState, [gStateObj]);
                    }
                    if (isSimpleGState) {
                      localGStateCache.set(cacheKey, gStateRef, gStateObj);
                    }
                  });
                }
                loadFont(fontName, font, resources, fallbackFontDict = null, cssFontInfo = null) {
                  const errorFont = async () => {
                    return new TranslatedFont({
                      loadedName: "g_font_error",
                      font: new _fonts.ErrorFont(`Font "${fontName}" is not available.`),
                      dict: font,
                      evaluatorOptions: this.options
                    });
                  };
                  let fontRef;
                  if (font) {
                    if (font instanceof _primitives.Ref) {
                      fontRef = font;
                    }
                  } else {
                    const fontRes = resources.get("Font");
                    if (fontRes) {
                      fontRef = fontRes.getRaw(fontName);
                    }
                  }
                  if (fontRef) {
                    if (this.parsingType3Font && this.type3FontRefs.has(fontRef)) {
                      return errorFont();
                    }
                    if (this.fontCache.has(fontRef)) {
                      return this.fontCache.get(fontRef);
                    }
                    font = this.xref.fetchIfRef(fontRef);
                  }
                  if (!(font instanceof _primitives.Dict)) {
                    if (!this.options.ignoreErrors && !this.parsingType3Font) {
                      (0, _util.warn)(`Font "${fontName}" is not available.`);
                      return errorFont();
                    }
                    (0, _util.warn)(`Font "${fontName}" is not available -- attempting to fallback to a default font.`);
                    font = fallbackFontDict || PartialEvaluator.fallbackFontDict;
                  }
                  if (font.cacheKey && this.fontCache.has(font.cacheKey)) {
                    return this.fontCache.get(font.cacheKey);
                  }
                  const fontCapability = new _util.PromiseCapability();
                  let preEvaluatedFont;
                  try {
                    preEvaluatedFont = this.preEvaluateFont(font);
                    preEvaluatedFont.cssFontInfo = cssFontInfo;
                  } catch (reason) {
                    (0, _util.warn)(`loadFont - preEvaluateFont failed: "${reason}".`);
                    return errorFont();
                  }
                  const {
                    descriptor,
                    hash
                  } = preEvaluatedFont;
                  const fontRefIsRef = fontRef instanceof _primitives.Ref;
                  let fontID;
                  if (hash && descriptor instanceof _primitives.Dict) {
                    const fontAliases = descriptor.fontAliases || (descriptor.fontAliases = /* @__PURE__ */ Object.create(null));
                    if (fontAliases[hash]) {
                      const aliasFontRef = fontAliases[hash].aliasRef;
                      if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
                        this.fontCache.putAlias(fontRef, aliasFontRef);
                        return this.fontCache.get(fontRef);
                      }
                    } else {
                      fontAliases[hash] = {
                        fontID: this.idFactory.createFontId()
                      };
                    }
                    if (fontRefIsRef) {
                      fontAliases[hash].aliasRef = fontRef;
                    }
                    fontID = fontAliases[hash].fontID;
                  } else {
                    fontID = this.idFactory.createFontId();
                  }
                  (0, _util.assert)(fontID == null ? void 0 : fontID.startsWith("f"), 'The "fontID" must be (correctly) defined.');
                  if (fontRefIsRef) {
                    this.fontCache.put(fontRef, fontCapability.promise);
                  } else {
                    font.cacheKey = `cacheKey_${fontID}`;
                    this.fontCache.put(font.cacheKey, fontCapability.promise);
                  }
                  font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;
                  this.translateFont(preEvaluatedFont).then((translatedFont) => {
                    fontCapability.resolve(new TranslatedFont({
                      loadedName: font.loadedName,
                      font: translatedFont,
                      dict: font,
                      evaluatorOptions: this.options
                    }));
                  }).catch((reason) => {
                    (0, _util.warn)(`loadFont - translateFont failed: "${reason}".`);
                    fontCapability.resolve(new TranslatedFont({
                      loadedName: font.loadedName,
                      font: new _fonts.ErrorFont(reason instanceof Error ? reason.message : reason),
                      dict: font,
                      evaluatorOptions: this.options
                    }));
                  });
                  return fontCapability.promise;
                }
                buildPath(operatorList, fn, args, parsingText = false) {
                  const lastIndex = operatorList.length - 1;
                  if (!args) {
                    args = [];
                  }
                  if (lastIndex < 0 || operatorList.fnArray[lastIndex] !== _util.OPS.constructPath) {
                    if (parsingText) {
                      (0, _util.warn)(`Encountered path operator "${fn}" inside of a text object.`);
                      operatorList.addOp(_util.OPS.save, null);
                    }
                    let minMax;
                    switch (fn) {
                      case _util.OPS.rectangle:
                        const x = args[0] + args[2];
                        const y = args[1] + args[3];
                        minMax = [Math.min(args[0], x), Math.max(args[0], x), Math.min(args[1], y), Math.max(args[1], y)];
                        break;
                      case _util.OPS.moveTo:
                      case _util.OPS.lineTo:
                        minMax = [args[0], args[0], args[1], args[1]];
                        break;
                      default:
                        minMax = [Infinity, -Infinity, Infinity, -Infinity];
                        break;
                    }
                    operatorList.addOp(_util.OPS.constructPath, [[fn], args, minMax]);
                    if (parsingText) {
                      operatorList.addOp(_util.OPS.restore, null);
                    }
                  } else {
                    const opArgs = operatorList.argsArray[lastIndex];
                    opArgs[0].push(fn);
                    opArgs[1].push(...args);
                    const minMax = opArgs[2];
                    switch (fn) {
                      case _util.OPS.rectangle:
                        const x = args[0] + args[2];
                        const y = args[1] + args[3];
                        minMax[0] = Math.min(minMax[0], args[0], x);
                        minMax[1] = Math.max(minMax[1], args[0], x);
                        minMax[2] = Math.min(minMax[2], args[1], y);
                        minMax[3] = Math.max(minMax[3], args[1], y);
                        break;
                      case _util.OPS.moveTo:
                      case _util.OPS.lineTo:
                        minMax[0] = Math.min(minMax[0], args[0]);
                        minMax[1] = Math.max(minMax[1], args[0]);
                        minMax[2] = Math.min(minMax[2], args[1]);
                        minMax[3] = Math.max(minMax[3], args[1]);
                        break;
                    }
                  }
                }
                parseColorSpace({
                  cs,
                  resources,
                  localColorSpaceCache
                }) {
                  return _colorspace.ColorSpace.parseAsync({
                    cs,
                    xref: this.xref,
                    resources,
                    pdfFunctionFactory: this._pdfFunctionFactory,
                    localColorSpaceCache
                  }).catch((reason) => {
                    if (reason instanceof _util.AbortException) {
                      return null;
                    }
                    if (this.options.ignoreErrors) {
                      (0, _util.warn)(`parseColorSpace - ignoring ColorSpace: "${reason}".`);
                      return null;
                    }
                    throw reason;
                  });
                }
                parseShading({
                  shading,
                  resources,
                  localColorSpaceCache,
                  localShadingPatternCache
                }) {
                  let id = localShadingPatternCache.get(shading);
                  if (!id) {
                    var shadingFill = _pattern.Pattern.parseShading(shading, this.xref, resources, this._pdfFunctionFactory, localColorSpaceCache);
                    const patternIR = shadingFill.getIR();
                    id = `pattern_${this.idFactory.createObjId()}`;
                    if (this.parsingType3Font) {
                      id = `${this.idFactory.getDocId()}_type3_${id}`;
                    }
                    localShadingPatternCache.set(shading, id);
                    if (this.parsingType3Font) {
                      this.handler.send("commonobj", [id, "Pattern", patternIR]);
                    } else {
                      this.handler.send("obj", [id, this.pageIndex, "Pattern", patternIR]);
                    }
                  }
                  return id;
                }
                handleColorN(operatorList, fn, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache) {
                  const patternName = args.pop();
                  if (patternName instanceof _primitives.Name) {
                    const rawPattern = patterns.getRaw(patternName.name);
                    const localTilingPattern = rawPattern instanceof _primitives.Ref && localTilingPatternCache.getByRef(rawPattern);
                    if (localTilingPattern) {
                      try {
                        const color = cs.base ? cs.base.getRgb(args, 0) : null;
                        const tilingPatternIR = (0, _pattern.getTilingPatternIR)(localTilingPattern.operatorListIR, localTilingPattern.dict, color);
                        operatorList.addOp(fn, tilingPatternIR);
                        return void 0;
                      } catch {
                      }
                    }
                    const pattern = this.xref.fetchIfRef(rawPattern);
                    if (pattern) {
                      const dict = pattern instanceof _base_stream.BaseStream ? pattern.dict : pattern;
                      const typeNum = dict.get("PatternType");
                      if (typeNum === PatternType.TILING) {
                        const color = cs.base ? cs.base.getRgb(args, 0) : null;
                        return this.handleTilingType(fn, color, resources, pattern, dict, operatorList, task, localTilingPatternCache);
                      } else if (typeNum === PatternType.SHADING) {
                        const shading = dict.get("Shading");
                        const matrix = dict.getArray("Matrix");
                        const objId = this.parseShading({
                          shading,
                          resources,
                          localColorSpaceCache,
                          localShadingPatternCache
                        });
                        operatorList.addOp(fn, ["Shading", objId, matrix]);
                        return void 0;
                      }
                      throw new _util.FormatError(`Unknown PatternType: ${typeNum}`);
                    }
                  }
                  throw new _util.FormatError(`Unknown PatternName: ${patternName}`);
                }
                _parseVisibilityExpression(array, nestingCounter, currentResult) {
                  const MAX_NESTING = 10;
                  if (++nestingCounter > MAX_NESTING) {
                    (0, _util.warn)("Visibility expression is too deeply nested");
                    return;
                  }
                  const length = array.length;
                  const operator = this.xref.fetchIfRef(array[0]);
                  if (length < 2 || !(operator instanceof _primitives.Name)) {
                    (0, _util.warn)("Invalid visibility expression");
                    return;
                  }
                  switch (operator.name) {
                    case "And":
                    case "Or":
                    case "Not":
                      currentResult.push(operator.name);
                      break;
                    default:
                      (0, _util.warn)(`Invalid operator ${operator.name} in visibility expression`);
                      return;
                  }
                  for (let i = 1; i < length; i++) {
                    const raw = array[i];
                    const object = this.xref.fetchIfRef(raw);
                    if (Array.isArray(object)) {
                      const nestedResult = [];
                      currentResult.push(nestedResult);
                      this._parseVisibilityExpression(object, nestingCounter, nestedResult);
                    } else if (raw instanceof _primitives.Ref) {
                      currentResult.push(raw.toString());
                    }
                  }
                }
                async parseMarkedContentProps(contentProperties, resources) {
                  var _a;
                  let optionalContent;
                  if (contentProperties instanceof _primitives.Name) {
                    const properties = resources.get("Properties");
                    optionalContent = properties.get(contentProperties.name);
                  } else if (contentProperties instanceof _primitives.Dict) {
                    optionalContent = contentProperties;
                  } else {
                    throw new _util.FormatError("Optional content properties malformed.");
                  }
                  const optionalContentType = (_a = optionalContent.get("Type")) == null ? void 0 : _a.name;
                  if (optionalContentType === "OCG") {
                    return {
                      type: optionalContentType,
                      id: optionalContent.objId
                    };
                  } else if (optionalContentType === "OCMD") {
                    const expression = optionalContent.get("VE");
                    if (Array.isArray(expression)) {
                      const result = [];
                      this._parseVisibilityExpression(expression, 0, result);
                      if (result.length > 0) {
                        return {
                          type: "OCMD",
                          expression: result
                        };
                      }
                    }
                    const optionalContentGroups = optionalContent.get("OCGs");
                    if (Array.isArray(optionalContentGroups) || optionalContentGroups instanceof _primitives.Dict) {
                      const groupIds = [];
                      if (Array.isArray(optionalContentGroups)) {
                        for (const ocg of optionalContentGroups) {
                          groupIds.push(ocg.toString());
                        }
                      } else {
                        groupIds.push(optionalContentGroups.objId);
                      }
                      return {
                        type: optionalContentType,
                        ids: groupIds,
                        policy: optionalContent.get("P") instanceof _primitives.Name ? optionalContent.get("P").name : null,
                        expression: null
                      };
                    } else if (optionalContentGroups instanceof _primitives.Ref) {
                      return {
                        type: optionalContentType,
                        id: optionalContentGroups.toString()
                      };
                    }
                  }
                  return null;
                }
                getOperatorList({
                  stream,
                  task,
                  resources,
                  operatorList,
                  initialState = null,
                  fallbackFontDict = null
                }) {
                  resources || (resources = _primitives.Dict.empty);
                  initialState || (initialState = new EvalState());
                  if (!operatorList) {
                    throw new Error('getOperatorList: missing "operatorList" parameter');
                  }
                  const self2 = this;
                  const xref = this.xref;
                  let parsingText = false;
                  const localImageCache = new _image_utils.LocalImageCache();
                  const localColorSpaceCache = new _image_utils.LocalColorSpaceCache();
                  const localGStateCache = new _image_utils.LocalGStateCache();
                  const localTilingPatternCache = new _image_utils.LocalTilingPatternCache();
                  const localShadingPatternCache = /* @__PURE__ */ new Map();
                  const xobjs = resources.get("XObject") || _primitives.Dict.empty;
                  const patterns = resources.get("Pattern") || _primitives.Dict.empty;
                  const stateManager = new StateManager(initialState);
                  const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
                  const timeSlotManager = new TimeSlotManager();
                  function closePendingRestoreOPS(argument) {
                    for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
                      operatorList.addOp(_util.OPS.restore, []);
                    }
                  }
                  return new Promise(function promiseBody(resolve, reject) {
                    const next = function(promise) {
                      Promise.all([promise, operatorList.ready]).then(function() {
                        try {
                          promiseBody(resolve, reject);
                        } catch (ex) {
                          reject(ex);
                        }
                      }, reject);
                    };
                    task.ensureNotTerminated();
                    timeSlotManager.reset();
                    const operation = {};
                    let stop, i, ii, cs, name, isValidName;
                    while (!(stop = timeSlotManager.check())) {
                      operation.args = null;
                      if (!preprocessor.read(operation)) {
                        break;
                      }
                      let args = operation.args;
                      let fn = operation.fn;
                      switch (fn | 0) {
                        case _util.OPS.paintXObject:
                          isValidName = args[0] instanceof _primitives.Name;
                          name = args[0].name;
                          if (isValidName) {
                            const localImage = localImageCache.getByName(name);
                            if (localImage) {
                              operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent);
                              incrementCachedImageMaskCount(localImage);
                              args = null;
                              continue;
                            }
                          }
                          next(new Promise(function(resolveXObject, rejectXObject) {
                            if (!isValidName) {
                              throw new _util.FormatError("XObject must be referred to by name.");
                            }
                            let xobj = xobjs.getRaw(name);
                            if (xobj instanceof _primitives.Ref) {
                              const localImage = localImageCache.getByRef(xobj) || self2._regionalImageCache.getByRef(xobj);
                              if (localImage) {
                                operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent);
                                incrementCachedImageMaskCount(localImage);
                                resolveXObject();
                                return;
                              }
                              const globalImage = self2.globalImageCache.getData(xobj, self2.pageIndex);
                              if (globalImage) {
                                operatorList.addDependency(globalImage.objId);
                                operatorList.addImageOps(globalImage.fn, globalImage.args, globalImage.optionalContent);
                                resolveXObject();
                                return;
                              }
                              xobj = xref.fetch(xobj);
                            }
                            if (!(xobj instanceof _base_stream.BaseStream)) {
                              throw new _util.FormatError("XObject should be a stream");
                            }
                            const type = xobj.dict.get("Subtype");
                            if (!(type instanceof _primitives.Name)) {
                              throw new _util.FormatError("XObject should have a Name subtype");
                            }
                            if (type.name === "Form") {
                              stateManager.save();
                              self2.buildFormXObject(resources, xobj, null, operatorList, task, stateManager.state.clone(), localColorSpaceCache).then(function() {
                                stateManager.restore();
                                resolveXObject();
                              }, rejectXObject);
                              return;
                            } else if (type.name === "Image") {
                              self2.buildPaintImageXObject({
                                resources,
                                image: xobj,
                                operatorList,
                                cacheKey: name,
                                localImageCache,
                                localColorSpaceCache
                              }).then(resolveXObject, rejectXObject);
                              return;
                            } else if (type.name === "PS") {
                              (0, _util.info)("Ignored XObject subtype PS");
                            } else {
                              throw new _util.FormatError(`Unhandled XObject subtype ${type.name}`);
                            }
                            resolveXObject();
                          }).catch(function(reason) {
                            if (reason instanceof _util.AbortException) {
                              return;
                            }
                            if (self2.options.ignoreErrors) {
                              (0, _util.warn)(`getOperatorList - ignoring XObject: "${reason}".`);
                              return;
                            }
                            throw reason;
                          }));
                          return;
                        case _util.OPS.setFont:
                          var fontSize = args[1];
                          next(self2.handleSetFont(resources, args, null, operatorList, task, stateManager.state, fallbackFontDict).then(function(loadedName) {
                            operatorList.addDependency(loadedName);
                            operatorList.addOp(_util.OPS.setFont, [loadedName, fontSize]);
                          }));
                          return;
                        case _util.OPS.beginText:
                          parsingText = true;
                          break;
                        case _util.OPS.endText:
                          parsingText = false;
                          break;
                        case _util.OPS.endInlineImage:
                          var cacheKey = args[0].cacheKey;
                          if (cacheKey) {
                            const localImage = localImageCache.getByName(cacheKey);
                            if (localImage) {
                              operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent);
                              incrementCachedImageMaskCount(localImage);
                              args = null;
                              continue;
                            }
                          }
                          next(self2.buildPaintImageXObject({
                            resources,
                            image: args[0],
                            isInline: true,
                            operatorList,
                            cacheKey,
                            localImageCache,
                            localColorSpaceCache
                          }));
                          return;
                        case _util.OPS.showText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          args[0] = self2.handleText(args[0], stateManager.state);
                          break;
                        case _util.OPS.showSpacedText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          var combinedGlyphs = [];
                          var state = stateManager.state;
                          for (const arrItem of args[0]) {
                            if (typeof arrItem === "string") {
                              combinedGlyphs.push(...self2.handleText(arrItem, state));
                            } else if (typeof arrItem === "number") {
                              combinedGlyphs.push(arrItem);
                            }
                          }
                          args[0] = combinedGlyphs;
                          fn = _util.OPS.showText;
                          break;
                        case _util.OPS.nextLineShowText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          operatorList.addOp(_util.OPS.nextLine);
                          args[0] = self2.handleText(args[0], stateManager.state);
                          fn = _util.OPS.showText;
                          break;
                        case _util.OPS.nextLineSetSpacingShowText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          operatorList.addOp(_util.OPS.nextLine);
                          operatorList.addOp(_util.OPS.setWordSpacing, [args.shift()]);
                          operatorList.addOp(_util.OPS.setCharSpacing, [args.shift()]);
                          args[0] = self2.handleText(args[0], stateManager.state);
                          fn = _util.OPS.showText;
                          break;
                        case _util.OPS.setTextRenderingMode:
                          stateManager.state.textRenderingMode = args[0];
                          break;
                        case _util.OPS.setFillColorSpace: {
                          const cachedColorSpace = _colorspace.ColorSpace.getCached(args[0], xref, localColorSpaceCache);
                          if (cachedColorSpace) {
                            stateManager.state.fillColorSpace = cachedColorSpace;
                            continue;
                          }
                          next(self2.parseColorSpace({
                            cs: args[0],
                            resources,
                            localColorSpaceCache
                          }).then(function(colorSpace) {
                            if (colorSpace) {
                              stateManager.state.fillColorSpace = colorSpace;
                            }
                          }));
                          return;
                        }
                        case _util.OPS.setStrokeColorSpace: {
                          const cachedColorSpace = _colorspace.ColorSpace.getCached(args[0], xref, localColorSpaceCache);
                          if (cachedColorSpace) {
                            stateManager.state.strokeColorSpace = cachedColorSpace;
                            continue;
                          }
                          next(self2.parseColorSpace({
                            cs: args[0],
                            resources,
                            localColorSpaceCache
                          }).then(function(colorSpace) {
                            if (colorSpace) {
                              stateManager.state.strokeColorSpace = colorSpace;
                            }
                          }));
                          return;
                        }
                        case _util.OPS.setFillColor:
                          cs = stateManager.state.fillColorSpace;
                          args = cs.getRgb(args, 0);
                          fn = _util.OPS.setFillRGBColor;
                          break;
                        case _util.OPS.setStrokeColor:
                          cs = stateManager.state.strokeColorSpace;
                          args = cs.getRgb(args, 0);
                          fn = _util.OPS.setStrokeRGBColor;
                          break;
                        case _util.OPS.setFillGray:
                          stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
                          args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
                          fn = _util.OPS.setFillRGBColor;
                          break;
                        case _util.OPS.setStrokeGray:
                          stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
                          args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
                          fn = _util.OPS.setStrokeRGBColor;
                          break;
                        case _util.OPS.setFillCMYKColor:
                          stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.cmyk;
                          args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
                          fn = _util.OPS.setFillRGBColor;
                          break;
                        case _util.OPS.setStrokeCMYKColor:
                          stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.cmyk;
                          args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
                          fn = _util.OPS.setStrokeRGBColor;
                          break;
                        case _util.OPS.setFillRGBColor:
                          stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.rgb;
                          args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
                          break;
                        case _util.OPS.setStrokeRGBColor:
                          stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.rgb;
                          args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
                          break;
                        case _util.OPS.setFillColorN:
                          cs = stateManager.state.fillColorSpace;
                          if (cs.name === "Pattern") {
                            next(self2.handleColorN(operatorList, _util.OPS.setFillColorN, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache));
                            return;
                          }
                          args = cs.getRgb(args, 0);
                          fn = _util.OPS.setFillRGBColor;
                          break;
                        case _util.OPS.setStrokeColorN:
                          cs = stateManager.state.strokeColorSpace;
                          if (cs.name === "Pattern") {
                            next(self2.handleColorN(operatorList, _util.OPS.setStrokeColorN, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache));
                            return;
                          }
                          args = cs.getRgb(args, 0);
                          fn = _util.OPS.setStrokeRGBColor;
                          break;
                        case _util.OPS.shadingFill:
                          var shadingRes = resources.get("Shading");
                          if (!shadingRes) {
                            throw new _util.FormatError("No shading resource found");
                          }
                          var shading = shadingRes.get(args[0].name);
                          if (!shading) {
                            throw new _util.FormatError("No shading object found");
                          }
                          const patternId = self2.parseShading({
                            shading,
                            resources,
                            localColorSpaceCache,
                            localShadingPatternCache
                          });
                          args = [patternId];
                          fn = _util.OPS.shadingFill;
                          break;
                        case _util.OPS.setGState:
                          isValidName = args[0] instanceof _primitives.Name;
                          name = args[0].name;
                          if (isValidName) {
                            const localGStateObj = localGStateCache.getByName(name);
                            if (localGStateObj) {
                              if (localGStateObj.length > 0) {
                                operatorList.addOp(_util.OPS.setGState, [localGStateObj]);
                              }
                              args = null;
                              continue;
                            }
                          }
                          next(new Promise(function(resolveGState, rejectGState) {
                            if (!isValidName) {
                              throw new _util.FormatError("GState must be referred to by name.");
                            }
                            const extGState = resources.get("ExtGState");
                            if (!(extGState instanceof _primitives.Dict)) {
                              throw new _util.FormatError("ExtGState should be a dictionary.");
                            }
                            const gState = extGState.get(name);
                            if (!(gState instanceof _primitives.Dict)) {
                              throw new _util.FormatError("GState should be a dictionary.");
                            }
                            self2.setGState({
                              resources,
                              gState,
                              operatorList,
                              cacheKey: name,
                              task,
                              stateManager,
                              localGStateCache,
                              localColorSpaceCache
                            }).then(resolveGState, rejectGState);
                          }).catch(function(reason) {
                            if (reason instanceof _util.AbortException) {
                              return;
                            }
                            if (self2.options.ignoreErrors) {
                              (0, _util.warn)(`getOperatorList - ignoring ExtGState: "${reason}".`);
                              return;
                            }
                            throw reason;
                          }));
                          return;
                        case _util.OPS.moveTo:
                        case _util.OPS.lineTo:
                        case _util.OPS.curveTo:
                        case _util.OPS.curveTo2:
                        case _util.OPS.curveTo3:
                        case _util.OPS.closePath:
                        case _util.OPS.rectangle:
                          self2.buildPath(operatorList, fn, args, parsingText);
                          continue;
                        case _util.OPS.markPoint:
                        case _util.OPS.markPointProps:
                        case _util.OPS.beginCompat:
                        case _util.OPS.endCompat:
                          continue;
                        case _util.OPS.beginMarkedContentProps:
                          if (!(args[0] instanceof _primitives.Name)) {
                            (0, _util.warn)(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
                            continue;
                          }
                          if (args[0].name === "OC") {
                            next(self2.parseMarkedContentProps(args[1], resources).then((data) => {
                              operatorList.addOp(_util.OPS.beginMarkedContentProps, ["OC", data]);
                            }).catch((reason) => {
                              if (reason instanceof _util.AbortException) {
                                return;
                              }
                              if (self2.options.ignoreErrors) {
                                (0, _util.warn)(`getOperatorList - ignoring beginMarkedContentProps: "${reason}".`);
                                return;
                              }
                              throw reason;
                            }));
                            return;
                          }
                          args = [args[0].name, args[1] instanceof _primitives.Dict ? args[1].get("MCID") : null];
                          break;
                        case _util.OPS.beginMarkedContent:
                        case _util.OPS.endMarkedContent:
                        default:
                          if (args !== null) {
                            for (i = 0, ii = args.length; i < ii; i++) {
                              if (args[i] instanceof _primitives.Dict) {
                                break;
                              }
                            }
                            if (i < ii) {
                              (0, _util.warn)("getOperatorList - ignoring operator: " + fn);
                              continue;
                            }
                          }
                      }
                      operatorList.addOp(fn, args);
                    }
                    if (stop) {
                      next(deferred);
                      return;
                    }
                    closePendingRestoreOPS();
                    resolve();
                  }).catch((reason) => {
                    if (reason instanceof _util.AbortException) {
                      return;
                    }
                    if (this.options.ignoreErrors) {
                      (0, _util.warn)(`getOperatorList - ignoring errors during "${task.name}" task: "${reason}".`);
                      closePendingRestoreOPS();
                      return;
                    }
                    throw reason;
                  });
                }
                getTextContent({
                  stream,
                  task,
                  resources,
                  stateManager = null,
                  includeMarkedContent = false,
                  sink,
                  seenStyles = /* @__PURE__ */ new Set(),
                  viewBox,
                  markedContentData = null,
                  disableNormalization = false
                }) {
                  resources || (resources = _primitives.Dict.empty);
                  stateManager || (stateManager = new StateManager(new TextState()));
                  if (includeMarkedContent) {
                    markedContentData || (markedContentData = {
                      level: 0
                    });
                  }
                  const textContent = {
                    items: [],
                    styles: /* @__PURE__ */ Object.create(null)
                  };
                  const textContentItem = {
                    initialized: false,
                    str: [],
                    totalWidth: 0,
                    totalHeight: 0,
                    width: 0,
                    height: 0,
                    vertical: false,
                    prevTransform: null,
                    textAdvanceScale: 0,
                    spaceInFlowMin: 0,
                    spaceInFlowMax: 0,
                    trackingSpaceMin: Infinity,
                    negativeSpaceMax: -Infinity,
                    notASpace: -Infinity,
                    transform: null,
                    fontName: null,
                    hasEOL: false
                  };
                  const twoLastChars = [" ", " "];
                  let twoLastCharsPos = 0;
                  function saveLastChar(char) {
                    const nextPos = (twoLastCharsPos + 1) % 2;
                    const ret = twoLastChars[twoLastCharsPos] !== " " && twoLastChars[nextPos] === " ";
                    twoLastChars[twoLastCharsPos] = char;
                    twoLastCharsPos = nextPos;
                    return ret;
                  }
                  function shouldAddWhitepsace() {
                    return twoLastChars[twoLastCharsPos] !== " " && twoLastChars[(twoLastCharsPos + 1) % 2] === " ";
                  }
                  function resetLastChars() {
                    twoLastChars[0] = twoLastChars[1] = " ";
                    twoLastCharsPos = 0;
                  }
                  const TRACKING_SPACE_FACTOR = 0.102;
                  const NOT_A_SPACE_FACTOR = 0.03;
                  const NEGATIVE_SPACE_FACTOR = -0.2;
                  const SPACE_IN_FLOW_MIN_FACTOR = 0.102;
                  const SPACE_IN_FLOW_MAX_FACTOR = 0.6;
                  const VERTICAL_SHIFT_RATIO = 0.25;
                  const self2 = this;
                  const xref = this.xref;
                  const showSpacedTextBuffer = [];
                  let xobjs = null;
                  const emptyXObjectCache = new _image_utils.LocalImageCache();
                  const emptyGStateCache = new _image_utils.LocalGStateCache();
                  const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
                  let textState;
                  function pushWhitespace({
                    width = 0,
                    height = 0,
                    transform = textContentItem.prevTransform,
                    fontName = textContentItem.fontName
                  }) {
                    textContent.items.push({
                      str: " ",
                      dir: "ltr",
                      width,
                      height,
                      transform,
                      fontName,
                      hasEOL: false
                    });
                  }
                  function getCurrentTextTransform() {
                    const font = textState.font;
                    const tsm = [textState.fontSize * textState.textHScale, 0, 0, textState.fontSize, 0, textState.textRise];
                    if (font.isType3Font && (textState.fontSize <= 1 || font.isCharBBox) && !(0, _util.isArrayEqual)(textState.fontMatrix, _util.FONT_IDENTITY_MATRIX)) {
                      const glyphHeight = font.bbox[3] - font.bbox[1];
                      if (glyphHeight > 0) {
                        tsm[3] *= glyphHeight * textState.fontMatrix[3];
                      }
                    }
                    return _util.Util.transform(textState.ctm, _util.Util.transform(textState.textMatrix, tsm));
                  }
                  function ensureTextContentItem() {
                    if (textContentItem.initialized) {
                      return textContentItem;
                    }
                    const {
                      font,
                      loadedName
                    } = textState;
                    if (!seenStyles.has(loadedName)) {
                      seenStyles.add(loadedName);
                      textContent.styles[loadedName] = {
                        fontFamily: font.fallbackName,
                        ascent: font.ascent,
                        descent: font.descent,
                        vertical: font.vertical
                      };
                    }
                    textContentItem.fontName = loadedName;
                    const trm = textContentItem.transform = getCurrentTextTransform();
                    if (!font.vertical) {
                      textContentItem.width = textContentItem.totalWidth = 0;
                      textContentItem.height = textContentItem.totalHeight = Math.hypot(trm[2], trm[3]);
                      textContentItem.vertical = false;
                    } else {
                      textContentItem.width = textContentItem.totalWidth = Math.hypot(trm[0], trm[1]);
                      textContentItem.height = textContentItem.totalHeight = 0;
                      textContentItem.vertical = true;
                    }
                    const scaleLineX = Math.hypot(textState.textLineMatrix[0], textState.textLineMatrix[1]);
                    const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
                    textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
                    const {
                      fontSize
                    } = textState;
                    textContentItem.trackingSpaceMin = fontSize * TRACKING_SPACE_FACTOR;
                    textContentItem.notASpace = fontSize * NOT_A_SPACE_FACTOR;
                    textContentItem.negativeSpaceMax = fontSize * NEGATIVE_SPACE_FACTOR;
                    textContentItem.spaceInFlowMin = fontSize * SPACE_IN_FLOW_MIN_FACTOR;
                    textContentItem.spaceInFlowMax = fontSize * SPACE_IN_FLOW_MAX_FACTOR;
                    textContentItem.hasEOL = false;
                    textContentItem.initialized = true;
                    return textContentItem;
                  }
                  function updateAdvanceScale() {
                    if (!textContentItem.initialized) {
                      return;
                    }
                    const scaleLineX = Math.hypot(textState.textLineMatrix[0], textState.textLineMatrix[1]);
                    const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
                    const scaleFactor = scaleCtmX * scaleLineX;
                    if (scaleFactor === textContentItem.textAdvanceScale) {
                      return;
                    }
                    if (!textContentItem.vertical) {
                      textContentItem.totalWidth += textContentItem.width * textContentItem.textAdvanceScale;
                      textContentItem.width = 0;
                    } else {
                      textContentItem.totalHeight += textContentItem.height * textContentItem.textAdvanceScale;
                      textContentItem.height = 0;
                    }
                    textContentItem.textAdvanceScale = scaleFactor;
                  }
                  function runBidiTransform(textChunk) {
                    let text = textChunk.str.join("");
                    if (!disableNormalization) {
                      text = (0, _util.normalizeUnicode)(text);
                    }
                    const bidiResult = (0, _bidi.bidi)(text, -1, textChunk.vertical);
                    return {
                      str: bidiResult.str,
                      dir: bidiResult.dir,
                      width: Math.abs(textChunk.totalWidth),
                      height: Math.abs(textChunk.totalHeight),
                      transform: textChunk.transform,
                      fontName: textChunk.fontName,
                      hasEOL: textChunk.hasEOL
                    };
                  }
                  function handleSetFont(fontName, fontRef) {
                    return self2.loadFont(fontName, fontRef, resources).then(function(translated) {
                      if (!translated.font.isType3Font) {
                        return translated;
                      }
                      return translated.loadType3Data(self2, resources, task).catch(function() {
                      }).then(function() {
                        return translated;
                      });
                    }).then(function(translated) {
                      textState.loadedName = translated.loadedName;
                      textState.font = translated.font;
                      textState.fontMatrix = translated.font.fontMatrix || _util.FONT_IDENTITY_MATRIX;
                    });
                  }
                  function applyInverseRotation(x, y, matrix) {
                    const scale = Math.hypot(matrix[0], matrix[1]);
                    return [(matrix[0] * x + matrix[1] * y) / scale, (matrix[2] * x + matrix[3] * y) / scale];
                  }
                  function compareWithLastPosition(glyphWidth) {
                    var _a;
                    const currentTransform = getCurrentTextTransform();
                    let posX = currentTransform[4];
                    let posY = currentTransform[5];
                    if ((_a = textState.font) == null ? void 0 : _a.vertical) {
                      if (posX < viewBox[0] || posX > viewBox[2] || posY + glyphWidth < viewBox[1] || posY > viewBox[3]) {
                        return false;
                      }
                    } else if (posX + glyphWidth < viewBox[0] || posX > viewBox[2] || posY < viewBox[1] || posY > viewBox[3]) {
                      return false;
                    }
                    if (!textState.font || !textContentItem.prevTransform) {
                      return true;
                    }
                    let lastPosX = textContentItem.prevTransform[4];
                    let lastPosY = textContentItem.prevTransform[5];
                    if (lastPosX === posX && lastPosY === posY) {
                      return true;
                    }
                    let rotate = -1;
                    if (currentTransform[0] && currentTransform[1] === 0 && currentTransform[2] === 0) {
                      rotate = currentTransform[0] > 0 ? 0 : 180;
                    } else if (currentTransform[1] && currentTransform[0] === 0 && currentTransform[3] === 0) {
                      rotate = currentTransform[1] > 0 ? 90 : 270;
                    }
                    switch (rotate) {
                      case 0:
                        break;
                      case 90:
                        [posX, posY] = [posY, posX];
                        [lastPosX, lastPosY] = [lastPosY, lastPosX];
                        break;
                      case 180:
                        [posX, posY, lastPosX, lastPosY] = [-posX, -posY, -lastPosX, -lastPosY];
                        break;
                      case 270:
                        [posX, posY] = [-posY, -posX];
                        [lastPosX, lastPosY] = [-lastPosY, -lastPosX];
                        break;
                      default:
                        [posX, posY] = applyInverseRotation(posX, posY, currentTransform);
                        [lastPosX, lastPosY] = applyInverseRotation(lastPosX, lastPosY, textContentItem.prevTransform);
                    }
                    if (textState.font.vertical) {
                      const advanceY2 = (lastPosY - posY) / textContentItem.textAdvanceScale;
                      const advanceX2 = posX - lastPosX;
                      const textOrientation2 = Math.sign(textContentItem.height);
                      if (advanceY2 < textOrientation2 * textContentItem.negativeSpaceMax) {
                        if (Math.abs(advanceX2) > 0.5 * textContentItem.width) {
                          appendEOL();
                          return true;
                        }
                        resetLastChars();
                        flushTextContentItem();
                        return true;
                      }
                      if (Math.abs(advanceX2) > textContentItem.width) {
                        appendEOL();
                        return true;
                      }
                      if (advanceY2 <= textOrientation2 * textContentItem.notASpace) {
                        resetLastChars();
                      }
                      if (advanceY2 <= textOrientation2 * textContentItem.trackingSpaceMin) {
                        if (shouldAddWhitepsace()) {
                          resetLastChars();
                          flushTextContentItem();
                          pushWhitespace({
                            height: Math.abs(advanceY2)
                          });
                        } else {
                          textContentItem.height += advanceY2;
                        }
                      } else if (!addFakeSpaces(advanceY2, textContentItem.prevTransform, textOrientation2)) {
                        if (textContentItem.str.length === 0) {
                          resetLastChars();
                          pushWhitespace({
                            height: Math.abs(advanceY2)
                          });
                        } else {
                          textContentItem.height += advanceY2;
                        }
                      }
                      if (Math.abs(advanceX2) > textContentItem.width * VERTICAL_SHIFT_RATIO) {
                        flushTextContentItem();
                      }
                      return true;
                    }
                    const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;
                    const advanceY = posY - lastPosY;
                    const textOrientation = Math.sign(textContentItem.width);
                    if (advanceX < textOrientation * textContentItem.negativeSpaceMax) {
                      if (Math.abs(advanceY) > 0.5 * textContentItem.height) {
                        appendEOL();
                        return true;
                      }
                      resetLastChars();
                      flushTextContentItem();
                      return true;
                    }
                    if (Math.abs(advanceY) > textContentItem.height) {
                      appendEOL();
                      return true;
                    }
                    if (advanceX <= textOrientation * textContentItem.notASpace) {
                      resetLastChars();
                    }
                    if (advanceX <= textOrientation * textContentItem.trackingSpaceMin) {
                      if (shouldAddWhitepsace()) {
                        resetLastChars();
                        flushTextContentItem();
                        pushWhitespace({
                          width: Math.abs(advanceX)
                        });
                      } else {
                        textContentItem.width += advanceX;
                      }
                    } else if (!addFakeSpaces(advanceX, textContentItem.prevTransform, textOrientation)) {
                      if (textContentItem.str.length === 0) {
                        resetLastChars();
                        pushWhitespace({
                          width: Math.abs(advanceX)
                        });
                      } else {
                        textContentItem.width += advanceX;
                      }
                    }
                    if (Math.abs(advanceY) > textContentItem.height * VERTICAL_SHIFT_RATIO) {
                      flushTextContentItem();
                    }
                    return true;
                  }
                  function buildTextContentItem({
                    chars,
                    extraSpacing
                  }) {
                    const font = textState.font;
                    if (!chars) {
                      const charSpacing = textState.charSpacing + extraSpacing;
                      if (charSpacing) {
                        if (!font.vertical) {
                          textState.translateTextMatrix(charSpacing * textState.textHScale, 0);
                        } else {
                          textState.translateTextMatrix(0, -charSpacing);
                        }
                      }
                      return;
                    }
                    const glyphs = font.charsToGlyphs(chars);
                    const scale = textState.fontMatrix[0] * textState.fontSize;
                    for (let i = 0, ii = glyphs.length; i < ii; i++) {
                      const glyph = glyphs[i];
                      const {
                        category
                      } = glyph;
                      if (category.isInvisibleFormatMark) {
                        continue;
                      }
                      let charSpacing = textState.charSpacing + (i + 1 === ii ? extraSpacing : 0);
                      let glyphWidth = glyph.width;
                      if (font.vertical) {
                        glyphWidth = glyph.vmetric ? glyph.vmetric[0] : -glyphWidth;
                      }
                      let scaledDim = glyphWidth * scale;
                      if (category.isWhitespace) {
                        if (!font.vertical) {
                          charSpacing += scaledDim + textState.wordSpacing;
                          textState.translateTextMatrix(charSpacing * textState.textHScale, 0);
                        } else {
                          charSpacing += -scaledDim + textState.wordSpacing;
                          textState.translateTextMatrix(0, -charSpacing);
                        }
                        saveLastChar(" ");
                        continue;
                      }
                      if (!category.isZeroWidthDiacritic && !compareWithLastPosition(scaledDim)) {
                        if (!font.vertical) {
                          textState.translateTextMatrix(scaledDim * textState.textHScale, 0);
                        } else {
                          textState.translateTextMatrix(0, scaledDim);
                        }
                        continue;
                      }
                      const textChunk = ensureTextContentItem();
                      if (category.isZeroWidthDiacritic) {
                        scaledDim = 0;
                      }
                      if (!font.vertical) {
                        scaledDim *= textState.textHScale;
                        textState.translateTextMatrix(scaledDim, 0);
                        textChunk.width += scaledDim;
                      } else {
                        textState.translateTextMatrix(0, scaledDim);
                        scaledDim = Math.abs(scaledDim);
                        textChunk.height += scaledDim;
                      }
                      if (scaledDim) {
                        textChunk.prevTransform = getCurrentTextTransform();
                      }
                      const glyphUnicode = glyph.unicode;
                      if (saveLastChar(glyphUnicode)) {
                        textChunk.str.push(" ");
                      }
                      textChunk.str.push(glyphUnicode);
                      if (charSpacing) {
                        if (!font.vertical) {
                          textState.translateTextMatrix(charSpacing * textState.textHScale, 0);
                        } else {
                          textState.translateTextMatrix(0, -charSpacing);
                        }
                      }
                    }
                  }
                  function appendEOL() {
                    resetLastChars();
                    if (textContentItem.initialized) {
                      textContentItem.hasEOL = true;
                      flushTextContentItem();
                    } else {
                      textContent.items.push({
                        str: "",
                        dir: "ltr",
                        width: 0,
                        height: 0,
                        transform: getCurrentTextTransform(),
                        fontName: textState.loadedName,
                        hasEOL: true
                      });
                    }
                  }
                  function addFakeSpaces(width, transf, textOrientation) {
                    if (textOrientation * textContentItem.spaceInFlowMin <= width && width <= textOrientation * textContentItem.spaceInFlowMax) {
                      if (textContentItem.initialized) {
                        resetLastChars();
                        textContentItem.str.push(" ");
                      }
                      return false;
                    }
                    const fontName = textContentItem.fontName;
                    let height = 0;
                    if (textContentItem.vertical) {
                      height = width;
                      width = 0;
                    }
                    flushTextContentItem();
                    resetLastChars();
                    pushWhitespace({
                      width: Math.abs(width),
                      height: Math.abs(height),
                      transform: transf || getCurrentTextTransform(),
                      fontName
                    });
                    return true;
                  }
                  function flushTextContentItem() {
                    if (!textContentItem.initialized || !textContentItem.str) {
                      return;
                    }
                    if (!textContentItem.vertical) {
                      textContentItem.totalWidth += textContentItem.width * textContentItem.textAdvanceScale;
                    } else {
                      textContentItem.totalHeight += textContentItem.height * textContentItem.textAdvanceScale;
                    }
                    textContent.items.push(runBidiTransform(textContentItem));
                    textContentItem.initialized = false;
                    textContentItem.str.length = 0;
                  }
                  function enqueueChunk(batch = false) {
                    const length = textContent.items.length;
                    if (length === 0) {
                      return;
                    }
                    if (batch && length < TEXT_CHUNK_BATCH_SIZE) {
                      return;
                    }
                    sink.enqueue(textContent, length);
                    textContent.items = [];
                    textContent.styles = /* @__PURE__ */ Object.create(null);
                  }
                  const timeSlotManager = new TimeSlotManager();
                  return new Promise(function promiseBody(resolve, reject) {
                    const next = function(promise) {
                      enqueueChunk(true);
                      Promise.all([promise, sink.ready]).then(function() {
                        try {
                          promiseBody(resolve, reject);
                        } catch (ex) {
                          reject(ex);
                        }
                      }, reject);
                    };
                    task.ensureNotTerminated();
                    timeSlotManager.reset();
                    const operation = {};
                    let stop, args = [];
                    while (!(stop = timeSlotManager.check())) {
                      args.length = 0;
                      operation.args = args;
                      if (!preprocessor.read(operation)) {
                        break;
                      }
                      const previousState = textState;
                      textState = stateManager.state;
                      const fn = operation.fn;
                      args = operation.args;
                      switch (fn | 0) {
                        case _util.OPS.setFont:
                          var fontNameArg = args[0].name, fontSizeArg = args[1];
                          if (textState.font && fontNameArg === textState.fontName && fontSizeArg === textState.fontSize) {
                            break;
                          }
                          flushTextContentItem();
                          textState.fontName = fontNameArg;
                          textState.fontSize = fontSizeArg;
                          next(handleSetFont(fontNameArg, null));
                          return;
                        case _util.OPS.setTextRise:
                          textState.textRise = args[0];
                          break;
                        case _util.OPS.setHScale:
                          textState.textHScale = args[0] / 100;
                          break;
                        case _util.OPS.setLeading:
                          textState.leading = args[0];
                          break;
                        case _util.OPS.moveText:
                          textState.translateTextLineMatrix(args[0], args[1]);
                          textState.textMatrix = textState.textLineMatrix.slice();
                          break;
                        case _util.OPS.setLeadingMoveText:
                          textState.leading = -args[1];
                          textState.translateTextLineMatrix(args[0], args[1]);
                          textState.textMatrix = textState.textLineMatrix.slice();
                          break;
                        case _util.OPS.nextLine:
                          textState.carriageReturn();
                          break;
                        case _util.OPS.setTextMatrix:
                          textState.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                          textState.setTextLineMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                          updateAdvanceScale();
                          break;
                        case _util.OPS.setCharSpacing:
                          textState.charSpacing = args[0];
                          break;
                        case _util.OPS.setWordSpacing:
                          textState.wordSpacing = args[0];
                          break;
                        case _util.OPS.beginText:
                          textState.textMatrix = _util.IDENTITY_MATRIX.slice();
                          textState.textLineMatrix = _util.IDENTITY_MATRIX.slice();
                          break;
                        case _util.OPS.showSpacedText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          const spaceFactor = (textState.font.vertical ? 1 : -1) * textState.fontSize / 1e3;
                          const elements = args[0];
                          for (let i = 0, ii = elements.length; i < ii; i++) {
                            const item = elements[i];
                            if (typeof item === "string") {
                              showSpacedTextBuffer.push(item);
                            } else if (typeof item === "number" && item !== 0) {
                              const str = showSpacedTextBuffer.join("");
                              showSpacedTextBuffer.length = 0;
                              buildTextContentItem({
                                chars: str,
                                extraSpacing: item * spaceFactor
                              });
                            }
                          }
                          if (showSpacedTextBuffer.length > 0) {
                            const str = showSpacedTextBuffer.join("");
                            showSpacedTextBuffer.length = 0;
                            buildTextContentItem({
                              chars: str,
                              extraSpacing: 0
                            });
                          }
                          break;
                        case _util.OPS.showText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          buildTextContentItem({
                            chars: args[0],
                            extraSpacing: 0
                          });
                          break;
                        case _util.OPS.nextLineShowText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          textState.carriageReturn();
                          buildTextContentItem({
                            chars: args[0],
                            extraSpacing: 0
                          });
                          break;
                        case _util.OPS.nextLineSetSpacingShowText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          textState.wordSpacing = args[0];
                          textState.charSpacing = args[1];
                          textState.carriageReturn();
                          buildTextContentItem({
                            chars: args[2],
                            extraSpacing: 0
                          });
                          break;
                        case _util.OPS.paintXObject:
                          flushTextContentItem();
                          if (!xobjs) {
                            xobjs = resources.get("XObject") || _primitives.Dict.empty;
                          }
                          var isValidName = args[0] instanceof _primitives.Name;
                          var name = args[0].name;
                          if (isValidName && emptyXObjectCache.getByName(name)) {
                            break;
                          }
                          next(new Promise(function(resolveXObject, rejectXObject) {
                            if (!isValidName) {
                              throw new _util.FormatError("XObject must be referred to by name.");
                            }
                            let xobj = xobjs.getRaw(name);
                            if (xobj instanceof _primitives.Ref) {
                              if (emptyXObjectCache.getByRef(xobj)) {
                                resolveXObject();
                                return;
                              }
                              const globalImage = self2.globalImageCache.getData(xobj, self2.pageIndex);
                              if (globalImage) {
                                resolveXObject();
                                return;
                              }
                              xobj = xref.fetch(xobj);
                            }
                            if (!(xobj instanceof _base_stream.BaseStream)) {
                              throw new _util.FormatError("XObject should be a stream");
                            }
                            const type = xobj.dict.get("Subtype");
                            if (!(type instanceof _primitives.Name)) {
                              throw new _util.FormatError("XObject should have a Name subtype");
                            }
                            if (type.name !== "Form") {
                              emptyXObjectCache.set(name, xobj.dict.objId, true);
                              resolveXObject();
                              return;
                            }
                            const currentState = stateManager.state.clone();
                            const xObjStateManager = new StateManager(currentState);
                            const matrix = xobj.dict.getArray("Matrix");
                            if (Array.isArray(matrix) && matrix.length === 6) {
                              xObjStateManager.transform(matrix);
                            }
                            enqueueChunk();
                            const sinkWrapper = {
                              enqueueInvoked: false,
                              enqueue(chunk, size) {
                                this.enqueueInvoked = true;
                                sink.enqueue(chunk, size);
                              },
                              get desiredSize() {
                                return sink.desiredSize;
                              },
                              get ready() {
                                return sink.ready;
                              }
                            };
                            self2.getTextContent({
                              stream: xobj,
                              task,
                              resources: xobj.dict.get("Resources") || resources,
                              stateManager: xObjStateManager,
                              includeMarkedContent,
                              sink: sinkWrapper,
                              seenStyles,
                              viewBox,
                              markedContentData,
                              disableNormalization
                            }).then(function() {
                              if (!sinkWrapper.enqueueInvoked) {
                                emptyXObjectCache.set(name, xobj.dict.objId, true);
                              }
                              resolveXObject();
                            }, rejectXObject);
                          }).catch(function(reason) {
                            if (reason instanceof _util.AbortException) {
                              return;
                            }
                            if (self2.options.ignoreErrors) {
                              (0, _util.warn)(`getTextContent - ignoring XObject: "${reason}".`);
                              return;
                            }
                            throw reason;
                          }));
                          return;
                        case _util.OPS.setGState:
                          isValidName = args[0] instanceof _primitives.Name;
                          name = args[0].name;
                          if (isValidName && emptyGStateCache.getByName(name)) {
                            break;
                          }
                          next(new Promise(function(resolveGState, rejectGState) {
                            if (!isValidName) {
                              throw new _util.FormatError("GState must be referred to by name.");
                            }
                            const extGState = resources.get("ExtGState");
                            if (!(extGState instanceof _primitives.Dict)) {
                              throw new _util.FormatError("ExtGState should be a dictionary.");
                            }
                            const gState = extGState.get(name);
                            if (!(gState instanceof _primitives.Dict)) {
                              throw new _util.FormatError("GState should be a dictionary.");
                            }
                            const gStateFont = gState.get("Font");
                            if (!gStateFont) {
                              emptyGStateCache.set(name, gState.objId, true);
                              resolveGState();
                              return;
                            }
                            flushTextContentItem();
                            textState.fontName = null;
                            textState.fontSize = gStateFont[1];
                            handleSetFont(null, gStateFont[0]).then(resolveGState, rejectGState);
                          }).catch(function(reason) {
                            if (reason instanceof _util.AbortException) {
                              return;
                            }
                            if (self2.options.ignoreErrors) {
                              (0, _util.warn)(`getTextContent - ignoring ExtGState: "${reason}".`);
                              return;
                            }
                            throw reason;
                          }));
                          return;
                        case _util.OPS.beginMarkedContent:
                          flushTextContentItem();
                          if (includeMarkedContent) {
                            markedContentData.level++;
                            textContent.items.push({
                              type: "beginMarkedContent",
                              tag: args[0] instanceof _primitives.Name ? args[0].name : null
                            });
                          }
                          break;
                        case _util.OPS.beginMarkedContentProps:
                          flushTextContentItem();
                          if (includeMarkedContent) {
                            markedContentData.level++;
                            let mcid = null;
                            if (args[1] instanceof _primitives.Dict) {
                              mcid = args[1].get("MCID");
                            }
                            textContent.items.push({
                              type: "beginMarkedContentProps",
                              id: Number.isInteger(mcid) ? `${self2.idFactory.getPageObjId()}_mc${mcid}` : null,
                              tag: args[0] instanceof _primitives.Name ? args[0].name : null
                            });
                          }
                          break;
                        case _util.OPS.endMarkedContent:
                          flushTextContentItem();
                          if (includeMarkedContent) {
                            if (markedContentData.level === 0) {
                              break;
                            }
                            markedContentData.level--;
                            textContent.items.push({
                              type: "endMarkedContent"
                            });
                          }
                          break;
                        case _util.OPS.restore:
                          if (previousState && (previousState.font !== textState.font || previousState.fontSize !== textState.fontSize || previousState.fontName !== textState.fontName)) {
                            flushTextContentItem();
                          }
                          break;
                      }
                      if (textContent.items.length >= sink.desiredSize) {
                        stop = true;
                        break;
                      }
                    }
                    if (stop) {
                      next(deferred);
                      return;
                    }
                    flushTextContentItem();
                    enqueueChunk();
                    resolve();
                  }).catch((reason) => {
                    if (reason instanceof _util.AbortException) {
                      return;
                    }
                    if (this.options.ignoreErrors) {
                      (0, _util.warn)(`getTextContent - ignoring errors during "${task.name}" task: "${reason}".`);
                      flushTextContentItem();
                      enqueueChunk();
                      return;
                    }
                    throw reason;
                  });
                }
                extractDataStructures(dict, baseDict, properties) {
                  const xref = this.xref;
                  let cidToGidBytes;
                  const toUnicodePromise = this.readToUnicode(properties.toUnicode || dict.get("ToUnicode") || baseDict.get("ToUnicode"));
                  if (properties.composite) {
                    const cidSystemInfo = dict.get("CIDSystemInfo");
                    if (cidSystemInfo instanceof _primitives.Dict) {
                      properties.cidSystemInfo = {
                        registry: (0, _util.stringToPDFString)(cidSystemInfo.get("Registry")),
                        ordering: (0, _util.stringToPDFString)(cidSystemInfo.get("Ordering")),
                        supplement: cidSystemInfo.get("Supplement")
                      };
                    }
                    try {
                      const cidToGidMap = dict.get("CIDToGIDMap");
                      if (cidToGidMap instanceof _base_stream.BaseStream) {
                        cidToGidBytes = cidToGidMap.getBytes();
                      }
                    } catch (ex) {
                      if (!this.options.ignoreErrors) {
                        throw ex;
                      }
                      (0, _util.warn)(`extractDataStructures - ignoring CIDToGIDMap data: "${ex}".`);
                    }
                  }
                  const differences = [];
                  let baseEncodingName = null;
                  let encoding;
                  if (dict.has("Encoding")) {
                    encoding = dict.get("Encoding");
                    if (encoding instanceof _primitives.Dict) {
                      baseEncodingName = encoding.get("BaseEncoding");
                      baseEncodingName = baseEncodingName instanceof _primitives.Name ? baseEncodingName.name : null;
                      if (encoding.has("Differences")) {
                        const diffEncoding = encoding.get("Differences");
                        let index = 0;
                        for (const entry of diffEncoding) {
                          const data = xref.fetchIfRef(entry);
                          if (typeof data === "number") {
                            index = data;
                          } else if (data instanceof _primitives.Name) {
                            differences[index++] = data.name;
                          } else {
                            throw new _util.FormatError(`Invalid entry in 'Differences' array: ${data}`);
                          }
                        }
                      }
                    } else if (encoding instanceof _primitives.Name) {
                      baseEncodingName = encoding.name;
                    } else {
                      const msg = "Encoding is not a Name nor a Dict";
                      if (!this.options.ignoreErrors) {
                        throw new _util.FormatError(msg);
                      }
                      (0, _util.warn)(msg);
                    }
                    if (baseEncodingName !== "MacRomanEncoding" && baseEncodingName !== "MacExpertEncoding" && baseEncodingName !== "WinAnsiEncoding") {
                      baseEncodingName = null;
                    }
                  }
                  const nonEmbeddedFont = !properties.file || properties.isInternalFont, isSymbolsFontName = (0, _standard_fonts.getSymbolsFonts)()[properties.name];
                  if (baseEncodingName && nonEmbeddedFont && isSymbolsFontName) {
                    baseEncodingName = null;
                  }
                  if (baseEncodingName) {
                    properties.defaultEncoding = (0, _encodings.getEncoding)(baseEncodingName);
                  } else {
                    const isSymbolicFont = !!(properties.flags & _fonts_utils.FontFlags.Symbolic);
                    const isNonsymbolicFont = !!(properties.flags & _fonts_utils.FontFlags.Nonsymbolic);
                    encoding = _encodings.StandardEncoding;
                    if (properties.type === "TrueType" && !isNonsymbolicFont) {
                      encoding = _encodings.WinAnsiEncoding;
                    }
                    if (isSymbolicFont || isSymbolsFontName) {
                      encoding = _encodings.MacRomanEncoding;
                      if (nonEmbeddedFont) {
                        if (/Symbol/i.test(properties.name)) {
                          encoding = _encodings.SymbolSetEncoding;
                        } else if (/Dingbats/i.test(properties.name)) {
                          encoding = _encodings.ZapfDingbatsEncoding;
                        } else if (/Wingdings/i.test(properties.name)) {
                          encoding = _encodings.WinAnsiEncoding;
                        }
                      }
                    }
                    properties.defaultEncoding = encoding;
                  }
                  properties.differences = differences;
                  properties.baseEncodingName = baseEncodingName;
                  properties.hasEncoding = !!baseEncodingName || differences.length > 0;
                  properties.dict = dict;
                  return toUnicodePromise.then((readToUnicode) => {
                    properties.toUnicode = readToUnicode;
                    return this.buildToUnicode(properties);
                  }).then((builtToUnicode) => {
                    properties.toUnicode = builtToUnicode;
                    if (cidToGidBytes) {
                      properties.cidToGidMap = this.readCidToGidMap(cidToGidBytes, builtToUnicode);
                    }
                    return properties;
                  });
                }
                _simpleFontToUnicode(properties, forceGlyphs = false) {
                  (0, _util.assert)(!properties.composite, "Must be a simple font.");
                  const toUnicode = [];
                  const encoding = properties.defaultEncoding.slice();
                  const baseEncodingName = properties.baseEncodingName;
                  const differences = properties.differences;
                  for (const charcode in differences) {
                    const glyphName = differences[charcode];
                    if (glyphName === ".notdef") {
                      continue;
                    }
                    encoding[charcode] = glyphName;
                  }
                  const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                  for (const charcode in encoding) {
                    let glyphName = encoding[charcode];
                    if (glyphName === "") {
                      continue;
                    }
                    let unicode = glyphsUnicodeMap[glyphName];
                    if (unicode !== void 0) {
                      toUnicode[charcode] = String.fromCharCode(unicode);
                      continue;
                    }
                    let code = 0;
                    switch (glyphName[0]) {
                      case "G":
                        if (glyphName.length === 3) {
                          code = parseInt(glyphName.substring(1), 16);
                        }
                        break;
                      case "g":
                        if (glyphName.length === 5) {
                          code = parseInt(glyphName.substring(1), 16);
                        }
                        break;
                      case "C":
                      case "c":
                        if (glyphName.length >= 3 && glyphName.length <= 4) {
                          const codeStr = glyphName.substring(1);
                          if (forceGlyphs) {
                            code = parseInt(codeStr, 16);
                            break;
                          }
                          code = +codeStr;
                          if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
                            return this._simpleFontToUnicode(properties, true);
                          }
                        }
                        break;
                      case "u":
                        unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
                        if (unicode !== -1) {
                          code = unicode;
                        }
                        break;
                      default:
                        switch (glyphName) {
                          case "f_h":
                          case "f_t":
                          case "T_h":
                            toUnicode[charcode] = glyphName.replaceAll("_", "");
                            continue;
                        }
                        break;
                    }
                    if (code > 0 && code <= 1114111 && Number.isInteger(code)) {
                      if (baseEncodingName && code === +charcode) {
                        const baseEncoding = (0, _encodings.getEncoding)(baseEncodingName);
                        if (baseEncoding && (glyphName = baseEncoding[charcode])) {
                          toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
                          continue;
                        }
                      }
                      toUnicode[charcode] = String.fromCodePoint(code);
                    }
                  }
                  return toUnicode;
                }
                async buildToUnicode(properties) {
                  var _a;
                  properties.hasIncludedToUnicodeMap = ((_a = properties.toUnicode) == null ? void 0 : _a.length) > 0;
                  if (properties.hasIncludedToUnicodeMap) {
                    if (!properties.composite && properties.hasEncoding) {
                      properties.fallbackToUnicode = this._simpleFontToUnicode(properties);
                    }
                    return properties.toUnicode;
                  }
                  if (!properties.composite) {
                    return new _to_unicode_map.ToUnicodeMap(this._simpleFontToUnicode(properties));
                  }
                  if (properties.composite && (properties.cMap.builtInCMap && !(properties.cMap instanceof _cmap.IdentityCMap) || properties.cidSystemInfo.registry === "Adobe" && (properties.cidSystemInfo.ordering === "GB1" || properties.cidSystemInfo.ordering === "CNS1" || properties.cidSystemInfo.ordering === "Japan1" || properties.cidSystemInfo.ordering === "Korea1"))) {
                    const {
                      registry,
                      ordering
                    } = properties.cidSystemInfo;
                    const ucs2CMapName = _primitives.Name.get(`${registry}-${ordering}-UCS2`);
                    const ucs2CMap = await _cmap.CMapFactory.create({
                      encoding: ucs2CMapName,
                      fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                      useCMap: null
                    });
                    const toUnicode = [], buf = [];
                    properties.cMap.forEach(function(charcode, cid) {
                      if (cid > 65535) {
                        throw new _util.FormatError("Max size of CID is 65,535");
                      }
                      const ucs2 = ucs2CMap.lookup(cid);
                      if (ucs2) {
                        buf.length = 0;
                        for (let i = 0, ii = ucs2.length; i < ii; i += 2) {
                          buf.push((ucs2.charCodeAt(i) << 8) + ucs2.charCodeAt(i + 1));
                        }
                        toUnicode[charcode] = String.fromCharCode(...buf);
                      }
                    });
                    return new _to_unicode_map.ToUnicodeMap(toUnicode);
                  }
                  return new _to_unicode_map.IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
                }
                readToUnicode(cmapObj) {
                  if (!cmapObj) {
                    return Promise.resolve(null);
                  }
                  if (cmapObj instanceof _primitives.Name) {
                    return _cmap.CMapFactory.create({
                      encoding: cmapObj,
                      fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                      useCMap: null
                    }).then(function(cmap) {
                      if (cmap instanceof _cmap.IdentityCMap) {
                        return new _to_unicode_map.IdentityToUnicodeMap(0, 65535);
                      }
                      return new _to_unicode_map.ToUnicodeMap(cmap.getMap());
                    });
                  } else if (cmapObj instanceof _base_stream.BaseStream) {
                    return _cmap.CMapFactory.create({
                      encoding: cmapObj,
                      fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                      useCMap: null
                    }).then(function(cmap) {
                      if (cmap instanceof _cmap.IdentityCMap) {
                        return new _to_unicode_map.IdentityToUnicodeMap(0, 65535);
                      }
                      const map = new Array(cmap.length);
                      cmap.forEach(function(charCode, token) {
                        if (typeof token === "number") {
                          map[charCode] = String.fromCodePoint(token);
                          return;
                        }
                        const str = [];
                        for (let k = 0; k < token.length; k += 2) {
                          const w1 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
                          if ((w1 & 63488) !== 55296) {
                            str.push(w1);
                            continue;
                          }
                          k += 2;
                          const w2 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
                          str.push(((w1 & 1023) << 10) + (w2 & 1023) + 65536);
                        }
                        map[charCode] = String.fromCodePoint(...str);
                      });
                      return new _to_unicode_map.ToUnicodeMap(map);
                    }, (reason) => {
                      if (reason instanceof _util.AbortException) {
                        return null;
                      }
                      if (this.options.ignoreErrors) {
                        (0, _util.warn)(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
                        return null;
                      }
                      throw reason;
                    });
                  }
                  return Promise.resolve(null);
                }
                readCidToGidMap(glyphsData, toUnicode) {
                  const result = [];
                  for (let j = 0, jj = glyphsData.length; j < jj; j++) {
                    const glyphID = glyphsData[j++] << 8 | glyphsData[j];
                    const code = j >> 1;
                    if (glyphID === 0 && !toUnicode.has(code)) {
                      continue;
                    }
                    result[code] = glyphID;
                  }
                  return result;
                }
                extractWidths(dict, descriptor, properties) {
                  const xref = this.xref;
                  let glyphsWidths = [];
                  let defaultWidth = 0;
                  const glyphsVMetrics = [];
                  let defaultVMetrics;
                  let i, ii, j, jj, start, code, widths;
                  if (properties.composite) {
                    defaultWidth = dict.has("DW") ? dict.get("DW") : 1e3;
                    widths = dict.get("W");
                    if (widths) {
                      for (i = 0, ii = widths.length; i < ii; i++) {
                        start = xref.fetchIfRef(widths[i++]);
                        code = xref.fetchIfRef(widths[i]);
                        if (Array.isArray(code)) {
                          for (j = 0, jj = code.length; j < jj; j++) {
                            glyphsWidths[start++] = xref.fetchIfRef(code[j]);
                          }
                        } else {
                          const width = xref.fetchIfRef(widths[++i]);
                          for (j = start; j <= code; j++) {
                            glyphsWidths[j] = width;
                          }
                        }
                      }
                    }
                    if (properties.vertical) {
                      let vmetrics = dict.getArray("DW2") || [880, -1e3];
                      defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
                      vmetrics = dict.get("W2");
                      if (vmetrics) {
                        for (i = 0, ii = vmetrics.length; i < ii; i++) {
                          start = xref.fetchIfRef(vmetrics[i++]);
                          code = xref.fetchIfRef(vmetrics[i]);
                          if (Array.isArray(code)) {
                            for (j = 0, jj = code.length; j < jj; j++) {
                              glyphsVMetrics[start++] = [xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j])];
                            }
                          } else {
                            const vmetric = [xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i])];
                            for (j = start; j <= code; j++) {
                              glyphsVMetrics[j] = vmetric;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    const firstChar = properties.firstChar;
                    widths = dict.get("Widths");
                    if (widths) {
                      j = firstChar;
                      for (i = 0, ii = widths.length; i < ii; i++) {
                        glyphsWidths[j++] = xref.fetchIfRef(widths[i]);
                      }
                      defaultWidth = parseFloat(descriptor.get("MissingWidth")) || 0;
                    } else {
                      const baseFontName = dict.get("BaseFont");
                      if (baseFontName instanceof _primitives.Name) {
                        const metrics = this.getBaseFontMetrics(baseFontName.name);
                        glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
                        defaultWidth = metrics.defaultWidth;
                      }
                    }
                  }
                  let isMonospace = true;
                  let firstWidth = defaultWidth;
                  for (const glyph in glyphsWidths) {
                    const glyphWidth = glyphsWidths[glyph];
                    if (!glyphWidth) {
                      continue;
                    }
                    if (!firstWidth) {
                      firstWidth = glyphWidth;
                      continue;
                    }
                    if (firstWidth !== glyphWidth) {
                      isMonospace = false;
                      break;
                    }
                  }
                  if (isMonospace) {
                    properties.flags |= _fonts_utils.FontFlags.FixedPitch;
                  } else {
                    properties.flags &= ~_fonts_utils.FontFlags.FixedPitch;
                  }
                  properties.defaultWidth = defaultWidth;
                  properties.widths = glyphsWidths;
                  properties.defaultVMetrics = defaultVMetrics;
                  properties.vmetrics = glyphsVMetrics;
                }
                isSerifFont(baseFontName) {
                  const fontNameWoStyle = baseFontName.split("-")[0];
                  return fontNameWoStyle in (0, _standard_fonts.getSerifFonts)() || /serif/gi.test(fontNameWoStyle);
                }
                getBaseFontMetrics(name) {
                  let defaultWidth = 0;
                  let widths = /* @__PURE__ */ Object.create(null);
                  let monospace = false;
                  const stdFontMap = (0, _standard_fonts.getStdFontMap)();
                  let lookupName = stdFontMap[name] || name;
                  const Metrics = (0, _metrics.getMetrics)();
                  if (!(lookupName in Metrics)) {
                    lookupName = this.isSerifFont(name) ? "Times-Roman" : "Helvetica";
                  }
                  const glyphWidths = Metrics[lookupName];
                  if (typeof glyphWidths === "number") {
                    defaultWidth = glyphWidths;
                    monospace = true;
                  } else {
                    widths = glyphWidths();
                  }
                  return {
                    defaultWidth,
                    monospace,
                    widths
                  };
                }
                buildCharCodeToWidth(widthsByGlyphName, properties) {
                  const widths = /* @__PURE__ */ Object.create(null);
                  const differences = properties.differences;
                  const encoding = properties.defaultEncoding;
                  for (let charCode = 0; charCode < 256; charCode++) {
                    if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
                      widths[charCode] = widthsByGlyphName[differences[charCode]];
                      continue;
                    }
                    if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
                      widths[charCode] = widthsByGlyphName[encoding[charCode]];
                      continue;
                    }
                  }
                  return widths;
                }
                preEvaluateFont(dict) {
                  const baseDict = dict;
                  let type = dict.get("Subtype");
                  if (!(type instanceof _primitives.Name)) {
                    throw new _util.FormatError("invalid font Subtype");
                  }
                  let composite = false;
                  let hash, toUnicode;
                  if (type.name === "Type0") {
                    const df = dict.get("DescendantFonts");
                    if (!df) {
                      throw new _util.FormatError("Descendant fonts are not specified");
                    }
                    dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
                    if (!(dict instanceof _primitives.Dict)) {
                      throw new _util.FormatError("Descendant font is not a dictionary.");
                    }
                    type = dict.get("Subtype");
                    if (!(type instanceof _primitives.Name)) {
                      throw new _util.FormatError("invalid font Subtype");
                    }
                    composite = true;
                  }
                  const firstChar = dict.get("FirstChar") || 0, lastChar = dict.get("LastChar") || (composite ? 65535 : 255);
                  const descriptor = dict.get("FontDescriptor");
                  if (descriptor) {
                    hash = new _murmurhash.MurmurHash3_64();
                    const encoding = baseDict.getRaw("Encoding");
                    if (encoding instanceof _primitives.Name) {
                      hash.update(encoding.name);
                    } else if (encoding instanceof _primitives.Ref) {
                      hash.update(encoding.toString());
                    } else if (encoding instanceof _primitives.Dict) {
                      for (const entry of encoding.getRawValues()) {
                        if (entry instanceof _primitives.Name) {
                          hash.update(entry.name);
                        } else if (entry instanceof _primitives.Ref) {
                          hash.update(entry.toString());
                        } else if (Array.isArray(entry)) {
                          const diffLength = entry.length, diffBuf = new Array(diffLength);
                          for (let j = 0; j < diffLength; j++) {
                            const diffEntry = entry[j];
                            if (diffEntry instanceof _primitives.Name) {
                              diffBuf[j] = diffEntry.name;
                            } else if (typeof diffEntry === "number" || diffEntry instanceof _primitives.Ref) {
                              diffBuf[j] = diffEntry.toString();
                            }
                          }
                          hash.update(diffBuf.join());
                        }
                      }
                    }
                    hash.update(`${firstChar}-${lastChar}`);
                    toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
                    if (toUnicode instanceof _base_stream.BaseStream) {
                      const stream = toUnicode.str || toUnicode;
                      const uint8array = stream.buffer ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength) : new Uint8Array(stream.bytes.buffer, stream.start, stream.end - stream.start);
                      hash.update(uint8array);
                    } else if (toUnicode instanceof _primitives.Name) {
                      hash.update(toUnicode.name);
                    }
                    const widths = dict.get("Widths") || baseDict.get("Widths");
                    if (Array.isArray(widths)) {
                      const widthsBuf = [];
                      for (const entry of widths) {
                        if (typeof entry === "number" || entry instanceof _primitives.Ref) {
                          widthsBuf.push(entry.toString());
                        }
                      }
                      hash.update(widthsBuf.join());
                    }
                    if (composite) {
                      hash.update("compositeFont");
                      const compositeWidths = dict.get("W") || baseDict.get("W");
                      if (Array.isArray(compositeWidths)) {
                        const widthsBuf = [];
                        for (const entry of compositeWidths) {
                          if (typeof entry === "number" || entry instanceof _primitives.Ref) {
                            widthsBuf.push(entry.toString());
                          } else if (Array.isArray(entry)) {
                            const subWidthsBuf = [];
                            for (const element of entry) {
                              if (typeof element === "number" || element instanceof _primitives.Ref) {
                                subWidthsBuf.push(element.toString());
                              }
                            }
                            widthsBuf.push(`[${subWidthsBuf.join()}]`);
                          }
                        }
                        hash.update(widthsBuf.join());
                      }
                      const cidToGidMap = dict.getRaw("CIDToGIDMap") || baseDict.getRaw("CIDToGIDMap");
                      if (cidToGidMap instanceof _primitives.Name) {
                        hash.update(cidToGidMap.name);
                      } else if (cidToGidMap instanceof _primitives.Ref) {
                        hash.update(cidToGidMap.toString());
                      } else if (cidToGidMap instanceof _base_stream.BaseStream) {
                        hash.update(cidToGidMap.peekBytes());
                      }
                    }
                  }
                  return {
                    descriptor,
                    dict,
                    baseDict,
                    composite,
                    type: type.name,
                    firstChar,
                    lastChar,
                    toUnicode,
                    hash: hash ? hash.hexdigest() : ""
                  };
                }
                async translateFont({
                  descriptor,
                  dict,
                  baseDict,
                  composite,
                  type,
                  firstChar,
                  lastChar,
                  toUnicode,
                  cssFontInfo
                }) {
                  const isType3Font = type === "Type3";
                  let properties;
                  if (!descriptor) {
                    if (isType3Font) {
                      descriptor = new _primitives.Dict(null);
                      descriptor.set("FontName", _primitives.Name.get(type));
                      descriptor.set("FontBBox", dict.getArray("FontBBox") || [0, 0, 0, 0]);
                    } else {
                      let baseFontName = dict.get("BaseFont");
                      if (!(baseFontName instanceof _primitives.Name)) {
                        throw new _util.FormatError("Base font is not specified");
                      }
                      baseFontName = baseFontName.name.replaceAll(/[,_]/g, "-");
                      const metrics = this.getBaseFontMetrics(baseFontName);
                      const fontNameWoStyle = baseFontName.split("-")[0];
                      const flags = (this.isSerifFont(fontNameWoStyle) ? _fonts_utils.FontFlags.Serif : 0) | (metrics.monospace ? _fonts_utils.FontFlags.FixedPitch : 0) | ((0, _standard_fonts.getSymbolsFonts)()[fontNameWoStyle] ? _fonts_utils.FontFlags.Symbolic : _fonts_utils.FontFlags.Nonsymbolic);
                      properties = {
                        type,
                        name: baseFontName,
                        loadedName: baseDict.loadedName,
                        systemFontInfo: null,
                        widths: metrics.widths,
                        defaultWidth: metrics.defaultWidth,
                        isSimulatedFlags: true,
                        flags,
                        firstChar,
                        lastChar,
                        toUnicode,
                        xHeight: 0,
                        capHeight: 0,
                        italicAngle: 0,
                        isType3Font
                      };
                      const widths = dict.get("Widths");
                      const standardFontName = (0, _standard_fonts.getStandardFontName)(baseFontName);
                      let file = null;
                      if (standardFontName) {
                        file = await this.fetchStandardFontData(standardFontName);
                        properties.isInternalFont = !!file;
                      }
                      if (!properties.isInternalFont && this.options.useSystemFonts) {
                        properties.systemFontInfo = (0, _font_substitutions.getFontSubstitution)(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, baseFontName, standardFontName);
                      }
                      return this.extractDataStructures(dict, dict, properties).then((newProperties) => {
                        if (widths) {
                          const glyphWidths = [];
                          let j = firstChar;
                          for (const width of widths) {
                            glyphWidths[j++] = this.xref.fetchIfRef(width);
                          }
                          newProperties.widths = glyphWidths;
                        } else {
                          newProperties.widths = this.buildCharCodeToWidth(metrics.widths, newProperties);
                        }
                        return new _fonts.Font(baseFontName, file, newProperties);
                      });
                    }
                  }
                  let fontName = descriptor.get("FontName");
                  let baseFont = dict.get("BaseFont");
                  if (typeof fontName === "string") {
                    fontName = _primitives.Name.get(fontName);
                  }
                  if (typeof baseFont === "string") {
                    baseFont = _primitives.Name.get(baseFont);
                  }
                  const fontNameStr = fontName == null ? void 0 : fontName.name;
                  const baseFontStr = baseFont == null ? void 0 : baseFont.name;
                  if (!isType3Font && fontNameStr !== baseFontStr) {
                    (0, _util.info)(`The FontDescriptor's FontName is "${fontNameStr}" but should be the same as the Font's BaseFont "${baseFontStr}".`);
                    if (fontNameStr && baseFontStr && (baseFontStr.startsWith(fontNameStr) || !(0, _standard_fonts.isKnownFontName)(fontNameStr) && (0, _standard_fonts.isKnownFontName)(baseFontStr))) {
                      fontName = null;
                    }
                  }
                  fontName || (fontName = baseFont);
                  if (!(fontName instanceof _primitives.Name)) {
                    throw new _util.FormatError("invalid font name");
                  }
                  let fontFile, subtype, length1, length2, length3;
                  try {
                    fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
                  } catch (ex) {
                    if (!this.options.ignoreErrors) {
                      throw ex;
                    }
                    (0, _util.warn)(`translateFont - fetching "${fontName.name}" font file: "${ex}".`);
                    fontFile = new _stream.NullStream();
                  }
                  let isInternalFont = false;
                  let glyphScaleFactors = null;
                  let systemFontInfo = null;
                  if (fontFile) {
                    if (fontFile.dict) {
                      const subtypeEntry = fontFile.dict.get("Subtype");
                      if (subtypeEntry instanceof _primitives.Name) {
                        subtype = subtypeEntry.name;
                      }
                      length1 = fontFile.dict.get("Length1");
                      length2 = fontFile.dict.get("Length2");
                      length3 = fontFile.dict.get("Length3");
                    }
                  } else if (cssFontInfo) {
                    const standardFontName = (0, _xfa_fonts.getXfaFontName)(fontName.name);
                    if (standardFontName) {
                      cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`;
                      cssFontInfo.metrics = standardFontName.metrics || null;
                      glyphScaleFactors = standardFontName.factors || null;
                      fontFile = await this.fetchStandardFontData(standardFontName.name);
                      isInternalFont = !!fontFile;
                      baseDict = dict = (0, _xfa_fonts.getXfaFontDict)(fontName.name);
                      composite = true;
                    }
                  } else if (!isType3Font) {
                    const standardFontName = (0, _standard_fonts.getStandardFontName)(fontName.name);
                    if (standardFontName) {
                      fontFile = await this.fetchStandardFontData(standardFontName);
                      isInternalFont = !!fontFile;
                    }
                    if (!isInternalFont && this.options.useSystemFonts) {
                      systemFontInfo = (0, _font_substitutions.getFontSubstitution)(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, fontName.name, standardFontName);
                    }
                  }
                  properties = {
                    type,
                    name: fontName.name,
                    subtype,
                    file: fontFile,
                    length1,
                    length2,
                    length3,
                    isInternalFont,
                    loadedName: baseDict.loadedName,
                    composite,
                    fixedPitch: false,
                    fontMatrix: dict.getArray("FontMatrix") || _util.FONT_IDENTITY_MATRIX,
                    firstChar,
                    lastChar,
                    toUnicode,
                    bbox: descriptor.getArray("FontBBox") || dict.getArray("FontBBox"),
                    ascent: descriptor.get("Ascent"),
                    descent: descriptor.get("Descent"),
                    xHeight: descriptor.get("XHeight") || 0,
                    capHeight: descriptor.get("CapHeight") || 0,
                    flags: descriptor.get("Flags"),
                    italicAngle: descriptor.get("ItalicAngle") || 0,
                    isType3Font,
                    cssFontInfo,
                    scaleFactors: glyphScaleFactors,
                    systemFontInfo
                  };
                  if (composite) {
                    const cidEncoding = baseDict.get("Encoding");
                    if (cidEncoding instanceof _primitives.Name) {
                      properties.cidEncoding = cidEncoding.name;
                    }
                    const cMap = await _cmap.CMapFactory.create({
                      encoding: cidEncoding,
                      fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                      useCMap: null
                    });
                    properties.cMap = cMap;
                    properties.vertical = properties.cMap.vertical;
                  }
                  return this.extractDataStructures(dict, baseDict, properties).then((newProperties) => {
                    this.extractWidths(dict, descriptor, newProperties);
                    return new _fonts.Font(fontName.name, fontFile, newProperties);
                  });
                }
                static buildFontPaths(font, glyphs, handler, evaluatorOptions) {
                  function buildPath(fontChar) {
                    const glyphName = `${font.loadedName}_path_${fontChar}`;
                    try {
                      if (font.renderer.hasBuiltPath(fontChar)) {
                        return;
                      }
                      handler.send("commonobj", [glyphName, "FontPath", font.renderer.getPathJs(fontChar)]);
                    } catch (reason) {
                      if (evaluatorOptions.ignoreErrors) {
                        (0, _util.warn)(`buildFontPaths - ignoring ${glyphName} glyph: "${reason}".`);
                        return;
                      }
                      throw reason;
                    }
                  }
                  for (const glyph of glyphs) {
                    buildPath(glyph.fontChar);
                    const accent = glyph.accent;
                    if (accent == null ? void 0 : accent.fontChar) {
                      buildPath(accent.fontChar);
                    }
                  }
                }
                static get fallbackFontDict() {
                  const dict = new _primitives.Dict();
                  dict.set("BaseFont", _primitives.Name.get("Helvetica"));
                  dict.set("Type", _primitives.Name.get("FallbackType"));
                  dict.set("Subtype", _primitives.Name.get("FallbackType"));
                  dict.set("Encoding", _primitives.Name.get("WinAnsiEncoding"));
                  return (0, _util.shadow)(this, "fallbackFontDict", dict);
                }
              }
              exports2.PartialEvaluator = PartialEvaluator;
              class TranslatedFont {
                constructor({
                  loadedName,
                  font,
                  dict,
                  evaluatorOptions
                }) {
                  this.loadedName = loadedName;
                  this.font = font;
                  this.dict = dict;
                  this._evaluatorOptions = evaluatorOptions || DefaultPartialEvaluatorOptions;
                  this.type3Loaded = null;
                  this.type3Dependencies = font.isType3Font ? /* @__PURE__ */ new Set() : null;
                  this.sent = false;
                }
                send(handler) {
                  if (this.sent) {
                    return;
                  }
                  this.sent = true;
                  handler.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]);
                }
                fallback(handler) {
                  if (!this.font.data) {
                    return;
                  }
                  this.font.disableFontFace = true;
                  PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, handler, this._evaluatorOptions);
                }
                loadType3Data(evaluator, resources, task) {
                  if (this.type3Loaded) {
                    return this.type3Loaded;
                  }
                  if (!this.font.isType3Font) {
                    throw new Error("Must be a Type3 font.");
                  }
                  const type3Evaluator = evaluator.clone({
                    ignoreErrors: false
                  });
                  type3Evaluator.parsingType3Font = true;
                  const type3FontRefs = new _primitives.RefSet(evaluator.type3FontRefs);
                  if (this.dict.objId && !type3FontRefs.has(this.dict.objId)) {
                    type3FontRefs.put(this.dict.objId);
                  }
                  type3Evaluator.type3FontRefs = type3FontRefs;
                  const translatedFont = this.font, type3Dependencies = this.type3Dependencies;
                  let loadCharProcsPromise = Promise.resolve();
                  const charProcs = this.dict.get("CharProcs");
                  const fontResources = this.dict.get("Resources") || resources;
                  const charProcOperatorList = /* @__PURE__ */ Object.create(null);
                  const fontBBox = _util.Util.normalizeRect(translatedFont.bbox || [0, 0, 0, 0]), width = fontBBox[2] - fontBBox[0], height = fontBBox[3] - fontBBox[1];
                  const fontBBoxSize = Math.hypot(width, height);
                  for (const key of charProcs.getKeys()) {
                    loadCharProcsPromise = loadCharProcsPromise.then(() => {
                      const glyphStream = charProcs.get(key);
                      const operatorList = new _operator_list.OperatorList();
                      return type3Evaluator.getOperatorList({
                        stream: glyphStream,
                        task,
                        resources: fontResources,
                        operatorList
                      }).then(() => {
                        if (operatorList.fnArray[0] === _util.OPS.setCharWidthAndBounds) {
                          this._removeType3ColorOperators(operatorList, fontBBoxSize);
                        }
                        charProcOperatorList[key] = operatorList.getIR();
                        for (const dependency of operatorList.dependencies) {
                          type3Dependencies.add(dependency);
                        }
                      }).catch(function(reason) {
                        (0, _util.warn)(`Type3 font resource "${key}" is not available.`);
                        const dummyOperatorList = new _operator_list.OperatorList();
                        charProcOperatorList[key] = dummyOperatorList.getIR();
                      });
                    });
                  }
                  this.type3Loaded = loadCharProcsPromise.then(() => {
                    translatedFont.charProcOperatorList = charProcOperatorList;
                    if (this._bbox) {
                      translatedFont.isCharBBox = true;
                      translatedFont.bbox = this._bbox;
                    }
                  });
                  return this.type3Loaded;
                }
                _removeType3ColorOperators(operatorList, fontBBoxSize = NaN) {
                  const charBBox = _util.Util.normalizeRect(operatorList.argsArray[0].slice(2)), width = charBBox[2] - charBBox[0], height = charBBox[3] - charBBox[1];
                  const charBBoxSize = Math.hypot(width, height);
                  if (width === 0 || height === 0) {
                    operatorList.fnArray.splice(0, 1);
                    operatorList.argsArray.splice(0, 1);
                  } else if (fontBBoxSize === 0 || Math.round(charBBoxSize / fontBBoxSize) >= 10) {
                    if (!this._bbox) {
                      this._bbox = [Infinity, Infinity, -Infinity, -Infinity];
                    }
                    this._bbox[0] = Math.min(this._bbox[0], charBBox[0]);
                    this._bbox[1] = Math.min(this._bbox[1], charBBox[1]);
                    this._bbox[2] = Math.max(this._bbox[2], charBBox[2]);
                    this._bbox[3] = Math.max(this._bbox[3], charBBox[3]);
                  }
                  let i = 0, ii = operatorList.length;
                  while (i < ii) {
                    switch (operatorList.fnArray[i]) {
                      case _util.OPS.setCharWidthAndBounds:
                        break;
                      case _util.OPS.setStrokeColorSpace:
                      case _util.OPS.setFillColorSpace:
                      case _util.OPS.setStrokeColor:
                      case _util.OPS.setStrokeColorN:
                      case _util.OPS.setFillColor:
                      case _util.OPS.setFillColorN:
                      case _util.OPS.setStrokeGray:
                      case _util.OPS.setFillGray:
                      case _util.OPS.setStrokeRGBColor:
                      case _util.OPS.setFillRGBColor:
                      case _util.OPS.setStrokeCMYKColor:
                      case _util.OPS.setFillCMYKColor:
                      case _util.OPS.shadingFill:
                      case _util.OPS.setRenderingIntent:
                        operatorList.fnArray.splice(i, 1);
                        operatorList.argsArray.splice(i, 1);
                        ii--;
                        continue;
                      case _util.OPS.setGState:
                        const [gStateObj] = operatorList.argsArray[i];
                        let j = 0, jj = gStateObj.length;
                        while (j < jj) {
                          const [gStateKey] = gStateObj[j];
                          switch (gStateKey) {
                            case "TR":
                            case "TR2":
                            case "HT":
                            case "BG":
                            case "BG2":
                            case "UCR":
                            case "UCR2":
                              gStateObj.splice(j, 1);
                              jj--;
                              continue;
                          }
                          j++;
                        }
                        break;
                    }
                    i++;
                  }
                }
              }
              class StateManager {
                constructor(initialState = new EvalState()) {
                  this.state = initialState;
                  this.stateStack = [];
                }
                save() {
                  const old = this.state;
                  this.stateStack.push(this.state);
                  this.state = old.clone();
                }
                restore() {
                  const prev = this.stateStack.pop();
                  if (prev) {
                    this.state = prev;
                  }
                }
                transform(args) {
                  this.state.ctm = _util.Util.transform(this.state.ctm, args);
                }
              }
              class TextState {
                constructor() {
                  this.ctm = new Float32Array(_util.IDENTITY_MATRIX);
                  this.fontName = null;
                  this.fontSize = 0;
                  this.loadedName = null;
                  this.font = null;
                  this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
                  this.textMatrix = _util.IDENTITY_MATRIX.slice();
                  this.textLineMatrix = _util.IDENTITY_MATRIX.slice();
                  this.charSpacing = 0;
                  this.wordSpacing = 0;
                  this.leading = 0;
                  this.textHScale = 1;
                  this.textRise = 0;
                }
                setTextMatrix(a, b, c, d, e, f) {
                  const m = this.textMatrix;
                  m[0] = a;
                  m[1] = b;
                  m[2] = c;
                  m[3] = d;
                  m[4] = e;
                  m[5] = f;
                }
                setTextLineMatrix(a, b, c, d, e, f) {
                  const m = this.textLineMatrix;
                  m[0] = a;
                  m[1] = b;
                  m[2] = c;
                  m[3] = d;
                  m[4] = e;
                  m[5] = f;
                }
                translateTextMatrix(x, y) {
                  const m = this.textMatrix;
                  m[4] = m[0] * x + m[2] * y + m[4];
                  m[5] = m[1] * x + m[3] * y + m[5];
                }
                translateTextLineMatrix(x, y) {
                  const m = this.textLineMatrix;
                  m[4] = m[0] * x + m[2] * y + m[4];
                  m[5] = m[1] * x + m[3] * y + m[5];
                }
                carriageReturn() {
                  this.translateTextLineMatrix(0, -this.leading);
                  this.textMatrix = this.textLineMatrix.slice();
                }
                clone() {
                  const clone = Object.create(this);
                  clone.textMatrix = this.textMatrix.slice();
                  clone.textLineMatrix = this.textLineMatrix.slice();
                  clone.fontMatrix = this.fontMatrix.slice();
                  return clone;
                }
              }
              class EvalState {
                constructor() {
                  this.ctm = new Float32Array(_util.IDENTITY_MATRIX);
                  this.font = null;
                  this.textRenderingMode = _util.TextRenderingMode.FILL;
                  this.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
                  this.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
                }
                clone() {
                  return Object.create(this);
                }
              }
              const _EvaluatorPreprocessor = class _EvaluatorPreprocessor {
                static get opMap() {
                  return (0, _util.shadow)(this, "opMap", {
                    w: {
                      id: _util.OPS.setLineWidth,
                      numArgs: 1,
                      variableArgs: false
                    },
                    J: {
                      id: _util.OPS.setLineCap,
                      numArgs: 1,
                      variableArgs: false
                    },
                    j: {
                      id: _util.OPS.setLineJoin,
                      numArgs: 1,
                      variableArgs: false
                    },
                    M: {
                      id: _util.OPS.setMiterLimit,
                      numArgs: 1,
                      variableArgs: false
                    },
                    d: {
                      id: _util.OPS.setDash,
                      numArgs: 2,
                      variableArgs: false
                    },
                    ri: {
                      id: _util.OPS.setRenderingIntent,
                      numArgs: 1,
                      variableArgs: false
                    },
                    i: {
                      id: _util.OPS.setFlatness,
                      numArgs: 1,
                      variableArgs: false
                    },
                    gs: {
                      id: _util.OPS.setGState,
                      numArgs: 1,
                      variableArgs: false
                    },
                    q: {
                      id: _util.OPS.save,
                      numArgs: 0,
                      variableArgs: false
                    },
                    Q: {
                      id: _util.OPS.restore,
                      numArgs: 0,
                      variableArgs: false
                    },
                    cm: {
                      id: _util.OPS.transform,
                      numArgs: 6,
                      variableArgs: false
                    },
                    m: {
                      id: _util.OPS.moveTo,
                      numArgs: 2,
                      variableArgs: false
                    },
                    l: {
                      id: _util.OPS.lineTo,
                      numArgs: 2,
                      variableArgs: false
                    },
                    c: {
                      id: _util.OPS.curveTo,
                      numArgs: 6,
                      variableArgs: false
                    },
                    v: {
                      id: _util.OPS.curveTo2,
                      numArgs: 4,
                      variableArgs: false
                    },
                    y: {
                      id: _util.OPS.curveTo3,
                      numArgs: 4,
                      variableArgs: false
                    },
                    h: {
                      id: _util.OPS.closePath,
                      numArgs: 0,
                      variableArgs: false
                    },
                    re: {
                      id: _util.OPS.rectangle,
                      numArgs: 4,
                      variableArgs: false
                    },
                    S: {
                      id: _util.OPS.stroke,
                      numArgs: 0,
                      variableArgs: false
                    },
                    s: {
                      id: _util.OPS.closeStroke,
                      numArgs: 0,
                      variableArgs: false
                    },
                    f: {
                      id: _util.OPS.fill,
                      numArgs: 0,
                      variableArgs: false
                    },
                    F: {
                      id: _util.OPS.fill,
                      numArgs: 0,
                      variableArgs: false
                    },
                    "f*": {
                      id: _util.OPS.eoFill,
                      numArgs: 0,
                      variableArgs: false
                    },
                    B: {
                      id: _util.OPS.fillStroke,
                      numArgs: 0,
                      variableArgs: false
                    },
                    "B*": {
                      id: _util.OPS.eoFillStroke,
                      numArgs: 0,
                      variableArgs: false
                    },
                    b: {
                      id: _util.OPS.closeFillStroke,
                      numArgs: 0,
                      variableArgs: false
                    },
                    "b*": {
                      id: _util.OPS.closeEOFillStroke,
                      numArgs: 0,
                      variableArgs: false
                    },
                    n: {
                      id: _util.OPS.endPath,
                      numArgs: 0,
                      variableArgs: false
                    },
                    W: {
                      id: _util.OPS.clip,
                      numArgs: 0,
                      variableArgs: false
                    },
                    "W*": {
                      id: _util.OPS.eoClip,
                      numArgs: 0,
                      variableArgs: false
                    },
                    BT: {
                      id: _util.OPS.beginText,
                      numArgs: 0,
                      variableArgs: false
                    },
                    ET: {
                      id: _util.OPS.endText,
                      numArgs: 0,
                      variableArgs: false
                    },
                    Tc: {
                      id: _util.OPS.setCharSpacing,
                      numArgs: 1,
                      variableArgs: false
                    },
                    Tw: {
                      id: _util.OPS.setWordSpacing,
                      numArgs: 1,
                      variableArgs: false
                    },
                    Tz: {
                      id: _util.OPS.setHScale,
                      numArgs: 1,
                      variableArgs: false
                    },
                    TL: {
                      id: _util.OPS.setLeading,
                      numArgs: 1,
                      variableArgs: false
                    },
                    Tf: {
                      id: _util.OPS.setFont,
                      numArgs: 2,
                      variableArgs: false
                    },
                    Tr: {
                      id: _util.OPS.setTextRenderingMode,
                      numArgs: 1,
                      variableArgs: false
                    },
                    Ts: {
                      id: _util.OPS.setTextRise,
                      numArgs: 1,
                      variableArgs: false
                    },
                    Td: {
                      id: _util.OPS.moveText,
                      numArgs: 2,
                      variableArgs: false
                    },
                    TD: {
                      id: _util.OPS.setLeadingMoveText,
                      numArgs: 2,
                      variableArgs: false
                    },
                    Tm: {
                      id: _util.OPS.setTextMatrix,
                      numArgs: 6,
                      variableArgs: false
                    },
                    "T*": {
                      id: _util.OPS.nextLine,
                      numArgs: 0,
                      variableArgs: false
                    },
                    Tj: {
                      id: _util.OPS.showText,
                      numArgs: 1,
                      variableArgs: false
                    },
                    TJ: {
                      id: _util.OPS.showSpacedText,
                      numArgs: 1,
                      variableArgs: false
                    },
                    "'": {
                      id: _util.OPS.nextLineShowText,
                      numArgs: 1,
                      variableArgs: false
                    },
                    '"': {
                      id: _util.OPS.nextLineSetSpacingShowText,
                      numArgs: 3,
                      variableArgs: false
                    },
                    d0: {
                      id: _util.OPS.setCharWidth,
                      numArgs: 2,
                      variableArgs: false
                    },
                    d1: {
                      id: _util.OPS.setCharWidthAndBounds,
                      numArgs: 6,
                      variableArgs: false
                    },
                    CS: {
                      id: _util.OPS.setStrokeColorSpace,
                      numArgs: 1,
                      variableArgs: false
                    },
                    cs: {
                      id: _util.OPS.setFillColorSpace,
                      numArgs: 1,
                      variableArgs: false
                    },
                    SC: {
                      id: _util.OPS.setStrokeColor,
                      numArgs: 4,
                      variableArgs: true
                    },
                    SCN: {
                      id: _util.OPS.setStrokeColorN,
                      numArgs: 33,
                      variableArgs: true
                    },
                    sc: {
                      id: _util.OPS.setFillColor,
                      numArgs: 4,
                      variableArgs: true
                    },
                    scn: {
                      id: _util.OPS.setFillColorN,
                      numArgs: 33,
                      variableArgs: true
                    },
                    G: {
                      id: _util.OPS.setStrokeGray,
                      numArgs: 1,
                      variableArgs: false
                    },
                    g: {
                      id: _util.OPS.setFillGray,
                      numArgs: 1,
                      variableArgs: false
                    },
                    RG: {
                      id: _util.OPS.setStrokeRGBColor,
                      numArgs: 3,
                      variableArgs: false
                    },
                    rg: {
                      id: _util.OPS.setFillRGBColor,
                      numArgs: 3,
                      variableArgs: false
                    },
                    K: {
                      id: _util.OPS.setStrokeCMYKColor,
                      numArgs: 4,
                      variableArgs: false
                    },
                    k: {
                      id: _util.OPS.setFillCMYKColor,
                      numArgs: 4,
                      variableArgs: false
                    },
                    sh: {
                      id: _util.OPS.shadingFill,
                      numArgs: 1,
                      variableArgs: false
                    },
                    BI: {
                      id: _util.OPS.beginInlineImage,
                      numArgs: 0,
                      variableArgs: false
                    },
                    ID: {
                      id: _util.OPS.beginImageData,
                      numArgs: 0,
                      variableArgs: false
                    },
                    EI: {
                      id: _util.OPS.endInlineImage,
                      numArgs: 1,
                      variableArgs: false
                    },
                    Do: {
                      id: _util.OPS.paintXObject,
                      numArgs: 1,
                      variableArgs: false
                    },
                    MP: {
                      id: _util.OPS.markPoint,
                      numArgs: 1,
                      variableArgs: false
                    },
                    DP: {
                      id: _util.OPS.markPointProps,
                      numArgs: 2,
                      variableArgs: false
                    },
                    BMC: {
                      id: _util.OPS.beginMarkedContent,
                      numArgs: 1,
                      variableArgs: false
                    },
                    BDC: {
                      id: _util.OPS.beginMarkedContentProps,
                      numArgs: 2,
                      variableArgs: false
                    },
                    EMC: {
                      id: _util.OPS.endMarkedContent,
                      numArgs: 0,
                      variableArgs: false
                    },
                    BX: {
                      id: _util.OPS.beginCompat,
                      numArgs: 0,
                      variableArgs: false
                    },
                    EX: {
                      id: _util.OPS.endCompat,
                      numArgs: 0,
                      variableArgs: false
                    },
                    BM: null,
                    BD: null,
                    true: null,
                    fa: null,
                    fal: null,
                    fals: null,
                    false: null,
                    nu: null,
                    nul: null,
                    null: null
                  });
                }
                constructor(stream, xref, stateManager = new StateManager()) {
                  this.parser = new _parser.Parser({
                    lexer: new _parser.Lexer(stream, _EvaluatorPreprocessor.opMap),
                    xref
                  });
                  this.stateManager = stateManager;
                  this.nonProcessedArgs = [];
                  this._isPathOp = false;
                  this._numInvalidPathOPS = 0;
                }
                get savedStatesDepth() {
                  return this.stateManager.stateStack.length;
                }
                read(operation) {
                  let args = operation.args;
                  while (true) {
                    const obj = this.parser.getObj();
                    if (obj instanceof _primitives.Cmd) {
                      const cmd = obj.cmd;
                      const opSpec = _EvaluatorPreprocessor.opMap[cmd];
                      if (!opSpec) {
                        (0, _util.warn)(`Unknown command "${cmd}".`);
                        continue;
                      }
                      const fn = opSpec.id;
                      const numArgs = opSpec.numArgs;
                      let argsLength = args !== null ? args.length : 0;
                      if (!this._isPathOp) {
                        this._numInvalidPathOPS = 0;
                      }
                      this._isPathOp = fn >= _util.OPS.moveTo && fn <= _util.OPS.endPath;
                      if (!opSpec.variableArgs) {
                        if (argsLength !== numArgs) {
                          const nonProcessedArgs = this.nonProcessedArgs;
                          while (argsLength > numArgs) {
                            nonProcessedArgs.push(args.shift());
                            argsLength--;
                          }
                          while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
                            if (args === null) {
                              args = [];
                            }
                            args.unshift(nonProcessedArgs.pop());
                            argsLength++;
                          }
                        }
                        if (argsLength < numArgs) {
                          const partialMsg = `command ${cmd}: expected ${numArgs} args, but received ${argsLength} args.`;
                          if (this._isPathOp && ++this._numInvalidPathOPS > _EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) {
                            throw new _util.FormatError(`Invalid ${partialMsg}`);
                          }
                          (0, _util.warn)(`Skipping ${partialMsg}`);
                          if (args !== null) {
                            args.length = 0;
                          }
                          continue;
                        }
                      } else if (argsLength > numArgs) {
                        (0, _util.info)(`Command ${cmd}: expected [0, ${numArgs}] args, but received ${argsLength} args.`);
                      }
                      this.preprocessCommand(fn, args);
                      operation.fn = fn;
                      operation.args = args;
                      return true;
                    }
                    if (obj === _primitives.EOF) {
                      return false;
                    }
                    if (obj !== null) {
                      if (args === null) {
                        args = [];
                      }
                      args.push(obj);
                      if (args.length > 33) {
                        throw new _util.FormatError("Too many arguments");
                      }
                    }
                  }
                }
                preprocessCommand(fn, args) {
                  switch (fn | 0) {
                    case _util.OPS.save:
                      this.stateManager.save();
                      break;
                    case _util.OPS.restore:
                      this.stateManager.restore();
                      break;
                    case _util.OPS.transform:
                      this.stateManager.transform(args);
                      break;
                  }
                }
              };
              __publicField(_EvaluatorPreprocessor, "MAX_INVALID_PATH_OPS", 10);
              let EvaluatorPreprocessor = _EvaluatorPreprocessor;
              exports2.EvaluatorPreprocessor = EvaluatorPreprocessor;
            },
            /* 14 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.IdentityCMap = exports2.CMapFactory = exports2.CMap = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(4);
              var _base_stream = __w_pdfjs_require__2(5);
              var _binary_cmap = __w_pdfjs_require__2(15);
              var _parser = __w_pdfjs_require__2(16);
              var _core_utils = __w_pdfjs_require__2(3);
              var _stream = __w_pdfjs_require__2(8);
              const BUILT_IN_CMAPS = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"];
              const MAX_MAP_RANGE = 2 ** 24 - 1;
              class CMap {
                constructor(builtInCMap = false) {
                  this.codespaceRanges = [[], [], [], []];
                  this.numCodespaceRanges = 0;
                  this._map = [];
                  this.name = "";
                  this.vertical = false;
                  this.useCMap = null;
                  this.builtInCMap = builtInCMap;
                }
                addCodespaceRange(n, low, high) {
                  this.codespaceRanges[n - 1].push(low, high);
                  this.numCodespaceRanges++;
                }
                mapCidRange(low, high, dstLow) {
                  if (high - low > MAX_MAP_RANGE) {
                    throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
                  }
                  while (low <= high) {
                    this._map[low++] = dstLow++;
                  }
                }
                mapBfRange(low, high, dstLow) {
                  if (high - low > MAX_MAP_RANGE) {
                    throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
                  }
                  const lastByte = dstLow.length - 1;
                  while (low <= high) {
                    this._map[low++] = dstLow;
                    const nextCharCode = dstLow.charCodeAt(lastByte) + 1;
                    if (nextCharCode > 255) {
                      dstLow = dstLow.substring(0, lastByte - 1) + String.fromCharCode(dstLow.charCodeAt(lastByte - 1) + 1) + "\0";
                      continue;
                    }
                    dstLow = dstLow.substring(0, lastByte) + String.fromCharCode(nextCharCode);
                  }
                }
                mapBfRangeToArray(low, high, array) {
                  if (high - low > MAX_MAP_RANGE) {
                    throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
                  }
                  const ii = array.length;
                  let i = 0;
                  while (low <= high && i < ii) {
                    this._map[low] = array[i++];
                    ++low;
                  }
                }
                mapOne(src, dst) {
                  this._map[src] = dst;
                }
                lookup(code) {
                  return this._map[code];
                }
                contains(code) {
                  return this._map[code] !== void 0;
                }
                forEach(callback) {
                  const map = this._map;
                  const length = map.length;
                  if (length <= 65536) {
                    for (let i = 0; i < length; i++) {
                      if (map[i] !== void 0) {
                        callback(i, map[i]);
                      }
                    }
                  } else {
                    for (const i in map) {
                      callback(i, map[i]);
                    }
                  }
                }
                charCodeOf(value) {
                  const map = this._map;
                  if (map.length <= 65536) {
                    return map.indexOf(value);
                  }
                  for (const charCode in map) {
                    if (map[charCode] === value) {
                      return charCode | 0;
                    }
                  }
                  return -1;
                }
                getMap() {
                  return this._map;
                }
                readCharCode(str, offset, out) {
                  let c = 0;
                  const codespaceRanges = this.codespaceRanges;
                  for (let n = 0, nn = codespaceRanges.length; n < nn; n++) {
                    c = (c << 8 | str.charCodeAt(offset + n)) >>> 0;
                    const codespaceRange = codespaceRanges[n];
                    for (let k = 0, kk = codespaceRange.length; k < kk; ) {
                      const low = codespaceRange[k++];
                      const high = codespaceRange[k++];
                      if (c >= low && c <= high) {
                        out.charcode = c;
                        out.length = n + 1;
                        return;
                      }
                    }
                  }
                  out.charcode = 0;
                  out.length = 1;
                }
                getCharCodeLength(charCode) {
                  const codespaceRanges = this.codespaceRanges;
                  for (let n = 0, nn = codespaceRanges.length; n < nn; n++) {
                    const codespaceRange = codespaceRanges[n];
                    for (let k = 0, kk = codespaceRange.length; k < kk; ) {
                      const low = codespaceRange[k++];
                      const high = codespaceRange[k++];
                      if (charCode >= low && charCode <= high) {
                        return n + 1;
                      }
                    }
                  }
                  return 1;
                }
                get length() {
                  return this._map.length;
                }
                get isIdentityCMap() {
                  if (!(this.name === "Identity-H" || this.name === "Identity-V")) {
                    return false;
                  }
                  if (this._map.length !== 65536) {
                    return false;
                  }
                  for (let i = 0; i < 65536; i++) {
                    if (this._map[i] !== i) {
                      return false;
                    }
                  }
                  return true;
                }
              }
              exports2.CMap = CMap;
              class IdentityCMap extends CMap {
                constructor(vertical, n) {
                  super();
                  this.vertical = vertical;
                  this.addCodespaceRange(n, 0, 65535);
                }
                mapCidRange(low, high, dstLow) {
                  (0, _util.unreachable)("should not call mapCidRange");
                }
                mapBfRange(low, high, dstLow) {
                  (0, _util.unreachable)("should not call mapBfRange");
                }
                mapBfRangeToArray(low, high, array) {
                  (0, _util.unreachable)("should not call mapBfRangeToArray");
                }
                mapOne(src, dst) {
                  (0, _util.unreachable)("should not call mapCidOne");
                }
                lookup(code) {
                  return Number.isInteger(code) && code <= 65535 ? code : void 0;
                }
                contains(code) {
                  return Number.isInteger(code) && code <= 65535;
                }
                forEach(callback) {
                  for (let i = 0; i <= 65535; i++) {
                    callback(i, i);
                  }
                }
                charCodeOf(value) {
                  return Number.isInteger(value) && value <= 65535 ? value : -1;
                }
                getMap() {
                  const map = new Array(65536);
                  for (let i = 0; i <= 65535; i++) {
                    map[i] = i;
                  }
                  return map;
                }
                get length() {
                  return 65536;
                }
                get isIdentityCMap() {
                  (0, _util.unreachable)("should not access .isIdentityCMap");
                }
              }
              exports2.IdentityCMap = IdentityCMap;
              function strToInt(str) {
                let a = 0;
                for (let i = 0; i < str.length; i++) {
                  a = a << 8 | str.charCodeAt(i);
                }
                return a >>> 0;
              }
              function expectString(obj) {
                if (typeof obj !== "string") {
                  throw new _util.FormatError("Malformed CMap: expected string.");
                }
              }
              function expectInt(obj) {
                if (!Number.isInteger(obj)) {
                  throw new _util.FormatError("Malformed CMap: expected int.");
                }
              }
              function parseBfChar(cMap, lexer) {
                while (true) {
                  let obj = lexer.getObj();
                  if (obj === _primitives.EOF) {
                    break;
                  }
                  if ((0, _primitives.isCmd)(obj, "endbfchar")) {
                    return;
                  }
                  expectString(obj);
                  const src = strToInt(obj);
                  obj = lexer.getObj();
                  expectString(obj);
                  const dst = obj;
                  cMap.mapOne(src, dst);
                }
              }
              function parseBfRange(cMap, lexer) {
                while (true) {
                  let obj = lexer.getObj();
                  if (obj === _primitives.EOF) {
                    break;
                  }
                  if ((0, _primitives.isCmd)(obj, "endbfrange")) {
                    return;
                  }
                  expectString(obj);
                  const low = strToInt(obj);
                  obj = lexer.getObj();
                  expectString(obj);
                  const high = strToInt(obj);
                  obj = lexer.getObj();
                  if (Number.isInteger(obj) || typeof obj === "string") {
                    const dstLow = Number.isInteger(obj) ? String.fromCharCode(obj) : obj;
                    cMap.mapBfRange(low, high, dstLow);
                  } else if ((0, _primitives.isCmd)(obj, "[")) {
                    obj = lexer.getObj();
                    const array = [];
                    while (!(0, _primitives.isCmd)(obj, "]") && obj !== _primitives.EOF) {
                      array.push(obj);
                      obj = lexer.getObj();
                    }
                    cMap.mapBfRangeToArray(low, high, array);
                  } else {
                    break;
                  }
                }
                throw new _util.FormatError("Invalid bf range.");
              }
              function parseCidChar(cMap, lexer) {
                while (true) {
                  let obj = lexer.getObj();
                  if (obj === _primitives.EOF) {
                    break;
                  }
                  if ((0, _primitives.isCmd)(obj, "endcidchar")) {
                    return;
                  }
                  expectString(obj);
                  const src = strToInt(obj);
                  obj = lexer.getObj();
                  expectInt(obj);
                  const dst = obj;
                  cMap.mapOne(src, dst);
                }
              }
              function parseCidRange(cMap, lexer) {
                while (true) {
                  let obj = lexer.getObj();
                  if (obj === _primitives.EOF) {
                    break;
                  }
                  if ((0, _primitives.isCmd)(obj, "endcidrange")) {
                    return;
                  }
                  expectString(obj);
                  const low = strToInt(obj);
                  obj = lexer.getObj();
                  expectString(obj);
                  const high = strToInt(obj);
                  obj = lexer.getObj();
                  expectInt(obj);
                  const dstLow = obj;
                  cMap.mapCidRange(low, high, dstLow);
                }
              }
              function parseCodespaceRange(cMap, lexer) {
                while (true) {
                  let obj = lexer.getObj();
                  if (obj === _primitives.EOF) {
                    break;
                  }
                  if ((0, _primitives.isCmd)(obj, "endcodespacerange")) {
                    return;
                  }
                  if (typeof obj !== "string") {
                    break;
                  }
                  const low = strToInt(obj);
                  obj = lexer.getObj();
                  if (typeof obj !== "string") {
                    break;
                  }
                  const high = strToInt(obj);
                  cMap.addCodespaceRange(obj.length, low, high);
                }
                throw new _util.FormatError("Invalid codespace range.");
              }
              function parseWMode(cMap, lexer) {
                const obj = lexer.getObj();
                if (Number.isInteger(obj)) {
                  cMap.vertical = !!obj;
                }
              }
              function parseCMapName(cMap, lexer) {
                const obj = lexer.getObj();
                if (obj instanceof _primitives.Name) {
                  cMap.name = obj.name;
                }
              }
              async function parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap) {
                let previous, embeddedUseCMap;
                objLoop:
                  while (true) {
                    try {
                      const obj = lexer.getObj();
                      if (obj === _primitives.EOF) {
                        break;
                      } else if (obj instanceof _primitives.Name) {
                        if (obj.name === "WMode") {
                          parseWMode(cMap, lexer);
                        } else if (obj.name === "CMapName") {
                          parseCMapName(cMap, lexer);
                        }
                        previous = obj;
                      } else if (obj instanceof _primitives.Cmd) {
                        switch (obj.cmd) {
                          case "endcmap":
                            break objLoop;
                          case "usecmap":
                            if (previous instanceof _primitives.Name) {
                              embeddedUseCMap = previous.name;
                            }
                            break;
                          case "begincodespacerange":
                            parseCodespaceRange(cMap, lexer);
                            break;
                          case "beginbfchar":
                            parseBfChar(cMap, lexer);
                            break;
                          case "begincidchar":
                            parseCidChar(cMap, lexer);
                            break;
                          case "beginbfrange":
                            parseBfRange(cMap, lexer);
                            break;
                          case "begincidrange":
                            parseCidRange(cMap, lexer);
                            break;
                        }
                      }
                    } catch (ex) {
                      if (ex instanceof _core_utils.MissingDataException) {
                        throw ex;
                      }
                      (0, _util.warn)("Invalid cMap data: " + ex);
                      continue;
                    }
                  }
                if (!useCMap && embeddedUseCMap) {
                  useCMap = embeddedUseCMap;
                }
                if (useCMap) {
                  return extendCMap(cMap, fetchBuiltInCMap, useCMap);
                }
                return cMap;
              }
              async function extendCMap(cMap, fetchBuiltInCMap, useCMap) {
                cMap.useCMap = await createBuiltInCMap(useCMap, fetchBuiltInCMap);
                if (cMap.numCodespaceRanges === 0) {
                  const useCodespaceRanges = cMap.useCMap.codespaceRanges;
                  for (let i = 0; i < useCodespaceRanges.length; i++) {
                    cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();
                  }
                  cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;
                }
                cMap.useCMap.forEach(function(key, value) {
                  if (!cMap.contains(key)) {
                    cMap.mapOne(key, cMap.useCMap.lookup(key));
                  }
                });
                return cMap;
              }
              async function createBuiltInCMap(name, fetchBuiltInCMap) {
                if (name === "Identity-H") {
                  return new IdentityCMap(false, 2);
                } else if (name === "Identity-V") {
                  return new IdentityCMap(true, 2);
                }
                if (!BUILT_IN_CMAPS.includes(name)) {
                  throw new Error("Unknown CMap name: " + name);
                }
                if (!fetchBuiltInCMap) {
                  throw new Error("Built-in CMap parameters are not provided.");
                }
                const {
                  cMapData,
                  compressionType
                } = await fetchBuiltInCMap(name);
                const cMap = new CMap(true);
                if (compressionType === _util.CMapCompressionType.BINARY) {
                  return new _binary_cmap.BinaryCMapReader().process(cMapData, cMap, (useCMap) => {
                    return extendCMap(cMap, fetchBuiltInCMap, useCMap);
                  });
                }
                if (compressionType === _util.CMapCompressionType.NONE) {
                  const lexer = new _parser.Lexer(new _stream.Stream(cMapData));
                  return parseCMap(cMap, lexer, fetchBuiltInCMap, null);
                }
                throw new Error(`Invalid CMap "compressionType" value: ${compressionType}`);
              }
              class CMapFactory {
                static async create({
                  encoding,
                  fetchBuiltInCMap,
                  useCMap
                }) {
                  if (encoding instanceof _primitives.Name) {
                    return createBuiltInCMap(encoding.name, fetchBuiltInCMap);
                  } else if (encoding instanceof _base_stream.BaseStream) {
                    const parsedCMap = await parseCMap(new CMap(), new _parser.Lexer(encoding), fetchBuiltInCMap, useCMap);
                    if (parsedCMap.isIdentityCMap) {
                      return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);
                    }
                    return parsedCMap;
                  }
                  throw new Error("Encoding required.");
                }
              }
              exports2.CMapFactory = CMapFactory;
            },
            /* 15 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.BinaryCMapReader = void 0;
              var _util = __w_pdfjs_require__2(2);
              function hexToInt(a, size) {
                let n = 0;
                for (let i = 0; i <= size; i++) {
                  n = n << 8 | a[i];
                }
                return n >>> 0;
              }
              function hexToStr(a, size) {
                if (size === 1) {
                  return String.fromCharCode(a[0], a[1]);
                }
                if (size === 3) {
                  return String.fromCharCode(a[0], a[1], a[2], a[3]);
                }
                return String.fromCharCode(...a.subarray(0, size + 1));
              }
              function addHex(a, b, size) {
                let c = 0;
                for (let i = size; i >= 0; i--) {
                  c += a[i] + b[i];
                  a[i] = c & 255;
                  c >>= 8;
                }
              }
              function incHex(a, size) {
                let c = 1;
                for (let i = size; i >= 0 && c > 0; i--) {
                  c += a[i];
                  a[i] = c & 255;
                  c >>= 8;
                }
              }
              const MAX_NUM_SIZE = 16;
              const MAX_ENCODED_NUM_SIZE = 19;
              class BinaryCMapStream {
                constructor(data) {
                  this.buffer = data;
                  this.pos = 0;
                  this.end = data.length;
                  this.tmpBuf = new Uint8Array(MAX_ENCODED_NUM_SIZE);
                }
                readByte() {
                  if (this.pos >= this.end) {
                    return -1;
                  }
                  return this.buffer[this.pos++];
                }
                readNumber() {
                  let n = 0;
                  let last;
                  do {
                    const b = this.readByte();
                    if (b < 0) {
                      throw new _util.FormatError("unexpected EOF in bcmap");
                    }
                    last = !(b & 128);
                    n = n << 7 | b & 127;
                  } while (!last);
                  return n;
                }
                readSigned() {
                  const n = this.readNumber();
                  return n & 1 ? ~(n >>> 1) : n >>> 1;
                }
                readHex(num, size) {
                  num.set(this.buffer.subarray(this.pos, this.pos + size + 1));
                  this.pos += size + 1;
                }
                readHexNumber(num, size) {
                  let last;
                  const stack = this.tmpBuf;
                  let sp = 0;
                  do {
                    const b = this.readByte();
                    if (b < 0) {
                      throw new _util.FormatError("unexpected EOF in bcmap");
                    }
                    last = !(b & 128);
                    stack[sp++] = b & 127;
                  } while (!last);
                  let i = size, buffer = 0, bufferSize = 0;
                  while (i >= 0) {
                    while (bufferSize < 8 && stack.length > 0) {
                      buffer |= stack[--sp] << bufferSize;
                      bufferSize += 7;
                    }
                    num[i] = buffer & 255;
                    i--;
                    buffer >>= 8;
                    bufferSize -= 8;
                  }
                }
                readHexSigned(num, size) {
                  this.readHexNumber(num, size);
                  const sign = num[size] & 1 ? 255 : 0;
                  let c = 0;
                  for (let i = 0; i <= size; i++) {
                    c = (c & 1) << 8 | num[i];
                    num[i] = c >> 1 ^ sign;
                  }
                }
                readString() {
                  const len = this.readNumber(), buf = new Array(len);
                  for (let i = 0; i < len; i++) {
                    buf[i] = this.readNumber();
                  }
                  return String.fromCharCode(...buf);
                }
              }
              class BinaryCMapReader {
                async process(data, cMap, extend) {
                  const stream = new BinaryCMapStream(data);
                  const header = stream.readByte();
                  cMap.vertical = !!(header & 1);
                  let useCMap = null;
                  const start = new Uint8Array(MAX_NUM_SIZE);
                  const end = new Uint8Array(MAX_NUM_SIZE);
                  const char = new Uint8Array(MAX_NUM_SIZE);
                  const charCode = new Uint8Array(MAX_NUM_SIZE);
                  const tmp = new Uint8Array(MAX_NUM_SIZE);
                  let code;
                  let b;
                  while ((b = stream.readByte()) >= 0) {
                    const type = b >> 5;
                    if (type === 7) {
                      switch (b & 31) {
                        case 0:
                          stream.readString();
                          break;
                        case 1:
                          useCMap = stream.readString();
                          break;
                      }
                      continue;
                    }
                    const sequence = !!(b & 16);
                    const dataSize = b & 15;
                    if (dataSize + 1 > MAX_NUM_SIZE) {
                      throw new Error("BinaryCMapReader.process: Invalid dataSize.");
                    }
                    const ucs2DataSize = 1;
                    const subitemsCount = stream.readNumber();
                    switch (type) {
                      case 0:
                        stream.readHex(start, dataSize);
                        stream.readHexNumber(end, dataSize);
                        addHex(end, start, dataSize);
                        cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
                        for (let i = 1; i < subitemsCount; i++) {
                          incHex(end, dataSize);
                          stream.readHexNumber(start, dataSize);
                          addHex(start, end, dataSize);
                          stream.readHexNumber(end, dataSize);
                          addHex(end, start, dataSize);
                          cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
                        }
                        break;
                      case 1:
                        stream.readHex(start, dataSize);
                        stream.readHexNumber(end, dataSize);
                        addHex(end, start, dataSize);
                        stream.readNumber();
                        for (let i = 1; i < subitemsCount; i++) {
                          incHex(end, dataSize);
                          stream.readHexNumber(start, dataSize);
                          addHex(start, end, dataSize);
                          stream.readHexNumber(end, dataSize);
                          addHex(end, start, dataSize);
                          stream.readNumber();
                        }
                        break;
                      case 2:
                        stream.readHex(char, dataSize);
                        code = stream.readNumber();
                        cMap.mapOne(hexToInt(char, dataSize), code);
                        for (let i = 1; i < subitemsCount; i++) {
                          incHex(char, dataSize);
                          if (!sequence) {
                            stream.readHexNumber(tmp, dataSize);
                            addHex(char, tmp, dataSize);
                          }
                          code = stream.readSigned() + (code + 1);
                          cMap.mapOne(hexToInt(char, dataSize), code);
                        }
                        break;
                      case 3:
                        stream.readHex(start, dataSize);
                        stream.readHexNumber(end, dataSize);
                        addHex(end, start, dataSize);
                        code = stream.readNumber();
                        cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
                        for (let i = 1; i < subitemsCount; i++) {
                          incHex(end, dataSize);
                          if (!sequence) {
                            stream.readHexNumber(start, dataSize);
                            addHex(start, end, dataSize);
                          } else {
                            start.set(end);
                          }
                          stream.readHexNumber(end, dataSize);
                          addHex(end, start, dataSize);
                          code = stream.readNumber();
                          cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
                        }
                        break;
                      case 4:
                        stream.readHex(char, ucs2DataSize);
                        stream.readHex(charCode, dataSize);
                        cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
                        for (let i = 1; i < subitemsCount; i++) {
                          incHex(char, ucs2DataSize);
                          if (!sequence) {
                            stream.readHexNumber(tmp, ucs2DataSize);
                            addHex(char, tmp, ucs2DataSize);
                          }
                          incHex(charCode, dataSize);
                          stream.readHexSigned(tmp, dataSize);
                          addHex(charCode, tmp, dataSize);
                          cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
                        }
                        break;
                      case 5:
                        stream.readHex(start, ucs2DataSize);
                        stream.readHexNumber(end, ucs2DataSize);
                        addHex(end, start, ucs2DataSize);
                        stream.readHex(charCode, dataSize);
                        cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
                        for (let i = 1; i < subitemsCount; i++) {
                          incHex(end, ucs2DataSize);
                          if (!sequence) {
                            stream.readHexNumber(start, ucs2DataSize);
                            addHex(start, end, ucs2DataSize);
                          } else {
                            start.set(end);
                          }
                          stream.readHexNumber(end, ucs2DataSize);
                          addHex(end, start, ucs2DataSize);
                          stream.readHex(charCode, dataSize);
                          cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
                        }
                        break;
                      default:
                        throw new Error(`BinaryCMapReader.process - unknown type: ${type}`);
                    }
                  }
                  if (useCMap) {
                    return extend(useCMap);
                  }
                  return cMap;
                }
              }
              exports2.BinaryCMapReader = BinaryCMapReader;
            },
            /* 16 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Parser = exports2.Linearization = exports2.Lexer = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(4);
              var _core_utils = __w_pdfjs_require__2(3);
              var _stream = __w_pdfjs_require__2(8);
              var _ascii_85_stream = __w_pdfjs_require__2(17);
              var _ascii_hex_stream = __w_pdfjs_require__2(19);
              var _ccitt_stream = __w_pdfjs_require__2(20);
              var _flate_stream = __w_pdfjs_require__2(22);
              var _jbig2_stream = __w_pdfjs_require__2(23);
              var _jpeg_stream = __w_pdfjs_require__2(26);
              var _jpx_stream = __w_pdfjs_require__2(29);
              var _lzw_stream = __w_pdfjs_require__2(31);
              var _predictor_stream = __w_pdfjs_require__2(32);
              var _run_length_stream = __w_pdfjs_require__2(33);
              const MAX_LENGTH_TO_CACHE = 1e3;
              function getInlineImageCacheKey(bytes) {
                const strBuf = [], ii = bytes.length;
                let i = 0;
                while (i < ii - 1) {
                  strBuf.push(bytes[i++] << 8 | bytes[i++]);
                }
                if (i < ii) {
                  strBuf.push(bytes[i]);
                }
                return ii + "_" + String.fromCharCode.apply(null, strBuf);
              }
              class Parser {
                constructor({
                  lexer,
                  xref,
                  allowStreams = false,
                  recoveryMode = false
                }) {
                  this.lexer = lexer;
                  this.xref = xref;
                  this.allowStreams = allowStreams;
                  this.recoveryMode = recoveryMode;
                  this.imageCache = /* @__PURE__ */ Object.create(null);
                  this._imageId = 0;
                  this.refill();
                }
                refill() {
                  this.buf1 = this.lexer.getObj();
                  this.buf2 = this.lexer.getObj();
                }
                shift() {
                  if (this.buf2 instanceof _primitives.Cmd && this.buf2.cmd === "ID") {
                    this.buf1 = this.buf2;
                    this.buf2 = null;
                  } else {
                    this.buf1 = this.buf2;
                    this.buf2 = this.lexer.getObj();
                  }
                }
                tryShift() {
                  try {
                    this.shift();
                    return true;
                  } catch (e) {
                    if (e instanceof _core_utils.MissingDataException) {
                      throw e;
                    }
                    return false;
                  }
                }
                getObj(cipherTransform = null) {
                  const buf1 = this.buf1;
                  this.shift();
                  if (buf1 instanceof _primitives.Cmd) {
                    switch (buf1.cmd) {
                      case "BI":
                        return this.makeInlineImage(cipherTransform);
                      case "[":
                        const array = [];
                        while (!(0, _primitives.isCmd)(this.buf1, "]") && this.buf1 !== _primitives.EOF) {
                          array.push(this.getObj(cipherTransform));
                        }
                        if (this.buf1 === _primitives.EOF) {
                          if (this.recoveryMode) {
                            return array;
                          }
                          throw new _core_utils.ParserEOFException("End of file inside array.");
                        }
                        this.shift();
                        return array;
                      case "<<":
                        const dict = new _primitives.Dict(this.xref);
                        while (!(0, _primitives.isCmd)(this.buf1, ">>") && this.buf1 !== _primitives.EOF) {
                          if (!(this.buf1 instanceof _primitives.Name)) {
                            (0, _util.info)("Malformed dictionary: key must be a name object");
                            this.shift();
                            continue;
                          }
                          const key = this.buf1.name;
                          this.shift();
                          if (this.buf1 === _primitives.EOF) {
                            break;
                          }
                          dict.set(key, this.getObj(cipherTransform));
                        }
                        if (this.buf1 === _primitives.EOF) {
                          if (this.recoveryMode) {
                            return dict;
                          }
                          throw new _core_utils.ParserEOFException("End of file inside dictionary.");
                        }
                        if ((0, _primitives.isCmd)(this.buf2, "stream")) {
                          return this.allowStreams ? this.makeStream(dict, cipherTransform) : dict;
                        }
                        this.shift();
                        return dict;
                      default:
                        return buf1;
                    }
                  }
                  if (Number.isInteger(buf1)) {
                    if (Number.isInteger(this.buf1) && (0, _primitives.isCmd)(this.buf2, "R")) {
                      const ref = _primitives.Ref.get(buf1, this.buf1);
                      this.shift();
                      this.shift();
                      return ref;
                    }
                    return buf1;
                  }
                  if (typeof buf1 === "string") {
                    if (cipherTransform) {
                      return cipherTransform.decryptString(buf1);
                    }
                    return buf1;
                  }
                  return buf1;
                }
                findDefaultInlineStreamEnd(stream) {
                  const E = 69, I = 73, SPACE = 32, LF = 10, CR = 13, NUL = 0;
                  const {
                    knownCommands
                  } = this.lexer, startPos = stream.pos, n = 15;
                  let state = 0, ch, maybeEIPos;
                  while ((ch = stream.getByte()) !== -1) {
                    if (state === 0) {
                      state = ch === E ? 1 : 0;
                    } else if (state === 1) {
                      state = ch === I ? 2 : 0;
                    } else {
                      if (ch === SPACE || ch === LF || ch === CR) {
                        maybeEIPos = stream.pos;
                        const followingBytes = stream.peekBytes(n);
                        const ii = followingBytes.length;
                        if (ii === 0) {
                          break;
                        }
                        for (let i = 0; i < ii; i++) {
                          ch = followingBytes[i];
                          if (ch === NUL && followingBytes[i + 1] !== NUL) {
                            continue;
                          }
                          if (ch !== LF && ch !== CR && (ch < SPACE || ch > 127)) {
                            state = 0;
                            break;
                          }
                        }
                        if (state !== 2) {
                          continue;
                        }
                        if (!knownCommands) {
                          (0, _util.warn)("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
                          continue;
                        }
                        const tmpLexer = new Lexer(new _stream.Stream(followingBytes.slice()), knownCommands);
                        tmpLexer._hexStringWarn = () => {
                        };
                        let numArgs = 0;
                        while (true) {
                          const nextObj = tmpLexer.getObj();
                          if (nextObj === _primitives.EOF) {
                            state = 0;
                            break;
                          }
                          if (nextObj instanceof _primitives.Cmd) {
                            const knownCommand = knownCommands[nextObj.cmd];
                            if (!knownCommand) {
                              state = 0;
                              break;
                            } else if (knownCommand.variableArgs ? numArgs <= knownCommand.numArgs : numArgs === knownCommand.numArgs) {
                              break;
                            }
                            numArgs = 0;
                            continue;
                          }
                          numArgs++;
                        }
                        if (state === 2) {
                          break;
                        }
                      } else {
                        state = 0;
                      }
                    }
                  }
                  if (ch === -1) {
                    (0, _util.warn)("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker");
                    if (maybeEIPos) {
                      (0, _util.warn)('... trying to recover by using the last "EI" occurrence.');
                      stream.skip(-(stream.pos - maybeEIPos));
                    }
                  }
                  let endOffset = 4;
                  stream.skip(-endOffset);
                  ch = stream.peekByte();
                  stream.skip(endOffset);
                  if (!(0, _core_utils.isWhiteSpace)(ch)) {
                    endOffset--;
                  }
                  return stream.pos - endOffset - startPos;
                }
                findDCTDecodeInlineStreamEnd(stream) {
                  const startPos = stream.pos;
                  let foundEOI = false, b, markerLength;
                  while ((b = stream.getByte()) !== -1) {
                    if (b !== 255) {
                      continue;
                    }
                    switch (stream.getByte()) {
                      case 0:
                        break;
                      case 255:
                        stream.skip(-1);
                        break;
                      case 217:
                        foundEOI = true;
                        break;
                      case 192:
                      case 193:
                      case 194:
                      case 195:
                      case 197:
                      case 198:
                      case 199:
                      case 201:
                      case 202:
                      case 203:
                      case 205:
                      case 206:
                      case 207:
                      case 196:
                      case 204:
                      case 218:
                      case 219:
                      case 220:
                      case 221:
                      case 222:
                      case 223:
                      case 224:
                      case 225:
                      case 226:
                      case 227:
                      case 228:
                      case 229:
                      case 230:
                      case 231:
                      case 232:
                      case 233:
                      case 234:
                      case 235:
                      case 236:
                      case 237:
                      case 238:
                      case 239:
                      case 254:
                        markerLength = stream.getUint16();
                        if (markerLength > 2) {
                          stream.skip(markerLength - 2);
                        } else {
                          stream.skip(-2);
                        }
                        break;
                    }
                    if (foundEOI) {
                      break;
                    }
                  }
                  const length = stream.pos - startPos;
                  if (b === -1) {
                    (0, _util.warn)("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead.");
                    stream.skip(-length);
                    return this.findDefaultInlineStreamEnd(stream);
                  }
                  this.inlineStreamSkipEI(stream);
                  return length;
                }
                findASCII85DecodeInlineStreamEnd(stream) {
                  const TILDE = 126, GT = 62;
                  const startPos = stream.pos;
                  let ch;
                  while ((ch = stream.getByte()) !== -1) {
                    if (ch === TILDE) {
                      const tildePos = stream.pos;
                      ch = stream.peekByte();
                      while ((0, _core_utils.isWhiteSpace)(ch)) {
                        stream.skip();
                        ch = stream.peekByte();
                      }
                      if (ch === GT) {
                        stream.skip();
                        break;
                      }
                      if (stream.pos > tildePos) {
                        const maybeEI = stream.peekBytes(2);
                        if (maybeEI[0] === 69 && maybeEI[1] === 73) {
                          break;
                        }
                      }
                    }
                  }
                  const length = stream.pos - startPos;
                  if (ch === -1) {
                    (0, _util.warn)("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead.");
                    stream.skip(-length);
                    return this.findDefaultInlineStreamEnd(stream);
                  }
                  this.inlineStreamSkipEI(stream);
                  return length;
                }
                findASCIIHexDecodeInlineStreamEnd(stream) {
                  const GT = 62;
                  const startPos = stream.pos;
                  let ch;
                  while ((ch = stream.getByte()) !== -1) {
                    if (ch === GT) {
                      break;
                    }
                  }
                  const length = stream.pos - startPos;
                  if (ch === -1) {
                    (0, _util.warn)("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead.");
                    stream.skip(-length);
                    return this.findDefaultInlineStreamEnd(stream);
                  }
                  this.inlineStreamSkipEI(stream);
                  return length;
                }
                inlineStreamSkipEI(stream) {
                  const E = 69, I = 73;
                  let state = 0, ch;
                  while ((ch = stream.getByte()) !== -1) {
                    if (state === 0) {
                      state = ch === E ? 1 : 0;
                    } else if (state === 1) {
                      state = ch === I ? 2 : 0;
                    } else if (state === 2) {
                      break;
                    }
                  }
                }
                makeInlineImage(cipherTransform) {
                  const lexer = this.lexer;
                  const stream = lexer.stream;
                  const dictMap = /* @__PURE__ */ Object.create(null);
                  let dictLength;
                  while (!(0, _primitives.isCmd)(this.buf1, "ID") && this.buf1 !== _primitives.EOF) {
                    if (!(this.buf1 instanceof _primitives.Name)) {
                      throw new _util.FormatError("Dictionary key must be a name object");
                    }
                    const key = this.buf1.name;
                    this.shift();
                    if (this.buf1 === _primitives.EOF) {
                      break;
                    }
                    dictMap[key] = this.getObj(cipherTransform);
                  }
                  if (lexer.beginInlineImagePos !== -1) {
                    dictLength = stream.pos - lexer.beginInlineImagePos;
                  }
                  const filter = this.xref.fetchIfRef(dictMap.F || dictMap.Filter);
                  let filterName;
                  if (filter instanceof _primitives.Name) {
                    filterName = filter.name;
                  } else if (Array.isArray(filter)) {
                    const filterZero = this.xref.fetchIfRef(filter[0]);
                    if (filterZero instanceof _primitives.Name) {
                      filterName = filterZero.name;
                    }
                  }
                  const startPos = stream.pos;
                  let length;
                  switch (filterName) {
                    case "DCT":
                    case "DCTDecode":
                      length = this.findDCTDecodeInlineStreamEnd(stream);
                      break;
                    case "A85":
                    case "ASCII85Decode":
                      length = this.findASCII85DecodeInlineStreamEnd(stream);
                      break;
                    case "AHx":
                    case "ASCIIHexDecode":
                      length = this.findASCIIHexDecodeInlineStreamEnd(stream);
                      break;
                    default:
                      length = this.findDefaultInlineStreamEnd(stream);
                  }
                  let cacheKey;
                  if (length < MAX_LENGTH_TO_CACHE && dictLength > 0) {
                    const initialStreamPos = stream.pos;
                    stream.pos = lexer.beginInlineImagePos;
                    cacheKey = getInlineImageCacheKey(stream.getBytes(dictLength + length));
                    stream.pos = initialStreamPos;
                    const cacheEntry = this.imageCache[cacheKey];
                    if (cacheEntry !== void 0) {
                      this.buf2 = _primitives.Cmd.get("EI");
                      this.shift();
                      cacheEntry.reset();
                      return cacheEntry;
                    }
                  }
                  const dict = new _primitives.Dict(this.xref);
                  for (const key in dictMap) {
                    dict.set(key, dictMap[key]);
                  }
                  let imageStream = stream.makeSubStream(startPos, length, dict);
                  if (cipherTransform) {
                    imageStream = cipherTransform.createStream(imageStream, length);
                  }
                  imageStream = this.filter(imageStream, dict, length);
                  imageStream.dict = dict;
                  if (cacheKey !== void 0) {
                    imageStream.cacheKey = `inline_img_${++this._imageId}`;
                    this.imageCache[cacheKey] = imageStream;
                  }
                  this.buf2 = _primitives.Cmd.get("EI");
                  this.shift();
                  return imageStream;
                }
                _findStreamLength(startPos, signature) {
                  const {
                    stream
                  } = this.lexer;
                  stream.pos = startPos;
                  const SCAN_BLOCK_LENGTH = 2048;
                  const signatureLength = signature.length;
                  while (stream.pos < stream.end) {
                    const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
                    const scanLength = scanBytes.length - signatureLength;
                    if (scanLength <= 0) {
                      break;
                    }
                    let pos = 0;
                    while (pos < scanLength) {
                      let j = 0;
                      while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
                        j++;
                      }
                      if (j >= signatureLength) {
                        stream.pos += pos;
                        return stream.pos - startPos;
                      }
                      pos++;
                    }
                    stream.pos += scanLength;
                  }
                  return -1;
                }
                makeStream(dict, cipherTransform) {
                  const lexer = this.lexer;
                  let stream = lexer.stream;
                  lexer.skipToNextLine();
                  const startPos = stream.pos - 1;
                  let length = dict.get("Length");
                  if (!Number.isInteger(length)) {
                    (0, _util.info)(`Bad length "${length && length.toString()}" in stream.`);
                    length = 0;
                  }
                  stream.pos = startPos + length;
                  lexer.nextChar();
                  if (this.tryShift() && (0, _primitives.isCmd)(this.buf2, "endstream")) {
                    this.shift();
                  } else {
                    const ENDSTREAM_SIGNATURE = new Uint8Array([101, 110, 100, 115, 116, 114, 101, 97, 109]);
                    let actualLength = this._findStreamLength(startPos, ENDSTREAM_SIGNATURE);
                    if (actualLength < 0) {
                      const MAX_TRUNCATION = 1;
                      for (let i = 1; i <= MAX_TRUNCATION; i++) {
                        const end = ENDSTREAM_SIGNATURE.length - i;
                        const TRUNCATED_SIGNATURE = ENDSTREAM_SIGNATURE.slice(0, end);
                        const maybeLength = this._findStreamLength(startPos, TRUNCATED_SIGNATURE);
                        if (maybeLength >= 0) {
                          const lastByte = stream.peekBytes(end + 1)[end];
                          if (!(0, _core_utils.isWhiteSpace)(lastByte)) {
                            break;
                          }
                          (0, _util.info)(`Found "${(0, _util.bytesToString)(TRUNCATED_SIGNATURE)}" when searching for endstream command.`);
                          actualLength = maybeLength;
                          break;
                        }
                      }
                      if (actualLength < 0) {
                        throw new _util.FormatError("Missing endstream command.");
                      }
                    }
                    length = actualLength;
                    lexer.nextChar();
                    this.shift();
                    this.shift();
                  }
                  this.shift();
                  stream = stream.makeSubStream(startPos, length, dict);
                  if (cipherTransform) {
                    stream = cipherTransform.createStream(stream, length);
                  }
                  stream = this.filter(stream, dict, length);
                  stream.dict = dict;
                  return stream;
                }
                filter(stream, dict, length) {
                  let filter = dict.get("F", "Filter");
                  let params = dict.get("DP", "DecodeParms");
                  if (filter instanceof _primitives.Name) {
                    if (Array.isArray(params)) {
                      (0, _util.warn)("/DecodeParms should not be an Array, when /Filter is a Name.");
                    }
                    return this.makeFilter(stream, filter.name, length, params);
                  }
                  let maybeLength = length;
                  if (Array.isArray(filter)) {
                    const filterArray = filter;
                    const paramsArray = params;
                    for (let i = 0, ii = filterArray.length; i < ii; ++i) {
                      filter = this.xref.fetchIfRef(filterArray[i]);
                      if (!(filter instanceof _primitives.Name)) {
                        throw new _util.FormatError(`Bad filter name "${filter}"`);
                      }
                      params = null;
                      if (Array.isArray(paramsArray) && i in paramsArray) {
                        params = this.xref.fetchIfRef(paramsArray[i]);
                      }
                      stream = this.makeFilter(stream, filter.name, maybeLength, params);
                      maybeLength = null;
                    }
                  }
                  return stream;
                }
                makeFilter(stream, name, maybeLength, params) {
                  if (maybeLength === 0) {
                    (0, _util.warn)(`Empty "${name}" stream.`);
                    return new _stream.NullStream();
                  }
                  try {
                    switch (name) {
                      case "Fl":
                      case "FlateDecode":
                        if (params) {
                          return new _predictor_stream.PredictorStream(new _flate_stream.FlateStream(stream, maybeLength), maybeLength, params);
                        }
                        return new _flate_stream.FlateStream(stream, maybeLength);
                      case "LZW":
                      case "LZWDecode":
                        let earlyChange = 1;
                        if (params) {
                          if (params.has("EarlyChange")) {
                            earlyChange = params.get("EarlyChange");
                          }
                          return new _predictor_stream.PredictorStream(new _lzw_stream.LZWStream(stream, maybeLength, earlyChange), maybeLength, params);
                        }
                        return new _lzw_stream.LZWStream(stream, maybeLength, earlyChange);
                      case "DCT":
                      case "DCTDecode":
                        return new _jpeg_stream.JpegStream(stream, maybeLength, params);
                      case "JPX":
                      case "JPXDecode":
                        return new _jpx_stream.JpxStream(stream, maybeLength, params);
                      case "A85":
                      case "ASCII85Decode":
                        return new _ascii_85_stream.Ascii85Stream(stream, maybeLength);
                      case "AHx":
                      case "ASCIIHexDecode":
                        return new _ascii_hex_stream.AsciiHexStream(stream, maybeLength);
                      case "CCF":
                      case "CCITTFaxDecode":
                        return new _ccitt_stream.CCITTFaxStream(stream, maybeLength, params);
                      case "RL":
                      case "RunLengthDecode":
                        return new _run_length_stream.RunLengthStream(stream, maybeLength);
                      case "JBIG2Decode":
                        return new _jbig2_stream.Jbig2Stream(stream, maybeLength, params);
                    }
                    (0, _util.warn)(`Filter "${name}" is not supported.`);
                    return stream;
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)(`Invalid stream: "${ex}"`);
                    return new _stream.NullStream();
                  }
                }
              }
              exports2.Parser = Parser;
              const specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              function toHexDigit(ch) {
                if (ch >= 48 && ch <= 57) {
                  return ch & 15;
                }
                if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
                  return (ch & 15) + 9;
                }
                return -1;
              }
              class Lexer {
                constructor(stream, knownCommands = null) {
                  this.stream = stream;
                  this.nextChar();
                  this.strBuf = [];
                  this.knownCommands = knownCommands;
                  this._hexStringNumWarn = 0;
                  this.beginInlineImagePos = -1;
                }
                nextChar() {
                  return this.currentChar = this.stream.getByte();
                }
                peekChar() {
                  return this.stream.peekByte();
                }
                getNumber() {
                  let ch = this.currentChar;
                  let eNotation = false;
                  let divideBy = 0;
                  let sign = 1;
                  if (ch === 45) {
                    sign = -1;
                    ch = this.nextChar();
                    if (ch === 45) {
                      ch = this.nextChar();
                    }
                  } else if (ch === 43) {
                    ch = this.nextChar();
                  }
                  if (ch === 10 || ch === 13) {
                    do {
                      ch = this.nextChar();
                    } while (ch === 10 || ch === 13);
                  }
                  if (ch === 46) {
                    divideBy = 10;
                    ch = this.nextChar();
                  }
                  if (ch < 48 || ch > 57) {
                    const msg = `Invalid number: ${String.fromCharCode(ch)} (charCode ${ch})`;
                    if ((0, _core_utils.isWhiteSpace)(ch) || ch === -1) {
                      (0, _util.info)(`Lexer.getNumber - "${msg}".`);
                      return 0;
                    }
                    throw new _util.FormatError(msg);
                  }
                  let baseValue = ch - 48;
                  let powerValue = 0;
                  let powerValueSign = 1;
                  while ((ch = this.nextChar()) >= 0) {
                    if (ch >= 48 && ch <= 57) {
                      const currentDigit = ch - 48;
                      if (eNotation) {
                        powerValue = powerValue * 10 + currentDigit;
                      } else {
                        if (divideBy !== 0) {
                          divideBy *= 10;
                        }
                        baseValue = baseValue * 10 + currentDigit;
                      }
                    } else if (ch === 46) {
                      if (divideBy === 0) {
                        divideBy = 1;
                      } else {
                        break;
                      }
                    } else if (ch === 45) {
                      (0, _util.warn)("Badly formatted number: minus sign in the middle");
                    } else if (ch === 69 || ch === 101) {
                      ch = this.peekChar();
                      if (ch === 43 || ch === 45) {
                        powerValueSign = ch === 45 ? -1 : 1;
                        this.nextChar();
                      } else if (ch < 48 || ch > 57) {
                        break;
                      }
                      eNotation = true;
                    } else {
                      break;
                    }
                  }
                  if (divideBy !== 0) {
                    baseValue /= divideBy;
                  }
                  if (eNotation) {
                    baseValue *= 10 ** (powerValueSign * powerValue);
                  }
                  return sign * baseValue;
                }
                getString() {
                  let numParen = 1;
                  let done = false;
                  const strBuf = this.strBuf;
                  strBuf.length = 0;
                  let ch = this.nextChar();
                  while (true) {
                    let charBuffered = false;
                    switch (ch | 0) {
                      case -1:
                        (0, _util.warn)("Unterminated string");
                        done = true;
                        break;
                      case 40:
                        ++numParen;
                        strBuf.push("(");
                        break;
                      case 41:
                        if (--numParen === 0) {
                          this.nextChar();
                          done = true;
                        } else {
                          strBuf.push(")");
                        }
                        break;
                      case 92:
                        ch = this.nextChar();
                        switch (ch) {
                          case -1:
                            (0, _util.warn)("Unterminated string");
                            done = true;
                            break;
                          case 110:
                            strBuf.push("\n");
                            break;
                          case 114:
                            strBuf.push("\r");
                            break;
                          case 116:
                            strBuf.push("	");
                            break;
                          case 98:
                            strBuf.push("\b");
                            break;
                          case 102:
                            strBuf.push("\f");
                            break;
                          case 92:
                          case 40:
                          case 41:
                            strBuf.push(String.fromCharCode(ch));
                            break;
                          case 48:
                          case 49:
                          case 50:
                          case 51:
                          case 52:
                          case 53:
                          case 54:
                          case 55:
                            let x = ch & 15;
                            ch = this.nextChar();
                            charBuffered = true;
                            if (ch >= 48 && ch <= 55) {
                              x = (x << 3) + (ch & 15);
                              ch = this.nextChar();
                              if (ch >= 48 && ch <= 55) {
                                charBuffered = false;
                                x = (x << 3) + (ch & 15);
                              }
                            }
                            strBuf.push(String.fromCharCode(x));
                            break;
                          case 13:
                            if (this.peekChar() === 10) {
                              this.nextChar();
                            }
                            break;
                          case 10:
                            break;
                          default:
                            strBuf.push(String.fromCharCode(ch));
                            break;
                        }
                        break;
                      default:
                        strBuf.push(String.fromCharCode(ch));
                        break;
                    }
                    if (done) {
                      break;
                    }
                    if (!charBuffered) {
                      ch = this.nextChar();
                    }
                  }
                  return strBuf.join("");
                }
                getName() {
                  let ch, previousCh;
                  const strBuf = this.strBuf;
                  strBuf.length = 0;
                  while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
                    if (ch === 35) {
                      ch = this.nextChar();
                      if (specialChars[ch]) {
                        (0, _util.warn)("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.");
                        strBuf.push("#");
                        break;
                      }
                      const x = toHexDigit(ch);
                      if (x !== -1) {
                        previousCh = ch;
                        ch = this.nextChar();
                        const x2 = toHexDigit(ch);
                        if (x2 === -1) {
                          (0, _util.warn)(`Lexer_getName: Illegal digit (${String.fromCharCode(ch)}) in hexadecimal number.`);
                          strBuf.push("#", String.fromCharCode(previousCh));
                          if (specialChars[ch]) {
                            break;
                          }
                          strBuf.push(String.fromCharCode(ch));
                          continue;
                        }
                        strBuf.push(String.fromCharCode(x << 4 | x2));
                      } else {
                        strBuf.push("#", String.fromCharCode(ch));
                      }
                    } else {
                      strBuf.push(String.fromCharCode(ch));
                    }
                  }
                  if (strBuf.length > 127) {
                    (0, _util.warn)(`Name token is longer than allowed by the spec: ${strBuf.length}`);
                  }
                  return _primitives.Name.get(strBuf.join(""));
                }
                _hexStringWarn(ch) {
                  const MAX_HEX_STRING_NUM_WARN = 5;
                  if (this._hexStringNumWarn++ === MAX_HEX_STRING_NUM_WARN) {
                    (0, _util.warn)("getHexString - ignoring additional invalid characters.");
                    return;
                  }
                  if (this._hexStringNumWarn > MAX_HEX_STRING_NUM_WARN) {
                    return;
                  }
                  (0, _util.warn)(`getHexString - ignoring invalid character: ${ch}`);
                }
                getHexString() {
                  const strBuf = this.strBuf;
                  strBuf.length = 0;
                  let ch = this.currentChar;
                  let isFirstHex = true;
                  let firstDigit, secondDigit;
                  this._hexStringNumWarn = 0;
                  while (true) {
                    if (ch < 0) {
                      (0, _util.warn)("Unterminated hex string");
                      break;
                    } else if (ch === 62) {
                      this.nextChar();
                      break;
                    } else if (specialChars[ch] === 1) {
                      ch = this.nextChar();
                      continue;
                    } else {
                      if (isFirstHex) {
                        firstDigit = toHexDigit(ch);
                        if (firstDigit === -1) {
                          this._hexStringWarn(ch);
                          ch = this.nextChar();
                          continue;
                        }
                      } else {
                        secondDigit = toHexDigit(ch);
                        if (secondDigit === -1) {
                          this._hexStringWarn(ch);
                          ch = this.nextChar();
                          continue;
                        }
                        strBuf.push(String.fromCharCode(firstDigit << 4 | secondDigit));
                      }
                      isFirstHex = !isFirstHex;
                      ch = this.nextChar();
                    }
                  }
                  return strBuf.join("");
                }
                getObj() {
                  let comment = false;
                  let ch = this.currentChar;
                  while (true) {
                    if (ch < 0) {
                      return _primitives.EOF;
                    }
                    if (comment) {
                      if (ch === 10 || ch === 13) {
                        comment = false;
                      }
                    } else if (ch === 37) {
                      comment = true;
                    } else if (specialChars[ch] !== 1) {
                      break;
                    }
                    ch = this.nextChar();
                  }
                  switch (ch | 0) {
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                    case 43:
                    case 45:
                    case 46:
                      return this.getNumber();
                    case 40:
                      return this.getString();
                    case 47:
                      return this.getName();
                    case 91:
                      this.nextChar();
                      return _primitives.Cmd.get("[");
                    case 93:
                      this.nextChar();
                      return _primitives.Cmd.get("]");
                    case 60:
                      ch = this.nextChar();
                      if (ch === 60) {
                        this.nextChar();
                        return _primitives.Cmd.get("<<");
                      }
                      return this.getHexString();
                    case 62:
                      ch = this.nextChar();
                      if (ch === 62) {
                        this.nextChar();
                        return _primitives.Cmd.get(">>");
                      }
                      return _primitives.Cmd.get(">");
                    case 123:
                      this.nextChar();
                      return _primitives.Cmd.get("{");
                    case 125:
                      this.nextChar();
                      return _primitives.Cmd.get("}");
                    case 41:
                      this.nextChar();
                      throw new _util.FormatError(`Illegal character: ${ch}`);
                  }
                  let str = String.fromCharCode(ch);
                  if (ch < 32 || ch > 127) {
                    const nextCh = this.peekChar();
                    if (nextCh >= 32 && nextCh <= 127) {
                      this.nextChar();
                      return _primitives.Cmd.get(str);
                    }
                  }
                  const knownCommands = this.knownCommands;
                  let knownCommandFound = (knownCommands == null ? void 0 : knownCommands[str]) !== void 0;
                  while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
                    const possibleCommand = str + String.fromCharCode(ch);
                    if (knownCommandFound && knownCommands[possibleCommand] === void 0) {
                      break;
                    }
                    if (str.length === 128) {
                      throw new _util.FormatError(`Command token too long: ${str.length}`);
                    }
                    str = possibleCommand;
                    knownCommandFound = (knownCommands == null ? void 0 : knownCommands[str]) !== void 0;
                  }
                  if (str === "true") {
                    return true;
                  }
                  if (str === "false") {
                    return false;
                  }
                  if (str === "null") {
                    return null;
                  }
                  if (str === "BI") {
                    this.beginInlineImagePos = this.stream.pos;
                  }
                  return _primitives.Cmd.get(str);
                }
                skipToNextLine() {
                  let ch = this.currentChar;
                  while (ch >= 0) {
                    if (ch === 13) {
                      ch = this.nextChar();
                      if (ch === 10) {
                        this.nextChar();
                      }
                      break;
                    } else if (ch === 10) {
                      this.nextChar();
                      break;
                    }
                    ch = this.nextChar();
                  }
                }
              }
              exports2.Lexer = Lexer;
              class Linearization {
                static create(stream) {
                  function getInt(linDict2, name, allowZeroValue = false) {
                    const obj4 = linDict2.get(name);
                    if (Number.isInteger(obj4) && (allowZeroValue ? obj4 >= 0 : obj4 > 0)) {
                      return obj4;
                    }
                    throw new Error(`The "${name}" parameter in the linearization dictionary is invalid.`);
                  }
                  function getHints(linDict2) {
                    const hints = linDict2.get("H");
                    let hintsLength;
                    if (Array.isArray(hints) && ((hintsLength = hints.length) === 2 || hintsLength === 4)) {
                      for (let index = 0; index < hintsLength; index++) {
                        const hint = hints[index];
                        if (!(Number.isInteger(hint) && hint > 0)) {
                          throw new Error(`Hint (${index}) in the linearization dictionary is invalid.`);
                        }
                      }
                      return hints;
                    }
                    throw new Error("Hint array in the linearization dictionary is invalid.");
                  }
                  const parser = new Parser({
                    lexer: new Lexer(stream),
                    xref: null
                  });
                  const obj1 = parser.getObj();
                  const obj2 = parser.getObj();
                  const obj3 = parser.getObj();
                  const linDict = parser.getObj();
                  let obj, length;
                  if (!(Number.isInteger(obj1) && Number.isInteger(obj2) && (0, _primitives.isCmd)(obj3, "obj") && linDict instanceof _primitives.Dict && typeof (obj = linDict.get("Linearized")) === "number" && obj > 0)) {
                    return null;
                  } else if ((length = getInt(linDict, "L")) !== stream.length) {
                    throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
                  }
                  return {
                    length,
                    hints: getHints(linDict),
                    objectNumberFirst: getInt(linDict, "O"),
                    endFirst: getInt(linDict, "E"),
                    numPages: getInt(linDict, "N"),
                    mainXRefEntriesOffset: getInt(linDict, "T"),
                    pageFirst: linDict.has("P") ? getInt(linDict, "P", true) : 0
                  };
                }
              }
              exports2.Linearization = Linearization;
            },
            /* 17 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Ascii85Stream = void 0;
              var _decode_stream = __w_pdfjs_require__2(18);
              var _core_utils = __w_pdfjs_require__2(3);
              class Ascii85Stream extends _decode_stream.DecodeStream {
                constructor(str, maybeLength) {
                  if (maybeLength) {
                    maybeLength *= 0.8;
                  }
                  super(maybeLength);
                  this.str = str;
                  this.dict = str.dict;
                  this.input = new Uint8Array(5);
                }
                readBlock() {
                  const TILDA_CHAR = 126;
                  const Z_LOWER_CHAR = 122;
                  const EOF = -1;
                  const str = this.str;
                  let c = str.getByte();
                  while ((0, _core_utils.isWhiteSpace)(c)) {
                    c = str.getByte();
                  }
                  if (c === EOF || c === TILDA_CHAR) {
                    this.eof = true;
                    return;
                  }
                  const bufferLength = this.bufferLength;
                  let buffer, i;
                  if (c === Z_LOWER_CHAR) {
                    buffer = this.ensureBuffer(bufferLength + 4);
                    for (i = 0; i < 4; ++i) {
                      buffer[bufferLength + i] = 0;
                    }
                    this.bufferLength += 4;
                  } else {
                    const input = this.input;
                    input[0] = c;
                    for (i = 1; i < 5; ++i) {
                      c = str.getByte();
                      while ((0, _core_utils.isWhiteSpace)(c)) {
                        c = str.getByte();
                      }
                      input[i] = c;
                      if (c === EOF || c === TILDA_CHAR) {
                        break;
                      }
                    }
                    buffer = this.ensureBuffer(bufferLength + i - 1);
                    this.bufferLength += i - 1;
                    if (i < 5) {
                      for (; i < 5; ++i) {
                        input[i] = 33 + 84;
                      }
                      this.eof = true;
                    }
                    let t = 0;
                    for (i = 0; i < 5; ++i) {
                      t = t * 85 + (input[i] - 33);
                    }
                    for (i = 3; i >= 0; --i) {
                      buffer[bufferLength + i] = t & 255;
                      t >>= 8;
                    }
                  }
                }
              }
              exports2.Ascii85Stream = Ascii85Stream;
            },
            /* 18 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StreamsSequenceStream = exports2.DecodeStream = void 0;
              var _base_stream = __w_pdfjs_require__2(5);
              var _stream = __w_pdfjs_require__2(8);
              const emptyBuffer = new Uint8Array(0);
              class DecodeStream extends _base_stream.BaseStream {
                constructor(maybeMinBufferLength) {
                  super();
                  this._rawMinBufferLength = maybeMinBufferLength || 0;
                  this.pos = 0;
                  this.bufferLength = 0;
                  this.eof = false;
                  this.buffer = emptyBuffer;
                  this.minBufferLength = 512;
                  if (maybeMinBufferLength) {
                    while (this.minBufferLength < maybeMinBufferLength) {
                      this.minBufferLength *= 2;
                    }
                  }
                }
                get isEmpty() {
                  while (!this.eof && this.bufferLength === 0) {
                    this.readBlock();
                  }
                  return this.bufferLength === 0;
                }
                ensureBuffer(requested) {
                  const buffer = this.buffer;
                  if (requested <= buffer.byteLength) {
                    return buffer;
                  }
                  let size = this.minBufferLength;
                  while (size < requested) {
                    size *= 2;
                  }
                  const buffer2 = new Uint8Array(size);
                  buffer2.set(buffer);
                  return this.buffer = buffer2;
                }
                getByte() {
                  const pos = this.pos;
                  while (this.bufferLength <= pos) {
                    if (this.eof) {
                      return -1;
                    }
                    this.readBlock();
                  }
                  return this.buffer[this.pos++];
                }
                getBytes(length) {
                  const pos = this.pos;
                  let end;
                  if (length) {
                    this.ensureBuffer(pos + length);
                    end = pos + length;
                    while (!this.eof && this.bufferLength < end) {
                      this.readBlock();
                    }
                    const bufEnd = this.bufferLength;
                    if (end > bufEnd) {
                      end = bufEnd;
                    }
                  } else {
                    while (!this.eof) {
                      this.readBlock();
                    }
                    end = this.bufferLength;
                  }
                  this.pos = end;
                  return this.buffer.subarray(pos, end);
                }
                reset() {
                  this.pos = 0;
                }
                makeSubStream(start, length, dict = null) {
                  if (length === void 0) {
                    while (!this.eof) {
                      this.readBlock();
                    }
                  } else {
                    const end = start + length;
                    while (this.bufferLength <= end && !this.eof) {
                      this.readBlock();
                    }
                  }
                  return new _stream.Stream(this.buffer, start, length, dict);
                }
                getBaseStreams() {
                  return this.str ? this.str.getBaseStreams() : null;
                }
              }
              exports2.DecodeStream = DecodeStream;
              class StreamsSequenceStream extends DecodeStream {
                constructor(streams, onError = null) {
                  let maybeLength = 0;
                  for (const stream of streams) {
                    maybeLength += stream instanceof DecodeStream ? stream._rawMinBufferLength : stream.length;
                  }
                  super(maybeLength);
                  this.streams = streams;
                  this._onError = onError;
                }
                readBlock() {
                  var _a;
                  const streams = this.streams;
                  if (streams.length === 0) {
                    this.eof = true;
                    return;
                  }
                  const stream = streams.shift();
                  let chunk;
                  try {
                    chunk = stream.getBytes();
                  } catch (reason) {
                    if (this._onError) {
                      this._onError(reason, (_a = stream.dict) == null ? void 0 : _a.objId);
                      return;
                    }
                    throw reason;
                  }
                  const bufferLength = this.bufferLength;
                  const newLength = bufferLength + chunk.length;
                  const buffer = this.ensureBuffer(newLength);
                  buffer.set(chunk, bufferLength);
                  this.bufferLength = newLength;
                }
                getBaseStreams() {
                  const baseStreamsBuf = [];
                  for (const stream of this.streams) {
                    const baseStreams = stream.getBaseStreams();
                    if (baseStreams) {
                      baseStreamsBuf.push(...baseStreams);
                    }
                  }
                  return baseStreamsBuf.length > 0 ? baseStreamsBuf : null;
                }
              }
              exports2.StreamsSequenceStream = StreamsSequenceStream;
            },
            /* 19 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AsciiHexStream = void 0;
              var _decode_stream = __w_pdfjs_require__2(18);
              class AsciiHexStream extends _decode_stream.DecodeStream {
                constructor(str, maybeLength) {
                  if (maybeLength) {
                    maybeLength *= 0.5;
                  }
                  super(maybeLength);
                  this.str = str;
                  this.dict = str.dict;
                  this.firstDigit = -1;
                }
                readBlock() {
                  const UPSTREAM_BLOCK_SIZE = 8e3;
                  const bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE);
                  if (!bytes.length) {
                    this.eof = true;
                    return;
                  }
                  const maxDecodeLength = bytes.length + 1 >> 1;
                  const buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
                  let bufferLength = this.bufferLength;
                  let firstDigit = this.firstDigit;
                  for (const ch of bytes) {
                    let digit;
                    if (ch >= 48 && ch <= 57) {
                      digit = ch & 15;
                    } else if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
                      digit = (ch & 15) + 9;
                    } else if (ch === 62) {
                      this.eof = true;
                      break;
                    } else {
                      continue;
                    }
                    if (firstDigit < 0) {
                      firstDigit = digit;
                    } else {
                      buffer[bufferLength++] = firstDigit << 4 | digit;
                      firstDigit = -1;
                    }
                  }
                  if (firstDigit >= 0 && this.eof) {
                    buffer[bufferLength++] = firstDigit << 4;
                    firstDigit = -1;
                  }
                  this.firstDigit = firstDigit;
                  this.bufferLength = bufferLength;
                }
              }
              exports2.AsciiHexStream = AsciiHexStream;
            },
            /* 20 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CCITTFaxStream = void 0;
              var _ccitt = __w_pdfjs_require__2(21);
              var _decode_stream = __w_pdfjs_require__2(18);
              var _primitives = __w_pdfjs_require__2(4);
              class CCITTFaxStream extends _decode_stream.DecodeStream {
                constructor(str, maybeLength, params) {
                  super(maybeLength);
                  this.str = str;
                  this.dict = str.dict;
                  if (!(params instanceof _primitives.Dict)) {
                    params = _primitives.Dict.empty;
                  }
                  const source = {
                    next() {
                      return str.getByte();
                    }
                  };
                  this.ccittFaxDecoder = new _ccitt.CCITTFaxDecoder(source, {
                    K: params.get("K"),
                    EndOfLine: params.get("EndOfLine"),
                    EncodedByteAlign: params.get("EncodedByteAlign"),
                    Columns: params.get("Columns"),
                    Rows: params.get("Rows"),
                    EndOfBlock: params.get("EndOfBlock"),
                    BlackIs1: params.get("BlackIs1")
                  });
                }
                readBlock() {
                  while (!this.eof) {
                    const c = this.ccittFaxDecoder.readNextChar();
                    if (c === -1) {
                      this.eof = true;
                      return;
                    }
                    this.ensureBuffer(this.bufferLength + 1);
                    this.buffer[this.bufferLength++] = c;
                  }
                }
              }
              exports2.CCITTFaxStream = CCITTFaxStream;
            },
            /* 21 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CCITTFaxDecoder = void 0;
              var _util = __w_pdfjs_require__2(2);
              const ccittEOL = -2;
              const ccittEOF = -1;
              const twoDimPass = 0;
              const twoDimHoriz = 1;
              const twoDimVert0 = 2;
              const twoDimVertR1 = 3;
              const twoDimVertL1 = 4;
              const twoDimVertR2 = 5;
              const twoDimVertL2 = 6;
              const twoDimVertR3 = 7;
              const twoDimVertL3 = 8;
              const twoDimTable = [[-1, -1], [-1, -1], [7, twoDimVertL3], [7, twoDimVertR3], [6, twoDimVertL2], [6, twoDimVertL2], [6, twoDimVertR2], [6, twoDimVertR2], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0]];
              const whiteTable1 = [[-1, -1], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]];
              const whiteTable2 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]];
              const blackTable1 = [[-1, -1], [-1, -1], [12, ccittEOL], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]];
              const blackTable2 = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]];
              const blackTable3 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
              class CCITTFaxDecoder {
                constructor(source, options = {}) {
                  if (!source || typeof source.next !== "function") {
                    throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
                  }
                  this.source = source;
                  this.eof = false;
                  this.encoding = options.K || 0;
                  this.eoline = options.EndOfLine || false;
                  this.byteAlign = options.EncodedByteAlign || false;
                  this.columns = options.Columns || 1728;
                  this.rows = options.Rows || 0;
                  this.eoblock = options.EndOfBlock ?? true;
                  this.black = options.BlackIs1 || false;
                  this.codingLine = new Uint32Array(this.columns + 1);
                  this.refLine = new Uint32Array(this.columns + 2);
                  this.codingLine[0] = this.columns;
                  this.codingPos = 0;
                  this.row = 0;
                  this.nextLine2D = this.encoding < 0;
                  this.inputBits = 0;
                  this.inputBuf = 0;
                  this.outputBits = 0;
                  this.rowsDone = false;
                  let code1;
                  while ((code1 = this._lookBits(12)) === 0) {
                    this._eatBits(1);
                  }
                  if (code1 === 1) {
                    this._eatBits(12);
                  }
                  if (this.encoding > 0) {
                    this.nextLine2D = !this._lookBits(1);
                    this._eatBits(1);
                  }
                }
                readNextChar() {
                  if (this.eof) {
                    return -1;
                  }
                  const refLine = this.refLine;
                  const codingLine = this.codingLine;
                  const columns = this.columns;
                  let refPos, blackPixels, bits, i;
                  if (this.outputBits === 0) {
                    if (this.rowsDone) {
                      this.eof = true;
                    }
                    if (this.eof) {
                      return -1;
                    }
                    this.err = false;
                    let code1, code2, code3;
                    if (this.nextLine2D) {
                      for (i = 0; codingLine[i] < columns; ++i) {
                        refLine[i] = codingLine[i];
                      }
                      refLine[i++] = columns;
                      refLine[i] = columns;
                      codingLine[0] = 0;
                      this.codingPos = 0;
                      refPos = 0;
                      blackPixels = 0;
                      while (codingLine[this.codingPos] < columns) {
                        code1 = this._getTwoDimCode();
                        switch (code1) {
                          case twoDimPass:
                            this._addPixels(refLine[refPos + 1], blackPixels);
                            if (refLine[refPos + 1] < columns) {
                              refPos += 2;
                            }
                            break;
                          case twoDimHoriz:
                            code1 = code2 = 0;
                            if (blackPixels) {
                              do {
                                code1 += code3 = this._getBlackCode();
                              } while (code3 >= 64);
                              do {
                                code2 += code3 = this._getWhiteCode();
                              } while (code3 >= 64);
                            } else {
                              do {
                                code1 += code3 = this._getWhiteCode();
                              } while (code3 >= 64);
                              do {
                                code2 += code3 = this._getBlackCode();
                              } while (code3 >= 64);
                            }
                            this._addPixels(codingLine[this.codingPos] + code1, blackPixels);
                            if (codingLine[this.codingPos] < columns) {
                              this._addPixels(codingLine[this.codingPos] + code2, blackPixels ^ 1);
                            }
                            while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                              refPos += 2;
                            }
                            break;
                          case twoDimVertR3:
                            this._addPixels(refLine[refPos] + 3, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              ++refPos;
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertR2:
                            this._addPixels(refLine[refPos] + 2, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              ++refPos;
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertR1:
                            this._addPixels(refLine[refPos] + 1, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              ++refPos;
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVert0:
                            this._addPixels(refLine[refPos], blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              ++refPos;
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertL3:
                            this._addPixelsNeg(refLine[refPos] - 3, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              if (refPos > 0) {
                                --refPos;
                              } else {
                                ++refPos;
                              }
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertL2:
                            this._addPixelsNeg(refLine[refPos] - 2, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              if (refPos > 0) {
                                --refPos;
                              } else {
                                ++refPos;
                              }
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertL1:
                            this._addPixelsNeg(refLine[refPos] - 1, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              if (refPos > 0) {
                                --refPos;
                              } else {
                                ++refPos;
                              }
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case ccittEOF:
                            this._addPixels(columns, 0);
                            this.eof = true;
                            break;
                          default:
                            (0, _util.info)("bad 2d code");
                            this._addPixels(columns, 0);
                            this.err = true;
                        }
                      }
                    } else {
                      codingLine[0] = 0;
                      this.codingPos = 0;
                      blackPixels = 0;
                      while (codingLine[this.codingPos] < columns) {
                        code1 = 0;
                        if (blackPixels) {
                          do {
                            code1 += code3 = this._getBlackCode();
                          } while (code3 >= 64);
                        } else {
                          do {
                            code1 += code3 = this._getWhiteCode();
                          } while (code3 >= 64);
                        }
                        this._addPixels(codingLine[this.codingPos] + code1, blackPixels);
                        blackPixels ^= 1;
                      }
                    }
                    let gotEOL = false;
                    if (this.byteAlign) {
                      this.inputBits &= ~7;
                    }
                    if (!this.eoblock && this.row === this.rows - 1) {
                      this.rowsDone = true;
                    } else {
                      code1 = this._lookBits(12);
                      if (this.eoline) {
                        while (code1 !== ccittEOF && code1 !== 1) {
                          this._eatBits(1);
                          code1 = this._lookBits(12);
                        }
                      } else {
                        while (code1 === 0) {
                          this._eatBits(1);
                          code1 = this._lookBits(12);
                        }
                      }
                      if (code1 === 1) {
                        this._eatBits(12);
                        gotEOL = true;
                      } else if (code1 === ccittEOF) {
                        this.eof = true;
                      }
                    }
                    if (!this.eof && this.encoding > 0 && !this.rowsDone) {
                      this.nextLine2D = !this._lookBits(1);
                      this._eatBits(1);
                    }
                    if (this.eoblock && gotEOL && this.byteAlign) {
                      code1 = this._lookBits(12);
                      if (code1 === 1) {
                        this._eatBits(12);
                        if (this.encoding > 0) {
                          this._lookBits(1);
                          this._eatBits(1);
                        }
                        if (this.encoding >= 0) {
                          for (i = 0; i < 4; ++i) {
                            code1 = this._lookBits(12);
                            if (code1 !== 1) {
                              (0, _util.info)("bad rtc code: " + code1);
                            }
                            this._eatBits(12);
                            if (this.encoding > 0) {
                              this._lookBits(1);
                              this._eatBits(1);
                            }
                          }
                        }
                        this.eof = true;
                      }
                    } else if (this.err && this.eoline) {
                      while (true) {
                        code1 = this._lookBits(13);
                        if (code1 === ccittEOF) {
                          this.eof = true;
                          return -1;
                        }
                        if (code1 >> 1 === 1) {
                          break;
                        }
                        this._eatBits(1);
                      }
                      this._eatBits(12);
                      if (this.encoding > 0) {
                        this._eatBits(1);
                        this.nextLine2D = !(code1 & 1);
                      }
                    }
                    this.outputBits = codingLine[0] > 0 ? codingLine[this.codingPos = 0] : codingLine[this.codingPos = 1];
                    this.row++;
                  }
                  let c;
                  if (this.outputBits >= 8) {
                    c = this.codingPos & 1 ? 0 : 255;
                    this.outputBits -= 8;
                    if (this.outputBits === 0 && codingLine[this.codingPos] < columns) {
                      this.codingPos++;
                      this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
                    }
                  } else {
                    bits = 8;
                    c = 0;
                    do {
                      if (typeof this.outputBits !== "number") {
                        throw new _util.FormatError('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
                      }
                      if (this.outputBits > bits) {
                        c <<= bits;
                        if (!(this.codingPos & 1)) {
                          c |= 255 >> 8 - bits;
                        }
                        this.outputBits -= bits;
                        bits = 0;
                      } else {
                        c <<= this.outputBits;
                        if (!(this.codingPos & 1)) {
                          c |= 255 >> 8 - this.outputBits;
                        }
                        bits -= this.outputBits;
                        this.outputBits = 0;
                        if (codingLine[this.codingPos] < columns) {
                          this.codingPos++;
                          this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
                        } else if (bits > 0) {
                          c <<= bits;
                          bits = 0;
                        }
                      }
                    } while (bits);
                  }
                  if (this.black) {
                    c ^= 255;
                  }
                  return c;
                }
                _addPixels(a1, blackPixels) {
                  const codingLine = this.codingLine;
                  let codingPos = this.codingPos;
                  if (a1 > codingLine[codingPos]) {
                    if (a1 > this.columns) {
                      (0, _util.info)("row is wrong length");
                      this.err = true;
                      a1 = this.columns;
                    }
                    if (codingPos & 1 ^ blackPixels) {
                      ++codingPos;
                    }
                    codingLine[codingPos] = a1;
                  }
                  this.codingPos = codingPos;
                }
                _addPixelsNeg(a1, blackPixels) {
                  const codingLine = this.codingLine;
                  let codingPos = this.codingPos;
                  if (a1 > codingLine[codingPos]) {
                    if (a1 > this.columns) {
                      (0, _util.info)("row is wrong length");
                      this.err = true;
                      a1 = this.columns;
                    }
                    if (codingPos & 1 ^ blackPixels) {
                      ++codingPos;
                    }
                    codingLine[codingPos] = a1;
                  } else if (a1 < codingLine[codingPos]) {
                    if (a1 < 0) {
                      (0, _util.info)("invalid code");
                      this.err = true;
                      a1 = 0;
                    }
                    while (codingPos > 0 && a1 < codingLine[codingPos - 1]) {
                      --codingPos;
                    }
                    codingLine[codingPos] = a1;
                  }
                  this.codingPos = codingPos;
                }
                _findTableCode(start, end, table, limit) {
                  const limitValue = limit || 0;
                  for (let i = start; i <= end; ++i) {
                    let code = this._lookBits(i);
                    if (code === ccittEOF) {
                      return [true, 1, false];
                    }
                    if (i < end) {
                      code <<= end - i;
                    }
                    if (!limitValue || code >= limitValue) {
                      const p = table[code - limitValue];
                      if (p[0] === i) {
                        this._eatBits(i);
                        return [true, p[1], true];
                      }
                    }
                  }
                  return [false, 0, false];
                }
                _getTwoDimCode() {
                  let code = 0;
                  let p;
                  if (this.eoblock) {
                    code = this._lookBits(7);
                    p = twoDimTable[code];
                    if ((p == null ? void 0 : p[0]) > 0) {
                      this._eatBits(p[0]);
                      return p[1];
                    }
                  } else {
                    const result = this._findTableCode(1, 7, twoDimTable);
                    if (result[0] && result[2]) {
                      return result[1];
                    }
                  }
                  (0, _util.info)("Bad two dim code");
                  return ccittEOF;
                }
                _getWhiteCode() {
                  let code = 0;
                  let p;
                  if (this.eoblock) {
                    code = this._lookBits(12);
                    if (code === ccittEOF) {
                      return 1;
                    }
                    p = code >> 5 === 0 ? whiteTable1[code] : whiteTable2[code >> 3];
                    if (p[0] > 0) {
                      this._eatBits(p[0]);
                      return p[1];
                    }
                  } else {
                    let result = this._findTableCode(1, 9, whiteTable2);
                    if (result[0]) {
                      return result[1];
                    }
                    result = this._findTableCode(11, 12, whiteTable1);
                    if (result[0]) {
                      return result[1];
                    }
                  }
                  (0, _util.info)("bad white code");
                  this._eatBits(1);
                  return 1;
                }
                _getBlackCode() {
                  let code, p;
                  if (this.eoblock) {
                    code = this._lookBits(13);
                    if (code === ccittEOF) {
                      return 1;
                    }
                    if (code >> 7 === 0) {
                      p = blackTable1[code];
                    } else if (code >> 9 === 0 && code >> 7 !== 0) {
                      p = blackTable2[(code >> 1) - 64];
                    } else {
                      p = blackTable3[code >> 7];
                    }
                    if (p[0] > 0) {
                      this._eatBits(p[0]);
                      return p[1];
                    }
                  } else {
                    let result = this._findTableCode(2, 6, blackTable3);
                    if (result[0]) {
                      return result[1];
                    }
                    result = this._findTableCode(7, 12, blackTable2, 64);
                    if (result[0]) {
                      return result[1];
                    }
                    result = this._findTableCode(10, 13, blackTable1);
                    if (result[0]) {
                      return result[1];
                    }
                  }
                  (0, _util.info)("bad black code");
                  this._eatBits(1);
                  return 1;
                }
                _lookBits(n) {
                  let c;
                  while (this.inputBits < n) {
                    if ((c = this.source.next()) === -1) {
                      if (this.inputBits === 0) {
                        return ccittEOF;
                      }
                      return this.inputBuf << n - this.inputBits & 65535 >> 16 - n;
                    }
                    this.inputBuf = this.inputBuf << 8 | c;
                    this.inputBits += 8;
                  }
                  return this.inputBuf >> this.inputBits - n & 65535 >> 16 - n;
                }
                _eatBits(n) {
                  if ((this.inputBits -= n) < 0) {
                    this.inputBits = 0;
                  }
                }
              }
              exports2.CCITTFaxDecoder = CCITTFaxDecoder;
            },
            /* 22 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FlateStream = void 0;
              var _decode_stream = __w_pdfjs_require__2(18);
              var _util = __w_pdfjs_require__2(2);
              const codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
              const lengthDecode = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]);
              const distDecode = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]);
              const fixedLitCodeTab = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9];
              const fixedDistCodeTab = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
              class FlateStream extends _decode_stream.DecodeStream {
                constructor(str, maybeLength) {
                  super(maybeLength);
                  this.str = str;
                  this.dict = str.dict;
                  const cmf = str.getByte();
                  const flg = str.getByte();
                  if (cmf === -1 || flg === -1) {
                    throw new _util.FormatError(`Invalid header in flate stream: ${cmf}, ${flg}`);
                  }
                  if ((cmf & 15) !== 8) {
                    throw new _util.FormatError(`Unknown compression method in flate stream: ${cmf}, ${flg}`);
                  }
                  if (((cmf << 8) + flg) % 31 !== 0) {
                    throw new _util.FormatError(`Bad FCHECK in flate stream: ${cmf}, ${flg}`);
                  }
                  if (flg & 32) {
                    throw new _util.FormatError(`FDICT bit set in flate stream: ${cmf}, ${flg}`);
                  }
                  this.codeSize = 0;
                  this.codeBuf = 0;
                }
                getBits(bits) {
                  const str = this.str;
                  let codeSize = this.codeSize;
                  let codeBuf = this.codeBuf;
                  let b;
                  while (codeSize < bits) {
                    if ((b = str.getByte()) === -1) {
                      throw new _util.FormatError("Bad encoding in flate stream");
                    }
                    codeBuf |= b << codeSize;
                    codeSize += 8;
                  }
                  b = codeBuf & (1 << bits) - 1;
                  this.codeBuf = codeBuf >> bits;
                  this.codeSize = codeSize -= bits;
                  return b;
                }
                getCode(table) {
                  const str = this.str;
                  const codes = table[0];
                  const maxLen = table[1];
                  let codeSize = this.codeSize;
                  let codeBuf = this.codeBuf;
                  let b;
                  while (codeSize < maxLen) {
                    if ((b = str.getByte()) === -1) {
                      break;
                    }
                    codeBuf |= b << codeSize;
                    codeSize += 8;
                  }
                  const code = codes[codeBuf & (1 << maxLen) - 1];
                  const codeLen = code >> 16;
                  const codeVal = code & 65535;
                  if (codeLen < 1 || codeSize < codeLen) {
                    throw new _util.FormatError("Bad encoding in flate stream");
                  }
                  this.codeBuf = codeBuf >> codeLen;
                  this.codeSize = codeSize - codeLen;
                  return codeVal;
                }
                generateHuffmanTable(lengths) {
                  const n = lengths.length;
                  let maxLen = 0;
                  let i;
                  for (i = 0; i < n; ++i) {
                    if (lengths[i] > maxLen) {
                      maxLen = lengths[i];
                    }
                  }
                  const size = 1 << maxLen;
                  const codes = new Int32Array(size);
                  for (let len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
                    for (let val = 0; val < n; ++val) {
                      if (lengths[val] === len) {
                        let code2 = 0;
                        let t = code;
                        for (i = 0; i < len; ++i) {
                          code2 = code2 << 1 | t & 1;
                          t >>= 1;
                        }
                        for (i = code2; i < size; i += skip) {
                          codes[i] = len << 16 | val;
                        }
                        ++code;
                      }
                    }
                  }
                  return [codes, maxLen];
                }
                readBlock() {
                  let buffer, len;
                  const str = this.str;
                  let hdr = this.getBits(3);
                  if (hdr & 1) {
                    this.eof = true;
                  }
                  hdr >>= 1;
                  if (hdr === 0) {
                    let b;
                    if ((b = str.getByte()) === -1) {
                      throw new _util.FormatError("Bad block header in flate stream");
                    }
                    let blockLen = b;
                    if ((b = str.getByte()) === -1) {
                      throw new _util.FormatError("Bad block header in flate stream");
                    }
                    blockLen |= b << 8;
                    if ((b = str.getByte()) === -1) {
                      throw new _util.FormatError("Bad block header in flate stream");
                    }
                    let check = b;
                    if ((b = str.getByte()) === -1) {
                      throw new _util.FormatError("Bad block header in flate stream");
                    }
                    check |= b << 8;
                    if (check !== (~blockLen & 65535) && (blockLen !== 0 || check !== 0)) {
                      throw new _util.FormatError("Bad uncompressed block length in flate stream");
                    }
                    this.codeBuf = 0;
                    this.codeSize = 0;
                    const bufferLength = this.bufferLength, end = bufferLength + blockLen;
                    buffer = this.ensureBuffer(end);
                    this.bufferLength = end;
                    if (blockLen === 0) {
                      if (str.peekByte() === -1) {
                        this.eof = true;
                      }
                    } else {
                      const block = str.getBytes(blockLen);
                      buffer.set(block, bufferLength);
                      if (block.length < blockLen) {
                        this.eof = true;
                      }
                    }
                    return;
                  }
                  let litCodeTable;
                  let distCodeTable;
                  if (hdr === 1) {
                    litCodeTable = fixedLitCodeTab;
                    distCodeTable = fixedDistCodeTab;
                  } else if (hdr === 2) {
                    const numLitCodes = this.getBits(5) + 257;
                    const numDistCodes = this.getBits(5) + 1;
                    const numCodeLenCodes = this.getBits(4) + 4;
                    const codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
                    let i;
                    for (i = 0; i < numCodeLenCodes; ++i) {
                      codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
                    }
                    const codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
                    len = 0;
                    i = 0;
                    const codes = numLitCodes + numDistCodes;
                    const codeLengths = new Uint8Array(codes);
                    let bitsLength, bitsOffset, what;
                    while (i < codes) {
                      const code = this.getCode(codeLenCodeTab);
                      if (code === 16) {
                        bitsLength = 2;
                        bitsOffset = 3;
                        what = len;
                      } else if (code === 17) {
                        bitsLength = 3;
                        bitsOffset = 3;
                        what = len = 0;
                      } else if (code === 18) {
                        bitsLength = 7;
                        bitsOffset = 11;
                        what = len = 0;
                      } else {
                        codeLengths[i++] = len = code;
                        continue;
                      }
                      let repeatLength = this.getBits(bitsLength) + bitsOffset;
                      while (repeatLength-- > 0) {
                        codeLengths[i++] = what;
                      }
                    }
                    litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
                    distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
                  } else {
                    throw new _util.FormatError("Unknown block type in flate stream");
                  }
                  buffer = this.buffer;
                  let limit = buffer ? buffer.length : 0;
                  let pos = this.bufferLength;
                  while (true) {
                    let code1 = this.getCode(litCodeTable);
                    if (code1 < 256) {
                      if (pos + 1 >= limit) {
                        buffer = this.ensureBuffer(pos + 1);
                        limit = buffer.length;
                      }
                      buffer[pos++] = code1;
                      continue;
                    }
                    if (code1 === 256) {
                      this.bufferLength = pos;
                      return;
                    }
                    code1 -= 257;
                    code1 = lengthDecode[code1];
                    let code2 = code1 >> 16;
                    if (code2 > 0) {
                      code2 = this.getBits(code2);
                    }
                    len = (code1 & 65535) + code2;
                    code1 = this.getCode(distCodeTable);
                    code1 = distDecode[code1];
                    code2 = code1 >> 16;
                    if (code2 > 0) {
                      code2 = this.getBits(code2);
                    }
                    const dist = (code1 & 65535) + code2;
                    if (pos + len >= limit) {
                      buffer = this.ensureBuffer(pos + len);
                      limit = buffer.length;
                    }
                    for (let k = 0; k < len; ++k, ++pos) {
                      buffer[pos] = buffer[pos - dist];
                    }
                  }
                }
              }
              exports2.FlateStream = FlateStream;
            },
            /* 23 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Jbig2Stream = void 0;
              var _base_stream = __w_pdfjs_require__2(5);
              var _decode_stream = __w_pdfjs_require__2(18);
              var _primitives = __w_pdfjs_require__2(4);
              var _jbig = __w_pdfjs_require__2(24);
              var _util = __w_pdfjs_require__2(2);
              class Jbig2Stream extends _decode_stream.DecodeStream {
                constructor(stream, maybeLength, params) {
                  super(maybeLength);
                  this.stream = stream;
                  this.dict = stream.dict;
                  this.maybeLength = maybeLength;
                  this.params = params;
                }
                get bytes() {
                  return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                }
                ensureBuffer(requested) {
                }
                readBlock() {
                  if (this.eof) {
                    return;
                  }
                  const jbig2Image = new _jbig.Jbig2Image();
                  const chunks = [];
                  if (this.params instanceof _primitives.Dict) {
                    const globalsStream = this.params.get("JBIG2Globals");
                    if (globalsStream instanceof _base_stream.BaseStream) {
                      const globals = globalsStream.getBytes();
                      chunks.push({
                        data: globals,
                        start: 0,
                        end: globals.length
                      });
                    }
                  }
                  chunks.push({
                    data: this.bytes,
                    start: 0,
                    end: this.bytes.length
                  });
                  const data = jbig2Image.parseChunks(chunks);
                  const dataLength = data.length;
                  for (let i = 0; i < dataLength; i++) {
                    data[i] ^= 255;
                  }
                  this.buffer = data;
                  this.bufferLength = dataLength;
                  this.eof = true;
                }
              }
              exports2.Jbig2Stream = Jbig2Stream;
            },
            /* 24 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Jbig2Image = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _core_utils = __w_pdfjs_require__2(3);
              var _arithmetic_decoder = __w_pdfjs_require__2(25);
              var _ccitt = __w_pdfjs_require__2(21);
              class Jbig2Error extends _util.BaseException {
                constructor(msg) {
                  super(`JBIG2 error: ${msg}`, "Jbig2Error");
                }
              }
              class ContextCache {
                getContexts(id) {
                  if (id in this) {
                    return this[id];
                  }
                  return this[id] = new Int8Array(1 << 16);
                }
              }
              class DecodingContext {
                constructor(data, start, end) {
                  this.data = data;
                  this.start = start;
                  this.end = end;
                }
                get decoder() {
                  const decoder = new _arithmetic_decoder.ArithmeticDecoder(this.data, this.start, this.end);
                  return (0, _util.shadow)(this, "decoder", decoder);
                }
                get contextCache() {
                  const cache = new ContextCache();
                  return (0, _util.shadow)(this, "contextCache", cache);
                }
              }
              const MAX_INT_32 = 2 ** 31 - 1;
              const MIN_INT_32 = -(2 ** 31);
              function decodeInteger(contextCache, procedure, decoder) {
                const contexts = contextCache.getContexts(procedure);
                let prev = 1;
                function readBits(length) {
                  let v = 0;
                  for (let i = 0; i < length; i++) {
                    const bit = decoder.readBit(contexts, prev);
                    prev = prev < 256 ? prev << 1 | bit : (prev << 1 | bit) & 511 | 256;
                    v = v << 1 | bit;
                  }
                  return v >>> 0;
                }
                const sign = readBits(1);
                const value = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
                let signedValue;
                if (sign === 0) {
                  signedValue = value;
                } else if (value > 0) {
                  signedValue = -value;
                }
                if (signedValue >= MIN_INT_32 && signedValue <= MAX_INT_32) {
                  return signedValue;
                }
                return null;
              }
              function decodeIAID(contextCache, decoder, codeLength) {
                const contexts = contextCache.getContexts("IAID");
                let prev = 1;
                for (let i = 0; i < codeLength; i++) {
                  const bit = decoder.readBit(contexts, prev);
                  prev = prev << 1 | bit;
                }
                if (codeLength < 31) {
                  return prev & (1 << codeLength) - 1;
                }
                return prev & 2147483647;
              }
              const SegmentTypes = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"];
              const CodingTemplates = [[{
                x: -1,
                y: -2
              }, {
                x: 0,
                y: -2
              }, {
                x: 1,
                y: -2
              }, {
                x: -2,
                y: -1
              }, {
                x: -1,
                y: -1
              }, {
                x: 0,
                y: -1
              }, {
                x: 1,
                y: -1
              }, {
                x: 2,
                y: -1
              }, {
                x: -4,
                y: 0
              }, {
                x: -3,
                y: 0
              }, {
                x: -2,
                y: 0
              }, {
                x: -1,
                y: 0
              }], [{
                x: -1,
                y: -2
              }, {
                x: 0,
                y: -2
              }, {
                x: 1,
                y: -2
              }, {
                x: 2,
                y: -2
              }, {
                x: -2,
                y: -1
              }, {
                x: -1,
                y: -1
              }, {
                x: 0,
                y: -1
              }, {
                x: 1,
                y: -1
              }, {
                x: 2,
                y: -1
              }, {
                x: -3,
                y: 0
              }, {
                x: -2,
                y: 0
              }, {
                x: -1,
                y: 0
              }], [{
                x: -1,
                y: -2
              }, {
                x: 0,
                y: -2
              }, {
                x: 1,
                y: -2
              }, {
                x: -2,
                y: -1
              }, {
                x: -1,
                y: -1
              }, {
                x: 0,
                y: -1
              }, {
                x: 1,
                y: -1
              }, {
                x: -2,
                y: 0
              }, {
                x: -1,
                y: 0
              }], [{
                x: -3,
                y: -1
              }, {
                x: -2,
                y: -1
              }, {
                x: -1,
                y: -1
              }, {
                x: 0,
                y: -1
              }, {
                x: 1,
                y: -1
              }, {
                x: -4,
                y: 0
              }, {
                x: -3,
                y: 0
              }, {
                x: -2,
                y: 0
              }, {
                x: -1,
                y: 0
              }]];
              const RefinementTemplates = [{
                coding: [{
                  x: 0,
                  y: -1
                }, {
                  x: 1,
                  y: -1
                }, {
                  x: -1,
                  y: 0
                }],
                reference: [{
                  x: 0,
                  y: -1
                }, {
                  x: 1,
                  y: -1
                }, {
                  x: -1,
                  y: 0
                }, {
                  x: 0,
                  y: 0
                }, {
                  x: 1,
                  y: 0
                }, {
                  x: -1,
                  y: 1
                }, {
                  x: 0,
                  y: 1
                }, {
                  x: 1,
                  y: 1
                }]
              }, {
                coding: [{
                  x: -1,
                  y: -1
                }, {
                  x: 0,
                  y: -1
                }, {
                  x: 1,
                  y: -1
                }, {
                  x: -1,
                  y: 0
                }],
                reference: [{
                  x: 0,
                  y: -1
                }, {
                  x: -1,
                  y: 0
                }, {
                  x: 0,
                  y: 0
                }, {
                  x: 1,
                  y: 0
                }, {
                  x: 0,
                  y: 1
                }, {
                  x: 1,
                  y: 1
                }]
              }];
              const ReusedContexts = [39717, 1941, 229, 405];
              const RefinementReusedContexts = [32, 8];
              function decodeBitmapTemplate0(width, height, decodingContext) {
                const decoder = decodingContext.decoder;
                const contexts = decodingContext.contextCache.getContexts("GB");
                const bitmap = [];
                let contextLabel, i, j, pixel, row, row1, row2;
                const OLD_PIXEL_MASK = 31735;
                for (i = 0; i < height; i++) {
                  row = bitmap[i] = new Uint8Array(width);
                  row1 = i < 1 ? row : bitmap[i - 1];
                  row2 = i < 2 ? row : bitmap[i - 2];
                  contextLabel = row2[0] << 13 | row2[1] << 12 | row2[2] << 11 | row1[0] << 7 | row1[1] << 6 | row1[2] << 5 | row1[3] << 4;
                  for (j = 0; j < width; j++) {
                    row[j] = pixel = decoder.readBit(contexts, contextLabel);
                    contextLabel = (contextLabel & OLD_PIXEL_MASK) << 1 | (j + 3 < width ? row2[j + 3] << 11 : 0) | (j + 4 < width ? row1[j + 4] << 4 : 0) | pixel;
                  }
                }
                return bitmap;
              }
              function decodeBitmap(mmr, width, height, templateIndex, prediction, skip, at, decodingContext) {
                if (mmr) {
                  const input = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
                  return decodeMMRBitmap(input, width, height, false);
                }
                if (templateIndex === 0 && !skip && !prediction && at.length === 4 && at[0].x === 3 && at[0].y === -1 && at[1].x === -3 && at[1].y === -1 && at[2].x === 2 && at[2].y === -2 && at[3].x === -2 && at[3].y === -2) {
                  return decodeBitmapTemplate0(width, height, decodingContext);
                }
                const useskip = !!skip;
                const template = CodingTemplates[templateIndex].concat(at);
                template.sort(function(a, b) {
                  return a.y - b.y || a.x - b.x;
                });
                const templateLength = template.length;
                const templateX = new Int8Array(templateLength);
                const templateY = new Int8Array(templateLength);
                const changingTemplateEntries = [];
                let reuseMask = 0, minX = 0, maxX = 0, minY = 0;
                let c, k;
                for (k = 0; k < templateLength; k++) {
                  templateX[k] = template[k].x;
                  templateY[k] = template[k].y;
                  minX = Math.min(minX, template[k].x);
                  maxX = Math.max(maxX, template[k].x);
                  minY = Math.min(minY, template[k].y);
                  if (k < templateLength - 1 && template[k].y === template[k + 1].y && template[k].x === template[k + 1].x - 1) {
                    reuseMask |= 1 << templateLength - 1 - k;
                  } else {
                    changingTemplateEntries.push(k);
                  }
                }
                const changingEntriesLength = changingTemplateEntries.length;
                const changingTemplateX = new Int8Array(changingEntriesLength);
                const changingTemplateY = new Int8Array(changingEntriesLength);
                const changingTemplateBit = new Uint16Array(changingEntriesLength);
                for (c = 0; c < changingEntriesLength; c++) {
                  k = changingTemplateEntries[c];
                  changingTemplateX[c] = template[k].x;
                  changingTemplateY[c] = template[k].y;
                  changingTemplateBit[c] = 1 << templateLength - 1 - k;
                }
                const sbb_left = -minX;
                const sbb_top = -minY;
                const sbb_right = width - maxX;
                const pseudoPixelContext = ReusedContexts[templateIndex];
                let row = new Uint8Array(width);
                const bitmap = [];
                const decoder = decodingContext.decoder;
                const contexts = decodingContext.contextCache.getContexts("GB");
                let ltp = 0, j, i0, j0, contextLabel = 0, bit, shift;
                for (let i = 0; i < height; i++) {
                  if (prediction) {
                    const sltp = decoder.readBit(contexts, pseudoPixelContext);
                    ltp ^= sltp;
                    if (ltp) {
                      bitmap.push(row);
                      continue;
                    }
                  }
                  row = new Uint8Array(row);
                  bitmap.push(row);
                  for (j = 0; j < width; j++) {
                    if (useskip && skip[i][j]) {
                      row[j] = 0;
                      continue;
                    }
                    if (j >= sbb_left && j < sbb_right && i >= sbb_top) {
                      contextLabel = contextLabel << 1 & reuseMask;
                      for (k = 0; k < changingEntriesLength; k++) {
                        i0 = i + changingTemplateY[k];
                        j0 = j + changingTemplateX[k];
                        bit = bitmap[i0][j0];
                        if (bit) {
                          bit = changingTemplateBit[k];
                          contextLabel |= bit;
                        }
                      }
                    } else {
                      contextLabel = 0;
                      shift = templateLength - 1;
                      for (k = 0; k < templateLength; k++, shift--) {
                        j0 = j + templateX[k];
                        if (j0 >= 0 && j0 < width) {
                          i0 = i + templateY[k];
                          if (i0 >= 0) {
                            bit = bitmap[i0][j0];
                            if (bit) {
                              contextLabel |= bit << shift;
                            }
                          }
                        }
                      }
                    }
                    const pixel = decoder.readBit(contexts, contextLabel);
                    row[j] = pixel;
                  }
                }
                return bitmap;
              }
              function decodeRefinement(width, height, templateIndex, referenceBitmap, offsetX, offsetY, prediction, at, decodingContext) {
                let codingTemplate = RefinementTemplates[templateIndex].coding;
                if (templateIndex === 0) {
                  codingTemplate = codingTemplate.concat([at[0]]);
                }
                const codingTemplateLength = codingTemplate.length;
                const codingTemplateX = new Int32Array(codingTemplateLength);
                const codingTemplateY = new Int32Array(codingTemplateLength);
                let k;
                for (k = 0; k < codingTemplateLength; k++) {
                  codingTemplateX[k] = codingTemplate[k].x;
                  codingTemplateY[k] = codingTemplate[k].y;
                }
                let referenceTemplate = RefinementTemplates[templateIndex].reference;
                if (templateIndex === 0) {
                  referenceTemplate = referenceTemplate.concat([at[1]]);
                }
                const referenceTemplateLength = referenceTemplate.length;
                const referenceTemplateX = new Int32Array(referenceTemplateLength);
                const referenceTemplateY = new Int32Array(referenceTemplateLength);
                for (k = 0; k < referenceTemplateLength; k++) {
                  referenceTemplateX[k] = referenceTemplate[k].x;
                  referenceTemplateY[k] = referenceTemplate[k].y;
                }
                const referenceWidth = referenceBitmap[0].length;
                const referenceHeight = referenceBitmap.length;
                const pseudoPixelContext = RefinementReusedContexts[templateIndex];
                const bitmap = [];
                const decoder = decodingContext.decoder;
                const contexts = decodingContext.contextCache.getContexts("GR");
                let ltp = 0;
                for (let i = 0; i < height; i++) {
                  if (prediction) {
                    const sltp = decoder.readBit(contexts, pseudoPixelContext);
                    ltp ^= sltp;
                    if (ltp) {
                      throw new Jbig2Error("prediction is not supported");
                    }
                  }
                  const row = new Uint8Array(width);
                  bitmap.push(row);
                  for (let j = 0; j < width; j++) {
                    let i0, j0;
                    let contextLabel = 0;
                    for (k = 0; k < codingTemplateLength; k++) {
                      i0 = i + codingTemplateY[k];
                      j0 = j + codingTemplateX[k];
                      if (i0 < 0 || j0 < 0 || j0 >= width) {
                        contextLabel <<= 1;
                      } else {
                        contextLabel = contextLabel << 1 | bitmap[i0][j0];
                      }
                    }
                    for (k = 0; k < referenceTemplateLength; k++) {
                      i0 = i + referenceTemplateY[k] - offsetY;
                      j0 = j + referenceTemplateX[k] - offsetX;
                      if (i0 < 0 || i0 >= referenceHeight || j0 < 0 || j0 >= referenceWidth) {
                        contextLabel <<= 1;
                      } else {
                        contextLabel = contextLabel << 1 | referenceBitmap[i0][j0];
                      }
                    }
                    const pixel = decoder.readBit(contexts, contextLabel);
                    row[j] = pixel;
                  }
                }
                return bitmap;
              }
              function decodeSymbolDictionary(huffman, refinement, symbols, numberOfNewSymbols, numberOfExportedSymbols, huffmanTables, templateIndex, at, refinementTemplateIndex, refinementAt, decodingContext, huffmanInput) {
                if (huffman && refinement) {
                  throw new Jbig2Error("symbol refinement with Huffman is not supported");
                }
                const newSymbols = [];
                let currentHeight = 0;
                let symbolCodeLength = (0, _core_utils.log2)(symbols.length + numberOfNewSymbols);
                const decoder = decodingContext.decoder;
                const contextCache = decodingContext.contextCache;
                let tableB1, symbolWidths;
                if (huffman) {
                  tableB1 = getStandardTable(1);
                  symbolWidths = [];
                  symbolCodeLength = Math.max(symbolCodeLength, 1);
                }
                while (newSymbols.length < numberOfNewSymbols) {
                  const deltaHeight = huffman ? huffmanTables.tableDeltaHeight.decode(huffmanInput) : decodeInteger(contextCache, "IADH", decoder);
                  currentHeight += deltaHeight;
                  let currentWidth = 0, totalWidth = 0;
                  const firstSymbol = huffman ? symbolWidths.length : 0;
                  while (true) {
                    const deltaWidth = huffman ? huffmanTables.tableDeltaWidth.decode(huffmanInput) : decodeInteger(contextCache, "IADW", decoder);
                    if (deltaWidth === null) {
                      break;
                    }
                    currentWidth += deltaWidth;
                    totalWidth += currentWidth;
                    let bitmap;
                    if (refinement) {
                      const numberOfInstances = decodeInteger(contextCache, "IAAI", decoder);
                      if (numberOfInstances > 1) {
                        bitmap = decodeTextRegion(huffman, refinement, currentWidth, currentHeight, 0, numberOfInstances, 1, symbols.concat(newSymbols), symbolCodeLength, 0, 0, 1, 0, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, 0, huffmanInput);
                      } else {
                        const symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);
                        const rdx = decodeInteger(contextCache, "IARDX", decoder);
                        const rdy = decodeInteger(contextCache, "IARDY", decoder);
                        const symbol = symbolId < symbols.length ? symbols[symbolId] : newSymbols[symbolId - symbols.length];
                        bitmap = decodeRefinement(currentWidth, currentHeight, refinementTemplateIndex, symbol, rdx, rdy, false, refinementAt, decodingContext);
                      }
                      newSymbols.push(bitmap);
                    } else if (huffman) {
                      symbolWidths.push(currentWidth);
                    } else {
                      bitmap = decodeBitmap(false, currentWidth, currentHeight, templateIndex, false, null, at, decodingContext);
                      newSymbols.push(bitmap);
                    }
                  }
                  if (huffman && !refinement) {
                    const bitmapSize = huffmanTables.tableBitmapSize.decode(huffmanInput);
                    huffmanInput.byteAlign();
                    let collectiveBitmap;
                    if (bitmapSize === 0) {
                      collectiveBitmap = readUncompressedBitmap(huffmanInput, totalWidth, currentHeight);
                    } else {
                      const originalEnd = huffmanInput.end;
                      const bitmapEnd = huffmanInput.position + bitmapSize;
                      huffmanInput.end = bitmapEnd;
                      collectiveBitmap = decodeMMRBitmap(huffmanInput, totalWidth, currentHeight, false);
                      huffmanInput.end = originalEnd;
                      huffmanInput.position = bitmapEnd;
                    }
                    const numberOfSymbolsDecoded = symbolWidths.length;
                    if (firstSymbol === numberOfSymbolsDecoded - 1) {
                      newSymbols.push(collectiveBitmap);
                    } else {
                      let i2, y, xMin = 0, xMax, bitmapWidth, symbolBitmap;
                      for (i2 = firstSymbol; i2 < numberOfSymbolsDecoded; i2++) {
                        bitmapWidth = symbolWidths[i2];
                        xMax = xMin + bitmapWidth;
                        symbolBitmap = [];
                        for (y = 0; y < currentHeight; y++) {
                          symbolBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
                        }
                        newSymbols.push(symbolBitmap);
                        xMin = xMax;
                      }
                    }
                  }
                }
                const exportedSymbols = [], flags = [];
                let currentFlag = false, i, ii;
                const totalSymbolsLength = symbols.length + numberOfNewSymbols;
                while (flags.length < totalSymbolsLength) {
                  let runLength = huffman ? tableB1.decode(huffmanInput) : decodeInteger(contextCache, "IAEX", decoder);
                  while (runLength--) {
                    flags.push(currentFlag);
                  }
                  currentFlag = !currentFlag;
                }
                for (i = 0, ii = symbols.length; i < ii; i++) {
                  if (flags[i]) {
                    exportedSymbols.push(symbols[i]);
                  }
                }
                for (let j = 0; j < numberOfNewSymbols; i++, j++) {
                  if (flags[i]) {
                    exportedSymbols.push(newSymbols[j]);
                  }
                }
                return exportedSymbols;
              }
              function decodeTextRegion(huffman, refinement, width, height, defaultPixelValue, numberOfSymbolInstances, stripSize, inputSymbols, symbolCodeLength, transposed, dsOffset, referenceCorner, combinationOperator, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, logStripSize, huffmanInput) {
                if (huffman && refinement) {
                  throw new Jbig2Error("refinement with Huffman is not supported");
                }
                const bitmap = [];
                let i, row;
                for (i = 0; i < height; i++) {
                  row = new Uint8Array(width);
                  if (defaultPixelValue) {
                    for (let j = 0; j < width; j++) {
                      row[j] = defaultPixelValue;
                    }
                  }
                  bitmap.push(row);
                }
                const decoder = decodingContext.decoder;
                const contextCache = decodingContext.contextCache;
                let stripT = huffman ? -huffmanTables.tableDeltaT.decode(huffmanInput) : -decodeInteger(contextCache, "IADT", decoder);
                let firstS = 0;
                i = 0;
                while (i < numberOfSymbolInstances) {
                  const deltaT = huffman ? huffmanTables.tableDeltaT.decode(huffmanInput) : decodeInteger(contextCache, "IADT", decoder);
                  stripT += deltaT;
                  const deltaFirstS = huffman ? huffmanTables.tableFirstS.decode(huffmanInput) : decodeInteger(contextCache, "IAFS", decoder);
                  firstS += deltaFirstS;
                  let currentS = firstS;
                  do {
                    let currentT = 0;
                    if (stripSize > 1) {
                      currentT = huffman ? huffmanInput.readBits(logStripSize) : decodeInteger(contextCache, "IAIT", decoder);
                    }
                    const t = stripSize * stripT + currentT;
                    const symbolId = huffman ? huffmanTables.symbolIDTable.decode(huffmanInput) : decodeIAID(contextCache, decoder, symbolCodeLength);
                    const applyRefinement = refinement && (huffman ? huffmanInput.readBit() : decodeInteger(contextCache, "IARI", decoder));
                    let symbolBitmap = inputSymbols[symbolId];
                    let symbolWidth = symbolBitmap[0].length;
                    let symbolHeight = symbolBitmap.length;
                    if (applyRefinement) {
                      const rdw = decodeInteger(contextCache, "IARDW", decoder);
                      const rdh = decodeInteger(contextCache, "IARDH", decoder);
                      const rdx = decodeInteger(contextCache, "IARDX", decoder);
                      const rdy = decodeInteger(contextCache, "IARDY", decoder);
                      symbolWidth += rdw;
                      symbolHeight += rdh;
                      symbolBitmap = decodeRefinement(symbolWidth, symbolHeight, refinementTemplateIndex, symbolBitmap, (rdw >> 1) + rdx, (rdh >> 1) + rdy, false, refinementAt, decodingContext);
                    }
                    const offsetT = t - (referenceCorner & 1 ? 0 : symbolHeight - 1);
                    const offsetS = currentS - (referenceCorner & 2 ? symbolWidth - 1 : 0);
                    let s2, t2, symbolRow;
                    if (transposed) {
                      for (s2 = 0; s2 < symbolHeight; s2++) {
                        row = bitmap[offsetS + s2];
                        if (!row) {
                          continue;
                        }
                        symbolRow = symbolBitmap[s2];
                        const maxWidth = Math.min(width - offsetT, symbolWidth);
                        switch (combinationOperator) {
                          case 0:
                            for (t2 = 0; t2 < maxWidth; t2++) {
                              row[offsetT + t2] |= symbolRow[t2];
                            }
                            break;
                          case 2:
                            for (t2 = 0; t2 < maxWidth; t2++) {
                              row[offsetT + t2] ^= symbolRow[t2];
                            }
                            break;
                          default:
                            throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
                        }
                      }
                      currentS += symbolHeight - 1;
                    } else {
                      for (t2 = 0; t2 < symbolHeight; t2++) {
                        row = bitmap[offsetT + t2];
                        if (!row) {
                          continue;
                        }
                        symbolRow = symbolBitmap[t2];
                        switch (combinationOperator) {
                          case 0:
                            for (s2 = 0; s2 < symbolWidth; s2++) {
                              row[offsetS + s2] |= symbolRow[s2];
                            }
                            break;
                          case 2:
                            for (s2 = 0; s2 < symbolWidth; s2++) {
                              row[offsetS + s2] ^= symbolRow[s2];
                            }
                            break;
                          default:
                            throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
                        }
                      }
                      currentS += symbolWidth - 1;
                    }
                    i++;
                    const deltaS = huffman ? huffmanTables.tableDeltaS.decode(huffmanInput) : decodeInteger(contextCache, "IADS", decoder);
                    if (deltaS === null) {
                      break;
                    }
                    currentS += deltaS + dsOffset;
                  } while (true);
                }
                return bitmap;
              }
              function decodePatternDictionary(mmr, patternWidth, patternHeight, maxPatternIndex, template, decodingContext) {
                const at = [];
                if (!mmr) {
                  at.push({
                    x: -patternWidth,
                    y: 0
                  });
                  if (template === 0) {
                    at.push({
                      x: -3,
                      y: -1
                    }, {
                      x: 2,
                      y: -2
                    }, {
                      x: -2,
                      y: -2
                    });
                  }
                }
                const collectiveWidth = (maxPatternIndex + 1) * patternWidth;
                const collectiveBitmap = decodeBitmap(mmr, collectiveWidth, patternHeight, template, false, null, at, decodingContext);
                const patterns = [];
                for (let i = 0; i <= maxPatternIndex; i++) {
                  const patternBitmap = [];
                  const xMin = patternWidth * i;
                  const xMax = xMin + patternWidth;
                  for (let y = 0; y < patternHeight; y++) {
                    patternBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
                  }
                  patterns.push(patternBitmap);
                }
                return patterns;
              }
              function decodeHalftoneRegion(mmr, patterns, template, regionWidth, regionHeight, defaultPixelValue, enableSkip, combinationOperator, gridWidth, gridHeight, gridOffsetX, gridOffsetY, gridVectorX, gridVectorY, decodingContext) {
                const skip = null;
                if (enableSkip) {
                  throw new Jbig2Error("skip is not supported");
                }
                if (combinationOperator !== 0) {
                  throw new Jbig2Error(`operator "${combinationOperator}" is not supported in halftone region`);
                }
                const regionBitmap = [];
                let i, j, row;
                for (i = 0; i < regionHeight; i++) {
                  row = new Uint8Array(regionWidth);
                  if (defaultPixelValue) {
                    for (j = 0; j < regionWidth; j++) {
                      row[j] = defaultPixelValue;
                    }
                  }
                  regionBitmap.push(row);
                }
                const numberOfPatterns = patterns.length;
                const pattern0 = patterns[0];
                const patternWidth = pattern0[0].length, patternHeight = pattern0.length;
                const bitsPerValue = (0, _core_utils.log2)(numberOfPatterns);
                const at = [];
                if (!mmr) {
                  at.push({
                    x: template <= 1 ? 3 : 2,
                    y: -1
                  });
                  if (template === 0) {
                    at.push({
                      x: -3,
                      y: -1
                    }, {
                      x: 2,
                      y: -2
                    }, {
                      x: -2,
                      y: -2
                    });
                  }
                }
                const grayScaleBitPlanes = [];
                let mmrInput, bitmap;
                if (mmr) {
                  mmrInput = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
                }
                for (i = bitsPerValue - 1; i >= 0; i--) {
                  if (mmr) {
                    bitmap = decodeMMRBitmap(mmrInput, gridWidth, gridHeight, true);
                  } else {
                    bitmap = decodeBitmap(false, gridWidth, gridHeight, template, false, skip, at, decodingContext);
                  }
                  grayScaleBitPlanes[i] = bitmap;
                }
                let mg, ng, bit, patternIndex, patternBitmap, x, y, patternRow, regionRow;
                for (mg = 0; mg < gridHeight; mg++) {
                  for (ng = 0; ng < gridWidth; ng++) {
                    bit = 0;
                    patternIndex = 0;
                    for (j = bitsPerValue - 1; j >= 0; j--) {
                      bit ^= grayScaleBitPlanes[j][mg][ng];
                      patternIndex |= bit << j;
                    }
                    patternBitmap = patterns[patternIndex];
                    x = gridOffsetX + mg * gridVectorY + ng * gridVectorX >> 8;
                    y = gridOffsetY + mg * gridVectorX - ng * gridVectorY >> 8;
                    if (x >= 0 && x + patternWidth <= regionWidth && y >= 0 && y + patternHeight <= regionHeight) {
                      for (i = 0; i < patternHeight; i++) {
                        regionRow = regionBitmap[y + i];
                        patternRow = patternBitmap[i];
                        for (j = 0; j < patternWidth; j++) {
                          regionRow[x + j] |= patternRow[j];
                        }
                      }
                    } else {
                      let regionX, regionY;
                      for (i = 0; i < patternHeight; i++) {
                        regionY = y + i;
                        if (regionY < 0 || regionY >= regionHeight) {
                          continue;
                        }
                        regionRow = regionBitmap[regionY];
                        patternRow = patternBitmap[i];
                        for (j = 0; j < patternWidth; j++) {
                          regionX = x + j;
                          if (regionX >= 0 && regionX < regionWidth) {
                            regionRow[regionX] |= patternRow[j];
                          }
                        }
                      }
                    }
                  }
                }
                return regionBitmap;
              }
              function readSegmentHeader(data, start) {
                const segmentHeader = {};
                segmentHeader.number = (0, _core_utils.readUint32)(data, start);
                const flags = data[start + 4];
                const segmentType = flags & 63;
                if (!SegmentTypes[segmentType]) {
                  throw new Jbig2Error("invalid segment type: " + segmentType);
                }
                segmentHeader.type = segmentType;
                segmentHeader.typeName = SegmentTypes[segmentType];
                segmentHeader.deferredNonRetain = !!(flags & 128);
                const pageAssociationFieldSize = !!(flags & 64);
                const referredFlags = data[start + 5];
                let referredToCount = referredFlags >> 5 & 7;
                const retainBits = [referredFlags & 31];
                let position = start + 6;
                if (referredFlags === 7) {
                  referredToCount = (0, _core_utils.readUint32)(data, position - 1) & 536870911;
                  position += 3;
                  let bytes = referredToCount + 7 >> 3;
                  retainBits[0] = data[position++];
                  while (--bytes > 0) {
                    retainBits.push(data[position++]);
                  }
                } else if (referredFlags === 5 || referredFlags === 6) {
                  throw new Jbig2Error("invalid referred-to flags");
                }
                segmentHeader.retainBits = retainBits;
                let referredToSegmentNumberSize = 4;
                if (segmentHeader.number <= 256) {
                  referredToSegmentNumberSize = 1;
                } else if (segmentHeader.number <= 65536) {
                  referredToSegmentNumberSize = 2;
                }
                const referredTo = [];
                let i, ii;
                for (i = 0; i < referredToCount; i++) {
                  let number;
                  if (referredToSegmentNumberSize === 1) {
                    number = data[position];
                  } else if (referredToSegmentNumberSize === 2) {
                    number = (0, _core_utils.readUint16)(data, position);
                  } else {
                    number = (0, _core_utils.readUint32)(data, position);
                  }
                  referredTo.push(number);
                  position += referredToSegmentNumberSize;
                }
                segmentHeader.referredTo = referredTo;
                if (!pageAssociationFieldSize) {
                  segmentHeader.pageAssociation = data[position++];
                } else {
                  segmentHeader.pageAssociation = (0, _core_utils.readUint32)(data, position);
                  position += 4;
                }
                segmentHeader.length = (0, _core_utils.readUint32)(data, position);
                position += 4;
                if (segmentHeader.length === 4294967295) {
                  if (segmentType === 38) {
                    const genericRegionInfo = readRegionSegmentInformation(data, position);
                    const genericRegionSegmentFlags = data[position + RegionSegmentInformationFieldLength];
                    const genericRegionMmr = !!(genericRegionSegmentFlags & 1);
                    const searchPatternLength = 6;
                    const searchPattern = new Uint8Array(searchPatternLength);
                    if (!genericRegionMmr) {
                      searchPattern[0] = 255;
                      searchPattern[1] = 172;
                    }
                    searchPattern[2] = genericRegionInfo.height >>> 24 & 255;
                    searchPattern[3] = genericRegionInfo.height >> 16 & 255;
                    searchPattern[4] = genericRegionInfo.height >> 8 & 255;
                    searchPattern[5] = genericRegionInfo.height & 255;
                    for (i = position, ii = data.length; i < ii; i++) {
                      let j = 0;
                      while (j < searchPatternLength && searchPattern[j] === data[i + j]) {
                        j++;
                      }
                      if (j === searchPatternLength) {
                        segmentHeader.length = i + searchPatternLength;
                        break;
                      }
                    }
                    if (segmentHeader.length === 4294967295) {
                      throw new Jbig2Error("segment end was not found");
                    }
                  } else {
                    throw new Jbig2Error("invalid unknown segment length");
                  }
                }
                segmentHeader.headerEnd = position;
                return segmentHeader;
              }
              function readSegments(header, data, start, end) {
                const segments = [];
                let position = start;
                while (position < end) {
                  const segmentHeader = readSegmentHeader(data, position);
                  position = segmentHeader.headerEnd;
                  const segment = {
                    header: segmentHeader,
                    data
                  };
                  if (!header.randomAccess) {
                    segment.start = position;
                    position += segmentHeader.length;
                    segment.end = position;
                  }
                  segments.push(segment);
                  if (segmentHeader.type === 51) {
                    break;
                  }
                }
                if (header.randomAccess) {
                  for (let i = 0, ii = segments.length; i < ii; i++) {
                    segments[i].start = position;
                    position += segments[i].header.length;
                    segments[i].end = position;
                  }
                }
                return segments;
              }
              function readRegionSegmentInformation(data, start) {
                return {
                  width: (0, _core_utils.readUint32)(data, start),
                  height: (0, _core_utils.readUint32)(data, start + 4),
                  x: (0, _core_utils.readUint32)(data, start + 8),
                  y: (0, _core_utils.readUint32)(data, start + 12),
                  combinationOperator: data[start + 16] & 7
                };
              }
              const RegionSegmentInformationFieldLength = 17;
              function processSegment(segment, visitor) {
                const header = segment.header;
                const data = segment.data, end = segment.end;
                let position = segment.start;
                let args, at, i, atLength;
                switch (header.type) {
                  case 0:
                    const dictionary = {};
                    const dictionaryFlags = (0, _core_utils.readUint16)(data, position);
                    dictionary.huffman = !!(dictionaryFlags & 1);
                    dictionary.refinement = !!(dictionaryFlags & 2);
                    dictionary.huffmanDHSelector = dictionaryFlags >> 2 & 3;
                    dictionary.huffmanDWSelector = dictionaryFlags >> 4 & 3;
                    dictionary.bitmapSizeSelector = dictionaryFlags >> 6 & 1;
                    dictionary.aggregationInstancesSelector = dictionaryFlags >> 7 & 1;
                    dictionary.bitmapCodingContextUsed = !!(dictionaryFlags & 256);
                    dictionary.bitmapCodingContextRetained = !!(dictionaryFlags & 512);
                    dictionary.template = dictionaryFlags >> 10 & 3;
                    dictionary.refinementTemplate = dictionaryFlags >> 12 & 1;
                    position += 2;
                    if (!dictionary.huffman) {
                      atLength = dictionary.template === 0 ? 4 : 1;
                      at = [];
                      for (i = 0; i < atLength; i++) {
                        at.push({
                          x: (0, _core_utils.readInt8)(data, position),
                          y: (0, _core_utils.readInt8)(data, position + 1)
                        });
                        position += 2;
                      }
                      dictionary.at = at;
                    }
                    if (dictionary.refinement && !dictionary.refinementTemplate) {
                      at = [];
                      for (i = 0; i < 2; i++) {
                        at.push({
                          x: (0, _core_utils.readInt8)(data, position),
                          y: (0, _core_utils.readInt8)(data, position + 1)
                        });
                        position += 2;
                      }
                      dictionary.refinementAt = at;
                    }
                    dictionary.numberOfExportedSymbols = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    dictionary.numberOfNewSymbols = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    args = [dictionary, header.number, header.referredTo, data, position, end];
                    break;
                  case 6:
                  case 7:
                    const textRegion = {};
                    textRegion.info = readRegionSegmentInformation(data, position);
                    position += RegionSegmentInformationFieldLength;
                    const textRegionSegmentFlags = (0, _core_utils.readUint16)(data, position);
                    position += 2;
                    textRegion.huffman = !!(textRegionSegmentFlags & 1);
                    textRegion.refinement = !!(textRegionSegmentFlags & 2);
                    textRegion.logStripSize = textRegionSegmentFlags >> 2 & 3;
                    textRegion.stripSize = 1 << textRegion.logStripSize;
                    textRegion.referenceCorner = textRegionSegmentFlags >> 4 & 3;
                    textRegion.transposed = !!(textRegionSegmentFlags & 64);
                    textRegion.combinationOperator = textRegionSegmentFlags >> 7 & 3;
                    textRegion.defaultPixelValue = textRegionSegmentFlags >> 9 & 1;
                    textRegion.dsOffset = textRegionSegmentFlags << 17 >> 27;
                    textRegion.refinementTemplate = textRegionSegmentFlags >> 15 & 1;
                    if (textRegion.huffman) {
                      const textRegionHuffmanFlags = (0, _core_utils.readUint16)(data, position);
                      position += 2;
                      textRegion.huffmanFS = textRegionHuffmanFlags & 3;
                      textRegion.huffmanDS = textRegionHuffmanFlags >> 2 & 3;
                      textRegion.huffmanDT = textRegionHuffmanFlags >> 4 & 3;
                      textRegion.huffmanRefinementDW = textRegionHuffmanFlags >> 6 & 3;
                      textRegion.huffmanRefinementDH = textRegionHuffmanFlags >> 8 & 3;
                      textRegion.huffmanRefinementDX = textRegionHuffmanFlags >> 10 & 3;
                      textRegion.huffmanRefinementDY = textRegionHuffmanFlags >> 12 & 3;
                      textRegion.huffmanRefinementSizeSelector = !!(textRegionHuffmanFlags & 16384);
                    }
                    if (textRegion.refinement && !textRegion.refinementTemplate) {
                      at = [];
                      for (i = 0; i < 2; i++) {
                        at.push({
                          x: (0, _core_utils.readInt8)(data, position),
                          y: (0, _core_utils.readInt8)(data, position + 1)
                        });
                        position += 2;
                      }
                      textRegion.refinementAt = at;
                    }
                    textRegion.numberOfSymbolInstances = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    args = [textRegion, header.referredTo, data, position, end];
                    break;
                  case 16:
                    const patternDictionary = {};
                    const patternDictionaryFlags = data[position++];
                    patternDictionary.mmr = !!(patternDictionaryFlags & 1);
                    patternDictionary.template = patternDictionaryFlags >> 1 & 3;
                    patternDictionary.patternWidth = data[position++];
                    patternDictionary.patternHeight = data[position++];
                    patternDictionary.maxPatternIndex = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    args = [patternDictionary, header.number, data, position, end];
                    break;
                  case 22:
                  case 23:
                    const halftoneRegion = {};
                    halftoneRegion.info = readRegionSegmentInformation(data, position);
                    position += RegionSegmentInformationFieldLength;
                    const halftoneRegionFlags = data[position++];
                    halftoneRegion.mmr = !!(halftoneRegionFlags & 1);
                    halftoneRegion.template = halftoneRegionFlags >> 1 & 3;
                    halftoneRegion.enableSkip = !!(halftoneRegionFlags & 8);
                    halftoneRegion.combinationOperator = halftoneRegionFlags >> 4 & 7;
                    halftoneRegion.defaultPixelValue = halftoneRegionFlags >> 7 & 1;
                    halftoneRegion.gridWidth = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    halftoneRegion.gridHeight = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    halftoneRegion.gridOffsetX = (0, _core_utils.readUint32)(data, position) & 4294967295;
                    position += 4;
                    halftoneRegion.gridOffsetY = (0, _core_utils.readUint32)(data, position) & 4294967295;
                    position += 4;
                    halftoneRegion.gridVectorX = (0, _core_utils.readUint16)(data, position);
                    position += 2;
                    halftoneRegion.gridVectorY = (0, _core_utils.readUint16)(data, position);
                    position += 2;
                    args = [halftoneRegion, header.referredTo, data, position, end];
                    break;
                  case 38:
                  case 39:
                    const genericRegion = {};
                    genericRegion.info = readRegionSegmentInformation(data, position);
                    position += RegionSegmentInformationFieldLength;
                    const genericRegionSegmentFlags = data[position++];
                    genericRegion.mmr = !!(genericRegionSegmentFlags & 1);
                    genericRegion.template = genericRegionSegmentFlags >> 1 & 3;
                    genericRegion.prediction = !!(genericRegionSegmentFlags & 8);
                    if (!genericRegion.mmr) {
                      atLength = genericRegion.template === 0 ? 4 : 1;
                      at = [];
                      for (i = 0; i < atLength; i++) {
                        at.push({
                          x: (0, _core_utils.readInt8)(data, position),
                          y: (0, _core_utils.readInt8)(data, position + 1)
                        });
                        position += 2;
                      }
                      genericRegion.at = at;
                    }
                    args = [genericRegion, data, position, end];
                    break;
                  case 48:
                    const pageInfo = {
                      width: (0, _core_utils.readUint32)(data, position),
                      height: (0, _core_utils.readUint32)(data, position + 4),
                      resolutionX: (0, _core_utils.readUint32)(data, position + 8),
                      resolutionY: (0, _core_utils.readUint32)(data, position + 12)
                    };
                    if (pageInfo.height === 4294967295) {
                      delete pageInfo.height;
                    }
                    const pageSegmentFlags = data[position + 16];
                    (0, _core_utils.readUint16)(data, position + 17);
                    pageInfo.lossless = !!(pageSegmentFlags & 1);
                    pageInfo.refinement = !!(pageSegmentFlags & 2);
                    pageInfo.defaultPixelValue = pageSegmentFlags >> 2 & 1;
                    pageInfo.combinationOperator = pageSegmentFlags >> 3 & 3;
                    pageInfo.requiresBuffer = !!(pageSegmentFlags & 32);
                    pageInfo.combinationOperatorOverride = !!(pageSegmentFlags & 64);
                    args = [pageInfo];
                    break;
                  case 49:
                    break;
                  case 50:
                    break;
                  case 51:
                    break;
                  case 53:
                    args = [header.number, data, position, end];
                    break;
                  case 62:
                    break;
                  default:
                    throw new Jbig2Error(`segment type ${header.typeName}(${header.type}) is not implemented`);
                }
                const callbackName = "on" + header.typeName;
                if (callbackName in visitor) {
                  visitor[callbackName].apply(visitor, args);
                }
              }
              function processSegments(segments, visitor) {
                for (let i = 0, ii = segments.length; i < ii; i++) {
                  processSegment(segments[i], visitor);
                }
              }
              function parseJbig2Chunks(chunks) {
                const visitor = new SimpleSegmentVisitor();
                for (let i = 0, ii = chunks.length; i < ii; i++) {
                  const chunk = chunks[i];
                  const segments = readSegments({}, chunk.data, chunk.start, chunk.end);
                  processSegments(segments, visitor);
                }
                return visitor.buffer;
              }
              function parseJbig2(data) {
                throw new Error("Not implemented: parseJbig2");
              }
              class SimpleSegmentVisitor {
                onPageInformation(info) {
                  this.currentPageInfo = info;
                  const rowSize = info.width + 7 >> 3;
                  const buffer = new Uint8ClampedArray(rowSize * info.height);
                  if (info.defaultPixelValue) {
                    buffer.fill(255);
                  }
                  this.buffer = buffer;
                }
                drawBitmap(regionInfo, bitmap) {
                  const pageInfo = this.currentPageInfo;
                  const width = regionInfo.width, height = regionInfo.height;
                  const rowSize = pageInfo.width + 7 >> 3;
                  const combinationOperator = pageInfo.combinationOperatorOverride ? regionInfo.combinationOperator : pageInfo.combinationOperator;
                  const buffer = this.buffer;
                  const mask0 = 128 >> (regionInfo.x & 7);
                  let offset0 = regionInfo.y * rowSize + (regionInfo.x >> 3);
                  let i, j, mask, offset;
                  switch (combinationOperator) {
                    case 0:
                      for (i = 0; i < height; i++) {
                        mask = mask0;
                        offset = offset0;
                        for (j = 0; j < width; j++) {
                          if (bitmap[i][j]) {
                            buffer[offset] |= mask;
                          }
                          mask >>= 1;
                          if (!mask) {
                            mask = 128;
                            offset++;
                          }
                        }
                        offset0 += rowSize;
                      }
                      break;
                    case 2:
                      for (i = 0; i < height; i++) {
                        mask = mask0;
                        offset = offset0;
                        for (j = 0; j < width; j++) {
                          if (bitmap[i][j]) {
                            buffer[offset] ^= mask;
                          }
                          mask >>= 1;
                          if (!mask) {
                            mask = 128;
                            offset++;
                          }
                        }
                        offset0 += rowSize;
                      }
                      break;
                    default:
                      throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
                  }
                }
                onImmediateGenericRegion(region, data, start, end) {
                  const regionInfo = region.info;
                  const decodingContext = new DecodingContext(data, start, end);
                  const bitmap = decodeBitmap(region.mmr, regionInfo.width, regionInfo.height, region.template, region.prediction, null, region.at, decodingContext);
                  this.drawBitmap(regionInfo, bitmap);
                }
                onImmediateLosslessGenericRegion() {
                  this.onImmediateGenericRegion(...arguments);
                }
                onSymbolDictionary(dictionary, currentSegment, referredSegments, data, start, end) {
                  let huffmanTables, huffmanInput;
                  if (dictionary.huffman) {
                    huffmanTables = getSymbolDictionaryHuffmanTables(dictionary, referredSegments, this.customTables);
                    huffmanInput = new Reader(data, start, end);
                  }
                  let symbols = this.symbols;
                  if (!symbols) {
                    this.symbols = symbols = {};
                  }
                  const inputSymbols = [];
                  for (const referredSegment of referredSegments) {
                    const referredSymbols = symbols[referredSegment];
                    if (referredSymbols) {
                      inputSymbols.push(...referredSymbols);
                    }
                  }
                  const decodingContext = new DecodingContext(data, start, end);
                  symbols[currentSegment] = decodeSymbolDictionary(dictionary.huffman, dictionary.refinement, inputSymbols, dictionary.numberOfNewSymbols, dictionary.numberOfExportedSymbols, huffmanTables, dictionary.template, dictionary.at, dictionary.refinementTemplate, dictionary.refinementAt, decodingContext, huffmanInput);
                }
                onImmediateTextRegion(region, referredSegments, data, start, end) {
                  const regionInfo = region.info;
                  let huffmanTables, huffmanInput;
                  const symbols = this.symbols;
                  const inputSymbols = [];
                  for (const referredSegment of referredSegments) {
                    const referredSymbols = symbols[referredSegment];
                    if (referredSymbols) {
                      inputSymbols.push(...referredSymbols);
                    }
                  }
                  const symbolCodeLength = (0, _core_utils.log2)(inputSymbols.length);
                  if (region.huffman) {
                    huffmanInput = new Reader(data, start, end);
                    huffmanTables = getTextRegionHuffmanTables(region, referredSegments, this.customTables, inputSymbols.length, huffmanInput);
                  }
                  const decodingContext = new DecodingContext(data, start, end);
                  const bitmap = decodeTextRegion(region.huffman, region.refinement, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.numberOfSymbolInstances, region.stripSize, inputSymbols, symbolCodeLength, region.transposed, region.dsOffset, region.referenceCorner, region.combinationOperator, huffmanTables, region.refinementTemplate, region.refinementAt, decodingContext, region.logStripSize, huffmanInput);
                  this.drawBitmap(regionInfo, bitmap);
                }
                onImmediateLosslessTextRegion() {
                  this.onImmediateTextRegion(...arguments);
                }
                onPatternDictionary(dictionary, currentSegment, data, start, end) {
                  let patterns = this.patterns;
                  if (!patterns) {
                    this.patterns = patterns = {};
                  }
                  const decodingContext = new DecodingContext(data, start, end);
                  patterns[currentSegment] = decodePatternDictionary(dictionary.mmr, dictionary.patternWidth, dictionary.patternHeight, dictionary.maxPatternIndex, dictionary.template, decodingContext);
                }
                onImmediateHalftoneRegion(region, referredSegments, data, start, end) {
                  const patterns = this.patterns[referredSegments[0]];
                  const regionInfo = region.info;
                  const decodingContext = new DecodingContext(data, start, end);
                  const bitmap = decodeHalftoneRegion(region.mmr, patterns, region.template, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.enableSkip, region.combinationOperator, region.gridWidth, region.gridHeight, region.gridOffsetX, region.gridOffsetY, region.gridVectorX, region.gridVectorY, decodingContext);
                  this.drawBitmap(regionInfo, bitmap);
                }
                onImmediateLosslessHalftoneRegion() {
                  this.onImmediateHalftoneRegion(...arguments);
                }
                onTables(currentSegment, data, start, end) {
                  let customTables = this.customTables;
                  if (!customTables) {
                    this.customTables = customTables = {};
                  }
                  customTables[currentSegment] = decodeTablesSegment(data, start, end);
                }
              }
              class HuffmanLine {
                constructor(lineData) {
                  if (lineData.length === 2) {
                    this.isOOB = true;
                    this.rangeLow = 0;
                    this.prefixLength = lineData[0];
                    this.rangeLength = 0;
                    this.prefixCode = lineData[1];
                    this.isLowerRange = false;
                  } else {
                    this.isOOB = false;
                    this.rangeLow = lineData[0];
                    this.prefixLength = lineData[1];
                    this.rangeLength = lineData[2];
                    this.prefixCode = lineData[3];
                    this.isLowerRange = lineData[4] === "lower";
                  }
                }
              }
              class HuffmanTreeNode {
                constructor(line) {
                  this.children = [];
                  if (line) {
                    this.isLeaf = true;
                    this.rangeLength = line.rangeLength;
                    this.rangeLow = line.rangeLow;
                    this.isLowerRange = line.isLowerRange;
                    this.isOOB = line.isOOB;
                  } else {
                    this.isLeaf = false;
                  }
                }
                buildTree(line, shift) {
                  const bit = line.prefixCode >> shift & 1;
                  if (shift <= 0) {
                    this.children[bit] = new HuffmanTreeNode(line);
                  } else {
                    let node = this.children[bit];
                    if (!node) {
                      this.children[bit] = node = new HuffmanTreeNode(null);
                    }
                    node.buildTree(line, shift - 1);
                  }
                }
                decodeNode(reader) {
                  if (this.isLeaf) {
                    if (this.isOOB) {
                      return null;
                    }
                    const htOffset = reader.readBits(this.rangeLength);
                    return this.rangeLow + (this.isLowerRange ? -htOffset : htOffset);
                  }
                  const node = this.children[reader.readBit()];
                  if (!node) {
                    throw new Jbig2Error("invalid Huffman data");
                  }
                  return node.decodeNode(reader);
                }
              }
              class HuffmanTable {
                constructor(lines, prefixCodesDone) {
                  if (!prefixCodesDone) {
                    this.assignPrefixCodes(lines);
                  }
                  this.rootNode = new HuffmanTreeNode(null);
                  for (let i = 0, ii = lines.length; i < ii; i++) {
                    const line = lines[i];
                    if (line.prefixLength > 0) {
                      this.rootNode.buildTree(line, line.prefixLength - 1);
                    }
                  }
                }
                decode(reader) {
                  return this.rootNode.decodeNode(reader);
                }
                assignPrefixCodes(lines) {
                  const linesLength = lines.length;
                  let prefixLengthMax = 0;
                  for (let i = 0; i < linesLength; i++) {
                    prefixLengthMax = Math.max(prefixLengthMax, lines[i].prefixLength);
                  }
                  const histogram = new Uint32Array(prefixLengthMax + 1);
                  for (let i = 0; i < linesLength; i++) {
                    histogram[lines[i].prefixLength]++;
                  }
                  let currentLength = 1, firstCode = 0, currentCode, currentTemp, line;
                  histogram[0] = 0;
                  while (currentLength <= prefixLengthMax) {
                    firstCode = firstCode + histogram[currentLength - 1] << 1;
                    currentCode = firstCode;
                    currentTemp = 0;
                    while (currentTemp < linesLength) {
                      line = lines[currentTemp];
                      if (line.prefixLength === currentLength) {
                        line.prefixCode = currentCode;
                        currentCode++;
                      }
                      currentTemp++;
                    }
                    currentLength++;
                  }
                }
              }
              function decodeTablesSegment(data, start, end) {
                const flags = data[start];
                const lowestValue = (0, _core_utils.readUint32)(data, start + 1) & 4294967295;
                const highestValue = (0, _core_utils.readUint32)(data, start + 5) & 4294967295;
                const reader = new Reader(data, start + 9, end);
                const prefixSizeBits = (flags >> 1 & 7) + 1;
                const rangeSizeBits = (flags >> 4 & 7) + 1;
                const lines = [];
                let prefixLength, rangeLength, currentRangeLow = lowestValue;
                do {
                  prefixLength = reader.readBits(prefixSizeBits);
                  rangeLength = reader.readBits(rangeSizeBits);
                  lines.push(new HuffmanLine([currentRangeLow, prefixLength, rangeLength, 0]));
                  currentRangeLow += 1 << rangeLength;
                } while (currentRangeLow < highestValue);
                prefixLength = reader.readBits(prefixSizeBits);
                lines.push(new HuffmanLine([lowestValue - 1, prefixLength, 32, 0, "lower"]));
                prefixLength = reader.readBits(prefixSizeBits);
                lines.push(new HuffmanLine([highestValue, prefixLength, 32, 0]));
                if (flags & 1) {
                  prefixLength = reader.readBits(prefixSizeBits);
                  lines.push(new HuffmanLine([prefixLength, 0]));
                }
                return new HuffmanTable(lines, false);
              }
              const standardTablesCache = {};
              function getStandardTable(number) {
                let table = standardTablesCache[number];
                if (table) {
                  return table;
                }
                let lines;
                switch (number) {
                  case 1:
                    lines = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
                    break;
                  case 2:
                    lines = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
                    break;
                  case 3:
                    lines = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
                    break;
                  case 4:
                    lines = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
                    break;
                  case 5:
                    lines = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
                    break;
                  case 6:
                    lines = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
                    break;
                  case 7:
                    lines = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
                    break;
                  case 8:
                    lines = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
                    break;
                  case 9:
                    lines = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
                    break;
                  case 10:
                    lines = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
                    break;
                  case 11:
                    lines = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
                    break;
                  case 12:
                    lines = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
                    break;
                  case 13:
                    lines = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
                    break;
                  case 14:
                    lines = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
                    break;
                  case 15:
                    lines = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
                    break;
                  default:
                    throw new Jbig2Error(`standard table B.${number} does not exist`);
                }
                for (let i = 0, ii = lines.length; i < ii; i++) {
                  lines[i] = new HuffmanLine(lines[i]);
                }
                table = new HuffmanTable(lines, true);
                standardTablesCache[number] = table;
                return table;
              }
              class Reader {
                constructor(data, start, end) {
                  this.data = data;
                  this.start = start;
                  this.end = end;
                  this.position = start;
                  this.shift = -1;
                  this.currentByte = 0;
                }
                readBit() {
                  if (this.shift < 0) {
                    if (this.position >= this.end) {
                      throw new Jbig2Error("end of data while reading bit");
                    }
                    this.currentByte = this.data[this.position++];
                    this.shift = 7;
                  }
                  const bit = this.currentByte >> this.shift & 1;
                  this.shift--;
                  return bit;
                }
                readBits(numBits) {
                  let result = 0, i;
                  for (i = numBits - 1; i >= 0; i--) {
                    result |= this.readBit() << i;
                  }
                  return result;
                }
                byteAlign() {
                  this.shift = -1;
                }
                next() {
                  if (this.position >= this.end) {
                    return -1;
                  }
                  return this.data[this.position++];
                }
              }
              function getCustomHuffmanTable(index, referredTo, customTables) {
                let currentIndex = 0;
                for (let i = 0, ii = referredTo.length; i < ii; i++) {
                  const table = customTables[referredTo[i]];
                  if (table) {
                    if (index === currentIndex) {
                      return table;
                    }
                    currentIndex++;
                  }
                }
                throw new Jbig2Error("can't find custom Huffman table");
              }
              function getTextRegionHuffmanTables(textRegion, referredTo, customTables, numberOfSymbols, reader) {
                const codes = [];
                for (let i = 0; i <= 34; i++) {
                  const codeLength = reader.readBits(4);
                  codes.push(new HuffmanLine([i, codeLength, 0, 0]));
                }
                const runCodesTable = new HuffmanTable(codes, false);
                codes.length = 0;
                for (let i = 0; i < numberOfSymbols; ) {
                  const codeLength = runCodesTable.decode(reader);
                  if (codeLength >= 32) {
                    let repeatedLength, numberOfRepeats, j;
                    switch (codeLength) {
                      case 32:
                        if (i === 0) {
                          throw new Jbig2Error("no previous value in symbol ID table");
                        }
                        numberOfRepeats = reader.readBits(2) + 3;
                        repeatedLength = codes[i - 1].prefixLength;
                        break;
                      case 33:
                        numberOfRepeats = reader.readBits(3) + 3;
                        repeatedLength = 0;
                        break;
                      case 34:
                        numberOfRepeats = reader.readBits(7) + 11;
                        repeatedLength = 0;
                        break;
                      default:
                        throw new Jbig2Error("invalid code length in symbol ID table");
                    }
                    for (j = 0; j < numberOfRepeats; j++) {
                      codes.push(new HuffmanLine([i, repeatedLength, 0, 0]));
                      i++;
                    }
                  } else {
                    codes.push(new HuffmanLine([i, codeLength, 0, 0]));
                    i++;
                  }
                }
                reader.byteAlign();
                const symbolIDTable = new HuffmanTable(codes, false);
                let customIndex = 0, tableFirstS, tableDeltaS, tableDeltaT;
                switch (textRegion.huffmanFS) {
                  case 0:
                  case 1:
                    tableFirstS = getStandardTable(textRegion.huffmanFS + 6);
                    break;
                  case 3:
                    tableFirstS = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman FS selector");
                }
                switch (textRegion.huffmanDS) {
                  case 0:
                  case 1:
                  case 2:
                    tableDeltaS = getStandardTable(textRegion.huffmanDS + 8);
                    break;
                  case 3:
                    tableDeltaS = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DS selector");
                }
                switch (textRegion.huffmanDT) {
                  case 0:
                  case 1:
                  case 2:
                    tableDeltaT = getStandardTable(textRegion.huffmanDT + 11);
                    break;
                  case 3:
                    tableDeltaT = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DT selector");
                }
                if (textRegion.refinement) {
                  throw new Jbig2Error("refinement with Huffman is not supported");
                }
                return {
                  symbolIDTable,
                  tableFirstS,
                  tableDeltaS,
                  tableDeltaT
                };
              }
              function getSymbolDictionaryHuffmanTables(dictionary, referredTo, customTables) {
                let customIndex = 0, tableDeltaHeight, tableDeltaWidth;
                switch (dictionary.huffmanDHSelector) {
                  case 0:
                  case 1:
                    tableDeltaHeight = getStandardTable(dictionary.huffmanDHSelector + 4);
                    break;
                  case 3:
                    tableDeltaHeight = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DH selector");
                }
                switch (dictionary.huffmanDWSelector) {
                  case 0:
                  case 1:
                    tableDeltaWidth = getStandardTable(dictionary.huffmanDWSelector + 2);
                    break;
                  case 3:
                    tableDeltaWidth = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DW selector");
                }
                let tableBitmapSize, tableAggregateInstances;
                if (dictionary.bitmapSizeSelector) {
                  tableBitmapSize = getCustomHuffmanTable(customIndex, referredTo, customTables);
                  customIndex++;
                } else {
                  tableBitmapSize = getStandardTable(1);
                }
                if (dictionary.aggregationInstancesSelector) {
                  tableAggregateInstances = getCustomHuffmanTable(customIndex, referredTo, customTables);
                } else {
                  tableAggregateInstances = getStandardTable(1);
                }
                return {
                  tableDeltaHeight,
                  tableDeltaWidth,
                  tableBitmapSize,
                  tableAggregateInstances
                };
              }
              function readUncompressedBitmap(reader, width, height) {
                const bitmap = [];
                for (let y = 0; y < height; y++) {
                  const row = new Uint8Array(width);
                  bitmap.push(row);
                  for (let x = 0; x < width; x++) {
                    row[x] = reader.readBit();
                  }
                  reader.byteAlign();
                }
                return bitmap;
              }
              function decodeMMRBitmap(input, width, height, endOfBlock) {
                const params = {
                  K: -1,
                  Columns: width,
                  Rows: height,
                  BlackIs1: true,
                  EndOfBlock: endOfBlock
                };
                const decoder = new _ccitt.CCITTFaxDecoder(input, params);
                const bitmap = [];
                let currentByte, eof = false;
                for (let y = 0; y < height; y++) {
                  const row = new Uint8Array(width);
                  bitmap.push(row);
                  let shift = -1;
                  for (let x = 0; x < width; x++) {
                    if (shift < 0) {
                      currentByte = decoder.readNextChar();
                      if (currentByte === -1) {
                        currentByte = 0;
                        eof = true;
                      }
                      shift = 7;
                    }
                    row[x] = currentByte >> shift & 1;
                    shift--;
                  }
                }
                if (endOfBlock && !eof) {
                  const lookForEOFLimit = 5;
                  for (let i = 0; i < lookForEOFLimit; i++) {
                    if (decoder.readNextChar() === -1) {
                      break;
                    }
                  }
                }
                return bitmap;
              }
              class Jbig2Image {
                parseChunks(chunks) {
                  return parseJbig2Chunks(chunks);
                }
                parse(data) {
                  throw new Error("Not implemented: Jbig2Image.parse");
                }
              }
              exports2.Jbig2Image = Jbig2Image;
            },
            /* 25 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ArithmeticDecoder = void 0;
              const QeTable = [{
                qe: 22017,
                nmps: 1,
                nlps: 1,
                switchFlag: 1
              }, {
                qe: 13313,
                nmps: 2,
                nlps: 6,
                switchFlag: 0
              }, {
                qe: 6145,
                nmps: 3,
                nlps: 9,
                switchFlag: 0
              }, {
                qe: 2753,
                nmps: 4,
                nlps: 12,
                switchFlag: 0
              }, {
                qe: 1313,
                nmps: 5,
                nlps: 29,
                switchFlag: 0
              }, {
                qe: 545,
                nmps: 38,
                nlps: 33,
                switchFlag: 0
              }, {
                qe: 22017,
                nmps: 7,
                nlps: 6,
                switchFlag: 1
              }, {
                qe: 21505,
                nmps: 8,
                nlps: 14,
                switchFlag: 0
              }, {
                qe: 18433,
                nmps: 9,
                nlps: 14,
                switchFlag: 0
              }, {
                qe: 14337,
                nmps: 10,
                nlps: 14,
                switchFlag: 0
              }, {
                qe: 12289,
                nmps: 11,
                nlps: 17,
                switchFlag: 0
              }, {
                qe: 9217,
                nmps: 12,
                nlps: 18,
                switchFlag: 0
              }, {
                qe: 7169,
                nmps: 13,
                nlps: 20,
                switchFlag: 0
              }, {
                qe: 5633,
                nmps: 29,
                nlps: 21,
                switchFlag: 0
              }, {
                qe: 22017,
                nmps: 15,
                nlps: 14,
                switchFlag: 1
              }, {
                qe: 21505,
                nmps: 16,
                nlps: 14,
                switchFlag: 0
              }, {
                qe: 20737,
                nmps: 17,
                nlps: 15,
                switchFlag: 0
              }, {
                qe: 18433,
                nmps: 18,
                nlps: 16,
                switchFlag: 0
              }, {
                qe: 14337,
                nmps: 19,
                nlps: 17,
                switchFlag: 0
              }, {
                qe: 13313,
                nmps: 20,
                nlps: 18,
                switchFlag: 0
              }, {
                qe: 12289,
                nmps: 21,
                nlps: 19,
                switchFlag: 0
              }, {
                qe: 10241,
                nmps: 22,
                nlps: 19,
                switchFlag: 0
              }, {
                qe: 9217,
                nmps: 23,
                nlps: 20,
                switchFlag: 0
              }, {
                qe: 8705,
                nmps: 24,
                nlps: 21,
                switchFlag: 0
              }, {
                qe: 7169,
                nmps: 25,
                nlps: 22,
                switchFlag: 0
              }, {
                qe: 6145,
                nmps: 26,
                nlps: 23,
                switchFlag: 0
              }, {
                qe: 5633,
                nmps: 27,
                nlps: 24,
                switchFlag: 0
              }, {
                qe: 5121,
                nmps: 28,
                nlps: 25,
                switchFlag: 0
              }, {
                qe: 4609,
                nmps: 29,
                nlps: 26,
                switchFlag: 0
              }, {
                qe: 4353,
                nmps: 30,
                nlps: 27,
                switchFlag: 0
              }, {
                qe: 2753,
                nmps: 31,
                nlps: 28,
                switchFlag: 0
              }, {
                qe: 2497,
                nmps: 32,
                nlps: 29,
                switchFlag: 0
              }, {
                qe: 2209,
                nmps: 33,
                nlps: 30,
                switchFlag: 0
              }, {
                qe: 1313,
                nmps: 34,
                nlps: 31,
                switchFlag: 0
              }, {
                qe: 1089,
                nmps: 35,
                nlps: 32,
                switchFlag: 0
              }, {
                qe: 673,
                nmps: 36,
                nlps: 33,
                switchFlag: 0
              }, {
                qe: 545,
                nmps: 37,
                nlps: 34,
                switchFlag: 0
              }, {
                qe: 321,
                nmps: 38,
                nlps: 35,
                switchFlag: 0
              }, {
                qe: 273,
                nmps: 39,
                nlps: 36,
                switchFlag: 0
              }, {
                qe: 133,
                nmps: 40,
                nlps: 37,
                switchFlag: 0
              }, {
                qe: 73,
                nmps: 41,
                nlps: 38,
                switchFlag: 0
              }, {
                qe: 37,
                nmps: 42,
                nlps: 39,
                switchFlag: 0
              }, {
                qe: 21,
                nmps: 43,
                nlps: 40,
                switchFlag: 0
              }, {
                qe: 9,
                nmps: 44,
                nlps: 41,
                switchFlag: 0
              }, {
                qe: 5,
                nmps: 45,
                nlps: 42,
                switchFlag: 0
              }, {
                qe: 1,
                nmps: 45,
                nlps: 43,
                switchFlag: 0
              }, {
                qe: 22017,
                nmps: 46,
                nlps: 46,
                switchFlag: 0
              }];
              class ArithmeticDecoder {
                constructor(data, start, end) {
                  this.data = data;
                  this.bp = start;
                  this.dataEnd = end;
                  this.chigh = data[start];
                  this.clow = 0;
                  this.byteIn();
                  this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127;
                  this.clow = this.clow << 7 & 65535;
                  this.ct -= 7;
                  this.a = 32768;
                }
                byteIn() {
                  const data = this.data;
                  let bp = this.bp;
                  if (data[bp] === 255) {
                    if (data[bp + 1] > 143) {
                      this.clow += 65280;
                      this.ct = 8;
                    } else {
                      bp++;
                      this.clow += data[bp] << 9;
                      this.ct = 7;
                      this.bp = bp;
                    }
                  } else {
                    bp++;
                    this.clow += bp < this.dataEnd ? data[bp] << 8 : 65280;
                    this.ct = 8;
                    this.bp = bp;
                  }
                  if (this.clow > 65535) {
                    this.chigh += this.clow >> 16;
                    this.clow &= 65535;
                  }
                }
                readBit(contexts, pos) {
                  let cx_index = contexts[pos] >> 1, cx_mps = contexts[pos] & 1;
                  const qeTableIcx = QeTable[cx_index];
                  const qeIcx = qeTableIcx.qe;
                  let d;
                  let a = this.a - qeIcx;
                  if (this.chigh < qeIcx) {
                    if (a < qeIcx) {
                      a = qeIcx;
                      d = cx_mps;
                      cx_index = qeTableIcx.nmps;
                    } else {
                      a = qeIcx;
                      d = 1 ^ cx_mps;
                      if (qeTableIcx.switchFlag === 1) {
                        cx_mps = d;
                      }
                      cx_index = qeTableIcx.nlps;
                    }
                  } else {
                    this.chigh -= qeIcx;
                    if ((a & 32768) !== 0) {
                      this.a = a;
                      return cx_mps;
                    }
                    if (a < qeIcx) {
                      d = 1 ^ cx_mps;
                      if (qeTableIcx.switchFlag === 1) {
                        cx_mps = d;
                      }
                      cx_index = qeTableIcx.nlps;
                    } else {
                      d = cx_mps;
                      cx_index = qeTableIcx.nmps;
                    }
                  }
                  do {
                    if (this.ct === 0) {
                      this.byteIn();
                    }
                    a <<= 1;
                    this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1;
                    this.clow = this.clow << 1 & 65535;
                    this.ct--;
                  } while ((a & 32768) === 0);
                  this.a = a;
                  contexts[pos] = cx_index << 1 | cx_mps;
                  return d;
                }
              }
              exports2.ArithmeticDecoder = ArithmeticDecoder;
            },
            /* 26 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.JpegStream = void 0;
              var _decode_stream = __w_pdfjs_require__2(18);
              var _primitives = __w_pdfjs_require__2(4);
              var _jpg = __w_pdfjs_require__2(27);
              var _util = __w_pdfjs_require__2(2);
              class JpegStream extends _decode_stream.DecodeStream {
                constructor(stream, maybeLength, params) {
                  let ch;
                  while ((ch = stream.getByte()) !== -1) {
                    if (ch === 255) {
                      stream.skip(-1);
                      break;
                    }
                  }
                  super(maybeLength);
                  this.stream = stream;
                  this.dict = stream.dict;
                  this.maybeLength = maybeLength;
                  this.params = params;
                }
                get bytes() {
                  return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                }
                ensureBuffer(requested) {
                }
                readBlock() {
                  if (this.eof) {
                    return;
                  }
                  const jpegOptions = {
                    decodeTransform: void 0,
                    colorTransform: void 0
                  };
                  const decodeArr = this.dict.getArray("D", "Decode");
                  if ((this.forceRGBA || this.forceRGB) && Array.isArray(decodeArr)) {
                    const bitsPerComponent = this.dict.get("BPC", "BitsPerComponent") || 8;
                    const decodeArrLength = decodeArr.length;
                    const transform = new Int32Array(decodeArrLength);
                    let transformNeeded = false;
                    const maxValue = (1 << bitsPerComponent) - 1;
                    for (let i = 0; i < decodeArrLength; i += 2) {
                      transform[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0;
                      transform[i + 1] = decodeArr[i] * maxValue | 0;
                      if (transform[i] !== 256 || transform[i + 1] !== 0) {
                        transformNeeded = true;
                      }
                    }
                    if (transformNeeded) {
                      jpegOptions.decodeTransform = transform;
                    }
                  }
                  if (this.params instanceof _primitives.Dict) {
                    const colorTransform = this.params.get("ColorTransform");
                    if (Number.isInteger(colorTransform)) {
                      jpegOptions.colorTransform = colorTransform;
                    }
                  }
                  const jpegImage = new _jpg.JpegImage(jpegOptions);
                  jpegImage.parse(this.bytes);
                  const data = jpegImage.getData({
                    width: this.drawWidth,
                    height: this.drawHeight,
                    forceRGBA: this.forceRGBA,
                    forceRGB: this.forceRGB,
                    isSourcePDF: true
                  });
                  this.buffer = data;
                  this.bufferLength = data.length;
                  this.eof = true;
                }
              }
              exports2.JpegStream = JpegStream;
            },
            /* 27 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.JpegImage = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _image_utils = __w_pdfjs_require__2(28);
              var _core_utils = __w_pdfjs_require__2(3);
              class JpegError extends _util.BaseException {
                constructor(msg) {
                  super(`JPEG error: ${msg}`, "JpegError");
                }
              }
              class DNLMarkerError extends _util.BaseException {
                constructor(message, scanLines) {
                  super(message, "DNLMarkerError");
                  this.scanLines = scanLines;
                }
              }
              class EOIMarkerError extends _util.BaseException {
                constructor(msg) {
                  super(msg, "EOIMarkerError");
                }
              }
              const dctZigZag = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
              const dctCos1 = 4017;
              const dctSin1 = 799;
              const dctCos3 = 3406;
              const dctSin3 = 2276;
              const dctCos6 = 1567;
              const dctSin6 = 3784;
              const dctSqrt2 = 5793;
              const dctSqrt1d2 = 2896;
              function buildHuffmanTable(codeLengths, values) {
                let k = 0, i, j, length = 16;
                while (length > 0 && !codeLengths[length - 1]) {
                  length--;
                }
                const code = [{
                  children: [],
                  index: 0
                }];
                let p = code[0], q;
                for (i = 0; i < length; i++) {
                  for (j = 0; j < codeLengths[i]; j++) {
                    p = code.pop();
                    p.children[p.index] = values[k];
                    while (p.index > 0) {
                      p = code.pop();
                    }
                    p.index++;
                    code.push(p);
                    while (code.length <= i) {
                      code.push(q = {
                        children: [],
                        index: 0
                      });
                      p.children[p.index] = q.children;
                      p = q;
                    }
                    k++;
                  }
                  if (i + 1 < length) {
                    code.push(q = {
                      children: [],
                      index: 0
                    });
                    p.children[p.index] = q.children;
                    p = q;
                  }
                }
                return code[0].children;
              }
              function getBlockBufferOffset(component, row, col) {
                return 64 * ((component.blocksPerLine + 1) * row + col);
              }
              function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, parseDNLMarker = false) {
                const mcusPerLine = frame.mcusPerLine;
                const progressive = frame.progressive;
                const startOffset = offset;
                let bitsData = 0, bitsCount = 0;
                function readBit() {
                  if (bitsCount > 0) {
                    bitsCount--;
                    return bitsData >> bitsCount & 1;
                  }
                  bitsData = data[offset++];
                  if (bitsData === 255) {
                    const nextByte = data[offset++];
                    if (nextByte) {
                      if (nextByte === 220 && parseDNLMarker) {
                        offset += 2;
                        const scanLines = (0, _core_utils.readUint16)(data, offset);
                        offset += 2;
                        if (scanLines > 0 && scanLines !== frame.scanLines) {
                          throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", scanLines);
                        }
                      } else if (nextByte === 217) {
                        if (parseDNLMarker) {
                          const maybeScanLines = blockRow * (frame.precision === 8 ? 8 : 0);
                          if (maybeScanLines > 0 && Math.round(frame.scanLines / maybeScanLines) >= 5) {
                            throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", maybeScanLines);
                          }
                        }
                        throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                      }
                      throw new JpegError(`unexpected marker ${(bitsData << 8 | nextByte).toString(16)}`);
                    }
                  }
                  bitsCount = 7;
                  return bitsData >>> 7;
                }
                function decodeHuffman(tree) {
                  let node = tree;
                  while (true) {
                    node = node[readBit()];
                    switch (typeof node) {
                      case "number":
                        return node;
                      case "object":
                        continue;
                    }
                    throw new JpegError("invalid huffman sequence");
                  }
                }
                function receive(length) {
                  let n2 = 0;
                  while (length > 0) {
                    n2 = n2 << 1 | readBit();
                    length--;
                  }
                  return n2;
                }
                function receiveAndExtend(length) {
                  if (length === 1) {
                    return readBit() === 1 ? 1 : -1;
                  }
                  const n2 = receive(length);
                  if (n2 >= 1 << length - 1) {
                    return n2;
                  }
                  return n2 + (-1 << length) + 1;
                }
                function decodeBaseline(component2, blockOffset) {
                  const t = decodeHuffman(component2.huffmanTableDC);
                  const diff = t === 0 ? 0 : receiveAndExtend(t);
                  component2.blockData[blockOffset] = component2.pred += diff;
                  let k2 = 1;
                  while (k2 < 64) {
                    const rs = decodeHuffman(component2.huffmanTableAC);
                    const s = rs & 15, r = rs >> 4;
                    if (s === 0) {
                      if (r < 15) {
                        break;
                      }
                      k2 += 16;
                      continue;
                    }
                    k2 += r;
                    const z = dctZigZag[k2];
                    component2.blockData[blockOffset + z] = receiveAndExtend(s);
                    k2++;
                  }
                }
                function decodeDCFirst(component2, blockOffset) {
                  const t = decodeHuffman(component2.huffmanTableDC);
                  const diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
                  component2.blockData[blockOffset] = component2.pred += diff;
                }
                function decodeDCSuccessive(component2, blockOffset) {
                  component2.blockData[blockOffset] |= readBit() << successive;
                }
                let eobrun = 0;
                function decodeACFirst(component2, blockOffset) {
                  if (eobrun > 0) {
                    eobrun--;
                    return;
                  }
                  let k2 = spectralStart;
                  const e = spectralEnd;
                  while (k2 <= e) {
                    const rs = decodeHuffman(component2.huffmanTableAC);
                    const s = rs & 15, r = rs >> 4;
                    if (s === 0) {
                      if (r < 15) {
                        eobrun = receive(r) + (1 << r) - 1;
                        break;
                      }
                      k2 += 16;
                      continue;
                    }
                    k2 += r;
                    const z = dctZigZag[k2];
                    component2.blockData[blockOffset + z] = receiveAndExtend(s) * (1 << successive);
                    k2++;
                  }
                }
                let successiveACState = 0, successiveACNextValue;
                function decodeACSuccessive(component2, blockOffset) {
                  let k2 = spectralStart;
                  const e = spectralEnd;
                  let r = 0;
                  let s;
                  let rs;
                  while (k2 <= e) {
                    const offsetZ = blockOffset + dctZigZag[k2];
                    const sign = component2.blockData[offsetZ] < 0 ? -1 : 1;
                    switch (successiveACState) {
                      case 0:
                        rs = decodeHuffman(component2.huffmanTableAC);
                        s = rs & 15;
                        r = rs >> 4;
                        if (s === 0) {
                          if (r < 15) {
                            eobrun = receive(r) + (1 << r);
                            successiveACState = 4;
                          } else {
                            r = 16;
                            successiveACState = 1;
                          }
                        } else {
                          if (s !== 1) {
                            throw new JpegError("invalid ACn encoding");
                          }
                          successiveACNextValue = receiveAndExtend(s);
                          successiveACState = r ? 2 : 3;
                        }
                        continue;
                      case 1:
                      case 2:
                        if (component2.blockData[offsetZ]) {
                          component2.blockData[offsetZ] += sign * (readBit() << successive);
                        } else {
                          r--;
                          if (r === 0) {
                            successiveACState = successiveACState === 2 ? 3 : 0;
                          }
                        }
                        break;
                      case 3:
                        if (component2.blockData[offsetZ]) {
                          component2.blockData[offsetZ] += sign * (readBit() << successive);
                        } else {
                          component2.blockData[offsetZ] = successiveACNextValue << successive;
                          successiveACState = 0;
                        }
                        break;
                      case 4:
                        if (component2.blockData[offsetZ]) {
                          component2.blockData[offsetZ] += sign * (readBit() << successive);
                        }
                        break;
                    }
                    k2++;
                  }
                  if (successiveACState === 4) {
                    eobrun--;
                    if (eobrun === 0) {
                      successiveACState = 0;
                    }
                  }
                }
                let blockRow = 0;
                function decodeMcu(component2, decode, mcu2, row, col) {
                  const mcuRow = mcu2 / mcusPerLine | 0;
                  const mcuCol = mcu2 % mcusPerLine;
                  blockRow = mcuRow * component2.v + row;
                  const blockCol = mcuCol * component2.h + col;
                  const blockOffset = getBlockBufferOffset(component2, blockRow, blockCol);
                  decode(component2, blockOffset);
                }
                function decodeBlock(component2, decode, mcu2) {
                  blockRow = mcu2 / component2.blocksPerLine | 0;
                  const blockCol = mcu2 % component2.blocksPerLine;
                  const blockOffset = getBlockBufferOffset(component2, blockRow, blockCol);
                  decode(component2, blockOffset);
                }
                const componentsLength = components.length;
                let component, i, j, k, n;
                let decodeFn;
                if (progressive) {
                  if (spectralStart === 0) {
                    decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
                  } else {
                    decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
                  }
                } else {
                  decodeFn = decodeBaseline;
                }
                let mcu = 0, fileMarker;
                const mcuExpected = componentsLength === 1 ? components[0].blocksPerLine * components[0].blocksPerColumn : mcusPerLine * frame.mcusPerColumn;
                let h, v;
                while (mcu <= mcuExpected) {
                  const mcuToRead = resetInterval ? Math.min(mcuExpected - mcu, resetInterval) : mcuExpected;
                  if (mcuToRead > 0) {
                    for (i = 0; i < componentsLength; i++) {
                      components[i].pred = 0;
                    }
                    eobrun = 0;
                    if (componentsLength === 1) {
                      component = components[0];
                      for (n = 0; n < mcuToRead; n++) {
                        decodeBlock(component, decodeFn, mcu);
                        mcu++;
                      }
                    } else {
                      for (n = 0; n < mcuToRead; n++) {
                        for (i = 0; i < componentsLength; i++) {
                          component = components[i];
                          h = component.h;
                          v = component.v;
                          for (j = 0; j < v; j++) {
                            for (k = 0; k < h; k++) {
                              decodeMcu(component, decodeFn, mcu, j, k);
                            }
                          }
                        }
                        mcu++;
                      }
                    }
                  }
                  bitsCount = 0;
                  fileMarker = findNextFileMarker(data, offset);
                  if (!fileMarker) {
                    break;
                  }
                  if (fileMarker.invalid) {
                    const partialMsg = mcuToRead > 0 ? "unexpected" : "excessive";
                    (0, _util.warn)(`decodeScan - ${partialMsg} MCU data, current marker is: ${fileMarker.invalid}`);
                    offset = fileMarker.offset;
                  }
                  if (fileMarker.marker >= 65488 && fileMarker.marker <= 65495) {
                    offset += 2;
                  } else {
                    break;
                  }
                }
                return offset - startOffset;
              }
              function quantizeAndInverse(component, blockBufferOffset, p) {
                const qt = component.quantizationTable, blockData = component.blockData;
                let v0, v1, v2, v3, v4, v5, v6, v7;
                let p0, p1, p2, p3, p4, p5, p6, p7;
                let t;
                if (!qt) {
                  throw new JpegError("missing required Quantization Table.");
                }
                for (let row = 0; row < 64; row += 8) {
                  p0 = blockData[blockBufferOffset + row];
                  p1 = blockData[blockBufferOffset + row + 1];
                  p2 = blockData[blockBufferOffset + row + 2];
                  p3 = blockData[blockBufferOffset + row + 3];
                  p4 = blockData[blockBufferOffset + row + 4];
                  p5 = blockData[blockBufferOffset + row + 5];
                  p6 = blockData[blockBufferOffset + row + 6];
                  p7 = blockData[blockBufferOffset + row + 7];
                  p0 *= qt[row];
                  if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
                    t = dctSqrt2 * p0 + 512 >> 10;
                    p[row] = t;
                    p[row + 1] = t;
                    p[row + 2] = t;
                    p[row + 3] = t;
                    p[row + 4] = t;
                    p[row + 5] = t;
                    p[row + 6] = t;
                    p[row + 7] = t;
                    continue;
                  }
                  p1 *= qt[row + 1];
                  p2 *= qt[row + 2];
                  p3 *= qt[row + 3];
                  p4 *= qt[row + 4];
                  p5 *= qt[row + 5];
                  p6 *= qt[row + 6];
                  p7 *= qt[row + 7];
                  v0 = dctSqrt2 * p0 + 128 >> 8;
                  v1 = dctSqrt2 * p4 + 128 >> 8;
                  v2 = p2;
                  v3 = p6;
                  v4 = dctSqrt1d2 * (p1 - p7) + 128 >> 8;
                  v7 = dctSqrt1d2 * (p1 + p7) + 128 >> 8;
                  v5 = p3 << 4;
                  v6 = p5 << 4;
                  v0 = v0 + v1 + 1 >> 1;
                  v1 = v0 - v1;
                  t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
                  v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
                  v3 = t;
                  v4 = v4 + v6 + 1 >> 1;
                  v6 = v4 - v6;
                  v7 = v7 + v5 + 1 >> 1;
                  v5 = v7 - v5;
                  v0 = v0 + v3 + 1 >> 1;
                  v3 = v0 - v3;
                  v1 = v1 + v2 + 1 >> 1;
                  v2 = v1 - v2;
                  t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
                  v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
                  v7 = t;
                  t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
                  v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
                  v6 = t;
                  p[row] = v0 + v7;
                  p[row + 7] = v0 - v7;
                  p[row + 1] = v1 + v6;
                  p[row + 6] = v1 - v6;
                  p[row + 2] = v2 + v5;
                  p[row + 5] = v2 - v5;
                  p[row + 3] = v3 + v4;
                  p[row + 4] = v3 - v4;
                }
                for (let col = 0; col < 8; ++col) {
                  p0 = p[col];
                  p1 = p[col + 8];
                  p2 = p[col + 16];
                  p3 = p[col + 24];
                  p4 = p[col + 32];
                  p5 = p[col + 40];
                  p6 = p[col + 48];
                  p7 = p[col + 56];
                  if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
                    t = dctSqrt2 * p0 + 8192 >> 14;
                    if (t < -2040) {
                      t = 0;
                    } else if (t >= 2024) {
                      t = 255;
                    } else {
                      t = t + 2056 >> 4;
                    }
                    blockData[blockBufferOffset + col] = t;
                    blockData[blockBufferOffset + col + 8] = t;
                    blockData[blockBufferOffset + col + 16] = t;
                    blockData[blockBufferOffset + col + 24] = t;
                    blockData[blockBufferOffset + col + 32] = t;
                    blockData[blockBufferOffset + col + 40] = t;
                    blockData[blockBufferOffset + col + 48] = t;
                    blockData[blockBufferOffset + col + 56] = t;
                    continue;
                  }
                  v0 = dctSqrt2 * p0 + 2048 >> 12;
                  v1 = dctSqrt2 * p4 + 2048 >> 12;
                  v2 = p2;
                  v3 = p6;
                  v4 = dctSqrt1d2 * (p1 - p7) + 2048 >> 12;
                  v7 = dctSqrt1d2 * (p1 + p7) + 2048 >> 12;
                  v5 = p3;
                  v6 = p5;
                  v0 = (v0 + v1 + 1 >> 1) + 4112;
                  v1 = v0 - v1;
                  t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
                  v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
                  v3 = t;
                  v4 = v4 + v6 + 1 >> 1;
                  v6 = v4 - v6;
                  v7 = v7 + v5 + 1 >> 1;
                  v5 = v7 - v5;
                  v0 = v0 + v3 + 1 >> 1;
                  v3 = v0 - v3;
                  v1 = v1 + v2 + 1 >> 1;
                  v2 = v1 - v2;
                  t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
                  v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
                  v7 = t;
                  t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
                  v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
                  v6 = t;
                  p0 = v0 + v7;
                  p7 = v0 - v7;
                  p1 = v1 + v6;
                  p6 = v1 - v6;
                  p2 = v2 + v5;
                  p5 = v2 - v5;
                  p3 = v3 + v4;
                  p4 = v3 - v4;
                  if (p0 < 16) {
                    p0 = 0;
                  } else if (p0 >= 4080) {
                    p0 = 255;
                  } else {
                    p0 >>= 4;
                  }
                  if (p1 < 16) {
                    p1 = 0;
                  } else if (p1 >= 4080) {
                    p1 = 255;
                  } else {
                    p1 >>= 4;
                  }
                  if (p2 < 16) {
                    p2 = 0;
                  } else if (p2 >= 4080) {
                    p2 = 255;
                  } else {
                    p2 >>= 4;
                  }
                  if (p3 < 16) {
                    p3 = 0;
                  } else if (p3 >= 4080) {
                    p3 = 255;
                  } else {
                    p3 >>= 4;
                  }
                  if (p4 < 16) {
                    p4 = 0;
                  } else if (p4 >= 4080) {
                    p4 = 255;
                  } else {
                    p4 >>= 4;
                  }
                  if (p5 < 16) {
                    p5 = 0;
                  } else if (p5 >= 4080) {
                    p5 = 255;
                  } else {
                    p5 >>= 4;
                  }
                  if (p6 < 16) {
                    p6 = 0;
                  } else if (p6 >= 4080) {
                    p6 = 255;
                  } else {
                    p6 >>= 4;
                  }
                  if (p7 < 16) {
                    p7 = 0;
                  } else if (p7 >= 4080) {
                    p7 = 255;
                  } else {
                    p7 >>= 4;
                  }
                  blockData[blockBufferOffset + col] = p0;
                  blockData[blockBufferOffset + col + 8] = p1;
                  blockData[blockBufferOffset + col + 16] = p2;
                  blockData[blockBufferOffset + col + 24] = p3;
                  blockData[blockBufferOffset + col + 32] = p4;
                  blockData[blockBufferOffset + col + 40] = p5;
                  blockData[blockBufferOffset + col + 48] = p6;
                  blockData[blockBufferOffset + col + 56] = p7;
                }
              }
              function buildComponentData(frame, component) {
                const blocksPerLine = component.blocksPerLine;
                const blocksPerColumn = component.blocksPerColumn;
                const computationBuffer = new Int16Array(64);
                for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
                  for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {
                    const offset = getBlockBufferOffset(component, blockRow, blockCol);
                    quantizeAndInverse(component, offset, computationBuffer);
                  }
                }
                return component.blockData;
              }
              function findNextFileMarker(data, currentPos, startPos = currentPos) {
                const maxPos = data.length - 1;
                let newPos = startPos < currentPos ? startPos : currentPos;
                if (currentPos >= maxPos) {
                  return null;
                }
                const currentMarker = (0, _core_utils.readUint16)(data, currentPos);
                if (currentMarker >= 65472 && currentMarker <= 65534) {
                  return {
                    invalid: null,
                    marker: currentMarker,
                    offset: currentPos
                  };
                }
                let newMarker = (0, _core_utils.readUint16)(data, newPos);
                while (!(newMarker >= 65472 && newMarker <= 65534)) {
                  if (++newPos >= maxPos) {
                    return null;
                  }
                  newMarker = (0, _core_utils.readUint16)(data, newPos);
                }
                return {
                  invalid: currentMarker.toString(16),
                  marker: newMarker,
                  offset: newPos
                };
              }
              class JpegImage {
                constructor({
                  decodeTransform = null,
                  colorTransform = -1
                } = {}) {
                  this._decodeTransform = decodeTransform;
                  this._colorTransform = colorTransform;
                }
                parse(data, {
                  dnlScanLines = null
                } = {}) {
                  function readDataBlock() {
                    const length = (0, _core_utils.readUint16)(data, offset);
                    offset += 2;
                    let endOffset = offset + length - 2;
                    const fileMarker2 = findNextFileMarker(data, endOffset, offset);
                    if (fileMarker2 == null ? void 0 : fileMarker2.invalid) {
                      (0, _util.warn)("readDataBlock - incorrect length, current marker is: " + fileMarker2.invalid);
                      endOffset = fileMarker2.offset;
                    }
                    const array = data.subarray(offset, endOffset);
                    offset += array.length;
                    return array;
                  }
                  function prepareComponents(frame2) {
                    const mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / frame2.maxH);
                    const mcusPerColumn = Math.ceil(frame2.scanLines / 8 / frame2.maxV);
                    for (const component of frame2.components) {
                      const blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component.h / frame2.maxH);
                      const blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component.v / frame2.maxV);
                      const blocksPerLineForMcu = mcusPerLine * component.h;
                      const blocksPerColumnForMcu = mcusPerColumn * component.v;
                      const blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
                      component.blockData = new Int16Array(blocksBufferSize);
                      component.blocksPerLine = blocksPerLine;
                      component.blocksPerColumn = blocksPerColumn;
                    }
                    frame2.mcusPerLine = mcusPerLine;
                    frame2.mcusPerColumn = mcusPerColumn;
                  }
                  let offset = 0;
                  let jfif = null;
                  let adobe = null;
                  let frame, resetInterval;
                  let numSOSMarkers = 0;
                  const quantizationTables = [];
                  const huffmanTablesAC = [], huffmanTablesDC = [];
                  let fileMarker = (0, _core_utils.readUint16)(data, offset);
                  offset += 2;
                  if (fileMarker !== 65496) {
                    throw new JpegError("SOI not found");
                  }
                  fileMarker = (0, _core_utils.readUint16)(data, offset);
                  offset += 2;
                  markerLoop:
                    while (fileMarker !== 65497) {
                      let i, j, l;
                      switch (fileMarker) {
                        case 65504:
                        case 65505:
                        case 65506:
                        case 65507:
                        case 65508:
                        case 65509:
                        case 65510:
                        case 65511:
                        case 65512:
                        case 65513:
                        case 65514:
                        case 65515:
                        case 65516:
                        case 65517:
                        case 65518:
                        case 65519:
                        case 65534:
                          const appData = readDataBlock();
                          if (fileMarker === 65504) {
                            if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                              jfif = {
                                version: {
                                  major: appData[5],
                                  minor: appData[6]
                                },
                                densityUnits: appData[7],
                                xDensity: appData[8] << 8 | appData[9],
                                yDensity: appData[10] << 8 | appData[11],
                                thumbWidth: appData[12],
                                thumbHeight: appData[13],
                                thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                              };
                            }
                          }
                          if (fileMarker === 65518) {
                            if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101) {
                              adobe = {
                                version: appData[5] << 8 | appData[6],
                                flags0: appData[7] << 8 | appData[8],
                                flags1: appData[9] << 8 | appData[10],
                                transformCode: appData[11]
                              };
                            }
                          }
                          break;
                        case 65499:
                          const quantizationTablesLength = (0, _core_utils.readUint16)(data, offset);
                          offset += 2;
                          const quantizationTablesEnd = quantizationTablesLength + offset - 2;
                          let z;
                          while (offset < quantizationTablesEnd) {
                            const quantizationTableSpec = data[offset++];
                            const tableData = new Uint16Array(64);
                            if (quantizationTableSpec >> 4 === 0) {
                              for (j = 0; j < 64; j++) {
                                z = dctZigZag[j];
                                tableData[z] = data[offset++];
                              }
                            } else if (quantizationTableSpec >> 4 === 1) {
                              for (j = 0; j < 64; j++) {
                                z = dctZigZag[j];
                                tableData[z] = (0, _core_utils.readUint16)(data, offset);
                                offset += 2;
                              }
                            } else {
                              throw new JpegError("DQT - invalid table spec");
                            }
                            quantizationTables[quantizationTableSpec & 15] = tableData;
                          }
                          break;
                        case 65472:
                        case 65473:
                        case 65474:
                          if (frame) {
                            throw new JpegError("Only single frame JPEGs supported");
                          }
                          offset += 2;
                          frame = {};
                          frame.extended = fileMarker === 65473;
                          frame.progressive = fileMarker === 65474;
                          frame.precision = data[offset++];
                          const sofScanLines = (0, _core_utils.readUint16)(data, offset);
                          offset += 2;
                          frame.scanLines = dnlScanLines || sofScanLines;
                          frame.samplesPerLine = (0, _core_utils.readUint16)(data, offset);
                          offset += 2;
                          frame.components = [];
                          frame.componentIds = {};
                          const componentsCount = data[offset++];
                          let maxH = 0, maxV = 0;
                          for (i = 0; i < componentsCount; i++) {
                            const componentId = data[offset];
                            const h = data[offset + 1] >> 4;
                            const v = data[offset + 1] & 15;
                            if (maxH < h) {
                              maxH = h;
                            }
                            if (maxV < v) {
                              maxV = v;
                            }
                            const qId = data[offset + 2];
                            l = frame.components.push({
                              h,
                              v,
                              quantizationId: qId,
                              quantizationTable: null
                            });
                            frame.componentIds[componentId] = l - 1;
                            offset += 3;
                          }
                          frame.maxH = maxH;
                          frame.maxV = maxV;
                          prepareComponents(frame);
                          break;
                        case 65476:
                          const huffmanLength = (0, _core_utils.readUint16)(data, offset);
                          offset += 2;
                          for (i = 2; i < huffmanLength; ) {
                            const huffmanTableSpec = data[offset++];
                            const codeLengths = new Uint8Array(16);
                            let codeLengthSum = 0;
                            for (j = 0; j < 16; j++, offset++) {
                              codeLengthSum += codeLengths[j] = data[offset];
                            }
                            const huffmanValues = new Uint8Array(codeLengthSum);
                            for (j = 0; j < codeLengthSum; j++, offset++) {
                              huffmanValues[j] = data[offset];
                            }
                            i += 17 + codeLengthSum;
                            (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                          }
                          break;
                        case 65501:
                          offset += 2;
                          resetInterval = (0, _core_utils.readUint16)(data, offset);
                          offset += 2;
                          break;
                        case 65498:
                          const parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;
                          offset += 2;
                          const selectorsCount = data[offset++], components = [];
                          for (i = 0; i < selectorsCount; i++) {
                            const index = data[offset++];
                            const componentIndex = frame.componentIds[index];
                            const component = frame.components[componentIndex];
                            component.index = index;
                            const tableSpec = data[offset++];
                            component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                            component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                            components.push(component);
                          }
                          const spectralStart = data[offset++], spectralEnd = data[offset++], successiveApproximation = data[offset++];
                          try {
                            const processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, parseDNLMarker);
                            offset += processed;
                          } catch (ex) {
                            if (ex instanceof DNLMarkerError) {
                              (0, _util.warn)(`${ex.message} -- attempting to re-parse the JPEG image.`);
                              return this.parse(data, {
                                dnlScanLines: ex.scanLines
                              });
                            } else if (ex instanceof EOIMarkerError) {
                              (0, _util.warn)(`${ex.message} -- ignoring the rest of the image data.`);
                              break markerLoop;
                            }
                            throw ex;
                          }
                          break;
                        case 65500:
                          offset += 4;
                          break;
                        case 65535:
                          if (data[offset] !== 255) {
                            offset--;
                          }
                          break;
                        default:
                          const nextFileMarker = findNextFileMarker(data, offset - 2, offset - 3);
                          if (nextFileMarker == null ? void 0 : nextFileMarker.invalid) {
                            (0, _util.warn)("JpegImage.parse - unexpected data, current marker is: " + nextFileMarker.invalid);
                            offset = nextFileMarker.offset;
                            break;
                          }
                          if (!nextFileMarker || offset >= data.length - 1) {
                            (0, _util.warn)("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
                            break markerLoop;
                          }
                          throw new JpegError("JpegImage.parse - unknown marker: " + fileMarker.toString(16));
                      }
                      fileMarker = (0, _core_utils.readUint16)(data, offset);
                      offset += 2;
                    }
                  this.width = frame.samplesPerLine;
                  this.height = frame.scanLines;
                  this.jfif = jfif;
                  this.adobe = adobe;
                  this.components = [];
                  for (const component of frame.components) {
                    const quantizationTable = quantizationTables[component.quantizationId];
                    if (quantizationTable) {
                      component.quantizationTable = quantizationTable;
                    }
                    this.components.push({
                      index: component.index,
                      output: buildComponentData(frame, component),
                      scaleX: component.h / frame.maxH,
                      scaleY: component.v / frame.maxV,
                      blocksPerLine: component.blocksPerLine,
                      blocksPerColumn: component.blocksPerColumn
                    });
                  }
                  this.numComponents = this.components.length;
                  return void 0;
                }
                _getLinearizedBlockData(width, height, isSourcePDF = false) {
                  const scaleX = this.width / width, scaleY = this.height / height;
                  let component, componentScaleX, componentScaleY, blocksPerScanline;
                  let x, y, i, j, k;
                  let index;
                  let offset = 0;
                  let output;
                  const numComponents = this.components.length;
                  const dataLength = width * height * numComponents;
                  const data = new Uint8ClampedArray(dataLength);
                  const xScaleBlockOffset = new Uint32Array(width);
                  const mask3LSB = 4294967288;
                  let lastComponentScaleX;
                  for (i = 0; i < numComponents; i++) {
                    component = this.components[i];
                    componentScaleX = component.scaleX * scaleX;
                    componentScaleY = component.scaleY * scaleY;
                    offset = i;
                    output = component.output;
                    blocksPerScanline = component.blocksPerLine + 1 << 3;
                    if (componentScaleX !== lastComponentScaleX) {
                      for (x = 0; x < width; x++) {
                        j = 0 | x * componentScaleX;
                        xScaleBlockOffset[x] = (j & mask3LSB) << 3 | j & 7;
                      }
                      lastComponentScaleX = componentScaleX;
                    }
                    for (y = 0; y < height; y++) {
                      j = 0 | y * componentScaleY;
                      index = blocksPerScanline * (j & mask3LSB) | (j & 7) << 3;
                      for (x = 0; x < width; x++) {
                        data[offset] = output[index + xScaleBlockOffset[x]];
                        offset += numComponents;
                      }
                    }
                  }
                  let transform = this._decodeTransform;
                  if (!isSourcePDF && numComponents === 4 && !transform) {
                    transform = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);
                  }
                  if (transform) {
                    for (i = 0; i < dataLength; ) {
                      for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {
                        data[i] = (data[i] * transform[k] >> 8) + transform[k + 1];
                      }
                    }
                  }
                  return data;
                }
                get _isColorConversionNeeded() {
                  if (this.adobe) {
                    return !!this.adobe.transformCode;
                  }
                  if (this.numComponents === 3) {
                    if (this._colorTransform === 0) {
                      return false;
                    } else if (this.components[0].index === 82 && this.components[1].index === 71 && this.components[2].index === 66) {
                      return false;
                    }
                    return true;
                  }
                  if (this._colorTransform === 1) {
                    return true;
                  }
                  return false;
                }
                _convertYccToRgb(data) {
                  let Y, Cb, Cr;
                  for (let i = 0, length = data.length; i < length; i += 3) {
                    Y = data[i];
                    Cb = data[i + 1];
                    Cr = data[i + 2];
                    data[i] = Y - 179.456 + 1.402 * Cr;
                    data[i + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;
                    data[i + 2] = Y - 226.816 + 1.772 * Cb;
                  }
                  return data;
                }
                _convertYccToRgba(data, out) {
                  for (let i = 0, j = 0, length = data.length; i < length; i += 3, j += 4) {
                    const Y = data[i];
                    const Cb = data[i + 1];
                    const Cr = data[i + 2];
                    out[j] = Y - 179.456 + 1.402 * Cr;
                    out[j + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;
                    out[j + 2] = Y - 226.816 + 1.772 * Cb;
                    out[j + 3] = 255;
                  }
                  return out;
                }
                _convertYcckToRgb(data) {
                  let Y, Cb, Cr, k;
                  let offset = 0;
                  for (let i = 0, length = data.length; i < length; i += 4) {
                    Y = data[i];
                    Cb = data[i + 1];
                    Cr = data[i + 2];
                    k = data[i + 3];
                    data[offset++] = -122.67195406894 + Cb * (-660635669420364e-19 * Cb + 437130475926232e-18 * Cr - 54080610064599e-18 * Y + 48449797120281e-17 * k - 0.154362151871126) + Cr * (-957964378445773e-18 * Cr + 817076911346625e-18 * Y - 0.00477271405408747 * k + 1.53380253221734) + Y * (961250184130688e-18 * Y - 0.00266257332283933 * k + 0.48357088451265) + k * (-336197177618394e-18 * k + 0.484791561490776);
                    data[offset++] = 107.268039397724 + Cb * (219927104525741e-19 * Cb - 640992018297945e-18 * Cr + 659397001245577e-18 * Y + 426105652938837e-18 * k - 0.176491792462875) + Cr * (-778269941513683e-18 * Cr + 0.00130872261408275 * Y + 770482631801132e-18 * k - 0.151051492775562) + Y * (0.00126935368114843 * Y - 0.00265090189010898 * k + 0.25802910206845) + k * (-318913117588328e-18 * k - 0.213742400323665);
                    data[offset++] = -20.810012546947 + Cb * (-570115196973677e-18 * Cb - 263409051004589e-19 * Cr + 0.0020741088115012 * Y - 0.00288260236853442 * k + 0.814272968359295) + Cr * (-153496057440975e-19 * Cr - 132689043961446e-18 * Y + 560833691242812e-18 * k - 0.195152027534049) + Y * (0.00174418132927582 * Y - 0.00255243321439347 * k + 0.116935020465145) + k * (-343531996510555e-18 * k + 0.24165260232407);
                  }
                  return data.subarray(0, offset);
                }
                _convertYcckToRgba(data) {
                  for (let i = 0, length = data.length; i < length; i += 4) {
                    const Y = data[i];
                    const Cb = data[i + 1];
                    const Cr = data[i + 2];
                    const k = data[i + 3];
                    data[i] = -122.67195406894 + Cb * (-660635669420364e-19 * Cb + 437130475926232e-18 * Cr - 54080610064599e-18 * Y + 48449797120281e-17 * k - 0.154362151871126) + Cr * (-957964378445773e-18 * Cr + 817076911346625e-18 * Y - 0.00477271405408747 * k + 1.53380253221734) + Y * (961250184130688e-18 * Y - 0.00266257332283933 * k + 0.48357088451265) + k * (-336197177618394e-18 * k + 0.484791561490776);
                    data[i + 1] = 107.268039397724 + Cb * (219927104525741e-19 * Cb - 640992018297945e-18 * Cr + 659397001245577e-18 * Y + 426105652938837e-18 * k - 0.176491792462875) + Cr * (-778269941513683e-18 * Cr + 0.00130872261408275 * Y + 770482631801132e-18 * k - 0.151051492775562) + Y * (0.00126935368114843 * Y - 0.00265090189010898 * k + 0.25802910206845) + k * (-318913117588328e-18 * k - 0.213742400323665);
                    data[i + 2] = -20.810012546947 + Cb * (-570115196973677e-18 * Cb - 263409051004589e-19 * Cr + 0.0020741088115012 * Y - 0.00288260236853442 * k + 0.814272968359295) + Cr * (-153496057440975e-19 * Cr - 132689043961446e-18 * Y + 560833691242812e-18 * k - 0.195152027534049) + Y * (0.00174418132927582 * Y - 0.00255243321439347 * k + 0.116935020465145) + k * (-343531996510555e-18 * k + 0.24165260232407);
                    data[i + 3] = 255;
                  }
                  return data;
                }
                _convertYcckToCmyk(data) {
                  let Y, Cb, Cr;
                  for (let i = 0, length = data.length; i < length; i += 4) {
                    Y = data[i];
                    Cb = data[i + 1];
                    Cr = data[i + 2];
                    data[i] = 434.456 - Y - 1.402 * Cr;
                    data[i + 1] = 119.541 - Y + 0.344 * Cb + 0.714 * Cr;
                    data[i + 2] = 481.816 - Y - 1.772 * Cb;
                  }
                  return data;
                }
                _convertCmykToRgb(data) {
                  let c, m, y, k;
                  let offset = 0;
                  for (let i = 0, length = data.length; i < length; i += 4) {
                    c = data[i];
                    m = data[i + 1];
                    y = data[i + 2];
                    k = data[i + 3];
                    data[offset++] = 255 + c * (-6747147073602441e-20 * c + 8379262121013727e-19 * m + 2894718188643294e-19 * y + 0.003264231057537806 * k - 1.1185611867203937) + m * (26374107616089405e-21 * m - 8626949158638572e-20 * y - 2748769067499491e-19 * k - 0.02155688794978967) + y * (-3878099212869363e-20 * y - 3267808279485286e-19 * k + 0.0686742238595345) - k * (3361971776183937e-19 * k + 0.7430659151342254);
                    data[offset++] = 255 + c * (13596372813588848e-20 * c + 924537132573585e-18 * m + 10567359618683593e-20 * y + 4791864687436512e-19 * k - 0.3109689587515875) + m * (-23545346108370344e-20 * m + 2702845253534714e-19 * y + 0.0020200308977307156 * k - 0.7488052167015494) + y * (6834815998235662e-20 * y + 15168452363460973e-20 * k - 0.09751927774728933) - k * (3189131175883281e-19 * k + 0.7364883807733168);
                    data[offset++] = 255 + c * (13598650411385307e-21 * c + 12423956175490851e-20 * m + 4751985097583589e-19 * y - 36729317476630422e-22 * k - 0.05562186980264034) + m * (16141380598724676e-20 * m + 9692239130725186e-19 * y + 7782692450036253e-19 * k - 0.44015232367526463) + y * (5068882914068769e-22 * y + 0.0017778369011375071 * k - 0.7591454649749609) - k * (3435319965105553e-19 * k + 0.7063770186160144);
                  }
                  return data.subarray(0, offset);
                }
                _convertCmykToRgba(data) {
                  for (let i = 0, length = data.length; i < length; i += 4) {
                    const c = data[i];
                    const m = data[i + 1];
                    const y = data[i + 2];
                    const k = data[i + 3];
                    data[i] = 255 + c * (-6747147073602441e-20 * c + 8379262121013727e-19 * m + 2894718188643294e-19 * y + 0.003264231057537806 * k - 1.1185611867203937) + m * (26374107616089405e-21 * m - 8626949158638572e-20 * y - 2748769067499491e-19 * k - 0.02155688794978967) + y * (-3878099212869363e-20 * y - 3267808279485286e-19 * k + 0.0686742238595345) - k * (3361971776183937e-19 * k + 0.7430659151342254);
                    data[i + 1] = 255 + c * (13596372813588848e-20 * c + 924537132573585e-18 * m + 10567359618683593e-20 * y + 4791864687436512e-19 * k - 0.3109689587515875) + m * (-23545346108370344e-20 * m + 2702845253534714e-19 * y + 0.0020200308977307156 * k - 0.7488052167015494) + y * (6834815998235662e-20 * y + 15168452363460973e-20 * k - 0.09751927774728933) - k * (3189131175883281e-19 * k + 0.7364883807733168);
                    data[i + 2] = 255 + c * (13598650411385307e-21 * c + 12423956175490851e-20 * m + 4751985097583589e-19 * y - 36729317476630422e-22 * k - 0.05562186980264034) + m * (16141380598724676e-20 * m + 9692239130725186e-19 * y + 7782692450036253e-19 * k - 0.44015232367526463) + y * (5068882914068769e-22 * y + 0.0017778369011375071 * k - 0.7591454649749609) - k * (3435319965105553e-19 * k + 0.7063770186160144);
                    data[i + 3] = 255;
                  }
                  return data;
                }
                getData({
                  width,
                  height,
                  forceRGBA = false,
                  forceRGB = false,
                  isSourcePDF = false
                }) {
                  if (this.numComponents > 4) {
                    throw new JpegError("Unsupported color mode");
                  }
                  const data = this._getLinearizedBlockData(width, height, isSourcePDF);
                  if (this.numComponents === 1 && (forceRGBA || forceRGB)) {
                    const len = data.length * (forceRGBA ? 4 : 3);
                    const rgbaData = new Uint8ClampedArray(len);
                    let offset = 0;
                    if (forceRGBA) {
                      (0, _image_utils.grayToRGBA)(data, new Uint32Array(rgbaData.buffer));
                    } else {
                      for (const grayColor of data) {
                        rgbaData[offset++] = grayColor;
                        rgbaData[offset++] = grayColor;
                        rgbaData[offset++] = grayColor;
                      }
                    }
                    return rgbaData;
                  } else if (this.numComponents === 3 && this._isColorConversionNeeded) {
                    if (forceRGBA) {
                      const rgbaData = new Uint8ClampedArray(data.length / 3 * 4);
                      return this._convertYccToRgba(data, rgbaData);
                    }
                    return this._convertYccToRgb(data);
                  } else if (this.numComponents === 4) {
                    if (this._isColorConversionNeeded) {
                      if (forceRGBA) {
                        return this._convertYcckToRgba(data);
                      }
                      if (forceRGB) {
                        return this._convertYcckToRgb(data);
                      }
                      return this._convertYcckToCmyk(data);
                    } else if (forceRGBA) {
                      return this._convertCmykToRgba(data);
                    } else if (forceRGB) {
                      return this._convertCmykToRgb(data);
                    }
                  }
                  return data;
                }
              }
              exports2.JpegImage = JpegImage;
            },
            /* 28 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.convertBlackAndWhiteToRGBA = convertBlackAndWhiteToRGBA;
              exports2.convertToRGBA = convertToRGBA;
              exports2.grayToRGBA = grayToRGBA;
              var _util = __w_pdfjs_require__2(2);
              function convertToRGBA(params) {
                switch (params.kind) {
                  case _util.ImageKind.GRAYSCALE_1BPP:
                    return convertBlackAndWhiteToRGBA(params);
                  case _util.ImageKind.RGB_24BPP:
                    return convertRGBToRGBA(params);
                }
                return null;
              }
              function convertBlackAndWhiteToRGBA({
                src,
                srcPos = 0,
                dest,
                width,
                height,
                nonBlackColor = 4294967295,
                inverseDecode = false
              }) {
                const black = _util.FeatureTest.isLittleEndian ? 4278190080 : 255;
                const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];
                const widthInSource = width >> 3;
                const widthRemainder = width & 7;
                const srcLength = src.length;
                dest = new Uint32Array(dest.buffer);
                let destPos = 0;
                for (let i = 0; i < height; i++) {
                  for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
                    const elem2 = srcPos < srcLength ? src[srcPos] : 255;
                    dest[destPos++] = elem2 & 128 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 64 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 32 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 16 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 8 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 4 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 2 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 1 ? oneMapping : zeroMapping;
                  }
                  if (widthRemainder === 0) {
                    continue;
                  }
                  const elem = srcPos < srcLength ? src[srcPos++] : 255;
                  for (let j = 0; j < widthRemainder; j++) {
                    dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
                  }
                }
                return {
                  srcPos,
                  destPos
                };
              }
              function convertRGBToRGBA({
                src,
                srcPos = 0,
                dest,
                destPos = 0,
                width,
                height
              }) {
                let i = 0;
                const len32 = src.length >> 2;
                const src32 = new Uint32Array(src.buffer, srcPos, len32);
                if (_util.FeatureTest.isLittleEndian) {
                  for (; i < len32 - 2; i += 3, destPos += 4) {
                    const s1 = src32[i];
                    const s2 = src32[i + 1];
                    const s3 = src32[i + 2];
                    dest[destPos] = s1 | 4278190080;
                    dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 4278190080;
                    dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 4278190080;
                    dest[destPos + 3] = s3 >>> 8 | 4278190080;
                  }
                  for (let j = i * 4, jj = src.length; j < jj; j += 3) {
                    dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 4278190080;
                  }
                } else {
                  for (; i < len32 - 2; i += 3, destPos += 4) {
                    const s1 = src32[i];
                    const s2 = src32[i + 1];
                    const s3 = src32[i + 2];
                    dest[destPos] = s1 | 255;
                    dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 255;
                    dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 255;
                    dest[destPos + 3] = s3 << 8 | 255;
                  }
                  for (let j = i * 4, jj = src.length; j < jj; j += 3) {
                    dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 255;
                  }
                }
                return {
                  srcPos,
                  destPos
                };
              }
              function grayToRGBA(src, dest) {
                if (_util.FeatureTest.isLittleEndian) {
                  for (let i = 0, ii = src.length; i < ii; i++) {
                    dest[i] = src[i] * 65793 | 4278190080;
                  }
                } else {
                  for (let i = 0, ii = src.length; i < ii; i++) {
                    dest[i] = src[i] * 16843008 | 255;
                  }
                }
              }
            },
            /* 29 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.JpxStream = void 0;
              var _decode_stream = __w_pdfjs_require__2(18);
              var _jpx = __w_pdfjs_require__2(30);
              var _util = __w_pdfjs_require__2(2);
              class JpxStream extends _decode_stream.DecodeStream {
                constructor(stream, maybeLength, params) {
                  super(maybeLength);
                  this.stream = stream;
                  this.dict = stream.dict;
                  this.maybeLength = maybeLength;
                  this.params = params;
                }
                get bytes() {
                  return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                }
                ensureBuffer(requested) {
                }
                readBlock() {
                  if (this.eof) {
                    return;
                  }
                  const jpxImage = new _jpx.JpxImage();
                  jpxImage.parse(this.bytes);
                  const width = jpxImage.width;
                  const height = jpxImage.height;
                  const componentsCount = jpxImage.componentsCount;
                  const tileCount = jpxImage.tiles.length;
                  if (tileCount === 1) {
                    this.buffer = jpxImage.tiles[0].items;
                  } else {
                    const data = new Uint8ClampedArray(width * height * componentsCount);
                    for (let k = 0; k < tileCount; k++) {
                      const tileComponents = jpxImage.tiles[k];
                      const tileWidth = tileComponents.width;
                      const tileHeight = tileComponents.height;
                      const tileLeft = tileComponents.left;
                      const tileTop = tileComponents.top;
                      const src = tileComponents.items;
                      let srcPosition = 0;
                      let dataPosition = (width * tileTop + tileLeft) * componentsCount;
                      const imgRowSize = width * componentsCount;
                      const tileRowSize = tileWidth * componentsCount;
                      for (let j = 0; j < tileHeight; j++) {
                        const rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize);
                        data.set(rowBytes, dataPosition);
                        srcPosition += tileRowSize;
                        dataPosition += imgRowSize;
                      }
                    }
                    this.buffer = data;
                  }
                  this.bufferLength = this.buffer.length;
                  this.eof = true;
                }
              }
              exports2.JpxStream = JpxStream;
            },
            /* 30 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.JpxImage = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _core_utils = __w_pdfjs_require__2(3);
              var _arithmetic_decoder = __w_pdfjs_require__2(25);
              class JpxError extends _util.BaseException {
                constructor(msg) {
                  super(`JPX error: ${msg}`, "JpxError");
                }
              }
              const SubbandsGainLog2 = {
                LL: 0,
                LH: 1,
                HL: 1,
                HH: 2
              };
              class JpxImage {
                constructor() {
                  this.failOnCorruptedImage = false;
                }
                parse(data) {
                  const head = (0, _core_utils.readUint16)(data, 0);
                  if (head === 65359) {
                    this.parseCodestream(data, 0, data.length);
                    return;
                  }
                  const length = data.length;
                  let position = 0;
                  while (position < length) {
                    let headerSize = 8;
                    let lbox = (0, _core_utils.readUint32)(data, position);
                    const tbox = (0, _core_utils.readUint32)(data, position + 4);
                    position += headerSize;
                    if (lbox === 1) {
                      lbox = (0, _core_utils.readUint32)(data, position) * 4294967296 + (0, _core_utils.readUint32)(data, position + 4);
                      position += 8;
                      headerSize += 8;
                    }
                    if (lbox === 0) {
                      lbox = length - position + headerSize;
                    }
                    if (lbox < headerSize) {
                      throw new JpxError("Invalid box field size");
                    }
                    const dataLength = lbox - headerSize;
                    let jumpDataLength = true;
                    switch (tbox) {
                      case 1785737832:
                        jumpDataLength = false;
                        break;
                      case 1668246642:
                        const method = data[position];
                        if (method === 1) {
                          const colorspace = (0, _core_utils.readUint32)(data, position + 3);
                          switch (colorspace) {
                            case 16:
                            case 17:
                            case 18:
                              break;
                            default:
                              (0, _util.warn)("Unknown colorspace " + colorspace);
                              break;
                          }
                        } else if (method === 2) {
                          (0, _util.info)("ICC profile not supported");
                        }
                        break;
                      case 1785737827:
                        this.parseCodestream(data, position, position + dataLength);
                        break;
                      case 1783636e3:
                        if ((0, _core_utils.readUint32)(data, position) !== 218793738) {
                          (0, _util.warn)("Invalid JP2 signature");
                        }
                        break;
                      case 1783634458:
                      case 1718909296:
                      case 1920099697:
                      case 1919251232:
                      case 1768449138:
                        break;
                      default:
                        const headerType = String.fromCharCode(tbox >> 24 & 255, tbox >> 16 & 255, tbox >> 8 & 255, tbox & 255);
                        (0, _util.warn)(`Unsupported header type ${tbox} (${headerType}).`);
                        break;
                    }
                    if (jumpDataLength) {
                      position += dataLength;
                    }
                  }
                }
                parseImageProperties(stream) {
                  let newByte = stream.getByte();
                  while (newByte >= 0) {
                    const oldByte = newByte;
                    newByte = stream.getByte();
                    const code = oldByte << 8 | newByte;
                    if (code === 65361) {
                      stream.skip(4);
                      const Xsiz = stream.getInt32() >>> 0;
                      const Ysiz = stream.getInt32() >>> 0;
                      const XOsiz = stream.getInt32() >>> 0;
                      const YOsiz = stream.getInt32() >>> 0;
                      stream.skip(16);
                      const Csiz = stream.getUint16();
                      this.width = Xsiz - XOsiz;
                      this.height = Ysiz - YOsiz;
                      this.componentsCount = Csiz;
                      this.bitsPerComponent = 8;
                      return;
                    }
                  }
                  throw new JpxError("No size marker found in JPX stream");
                }
                parseCodestream(data, start, end) {
                  const context = {};
                  let doNotRecover = false;
                  try {
                    let position = start;
                    while (position + 1 < end) {
                      const code = (0, _core_utils.readUint16)(data, position);
                      position += 2;
                      let length = 0, j, sqcd, spqcds, spqcdSize, scalarExpounded, tile;
                      switch (code) {
                        case 65359:
                          context.mainHeader = true;
                          break;
                        case 65497:
                          break;
                        case 65361:
                          length = (0, _core_utils.readUint16)(data, position);
                          const siz = {};
                          siz.Xsiz = (0, _core_utils.readUint32)(data, position + 4);
                          siz.Ysiz = (0, _core_utils.readUint32)(data, position + 8);
                          siz.XOsiz = (0, _core_utils.readUint32)(data, position + 12);
                          siz.YOsiz = (0, _core_utils.readUint32)(data, position + 16);
                          siz.XTsiz = (0, _core_utils.readUint32)(data, position + 20);
                          siz.YTsiz = (0, _core_utils.readUint32)(data, position + 24);
                          siz.XTOsiz = (0, _core_utils.readUint32)(data, position + 28);
                          siz.YTOsiz = (0, _core_utils.readUint32)(data, position + 32);
                          const componentsCount = (0, _core_utils.readUint16)(data, position + 36);
                          siz.Csiz = componentsCount;
                          const components = [];
                          j = position + 38;
                          for (let i = 0; i < componentsCount; i++) {
                            const component = {
                              precision: (data[j] & 127) + 1,
                              isSigned: !!(data[j] & 128),
                              XRsiz: data[j + 1],
                              YRsiz: data[j + 2]
                            };
                            j += 3;
                            calculateComponentDimensions(component, siz);
                            components.push(component);
                          }
                          context.SIZ = siz;
                          context.components = components;
                          calculateTileGrids(context, components);
                          context.QCC = [];
                          context.COC = [];
                          break;
                        case 65372:
                          length = (0, _core_utils.readUint16)(data, position);
                          const qcd = {};
                          j = position + 2;
                          sqcd = data[j++];
                          switch (sqcd & 31) {
                            case 0:
                              spqcdSize = 8;
                              scalarExpounded = true;
                              break;
                            case 1:
                              spqcdSize = 16;
                              scalarExpounded = false;
                              break;
                            case 2:
                              spqcdSize = 16;
                              scalarExpounded = true;
                              break;
                            default:
                              throw new Error("Invalid SQcd value " + sqcd);
                          }
                          qcd.noQuantization = spqcdSize === 8;
                          qcd.scalarExpounded = scalarExpounded;
                          qcd.guardBits = sqcd >> 5;
                          spqcds = [];
                          while (j < length + position) {
                            const spqcd = {};
                            if (spqcdSize === 8) {
                              spqcd.epsilon = data[j++] >> 3;
                              spqcd.mu = 0;
                            } else {
                              spqcd.epsilon = data[j] >> 3;
                              spqcd.mu = (data[j] & 7) << 8 | data[j + 1];
                              j += 2;
                            }
                            spqcds.push(spqcd);
                          }
                          qcd.SPqcds = spqcds;
                          if (context.mainHeader) {
                            context.QCD = qcd;
                          } else {
                            context.currentTile.QCD = qcd;
                            context.currentTile.QCC = [];
                          }
                          break;
                        case 65373:
                          length = (0, _core_utils.readUint16)(data, position);
                          const qcc = {};
                          j = position + 2;
                          let cqcc;
                          if (context.SIZ.Csiz < 257) {
                            cqcc = data[j++];
                          } else {
                            cqcc = (0, _core_utils.readUint16)(data, j);
                            j += 2;
                          }
                          sqcd = data[j++];
                          switch (sqcd & 31) {
                            case 0:
                              spqcdSize = 8;
                              scalarExpounded = true;
                              break;
                            case 1:
                              spqcdSize = 16;
                              scalarExpounded = false;
                              break;
                            case 2:
                              spqcdSize = 16;
                              scalarExpounded = true;
                              break;
                            default:
                              throw new Error("Invalid SQcd value " + sqcd);
                          }
                          qcc.noQuantization = spqcdSize === 8;
                          qcc.scalarExpounded = scalarExpounded;
                          qcc.guardBits = sqcd >> 5;
                          spqcds = [];
                          while (j < length + position) {
                            const spqcd = {};
                            if (spqcdSize === 8) {
                              spqcd.epsilon = data[j++] >> 3;
                              spqcd.mu = 0;
                            } else {
                              spqcd.epsilon = data[j] >> 3;
                              spqcd.mu = (data[j] & 7) << 8 | data[j + 1];
                              j += 2;
                            }
                            spqcds.push(spqcd);
                          }
                          qcc.SPqcds = spqcds;
                          if (context.mainHeader) {
                            context.QCC[cqcc] = qcc;
                          } else {
                            context.currentTile.QCC[cqcc] = qcc;
                          }
                          break;
                        case 65362:
                          length = (0, _core_utils.readUint16)(data, position);
                          const cod = {};
                          j = position + 2;
                          const scod = data[j++];
                          cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
                          cod.sopMarkerUsed = !!(scod & 2);
                          cod.ephMarkerUsed = !!(scod & 4);
                          cod.progressionOrder = data[j++];
                          cod.layersCount = (0, _core_utils.readUint16)(data, j);
                          j += 2;
                          cod.multipleComponentTransform = data[j++];
                          cod.decompositionLevelsCount = data[j++];
                          cod.xcb = (data[j++] & 15) + 2;
                          cod.ycb = (data[j++] & 15) + 2;
                          const blockStyle = data[j++];
                          cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
                          cod.resetContextProbabilities = !!(blockStyle & 2);
                          cod.terminationOnEachCodingPass = !!(blockStyle & 4);
                          cod.verticallyStripe = !!(blockStyle & 8);
                          cod.predictableTermination = !!(blockStyle & 16);
                          cod.segmentationSymbolUsed = !!(blockStyle & 32);
                          cod.reversibleTransformation = data[j++];
                          if (cod.entropyCoderWithCustomPrecincts) {
                            const precinctsSizes = [];
                            while (j < length + position) {
                              const precinctsSize = data[j++];
                              precinctsSizes.push({
                                PPx: precinctsSize & 15,
                                PPy: precinctsSize >> 4
                              });
                            }
                            cod.precinctsSizes = precinctsSizes;
                          }
                          const unsupported = [];
                          if (cod.selectiveArithmeticCodingBypass) {
                            unsupported.push("selectiveArithmeticCodingBypass");
                          }
                          if (cod.terminationOnEachCodingPass) {
                            unsupported.push("terminationOnEachCodingPass");
                          }
                          if (cod.verticallyStripe) {
                            unsupported.push("verticallyStripe");
                          }
                          if (cod.predictableTermination) {
                            unsupported.push("predictableTermination");
                          }
                          if (unsupported.length > 0) {
                            doNotRecover = true;
                            (0, _util.warn)(`JPX: Unsupported COD options (${unsupported.join(", ")}).`);
                          }
                          if (context.mainHeader) {
                            context.COD = cod;
                          } else {
                            context.currentTile.COD = cod;
                            context.currentTile.COC = [];
                          }
                          break;
                        case 65424:
                          length = (0, _core_utils.readUint16)(data, position);
                          tile = {};
                          tile.index = (0, _core_utils.readUint16)(data, position + 2);
                          tile.length = (0, _core_utils.readUint32)(data, position + 4);
                          tile.dataEnd = tile.length + position - 2;
                          tile.partIndex = data[position + 8];
                          tile.partsCount = data[position + 9];
                          context.mainHeader = false;
                          if (tile.partIndex === 0) {
                            tile.COD = context.COD;
                            tile.COC = context.COC.slice(0);
                            tile.QCD = context.QCD;
                            tile.QCC = context.QCC.slice(0);
                          }
                          context.currentTile = tile;
                          break;
                        case 65427:
                          tile = context.currentTile;
                          if (tile.partIndex === 0) {
                            initializeTile(context, tile.index);
                            buildPackets(context);
                          }
                          length = tile.dataEnd - position;
                          parseTilePackets(context, data, position, length);
                          break;
                        case 65363:
                          (0, _util.warn)("JPX: Codestream code 0xFF53 (COC) is not implemented.");
                        case 65365:
                        case 65367:
                        case 65368:
                        case 65380:
                          length = (0, _core_utils.readUint16)(data, position);
                          break;
                        default:
                          throw new Error("Unknown codestream code: " + code.toString(16));
                      }
                      position += length;
                    }
                  } catch (e) {
                    if (doNotRecover || this.failOnCorruptedImage) {
                      throw new JpxError(e.message);
                    } else {
                      (0, _util.warn)(`JPX: Trying to recover from: "${e.message}".`);
                    }
                  }
                  this.tiles = transformComponents(context);
                  this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
                  this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
                  this.componentsCount = context.SIZ.Csiz;
                }
              }
              exports2.JpxImage = JpxImage;
              function calculateComponentDimensions(component, siz) {
                component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
                component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
                component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
                component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
                component.width = component.x1 - component.x0;
                component.height = component.y1 - component.y0;
              }
              function calculateTileGrids(context, components) {
                const siz = context.SIZ;
                const tiles = [];
                let tile;
                const numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
                const numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
                for (let q = 0; q < numYtiles; q++) {
                  for (let p = 0; p < numXtiles; p++) {
                    tile = {};
                    tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
                    tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
                    tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
                    tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
                    tile.width = tile.tx1 - tile.tx0;
                    tile.height = tile.ty1 - tile.ty0;
                    tile.components = [];
                    tiles.push(tile);
                  }
                }
                context.tiles = tiles;
                const componentsCount = siz.Csiz;
                for (let i = 0, ii = componentsCount; i < ii; i++) {
                  const component = components[i];
                  for (let j = 0, jj = tiles.length; j < jj; j++) {
                    const tileComponent = {};
                    tile = tiles[j];
                    tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
                    tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
                    tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
                    tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
                    tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
                    tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
                    tile.components[i] = tileComponent;
                  }
                }
              }
              function getBlocksDimensions(context, component, r) {
                const codOrCoc = component.codingStyleParameters;
                const result = {};
                if (!codOrCoc.entropyCoderWithCustomPrecincts) {
                  result.PPx = 15;
                  result.PPy = 15;
                } else {
                  result.PPx = codOrCoc.precinctsSizes[r].PPx;
                  result.PPy = codOrCoc.precinctsSizes[r].PPy;
                }
                result.xcb_ = r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) : Math.min(codOrCoc.xcb, result.PPx);
                result.ycb_ = r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) : Math.min(codOrCoc.ycb, result.PPy);
                return result;
              }
              function buildPrecincts(context, resolution, dimensions) {
                const precinctWidth = 1 << dimensions.PPx;
                const precinctHeight = 1 << dimensions.PPy;
                const isZeroRes = resolution.resLevel === 0;
                const precinctWidthInSubband = 1 << dimensions.PPx + (isZeroRes ? 0 : -1);
                const precinctHeightInSubband = 1 << dimensions.PPy + (isZeroRes ? 0 : -1);
                const numprecinctswide = resolution.trx1 > resolution.trx0 ? Math.ceil(resolution.trx1 / precinctWidth) - Math.floor(resolution.trx0 / precinctWidth) : 0;
                const numprecinctshigh = resolution.try1 > resolution.try0 ? Math.ceil(resolution.try1 / precinctHeight) - Math.floor(resolution.try0 / precinctHeight) : 0;
                const numprecincts = numprecinctswide * numprecinctshigh;
                resolution.precinctParameters = {
                  precinctWidth,
                  precinctHeight,
                  numprecinctswide,
                  numprecinctshigh,
                  numprecincts,
                  precinctWidthInSubband,
                  precinctHeightInSubband
                };
              }
              function buildCodeblocks(context, subband, dimensions) {
                const xcb_ = dimensions.xcb_;
                const ycb_ = dimensions.ycb_;
                const codeblockWidth = 1 << xcb_;
                const codeblockHeight = 1 << ycb_;
                const cbx0 = subband.tbx0 >> xcb_;
                const cby0 = subband.tby0 >> ycb_;
                const cbx1 = subband.tbx1 + codeblockWidth - 1 >> xcb_;
                const cby1 = subband.tby1 + codeblockHeight - 1 >> ycb_;
                const precinctParameters = subband.resolution.precinctParameters;
                const codeblocks = [];
                const precincts = [];
                let i, j, codeblock, precinctNumber;
                for (j = cby0; j < cby1; j++) {
                  for (i = cbx0; i < cbx1; i++) {
                    codeblock = {
                      cbx: i,
                      cby: j,
                      tbx0: codeblockWidth * i,
                      tby0: codeblockHeight * j,
                      tbx1: codeblockWidth * (i + 1),
                      tby1: codeblockHeight * (j + 1)
                    };
                    codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
                    codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
                    codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
                    codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);
                    const pi = Math.floor((codeblock.tbx0_ - subband.tbx0) / precinctParameters.precinctWidthInSubband);
                    const pj = Math.floor((codeblock.tby0_ - subband.tby0) / precinctParameters.precinctHeightInSubband);
                    precinctNumber = pi + pj * precinctParameters.numprecinctswide;
                    codeblock.precinctNumber = precinctNumber;
                    codeblock.subbandType = subband.type;
                    codeblock.Lblock = 3;
                    if (codeblock.tbx1_ <= codeblock.tbx0_ || codeblock.tby1_ <= codeblock.tby0_) {
                      continue;
                    }
                    codeblocks.push(codeblock);
                    let precinct = precincts[precinctNumber];
                    if (precinct !== void 0) {
                      if (i < precinct.cbxMin) {
                        precinct.cbxMin = i;
                      } else if (i > precinct.cbxMax) {
                        precinct.cbxMax = i;
                      }
                      if (j < precinct.cbyMin) {
                        precinct.cbxMin = j;
                      } else if (j > precinct.cbyMax) {
                        precinct.cbyMax = j;
                      }
                    } else {
                      precincts[precinctNumber] = precinct = {
                        cbxMin: i,
                        cbyMin: j,
                        cbxMax: i,
                        cbyMax: j
                      };
                    }
                    codeblock.precinct = precinct;
                  }
                }
                subband.codeblockParameters = {
                  codeblockWidth: xcb_,
                  codeblockHeight: ycb_,
                  numcodeblockwide: cbx1 - cbx0 + 1,
                  numcodeblockhigh: cby1 - cby0 + 1
                };
                subband.codeblocks = codeblocks;
                subband.precincts = precincts;
              }
              function createPacket(resolution, precinctNumber, layerNumber) {
                const precinctCodeblocks = [];
                const subbands = resolution.subbands;
                for (let i = 0, ii = subbands.length; i < ii; i++) {
                  const subband = subbands[i];
                  const codeblocks = subband.codeblocks;
                  for (let j = 0, jj = codeblocks.length; j < jj; j++) {
                    const codeblock = codeblocks[j];
                    if (codeblock.precinctNumber !== precinctNumber) {
                      continue;
                    }
                    precinctCodeblocks.push(codeblock);
                  }
                }
                return {
                  layerNumber,
                  codeblocks: precinctCodeblocks
                };
              }
              function LayerResolutionComponentPositionIterator(context) {
                const siz = context.SIZ;
                const tileIndex = context.currentTile.index;
                const tile = context.tiles[tileIndex];
                const layersCount = tile.codingStyleDefaultParameters.layersCount;
                const componentsCount = siz.Csiz;
                let maxDecompositionLevelsCount = 0;
                for (let q = 0; q < componentsCount; q++) {
                  maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
                }
                let l = 0, r = 0, i = 0, k = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; l < layersCount; l++) {
                    for (; r <= maxDecompositionLevelsCount; r++) {
                      for (; i < componentsCount; i++) {
                        const component = tile.components[i];
                        if (r > component.codingStyleParameters.decompositionLevelsCount) {
                          continue;
                        }
                        const resolution = component.resolutions[r];
                        const numprecincts = resolution.precinctParameters.numprecincts;
                        for (; k < numprecincts; ) {
                          const packet = createPacket(resolution, k, l);
                          k++;
                          return packet;
                        }
                        k = 0;
                      }
                      i = 0;
                    }
                    r = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function ResolutionLayerComponentPositionIterator(context) {
                const siz = context.SIZ;
                const tileIndex = context.currentTile.index;
                const tile = context.tiles[tileIndex];
                const layersCount = tile.codingStyleDefaultParameters.layersCount;
                const componentsCount = siz.Csiz;
                let maxDecompositionLevelsCount = 0;
                for (let q = 0; q < componentsCount; q++) {
                  maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
                }
                let r = 0, l = 0, i = 0, k = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; r <= maxDecompositionLevelsCount; r++) {
                    for (; l < layersCount; l++) {
                      for (; i < componentsCount; i++) {
                        const component = tile.components[i];
                        if (r > component.codingStyleParameters.decompositionLevelsCount) {
                          continue;
                        }
                        const resolution = component.resolutions[r];
                        const numprecincts = resolution.precinctParameters.numprecincts;
                        for (; k < numprecincts; ) {
                          const packet = createPacket(resolution, k, l);
                          k++;
                          return packet;
                        }
                        k = 0;
                      }
                      i = 0;
                    }
                    l = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function ResolutionPositionComponentLayerIterator(context) {
                const siz = context.SIZ;
                const tileIndex = context.currentTile.index;
                const tile = context.tiles[tileIndex];
                const layersCount = tile.codingStyleDefaultParameters.layersCount;
                const componentsCount = siz.Csiz;
                let l, r, c, p;
                let maxDecompositionLevelsCount = 0;
                for (c = 0; c < componentsCount; c++) {
                  const component = tile.components[c];
                  maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, component.codingStyleParameters.decompositionLevelsCount);
                }
                const maxNumPrecinctsInLevel = new Int32Array(maxDecompositionLevelsCount + 1);
                for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
                  let maxNumPrecincts = 0;
                  for (c = 0; c < componentsCount; ++c) {
                    const resolutions = tile.components[c].resolutions;
                    if (r < resolutions.length) {
                      maxNumPrecincts = Math.max(maxNumPrecincts, resolutions[r].precinctParameters.numprecincts);
                    }
                  }
                  maxNumPrecinctsInLevel[r] = maxNumPrecincts;
                }
                l = 0;
                r = 0;
                c = 0;
                p = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; r <= maxDecompositionLevelsCount; r++) {
                    for (; p < maxNumPrecinctsInLevel[r]; p++) {
                      for (; c < componentsCount; c++) {
                        const component = tile.components[c];
                        if (r > component.codingStyleParameters.decompositionLevelsCount) {
                          continue;
                        }
                        const resolution = component.resolutions[r];
                        const numprecincts = resolution.precinctParameters.numprecincts;
                        if (p >= numprecincts) {
                          continue;
                        }
                        for (; l < layersCount; ) {
                          const packet = createPacket(resolution, p, l);
                          l++;
                          return packet;
                        }
                        l = 0;
                      }
                      c = 0;
                    }
                    p = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function PositionComponentResolutionLayerIterator(context) {
                const siz = context.SIZ;
                const tileIndex = context.currentTile.index;
                const tile = context.tiles[tileIndex];
                const layersCount = tile.codingStyleDefaultParameters.layersCount;
                const componentsCount = siz.Csiz;
                const precinctsSizes = getPrecinctSizesInImageScale(tile);
                const precinctsIterationSizes = precinctsSizes;
                let l = 0, r = 0, c = 0, px = 0, py = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; py < precinctsIterationSizes.maxNumHigh; py++) {
                    for (; px < precinctsIterationSizes.maxNumWide; px++) {
                      for (; c < componentsCount; c++) {
                        const component = tile.components[c];
                        const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                        for (; r <= decompositionLevelsCount; r++) {
                          const resolution = component.resolutions[r];
                          const sizeInImageScale = precinctsSizes.components[c].resolutions[r];
                          const k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
                          if (k === null) {
                            continue;
                          }
                          for (; l < layersCount; ) {
                            const packet = createPacket(resolution, k, l);
                            l++;
                            return packet;
                          }
                          l = 0;
                        }
                        r = 0;
                      }
                      c = 0;
                    }
                    px = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function ComponentPositionResolutionLayerIterator(context) {
                const siz = context.SIZ;
                const tileIndex = context.currentTile.index;
                const tile = context.tiles[tileIndex];
                const layersCount = tile.codingStyleDefaultParameters.layersCount;
                const componentsCount = siz.Csiz;
                const precinctsSizes = getPrecinctSizesInImageScale(tile);
                let l = 0, r = 0, c = 0, px = 0, py = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; c < componentsCount; ++c) {
                    const component = tile.components[c];
                    const precinctsIterationSizes = precinctsSizes.components[c];
                    const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                    for (; py < precinctsIterationSizes.maxNumHigh; py++) {
                      for (; px < precinctsIterationSizes.maxNumWide; px++) {
                        for (; r <= decompositionLevelsCount; r++) {
                          const resolution = component.resolutions[r];
                          const sizeInImageScale = precinctsIterationSizes.resolutions[r];
                          const k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
                          if (k === null) {
                            continue;
                          }
                          for (; l < layersCount; ) {
                            const packet = createPacket(resolution, k, l);
                            l++;
                            return packet;
                          }
                          l = 0;
                        }
                        r = 0;
                      }
                      px = 0;
                    }
                    py = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function getPrecinctIndexIfExist(pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
                const posX = pxIndex * precinctIterationSizes.minWidth;
                const posY = pyIndex * precinctIterationSizes.minHeight;
                if (posX % sizeInImageScale.width !== 0 || posY % sizeInImageScale.height !== 0) {
                  return null;
                }
                const startPrecinctRowIndex = posY / sizeInImageScale.width * resolution.precinctParameters.numprecinctswide;
                return posX / sizeInImageScale.height + startPrecinctRowIndex;
              }
              function getPrecinctSizesInImageScale(tile) {
                const componentsCount = tile.components.length;
                let minWidth = Number.MAX_VALUE;
                let minHeight = Number.MAX_VALUE;
                let maxNumWide = 0;
                let maxNumHigh = 0;
                const sizePerComponent = new Array(componentsCount);
                for (let c = 0; c < componentsCount; c++) {
                  const component = tile.components[c];
                  const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                  const sizePerResolution = new Array(decompositionLevelsCount + 1);
                  let minWidthCurrentComponent = Number.MAX_VALUE;
                  let minHeightCurrentComponent = Number.MAX_VALUE;
                  let maxNumWideCurrentComponent = 0;
                  let maxNumHighCurrentComponent = 0;
                  let scale = 1;
                  for (let r = decompositionLevelsCount; r >= 0; --r) {
                    const resolution = component.resolutions[r];
                    const widthCurrentResolution = scale * resolution.precinctParameters.precinctWidth;
                    const heightCurrentResolution = scale * resolution.precinctParameters.precinctHeight;
                    minWidthCurrentComponent = Math.min(minWidthCurrentComponent, widthCurrentResolution);
                    minHeightCurrentComponent = Math.min(minHeightCurrentComponent, heightCurrentResolution);
                    maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent, resolution.precinctParameters.numprecinctswide);
                    maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent, resolution.precinctParameters.numprecinctshigh);
                    sizePerResolution[r] = {
                      width: widthCurrentResolution,
                      height: heightCurrentResolution
                    };
                    scale <<= 1;
                  }
                  minWidth = Math.min(minWidth, minWidthCurrentComponent);
                  minHeight = Math.min(minHeight, minHeightCurrentComponent);
                  maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
                  maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
                  sizePerComponent[c] = {
                    resolutions: sizePerResolution,
                    minWidth: minWidthCurrentComponent,
                    minHeight: minHeightCurrentComponent,
                    maxNumWide: maxNumWideCurrentComponent,
                    maxNumHigh: maxNumHighCurrentComponent
                  };
                }
                return {
                  components: sizePerComponent,
                  minWidth,
                  minHeight,
                  maxNumWide,
                  maxNumHigh
                };
              }
              function buildPackets(context) {
                const siz = context.SIZ;
                const tileIndex = context.currentTile.index;
                const tile = context.tiles[tileIndex];
                const componentsCount = siz.Csiz;
                for (let c = 0; c < componentsCount; c++) {
                  const component = tile.components[c];
                  const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                  const resolutions = [];
                  const subbands = [];
                  for (let r = 0; r <= decompositionLevelsCount; r++) {
                    const blocksDimensions = getBlocksDimensions(context, component, r);
                    const resolution = {};
                    const scale = 1 << decompositionLevelsCount - r;
                    resolution.trx0 = Math.ceil(component.tcx0 / scale);
                    resolution.try0 = Math.ceil(component.tcy0 / scale);
                    resolution.trx1 = Math.ceil(component.tcx1 / scale);
                    resolution.try1 = Math.ceil(component.tcy1 / scale);
                    resolution.resLevel = r;
                    buildPrecincts(context, resolution, blocksDimensions);
                    resolutions.push(resolution);
                    let subband;
                    if (r === 0) {
                      subband = {};
                      subband.type = "LL";
                      subband.tbx0 = Math.ceil(component.tcx0 / scale);
                      subband.tby0 = Math.ceil(component.tcy0 / scale);
                      subband.tbx1 = Math.ceil(component.tcx1 / scale);
                      subband.tby1 = Math.ceil(component.tcy1 / scale);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolution.subbands = [subband];
                    } else {
                      const bscale = 1 << decompositionLevelsCount - r + 1;
                      const resolutionSubbands = [];
                      subband = {};
                      subband.type = "HL";
                      subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
                      subband.tby0 = Math.ceil(component.tcy0 / bscale);
                      subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
                      subband.tby1 = Math.ceil(component.tcy1 / bscale);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolutionSubbands.push(subband);
                      subband = {};
                      subband.type = "LH";
                      subband.tbx0 = Math.ceil(component.tcx0 / bscale);
                      subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
                      subband.tbx1 = Math.ceil(component.tcx1 / bscale);
                      subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolutionSubbands.push(subband);
                      subband = {};
                      subband.type = "HH";
                      subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
                      subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
                      subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
                      subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolutionSubbands.push(subband);
                      resolution.subbands = resolutionSubbands;
                    }
                  }
                  component.resolutions = resolutions;
                  component.subbands = subbands;
                }
                const progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
                switch (progressionOrder) {
                  case 0:
                    tile.packetsIterator = new LayerResolutionComponentPositionIterator(context);
                    break;
                  case 1:
                    tile.packetsIterator = new ResolutionLayerComponentPositionIterator(context);
                    break;
                  case 2:
                    tile.packetsIterator = new ResolutionPositionComponentLayerIterator(context);
                    break;
                  case 3:
                    tile.packetsIterator = new PositionComponentResolutionLayerIterator(context);
                    break;
                  case 4:
                    tile.packetsIterator = new ComponentPositionResolutionLayerIterator(context);
                    break;
                  default:
                    throw new JpxError(`Unsupported progression order ${progressionOrder}`);
                }
              }
              function parseTilePackets(context, data, offset, dataLength) {
                let position = 0;
                let buffer, bufferSize = 0, skipNextBit = false;
                function readBits(count) {
                  while (bufferSize < count) {
                    const b = data[offset + position];
                    position++;
                    if (skipNextBit) {
                      buffer = buffer << 7 | b;
                      bufferSize += 7;
                      skipNextBit = false;
                    } else {
                      buffer = buffer << 8 | b;
                      bufferSize += 8;
                    }
                    if (b === 255) {
                      skipNextBit = true;
                    }
                  }
                  bufferSize -= count;
                  return buffer >>> bufferSize & (1 << count) - 1;
                }
                function skipMarkerIfEqual(value) {
                  if (data[offset + position - 1] === 255 && data[offset + position] === value) {
                    skipBytes(1);
                    return true;
                  } else if (data[offset + position] === 255 && data[offset + position + 1] === value) {
                    skipBytes(2);
                    return true;
                  }
                  return false;
                }
                function skipBytes(count) {
                  position += count;
                }
                function alignToByte() {
                  bufferSize = 0;
                  if (skipNextBit) {
                    position++;
                    skipNextBit = false;
                  }
                }
                function readCodingpasses() {
                  if (readBits(1) === 0) {
                    return 1;
                  }
                  if (readBits(1) === 0) {
                    return 2;
                  }
                  let value = readBits(2);
                  if (value < 3) {
                    return value + 3;
                  }
                  value = readBits(5);
                  if (value < 31) {
                    return value + 6;
                  }
                  value = readBits(7);
                  return value + 37;
                }
                const tileIndex = context.currentTile.index;
                const tile = context.tiles[tileIndex];
                const sopMarkerUsed = context.COD.sopMarkerUsed;
                const ephMarkerUsed = context.COD.ephMarkerUsed;
                const packetsIterator = tile.packetsIterator;
                while (position < dataLength) {
                  alignToByte();
                  if (sopMarkerUsed && skipMarkerIfEqual(145)) {
                    skipBytes(4);
                  }
                  const packet = packetsIterator.nextPacket();
                  if (!readBits(1)) {
                    continue;
                  }
                  const layerNumber = packet.layerNumber, queue = [];
                  let codeblock;
                  for (let i = 0, ii = packet.codeblocks.length; i < ii; i++) {
                    codeblock = packet.codeblocks[i];
                    let precinct = codeblock.precinct;
                    const codeblockColumn = codeblock.cbx - precinct.cbxMin;
                    const codeblockRow = codeblock.cby - precinct.cbyMin;
                    let codeblockIncluded = false;
                    let firstTimeInclusion = false;
                    let valueReady, zeroBitPlanesTree;
                    if (codeblock.included !== void 0) {
                      codeblockIncluded = !!readBits(1);
                    } else {
                      precinct = codeblock.precinct;
                      let inclusionTree;
                      if (precinct.inclusionTree !== void 0) {
                        inclusionTree = precinct.inclusionTree;
                      } else {
                        const width = precinct.cbxMax - precinct.cbxMin + 1;
                        const height = precinct.cbyMax - precinct.cbyMin + 1;
                        inclusionTree = new InclusionTree(width, height, layerNumber);
                        zeroBitPlanesTree = new TagTree(width, height);
                        precinct.inclusionTree = inclusionTree;
                        precinct.zeroBitPlanesTree = zeroBitPlanesTree;
                        for (let l = 0; l < layerNumber; l++) {
                          if (readBits(1) !== 0) {
                            throw new JpxError("Invalid tag tree");
                          }
                        }
                      }
                      if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {
                        while (true) {
                          if (readBits(1)) {
                            valueReady = !inclusionTree.nextLevel();
                            if (valueReady) {
                              codeblock.included = true;
                              codeblockIncluded = firstTimeInclusion = true;
                              break;
                            }
                          } else {
                            inclusionTree.incrementValue(layerNumber);
                            break;
                          }
                        }
                      }
                    }
                    if (!codeblockIncluded) {
                      continue;
                    }
                    if (firstTimeInclusion) {
                      zeroBitPlanesTree = precinct.zeroBitPlanesTree;
                      zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
                      while (true) {
                        if (readBits(1)) {
                          valueReady = !zeroBitPlanesTree.nextLevel();
                          if (valueReady) {
                            break;
                          }
                        } else {
                          zeroBitPlanesTree.incrementValue();
                        }
                      }
                      codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
                    }
                    const codingpasses = readCodingpasses();
                    while (readBits(1)) {
                      codeblock.Lblock++;
                    }
                    const codingpassesLog2 = (0, _core_utils.log2)(codingpasses);
                    const bits = (codingpasses < 1 << codingpassesLog2 ? codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
                    const codedDataLength = readBits(bits);
                    queue.push({
                      codeblock,
                      codingpasses,
                      dataLength: codedDataLength
                    });
                  }
                  alignToByte();
                  if (ephMarkerUsed) {
                    skipMarkerIfEqual(146);
                  }
                  while (queue.length > 0) {
                    const packetItem = queue.shift();
                    codeblock = packetItem.codeblock;
                    if (codeblock.data === void 0) {
                      codeblock.data = [];
                    }
                    codeblock.data.push({
                      data,
                      start: offset + position,
                      end: offset + position + packetItem.dataLength,
                      codingpasses: packetItem.codingpasses
                    });
                    position += packetItem.dataLength;
                  }
                }
                return position;
              }
              function copyCoefficients(coefficients, levelWidth, levelHeight, subband, delta, mb, reversible, segmentationSymbolUsed, resetContextProbabilities) {
                const x0 = subband.tbx0;
                const y0 = subband.tby0;
                const width = subband.tbx1 - subband.tbx0;
                const codeblocks = subband.codeblocks;
                const right = subband.type.charAt(0) === "H" ? 1 : 0;
                const bottom = subband.type.charAt(1) === "H" ? levelWidth : 0;
                for (let i = 0, ii = codeblocks.length; i < ii; ++i) {
                  const codeblock = codeblocks[i];
                  const blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
                  const blockHeight = codeblock.tby1_ - codeblock.tby0_;
                  if (blockWidth === 0 || blockHeight === 0) {
                    continue;
                  }
                  if (codeblock.data === void 0) {
                    continue;
                  }
                  const bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType, codeblock.zeroBitPlanes, mb);
                  let currentCodingpassType = 2;
                  const data = codeblock.data;
                  let totalLength = 0, codingpasses = 0;
                  let j, jj, dataItem;
                  for (j = 0, jj = data.length; j < jj; j++) {
                    dataItem = data[j];
                    totalLength += dataItem.end - dataItem.start;
                    codingpasses += dataItem.codingpasses;
                  }
                  const encodedData = new Uint8Array(totalLength);
                  let position = 0;
                  for (j = 0, jj = data.length; j < jj; j++) {
                    dataItem = data[j];
                    const chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
                    encodedData.set(chunk, position);
                    position += chunk.length;
                  }
                  const decoder = new _arithmetic_decoder.ArithmeticDecoder(encodedData, 0, totalLength);
                  bitModel.setDecoder(decoder);
                  for (j = 0; j < codingpasses; j++) {
                    switch (currentCodingpassType) {
                      case 0:
                        bitModel.runSignificancePropagationPass();
                        break;
                      case 1:
                        bitModel.runMagnitudeRefinementPass();
                        break;
                      case 2:
                        bitModel.runCleanupPass();
                        if (segmentationSymbolUsed) {
                          bitModel.checkSegmentationSymbol();
                        }
                        break;
                    }
                    if (resetContextProbabilities) {
                      bitModel.reset();
                    }
                    currentCodingpassType = (currentCodingpassType + 1) % 3;
                  }
                  let offset = codeblock.tbx0_ - x0 + (codeblock.tby0_ - y0) * width;
                  const sign = bitModel.coefficentsSign;
                  const magnitude = bitModel.coefficentsMagnitude;
                  const bitsDecoded = bitModel.bitsDecoded;
                  const magnitudeCorrection = reversible ? 0 : 0.5;
                  let k, n, nb;
                  position = 0;
                  const interleave = subband.type !== "LL";
                  for (j = 0; j < blockHeight; j++) {
                    const row = offset / width | 0;
                    const levelOffset = 2 * row * (levelWidth - width) + right + bottom;
                    for (k = 0; k < blockWidth; k++) {
                      n = magnitude[position];
                      if (n !== 0) {
                        n = (n + magnitudeCorrection) * delta;
                        if (sign[position] !== 0) {
                          n = -n;
                        }
                        nb = bitsDecoded[position];
                        const pos = interleave ? levelOffset + (offset << 1) : offset;
                        coefficients[pos] = reversible && nb >= mb ? n : n * (1 << mb - nb);
                      }
                      offset++;
                      position++;
                    }
                    offset += width - blockWidth;
                  }
                }
              }
              function transformTile(context, tile, c) {
                const component = tile.components[c];
                const codingStyleParameters = component.codingStyleParameters;
                const quantizationParameters = component.quantizationParameters;
                const decompositionLevelsCount = codingStyleParameters.decompositionLevelsCount;
                const spqcds = quantizationParameters.SPqcds;
                const scalarExpounded = quantizationParameters.scalarExpounded;
                const guardBits = quantizationParameters.guardBits;
                const segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
                const resetContextProbabilities = codingStyleParameters.resetContextProbabilities;
                const precision = context.components[c].precision;
                const reversible = codingStyleParameters.reversibleTransformation;
                const transform = reversible ? new ReversibleTransform() : new IrreversibleTransform();
                const subbandCoefficients = [];
                let b = 0;
                for (let i = 0; i <= decompositionLevelsCount; i++) {
                  const resolution = component.resolutions[i];
                  const width = resolution.trx1 - resolution.trx0;
                  const height = resolution.try1 - resolution.try0;
                  const coefficients = new Float32Array(width * height);
                  for (let j = 0, jj = resolution.subbands.length; j < jj; j++) {
                    let mu, epsilon;
                    if (!scalarExpounded) {
                      mu = spqcds[0].mu;
                      epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
                    } else {
                      mu = spqcds[b].mu;
                      epsilon = spqcds[b].epsilon;
                      b++;
                    }
                    const subband = resolution.subbands[j];
                    const gainLog2 = SubbandsGainLog2[subband.type];
                    const delta = reversible ? 1 : 2 ** (precision + gainLog2 - epsilon) * (1 + mu / 2048);
                    const mb = guardBits + epsilon - 1;
                    copyCoefficients(coefficients, width, height, subband, delta, mb, reversible, segmentationSymbolUsed, resetContextProbabilities);
                  }
                  subbandCoefficients.push({
                    width,
                    height,
                    items: coefficients
                  });
                }
                const result = transform.calculate(subbandCoefficients, component.tcx0, component.tcy0);
                return {
                  left: component.tcx0,
                  top: component.tcy0,
                  width: result.width,
                  height: result.height,
                  items: result.items
                };
              }
              function transformComponents(context) {
                const siz = context.SIZ;
                const components = context.components;
                const componentsCount = siz.Csiz;
                const resultImages = [];
                for (let i = 0, ii = context.tiles.length; i < ii; i++) {
                  const tile = context.tiles[i];
                  const transformedTiles = [];
                  for (let c = 0; c < componentsCount; c++) {
                    transformedTiles[c] = transformTile(context, tile, c);
                  }
                  const tile0 = transformedTiles[0];
                  const out = new Uint8ClampedArray(tile0.items.length * componentsCount);
                  const result = {
                    left: tile0.left,
                    top: tile0.top,
                    width: tile0.width,
                    height: tile0.height,
                    items: out
                  };
                  let shift, offset;
                  let pos = 0, j, jj, y0, y1, y2;
                  if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
                    const fourComponents = componentsCount === 4;
                    const y0items = transformedTiles[0].items;
                    const y1items = transformedTiles[1].items;
                    const y2items = transformedTiles[2].items;
                    const y3items = fourComponents ? transformedTiles[3].items : null;
                    shift = components[0].precision - 8;
                    offset = (128 << shift) + 0.5;
                    const component0 = tile.components[0];
                    const alpha01 = componentsCount - 3;
                    jj = y0items.length;
                    if (!component0.codingStyleParameters.reversibleTransformation) {
                      for (j = 0; j < jj; j++, pos += alpha01) {
                        y0 = y0items[j] + offset;
                        y1 = y1items[j];
                        y2 = y2items[j];
                        out[pos++] = y0 + 1.402 * y2 >> shift;
                        out[pos++] = y0 - 0.34413 * y1 - 0.71414 * y2 >> shift;
                        out[pos++] = y0 + 1.772 * y1 >> shift;
                      }
                    } else {
                      for (j = 0; j < jj; j++, pos += alpha01) {
                        y0 = y0items[j] + offset;
                        y1 = y1items[j];
                        y2 = y2items[j];
                        const g = y0 - (y2 + y1 >> 2);
                        out[pos++] = g + y2 >> shift;
                        out[pos++] = g >> shift;
                        out[pos++] = g + y1 >> shift;
                      }
                    }
                    if (fourComponents) {
                      for (j = 0, pos = 3; j < jj; j++, pos += 4) {
                        out[pos] = y3items[j] + offset >> shift;
                      }
                    }
                  } else {
                    for (let c = 0; c < componentsCount; c++) {
                      const items = transformedTiles[c].items;
                      shift = components[c].precision - 8;
                      offset = (128 << shift) + 0.5;
                      for (pos = c, j = 0, jj = items.length; j < jj; j++) {
                        out[pos] = items[j] + offset >> shift;
                        pos += componentsCount;
                      }
                    }
                  }
                  resultImages.push(result);
                }
                return resultImages;
              }
              function initializeTile(context, tileIndex) {
                const siz = context.SIZ;
                const componentsCount = siz.Csiz;
                const tile = context.tiles[tileIndex];
                for (let c = 0; c < componentsCount; c++) {
                  const component = tile.components[c];
                  const qcdOrQcc = context.currentTile.QCC[c] !== void 0 ? context.currentTile.QCC[c] : context.currentTile.QCD;
                  component.quantizationParameters = qcdOrQcc;
                  const codOrCoc = context.currentTile.COC[c] !== void 0 ? context.currentTile.COC[c] : context.currentTile.COD;
                  component.codingStyleParameters = codOrCoc;
                }
                tile.codingStyleDefaultParameters = context.currentTile.COD;
              }
              class TagTree {
                constructor(width, height) {
                  const levelsLength = (0, _core_utils.log2)(Math.max(width, height)) + 1;
                  this.levels = [];
                  for (let i = 0; i < levelsLength; i++) {
                    const level = {
                      width,
                      height,
                      items: []
                    };
                    this.levels.push(level);
                    width = Math.ceil(width / 2);
                    height = Math.ceil(height / 2);
                  }
                }
                reset(i, j) {
                  let currentLevel = 0, value = 0, level;
                  while (currentLevel < this.levels.length) {
                    level = this.levels[currentLevel];
                    const index = i + j * level.width;
                    if (level.items[index] !== void 0) {
                      value = level.items[index];
                      break;
                    }
                    level.index = index;
                    i >>= 1;
                    j >>= 1;
                    currentLevel++;
                  }
                  currentLevel--;
                  level = this.levels[currentLevel];
                  level.items[level.index] = value;
                  this.currentLevel = currentLevel;
                  delete this.value;
                }
                incrementValue() {
                  const level = this.levels[this.currentLevel];
                  level.items[level.index]++;
                }
                nextLevel() {
                  let currentLevel = this.currentLevel;
                  let level = this.levels[currentLevel];
                  const value = level.items[level.index];
                  currentLevel--;
                  if (currentLevel < 0) {
                    this.value = value;
                    return false;
                  }
                  this.currentLevel = currentLevel;
                  level = this.levels[currentLevel];
                  level.items[level.index] = value;
                  return true;
                }
              }
              class InclusionTree {
                constructor(width, height, defaultValue) {
                  const levelsLength = (0, _core_utils.log2)(Math.max(width, height)) + 1;
                  this.levels = [];
                  for (let i = 0; i < levelsLength; i++) {
                    const items = new Uint8Array(width * height);
                    for (let j = 0, jj = items.length; j < jj; j++) {
                      items[j] = defaultValue;
                    }
                    const level = {
                      width,
                      height,
                      items
                    };
                    this.levels.push(level);
                    width = Math.ceil(width / 2);
                    height = Math.ceil(height / 2);
                  }
                }
                reset(i, j, stopValue) {
                  let currentLevel = 0;
                  while (currentLevel < this.levels.length) {
                    const level = this.levels[currentLevel];
                    const index = i + j * level.width;
                    level.index = index;
                    const value = level.items[index];
                    if (value === 255) {
                      break;
                    }
                    if (value > stopValue) {
                      this.currentLevel = currentLevel;
                      this.propagateValues();
                      return false;
                    }
                    i >>= 1;
                    j >>= 1;
                    currentLevel++;
                  }
                  this.currentLevel = currentLevel - 1;
                  return true;
                }
                incrementValue(stopValue) {
                  const level = this.levels[this.currentLevel];
                  level.items[level.index] = stopValue + 1;
                  this.propagateValues();
                }
                propagateValues() {
                  let levelIndex = this.currentLevel;
                  let level = this.levels[levelIndex];
                  const currentValue = level.items[level.index];
                  while (--levelIndex >= 0) {
                    level = this.levels[levelIndex];
                    level.items[level.index] = currentValue;
                  }
                }
                nextLevel() {
                  let currentLevel = this.currentLevel;
                  let level = this.levels[currentLevel];
                  const value = level.items[level.index];
                  level.items[level.index] = 255;
                  currentLevel--;
                  if (currentLevel < 0) {
                    return false;
                  }
                  this.currentLevel = currentLevel;
                  level = this.levels[currentLevel];
                  level.items[level.index] = value;
                  return true;
                }
              }
              const _BitModel = class _BitModel {
                constructor(width, height, subband, zeroBitPlanes, mb) {
                  this.width = width;
                  this.height = height;
                  let contextLabelTable;
                  if (subband === "HH") {
                    contextLabelTable = _BitModel.HHContextLabel;
                  } else if (subband === "HL") {
                    contextLabelTable = _BitModel.HLContextLabel;
                  } else {
                    contextLabelTable = _BitModel.LLAndLHContextsLabel;
                  }
                  this.contextLabelTable = contextLabelTable;
                  const coefficientCount = width * height;
                  this.neighborsSignificance = new Uint8Array(coefficientCount);
                  this.coefficentsSign = new Uint8Array(coefficientCount);
                  let coefficentsMagnitude;
                  if (mb > 14) {
                    coefficentsMagnitude = new Uint32Array(coefficientCount);
                  } else if (mb > 6) {
                    coefficentsMagnitude = new Uint16Array(coefficientCount);
                  } else {
                    coefficentsMagnitude = new Uint8Array(coefficientCount);
                  }
                  this.coefficentsMagnitude = coefficentsMagnitude;
                  this.processingFlags = new Uint8Array(coefficientCount);
                  const bitsDecoded = new Uint8Array(coefficientCount);
                  if (zeroBitPlanes !== 0) {
                    for (let i = 0; i < coefficientCount; i++) {
                      bitsDecoded[i] = zeroBitPlanes;
                    }
                  }
                  this.bitsDecoded = bitsDecoded;
                  this.reset();
                }
                setDecoder(decoder) {
                  this.decoder = decoder;
                }
                reset() {
                  this.contexts = new Int8Array(19);
                  this.contexts[0] = 4 << 1 | 0;
                  this.contexts[_BitModel.UNIFORM_CONTEXT] = 46 << 1 | 0;
                  this.contexts[_BitModel.RUNLENGTH_CONTEXT] = 3 << 1 | 0;
                }
                setNeighborsSignificance(row, column, index) {
                  const neighborsSignificance = this.neighborsSignificance;
                  const width = this.width, height = this.height;
                  const left = column > 0;
                  const right = column + 1 < width;
                  let i;
                  if (row > 0) {
                    i = index - width;
                    if (left) {
                      neighborsSignificance[i - 1] += 16;
                    }
                    if (right) {
                      neighborsSignificance[i + 1] += 16;
                    }
                    neighborsSignificance[i] += 4;
                  }
                  if (row + 1 < height) {
                    i = index + width;
                    if (left) {
                      neighborsSignificance[i - 1] += 16;
                    }
                    if (right) {
                      neighborsSignificance[i + 1] += 16;
                    }
                    neighborsSignificance[i] += 4;
                  }
                  if (left) {
                    neighborsSignificance[index - 1] += 1;
                  }
                  if (right) {
                    neighborsSignificance[index + 1] += 1;
                  }
                  neighborsSignificance[index] |= 128;
                }
                runSignificancePropagationPass() {
                  const decoder = this.decoder;
                  const width = this.width, height = this.height;
                  const coefficentsMagnitude = this.coefficentsMagnitude;
                  const coefficentsSign = this.coefficentsSign;
                  const neighborsSignificance = this.neighborsSignificance;
                  const processingFlags = this.processingFlags;
                  const contexts = this.contexts;
                  const labels = this.contextLabelTable;
                  const bitsDecoded = this.bitsDecoded;
                  const processedInverseMask = ~1;
                  const processedMask = 1;
                  const firstMagnitudeBitMask = 2;
                  for (let i0 = 0; i0 < height; i0 += 4) {
                    for (let j = 0; j < width; j++) {
                      let index = i0 * width + j;
                      for (let i1 = 0; i1 < 4; i1++, index += width) {
                        const i = i0 + i1;
                        if (i >= height) {
                          break;
                        }
                        processingFlags[index] &= processedInverseMask;
                        if (coefficentsMagnitude[index] || !neighborsSignificance[index]) {
                          continue;
                        }
                        const contextLabel = labels[neighborsSignificance[index]];
                        const decision = decoder.readBit(contexts, contextLabel);
                        if (decision) {
                          const sign = this.decodeSignBit(i, j, index);
                          coefficentsSign[index] = sign;
                          coefficentsMagnitude[index] = 1;
                          this.setNeighborsSignificance(i, j, index);
                          processingFlags[index] |= firstMagnitudeBitMask;
                        }
                        bitsDecoded[index]++;
                        processingFlags[index] |= processedMask;
                      }
                    }
                  }
                }
                decodeSignBit(row, column, index) {
                  const width = this.width, height = this.height;
                  const coefficentsMagnitude = this.coefficentsMagnitude;
                  const coefficentsSign = this.coefficentsSign;
                  let contribution, sign0, sign1, significance1;
                  let contextLabel, decoded;
                  significance1 = column > 0 && coefficentsMagnitude[index - 1] !== 0;
                  if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
                    sign1 = coefficentsSign[index + 1];
                    if (significance1) {
                      sign0 = coefficentsSign[index - 1];
                      contribution = 1 - sign1 - sign0;
                    } else {
                      contribution = 1 - sign1 - sign1;
                    }
                  } else if (significance1) {
                    sign0 = coefficentsSign[index - 1];
                    contribution = 1 - sign0 - sign0;
                  } else {
                    contribution = 0;
                  }
                  const horizontalContribution = 3 * contribution;
                  significance1 = row > 0 && coefficentsMagnitude[index - width] !== 0;
                  if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
                    sign1 = coefficentsSign[index + width];
                    if (significance1) {
                      sign0 = coefficentsSign[index - width];
                      contribution = 1 - sign1 - sign0 + horizontalContribution;
                    } else {
                      contribution = 1 - sign1 - sign1 + horizontalContribution;
                    }
                  } else if (significance1) {
                    sign0 = coefficentsSign[index - width];
                    contribution = 1 - sign0 - sign0 + horizontalContribution;
                  } else {
                    contribution = horizontalContribution;
                  }
                  if (contribution >= 0) {
                    contextLabel = 9 + contribution;
                    decoded = this.decoder.readBit(this.contexts, contextLabel);
                  } else {
                    contextLabel = 9 - contribution;
                    decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
                  }
                  return decoded;
                }
                runMagnitudeRefinementPass() {
                  const decoder = this.decoder;
                  const width = this.width, height = this.height;
                  const coefficentsMagnitude = this.coefficentsMagnitude;
                  const neighborsSignificance = this.neighborsSignificance;
                  const contexts = this.contexts;
                  const bitsDecoded = this.bitsDecoded;
                  const processingFlags = this.processingFlags;
                  const processedMask = 1;
                  const firstMagnitudeBitMask = 2;
                  const length = width * height;
                  const width4 = width * 4;
                  for (let index0 = 0, indexNext; index0 < length; index0 = indexNext) {
                    indexNext = Math.min(length, index0 + width4);
                    for (let j = 0; j < width; j++) {
                      for (let index = index0 + j; index < indexNext; index += width) {
                        if (!coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                          continue;
                        }
                        let contextLabel = 16;
                        if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
                          processingFlags[index] ^= firstMagnitudeBitMask;
                          const significance = neighborsSignificance[index] & 127;
                          contextLabel = significance === 0 ? 15 : 14;
                        }
                        const bit = decoder.readBit(contexts, contextLabel);
                        coefficentsMagnitude[index] = coefficentsMagnitude[index] << 1 | bit;
                        bitsDecoded[index]++;
                        processingFlags[index] |= processedMask;
                      }
                    }
                  }
                }
                runCleanupPass() {
                  const decoder = this.decoder;
                  const width = this.width, height = this.height;
                  const neighborsSignificance = this.neighborsSignificance;
                  const coefficentsMagnitude = this.coefficentsMagnitude;
                  const coefficentsSign = this.coefficentsSign;
                  const contexts = this.contexts;
                  const labels = this.contextLabelTable;
                  const bitsDecoded = this.bitsDecoded;
                  const processingFlags = this.processingFlags;
                  const processedMask = 1;
                  const firstMagnitudeBitMask = 2;
                  const oneRowDown = width;
                  const twoRowsDown = width * 2;
                  const threeRowsDown = width * 3;
                  let iNext;
                  for (let i0 = 0; i0 < height; i0 = iNext) {
                    iNext = Math.min(i0 + 4, height);
                    const indexBase = i0 * width;
                    const checkAllEmpty = i0 + 3 < height;
                    for (let j = 0; j < width; j++) {
                      const index0 = indexBase + j;
                      const allEmpty = checkAllEmpty && processingFlags[index0] === 0 && processingFlags[index0 + oneRowDown] === 0 && processingFlags[index0 + twoRowsDown] === 0 && processingFlags[index0 + threeRowsDown] === 0 && neighborsSignificance[index0] === 0 && neighborsSignificance[index0 + oneRowDown] === 0 && neighborsSignificance[index0 + twoRowsDown] === 0 && neighborsSignificance[index0 + threeRowsDown] === 0;
                      let i1 = 0, index = index0;
                      let i = i0, sign;
                      if (allEmpty) {
                        const hasSignificantCoefficent = decoder.readBit(contexts, _BitModel.RUNLENGTH_CONTEXT);
                        if (!hasSignificantCoefficent) {
                          bitsDecoded[index0]++;
                          bitsDecoded[index0 + oneRowDown]++;
                          bitsDecoded[index0 + twoRowsDown]++;
                          bitsDecoded[index0 + threeRowsDown]++;
                          continue;
                        }
                        i1 = decoder.readBit(contexts, _BitModel.UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, _BitModel.UNIFORM_CONTEXT);
                        if (i1 !== 0) {
                          i = i0 + i1;
                          index += i1 * width;
                        }
                        sign = this.decodeSignBit(i, j, index);
                        coefficentsSign[index] = sign;
                        coefficentsMagnitude[index] = 1;
                        this.setNeighborsSignificance(i, j, index);
                        processingFlags[index] |= firstMagnitudeBitMask;
                        index = index0;
                        for (let i2 = i0; i2 <= i; i2++, index += width) {
                          bitsDecoded[index]++;
                        }
                        i1++;
                      }
                      for (i = i0 + i1; i < iNext; i++, index += width) {
                        if (coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                          continue;
                        }
                        const contextLabel = labels[neighborsSignificance[index]];
                        const decision = decoder.readBit(contexts, contextLabel);
                        if (decision === 1) {
                          sign = this.decodeSignBit(i, j, index);
                          coefficentsSign[index] = sign;
                          coefficentsMagnitude[index] = 1;
                          this.setNeighborsSignificance(i, j, index);
                          processingFlags[index] |= firstMagnitudeBitMask;
                        }
                        bitsDecoded[index]++;
                      }
                    }
                  }
                }
                checkSegmentationSymbol() {
                  const decoder = this.decoder;
                  const contexts = this.contexts;
                  const symbol = decoder.readBit(contexts, _BitModel.UNIFORM_CONTEXT) << 3 | decoder.readBit(contexts, _BitModel.UNIFORM_CONTEXT) << 2 | decoder.readBit(contexts, _BitModel.UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, _BitModel.UNIFORM_CONTEXT);
                  if (symbol !== 10) {
                    throw new JpxError("Invalid segmentation symbol");
                  }
                }
              };
              __publicField(_BitModel, "UNIFORM_CONTEXT", 17);
              __publicField(_BitModel, "RUNLENGTH_CONTEXT", 18);
              __publicField(_BitModel, "LLAndLHContextsLabel", new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]));
              __publicField(_BitModel, "HLContextLabel", new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]));
              __publicField(_BitModel, "HHContextLabel", new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]));
              let BitModel = _BitModel;
              class Transform {
                constructor() {
                  if (this.constructor === Transform) {
                    (0, _util.unreachable)("Cannot initialize Transform.");
                  }
                }
                calculate(subbands, u0, v0) {
                  let ll = subbands[0];
                  for (let i = 1, ii = subbands.length; i < ii; i++) {
                    ll = this.iterate(ll, subbands[i], u0, v0);
                  }
                  return ll;
                }
                extend(buffer, offset, size) {
                  let i1 = offset - 1, j1 = offset + 1;
                  let i2 = offset + size - 2, j2 = offset + size;
                  buffer[i1--] = buffer[j1++];
                  buffer[j2++] = buffer[i2--];
                  buffer[i1--] = buffer[j1++];
                  buffer[j2++] = buffer[i2--];
                  buffer[i1--] = buffer[j1++];
                  buffer[j2++] = buffer[i2--];
                  buffer[i1] = buffer[j1];
                  buffer[j2] = buffer[i2];
                }
                filter(x, offset, length) {
                  (0, _util.unreachable)("Abstract method `filter` called");
                }
                iterate(ll, hl_lh_hh, u0, v0) {
                  const llWidth = ll.width, llHeight = ll.height;
                  let llItems = ll.items;
                  const width = hl_lh_hh.width;
                  const height = hl_lh_hh.height;
                  const items = hl_lh_hh.items;
                  let i, j, k, l, u, v;
                  for (k = 0, i = 0; i < llHeight; i++) {
                    l = i * 2 * width;
                    for (j = 0; j < llWidth; j++, k++, l += 2) {
                      items[l] = llItems[k];
                    }
                  }
                  llItems = ll.items = null;
                  const bufferPadding = 4;
                  const rowBuffer = new Float32Array(width + 2 * bufferPadding);
                  if (width === 1) {
                    if ((u0 & 1) !== 0) {
                      for (v = 0, k = 0; v < height; v++, k += width) {
                        items[k] *= 0.5;
                      }
                    }
                  } else {
                    for (v = 0, k = 0; v < height; v++, k += width) {
                      rowBuffer.set(items.subarray(k, k + width), bufferPadding);
                      this.extend(rowBuffer, bufferPadding, width);
                      this.filter(rowBuffer, bufferPadding, width);
                      items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k);
                    }
                  }
                  let numBuffers = 16;
                  const colBuffers = [];
                  for (i = 0; i < numBuffers; i++) {
                    colBuffers.push(new Float32Array(height + 2 * bufferPadding));
                  }
                  let b, currentBuffer = 0;
                  ll = bufferPadding + height;
                  if (height === 1) {
                    if ((v0 & 1) !== 0) {
                      for (u = 0; u < width; u++) {
                        items[u] *= 0.5;
                      }
                    }
                  } else {
                    for (u = 0; u < width; u++) {
                      if (currentBuffer === 0) {
                        numBuffers = Math.min(width - u, numBuffers);
                        for (k = u, l = bufferPadding; l < ll; k += width, l++) {
                          for (b = 0; b < numBuffers; b++) {
                            colBuffers[b][l] = items[k + b];
                          }
                        }
                        currentBuffer = numBuffers;
                      }
                      currentBuffer--;
                      const buffer = colBuffers[currentBuffer];
                      this.extend(buffer, bufferPadding, height);
                      this.filter(buffer, bufferPadding, height);
                      if (currentBuffer === 0) {
                        k = u - numBuffers + 1;
                        for (l = bufferPadding; l < ll; k += width, l++) {
                          for (b = 0; b < numBuffers; b++) {
                            items[k + b] = colBuffers[b][l];
                          }
                        }
                      }
                    }
                  }
                  return {
                    width,
                    height,
                    items
                  };
                }
              }
              class IrreversibleTransform extends Transform {
                filter(x, offset, length) {
                  const len = length >> 1;
                  offset |= 0;
                  let j, n, current, next;
                  const alpha = -1.586134342059924;
                  const beta = -0.052980118572961;
                  const gamma = 0.882911075530934;
                  const delta = 0.443506852043971;
                  const K = 1.230174104914001;
                  const K_ = 1 / K;
                  j = offset - 3;
                  for (n = len + 4; n--; j += 2) {
                    x[j] *= K_;
                  }
                  j = offset - 2;
                  current = delta * x[j - 1];
                  for (n = len + 3; n--; j += 2) {
                    next = delta * x[j + 1];
                    x[j] = K * x[j] - current - next;
                    if (n--) {
                      j += 2;
                      current = delta * x[j + 1];
                      x[j] = K * x[j] - current - next;
                    } else {
                      break;
                    }
                  }
                  j = offset - 1;
                  current = gamma * x[j - 1];
                  for (n = len + 2; n--; j += 2) {
                    next = gamma * x[j + 1];
                    x[j] -= current + next;
                    if (n--) {
                      j += 2;
                      current = gamma * x[j + 1];
                      x[j] -= current + next;
                    } else {
                      break;
                    }
                  }
                  j = offset;
                  current = beta * x[j - 1];
                  for (n = len + 1; n--; j += 2) {
                    next = beta * x[j + 1];
                    x[j] -= current + next;
                    if (n--) {
                      j += 2;
                      current = beta * x[j + 1];
                      x[j] -= current + next;
                    } else {
                      break;
                    }
                  }
                  if (len !== 0) {
                    j = offset + 1;
                    current = alpha * x[j - 1];
                    for (n = len; n--; j += 2) {
                      next = alpha * x[j + 1];
                      x[j] -= current + next;
                      if (n--) {
                        j += 2;
                        current = alpha * x[j + 1];
                        x[j] -= current + next;
                      } else {
                        break;
                      }
                    }
                  }
                }
              }
              class ReversibleTransform extends Transform {
                filter(x, offset, length) {
                  const len = length >> 1;
                  offset |= 0;
                  let j, n;
                  for (j = offset, n = len + 1; n--; j += 2) {
                    x[j] -= x[j - 1] + x[j + 1] + 2 >> 2;
                  }
                  for (j = offset + 1, n = len; n--; j += 2) {
                    x[j] += x[j - 1] + x[j + 1] >> 1;
                  }
                }
              }
            },
            /* 31 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.LZWStream = void 0;
              var _decode_stream = __w_pdfjs_require__2(18);
              class LZWStream extends _decode_stream.DecodeStream {
                constructor(str, maybeLength, earlyChange) {
                  super(maybeLength);
                  this.str = str;
                  this.dict = str.dict;
                  this.cachedData = 0;
                  this.bitsCached = 0;
                  const maxLzwDictionarySize = 4096;
                  const lzwState = {
                    earlyChange,
                    codeLength: 9,
                    nextCode: 258,
                    dictionaryValues: new Uint8Array(maxLzwDictionarySize),
                    dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
                    dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
                    currentSequence: new Uint8Array(maxLzwDictionarySize),
                    currentSequenceLength: 0
                  };
                  for (let i = 0; i < 256; ++i) {
                    lzwState.dictionaryValues[i] = i;
                    lzwState.dictionaryLengths[i] = 1;
                  }
                  this.lzwState = lzwState;
                }
                readBits(n) {
                  let bitsCached = this.bitsCached;
                  let cachedData = this.cachedData;
                  while (bitsCached < n) {
                    const c = this.str.getByte();
                    if (c === -1) {
                      this.eof = true;
                      return null;
                    }
                    cachedData = cachedData << 8 | c;
                    bitsCached += 8;
                  }
                  this.bitsCached = bitsCached -= n;
                  this.cachedData = cachedData;
                  this.lastCode = null;
                  return cachedData >>> bitsCached & (1 << n) - 1;
                }
                readBlock() {
                  const blockSize = 512, decodedSizeDelta = blockSize;
                  let estimatedDecodedSize = blockSize * 2;
                  let i, j, q;
                  const lzwState = this.lzwState;
                  if (!lzwState) {
                    return;
                  }
                  const earlyChange = lzwState.earlyChange;
                  let nextCode = lzwState.nextCode;
                  const dictionaryValues = lzwState.dictionaryValues;
                  const dictionaryLengths = lzwState.dictionaryLengths;
                  const dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
                  let codeLength = lzwState.codeLength;
                  let prevCode = lzwState.prevCode;
                  const currentSequence = lzwState.currentSequence;
                  let currentSequenceLength = lzwState.currentSequenceLength;
                  let decodedLength = 0;
                  let currentBufferLength = this.bufferLength;
                  let buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                  for (i = 0; i < blockSize; i++) {
                    const code = this.readBits(codeLength);
                    const hasPrev = currentSequenceLength > 0;
                    if (code < 256) {
                      currentSequence[0] = code;
                      currentSequenceLength = 1;
                    } else if (code >= 258) {
                      if (code < nextCode) {
                        currentSequenceLength = dictionaryLengths[code];
                        for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
                          currentSequence[j] = dictionaryValues[q];
                          q = dictionaryPrevCodes[q];
                        }
                      } else {
                        currentSequence[currentSequenceLength++] = currentSequence[0];
                      }
                    } else if (code === 256) {
                      codeLength = 9;
                      nextCode = 258;
                      currentSequenceLength = 0;
                      continue;
                    } else {
                      this.eof = true;
                      delete this.lzwState;
                      break;
                    }
                    if (hasPrev) {
                      dictionaryPrevCodes[nextCode] = prevCode;
                      dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
                      dictionaryValues[nextCode] = currentSequence[0];
                      nextCode++;
                      codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
                    }
                    prevCode = code;
                    decodedLength += currentSequenceLength;
                    if (estimatedDecodedSize < decodedLength) {
                      do {
                        estimatedDecodedSize += decodedSizeDelta;
                      } while (estimatedDecodedSize < decodedLength);
                      buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                    }
                    for (j = 0; j < currentSequenceLength; j++) {
                      buffer[currentBufferLength++] = currentSequence[j];
                    }
                  }
                  lzwState.nextCode = nextCode;
                  lzwState.codeLength = codeLength;
                  lzwState.prevCode = prevCode;
                  lzwState.currentSequenceLength = currentSequenceLength;
                  this.bufferLength = currentBufferLength;
                }
              }
              exports2.LZWStream = LZWStream;
            },
            /* 32 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PredictorStream = void 0;
              var _decode_stream = __w_pdfjs_require__2(18);
              var _primitives = __w_pdfjs_require__2(4);
              var _util = __w_pdfjs_require__2(2);
              class PredictorStream extends _decode_stream.DecodeStream {
                constructor(str, maybeLength, params) {
                  super(maybeLength);
                  if (!(params instanceof _primitives.Dict)) {
                    return str;
                  }
                  const predictor = this.predictor = params.get("Predictor") || 1;
                  if (predictor <= 1) {
                    return str;
                  }
                  if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
                    throw new _util.FormatError(`Unsupported predictor: ${predictor}`);
                  }
                  this.readBlock = predictor === 2 ? this.readBlockTiff : this.readBlockPng;
                  this.str = str;
                  this.dict = str.dict;
                  const colors = this.colors = params.get("Colors") || 1;
                  const bits = this.bits = params.get("BPC", "BitsPerComponent") || 8;
                  const columns = this.columns = params.get("Columns") || 1;
                  this.pixBytes = colors * bits + 7 >> 3;
                  this.rowBytes = columns * colors * bits + 7 >> 3;
                  return this;
                }
                readBlockTiff() {
                  const rowBytes = this.rowBytes;
                  const bufferLength = this.bufferLength;
                  const buffer = this.ensureBuffer(bufferLength + rowBytes);
                  const bits = this.bits;
                  const colors = this.colors;
                  const rawBytes = this.str.getBytes(rowBytes);
                  this.eof = !rawBytes.length;
                  if (this.eof) {
                    return;
                  }
                  let inbuf = 0, outbuf = 0;
                  let inbits = 0, outbits = 0;
                  let pos = bufferLength;
                  let i;
                  if (bits === 1 && colors === 1) {
                    for (i = 0; i < rowBytes; ++i) {
                      let c = rawBytes[i] ^ inbuf;
                      c ^= c >> 1;
                      c ^= c >> 2;
                      c ^= c >> 4;
                      inbuf = (c & 1) << 7;
                      buffer[pos++] = c;
                    }
                  } else if (bits === 8) {
                    for (i = 0; i < colors; ++i) {
                      buffer[pos++] = rawBytes[i];
                    }
                    for (; i < rowBytes; ++i) {
                      buffer[pos] = buffer[pos - colors] + rawBytes[i];
                      pos++;
                    }
                  } else if (bits === 16) {
                    const bytesPerPixel = colors * 2;
                    for (i = 0; i < bytesPerPixel; ++i) {
                      buffer[pos++] = rawBytes[i];
                    }
                    for (; i < rowBytes; i += 2) {
                      const sum = ((rawBytes[i] & 255) << 8) + (rawBytes[i + 1] & 255) + ((buffer[pos - bytesPerPixel] & 255) << 8) + (buffer[pos - bytesPerPixel + 1] & 255);
                      buffer[pos++] = sum >> 8 & 255;
                      buffer[pos++] = sum & 255;
                    }
                  } else {
                    const compArray = new Uint8Array(colors + 1);
                    const bitMask = (1 << bits) - 1;
                    let j = 0, k = bufferLength;
                    const columns = this.columns;
                    for (i = 0; i < columns; ++i) {
                      for (let kk = 0; kk < colors; ++kk) {
                        if (inbits < bits) {
                          inbuf = inbuf << 8 | rawBytes[j++] & 255;
                          inbits += 8;
                        }
                        compArray[kk] = compArray[kk] + (inbuf >> inbits - bits) & bitMask;
                        inbits -= bits;
                        outbuf = outbuf << bits | compArray[kk];
                        outbits += bits;
                        if (outbits >= 8) {
                          buffer[k++] = outbuf >> outbits - 8 & 255;
                          outbits -= 8;
                        }
                      }
                    }
                    if (outbits > 0) {
                      buffer[k++] = (outbuf << 8 - outbits) + (inbuf & (1 << 8 - outbits) - 1);
                    }
                  }
                  this.bufferLength += rowBytes;
                }
                readBlockPng() {
                  const rowBytes = this.rowBytes;
                  const pixBytes = this.pixBytes;
                  const predictor = this.str.getByte();
                  const rawBytes = this.str.getBytes(rowBytes);
                  this.eof = !rawBytes.length;
                  if (this.eof) {
                    return;
                  }
                  const bufferLength = this.bufferLength;
                  const buffer = this.ensureBuffer(bufferLength + rowBytes);
                  let prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
                  if (prevRow.length === 0) {
                    prevRow = new Uint8Array(rowBytes);
                  }
                  let i, j = bufferLength, up, c;
                  switch (predictor) {
                    case 0:
                      for (i = 0; i < rowBytes; ++i) {
                        buffer[j++] = rawBytes[i];
                      }
                      break;
                    case 1:
                      for (i = 0; i < pixBytes; ++i) {
                        buffer[j++] = rawBytes[i];
                      }
                      for (; i < rowBytes; ++i) {
                        buffer[j] = buffer[j - pixBytes] + rawBytes[i] & 255;
                        j++;
                      }
                      break;
                    case 2:
                      for (i = 0; i < rowBytes; ++i) {
                        buffer[j++] = prevRow[i] + rawBytes[i] & 255;
                      }
                      break;
                    case 3:
                      for (i = 0; i < pixBytes; ++i) {
                        buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];
                      }
                      for (; i < rowBytes; ++i) {
                        buffer[j] = (prevRow[i] + buffer[j - pixBytes] >> 1) + rawBytes[i] & 255;
                        j++;
                      }
                      break;
                    case 4:
                      for (i = 0; i < pixBytes; ++i) {
                        up = prevRow[i];
                        c = rawBytes[i];
                        buffer[j++] = up + c;
                      }
                      for (; i < rowBytes; ++i) {
                        up = prevRow[i];
                        const upLeft = prevRow[i - pixBytes];
                        const left = buffer[j - pixBytes];
                        const p = left + up - upLeft;
                        let pa = p - left;
                        if (pa < 0) {
                          pa = -pa;
                        }
                        let pb = p - up;
                        if (pb < 0) {
                          pb = -pb;
                        }
                        let pc = p - upLeft;
                        if (pc < 0) {
                          pc = -pc;
                        }
                        c = rawBytes[i];
                        if (pa <= pb && pa <= pc) {
                          buffer[j++] = left + c;
                        } else if (pb <= pc) {
                          buffer[j++] = up + c;
                        } else {
                          buffer[j++] = upLeft + c;
                        }
                      }
                      break;
                    default:
                      throw new _util.FormatError(`Unsupported predictor: ${predictor}`);
                  }
                  this.bufferLength += rowBytes;
                }
              }
              exports2.PredictorStream = PredictorStream;
            },
            /* 33 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.RunLengthStream = void 0;
              var _decode_stream = __w_pdfjs_require__2(18);
              class RunLengthStream extends _decode_stream.DecodeStream {
                constructor(str, maybeLength) {
                  super(maybeLength);
                  this.str = str;
                  this.dict = str.dict;
                }
                readBlock() {
                  const repeatHeader = this.str.getBytes(2);
                  if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
                    this.eof = true;
                    return;
                  }
                  let buffer;
                  let bufferLength = this.bufferLength;
                  let n = repeatHeader[0];
                  if (n < 128) {
                    buffer = this.ensureBuffer(bufferLength + n + 1);
                    buffer[bufferLength++] = repeatHeader[1];
                    if (n > 0) {
                      const source = this.str.getBytes(n);
                      buffer.set(source, bufferLength);
                      bufferLength += n;
                    }
                  } else {
                    n = 257 - n;
                    const b = repeatHeader[1];
                    buffer = this.ensureBuffer(bufferLength + n + 1);
                    for (let i = 0; i < n; i++) {
                      buffer[bufferLength++] = b;
                    }
                  }
                  this.bufferLength = bufferLength;
                }
              }
              exports2.RunLengthStream = RunLengthStream;
            },
            /* 34 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Font = exports2.ErrorFont = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _cff_parser = __w_pdfjs_require__2(35);
              var _fonts_utils = __w_pdfjs_require__2(38);
              var _unicode = __w_pdfjs_require__2(40);
              var _glyphlist = __w_pdfjs_require__2(39);
              var _encodings = __w_pdfjs_require__2(37);
              var _standard_fonts = __w_pdfjs_require__2(41);
              var _to_unicode_map = __w_pdfjs_require__2(42);
              var _cff_font = __w_pdfjs_require__2(43);
              var _font_renderer = __w_pdfjs_require__2(44);
              var _metrics = __w_pdfjs_require__2(45);
              var _glyf = __w_pdfjs_require__2(46);
              var _cmap = __w_pdfjs_require__2(14);
              var _opentype_file_builder = __w_pdfjs_require__2(47);
              var _core_utils = __w_pdfjs_require__2(3);
              var _stream = __w_pdfjs_require__2(8);
              var _type1_font = __w_pdfjs_require__2(48);
              const PRIVATE_USE_AREAS = [[57344, 63743], [1048576, 1114109]];
              const PDF_GLYPH_SPACE_UNITS = 1e3;
              const EXPORT_DATA_PROPERTIES = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "isInvalidPDFjsFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "systemFontInfo", "type", "vertical"];
              const EXPORT_DATA_EXTRA_PROPERTIES = ["cMap", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
              function adjustWidths(properties) {
                if (!properties.fontMatrix) {
                  return;
                }
                if (properties.fontMatrix[0] === _util.FONT_IDENTITY_MATRIX[0]) {
                  return;
                }
                const scale = 1e-3 / properties.fontMatrix[0];
                const glyphsWidths = properties.widths;
                for (const glyph in glyphsWidths) {
                  glyphsWidths[glyph] *= scale;
                }
                properties.defaultWidth *= scale;
              }
              function adjustTrueTypeToUnicode(properties, isSymbolicFont, nameRecords) {
                if (properties.isInternalFont) {
                  return;
                }
                if (properties.hasIncludedToUnicodeMap) {
                  return;
                }
                if (properties.hasEncoding) {
                  return;
                }
                if (properties.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
                  return;
                }
                if (!isSymbolicFont) {
                  return;
                }
                if (nameRecords.length === 0) {
                  return;
                }
                if (properties.defaultEncoding === _encodings.WinAnsiEncoding) {
                  return;
                }
                for (const r of nameRecords) {
                  if (!isWinNameRecord(r)) {
                    return;
                  }
                }
                const encoding = _encodings.WinAnsiEncoding;
                const toUnicode = [], glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                for (const charCode in encoding) {
                  const glyphName = encoding[charCode];
                  if (glyphName === "") {
                    continue;
                  }
                  const unicode = glyphsUnicodeMap[glyphName];
                  if (unicode === void 0) {
                    continue;
                  }
                  toUnicode[charCode] = String.fromCharCode(unicode);
                }
                if (toUnicode.length > 0) {
                  properties.toUnicode.amend(toUnicode);
                }
              }
              function adjustType1ToUnicode(properties, builtInEncoding) {
                if (properties.isInternalFont) {
                  return;
                }
                if (properties.hasIncludedToUnicodeMap) {
                  return;
                }
                if (builtInEncoding === properties.defaultEncoding) {
                  return;
                }
                if (properties.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
                  return;
                }
                const toUnicode = [], glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                for (const charCode in builtInEncoding) {
                  if (properties.hasEncoding) {
                    if (properties.baseEncodingName || properties.differences[charCode] !== void 0) {
                      continue;
                    }
                  }
                  const glyphName = builtInEncoding[charCode];
                  const unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
                  if (unicode !== -1) {
                    toUnicode[charCode] = String.fromCharCode(unicode);
                  }
                }
                if (toUnicode.length > 0) {
                  properties.toUnicode.amend(toUnicode);
                }
              }
              function amendFallbackToUnicode(properties) {
                if (!properties.fallbackToUnicode) {
                  return;
                }
                if (properties.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
                  return;
                }
                const toUnicode = [];
                for (const charCode in properties.fallbackToUnicode) {
                  if (properties.toUnicode.has(charCode)) {
                    continue;
                  }
                  toUnicode[charCode] = properties.fallbackToUnicode[charCode];
                }
                if (toUnicode.length > 0) {
                  properties.toUnicode.amend(toUnicode);
                }
              }
              class Glyph {
                constructor(originalCharCode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
                  this.originalCharCode = originalCharCode;
                  this.fontChar = fontChar;
                  this.unicode = unicode;
                  this.accent = accent;
                  this.width = width;
                  this.vmetric = vmetric;
                  this.operatorListId = operatorListId;
                  this.isSpace = isSpace;
                  this.isInFont = isInFont;
                }
                get category() {
                  return (0, _util.shadow)(this, "category", (0, _unicode.getCharUnicodeCategory)(this.unicode), true);
                }
              }
              function int16(b0, b1) {
                return (b0 << 8) + b1;
              }
              function writeSignedInt16(bytes, index, value) {
                bytes[index + 1] = value;
                bytes[index] = value >>> 8;
              }
              function signedInt16(b0, b1) {
                const value = (b0 << 8) + b1;
                return value & 1 << 15 ? value - 65536 : value;
              }
              function int32(b0, b1, b2, b3) {
                return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
              }
              function string16(value) {
                return String.fromCharCode(value >> 8 & 255, value & 255);
              }
              function safeString16(value) {
                if (value > 32767) {
                  value = 32767;
                } else if (value < -32768) {
                  value = -32768;
                }
                return String.fromCharCode(value >> 8 & 255, value & 255);
              }
              function isTrueTypeFile(file) {
                const header = file.peekBytes(4);
                return (0, _core_utils.readUint32)(header, 0) === 65536 || (0, _util.bytesToString)(header) === "true";
              }
              function isTrueTypeCollectionFile(file) {
                const header = file.peekBytes(4);
                return (0, _util.bytesToString)(header) === "ttcf";
              }
              function isOpenTypeFile(file) {
                const header = file.peekBytes(4);
                return (0, _util.bytesToString)(header) === "OTTO";
              }
              function isType1File(file) {
                const header = file.peekBytes(2);
                if (header[0] === 37 && header[1] === 33) {
                  return true;
                }
                if (header[0] === 128 && header[1] === 1) {
                  return true;
                }
                return false;
              }
              function isCFFFile(file) {
                const header = file.peekBytes(4);
                if (header[0] >= 1 && header[3] >= 1 && header[3] <= 4) {
                  return true;
                }
                return false;
              }
              function getFontFileType(file, {
                type,
                subtype,
                composite
              }) {
                let fileType, fileSubtype;
                if (isTrueTypeFile(file) || isTrueTypeCollectionFile(file)) {
                  fileType = composite ? "CIDFontType2" : "TrueType";
                } else if (isOpenTypeFile(file)) {
                  fileType = composite ? "CIDFontType2" : "OpenType";
                } else if (isType1File(file)) {
                  if (composite) {
                    fileType = "CIDFontType0";
                  } else {
                    fileType = type === "MMType1" ? "MMType1" : "Type1";
                  }
                } else if (isCFFFile(file)) {
                  if (composite) {
                    fileType = "CIDFontType0";
                    fileSubtype = "CIDFontType0C";
                  } else {
                    fileType = type === "MMType1" ? "MMType1" : "Type1";
                    fileSubtype = "Type1C";
                  }
                } else {
                  (0, _util.warn)("getFontFileType: Unable to detect correct font file Type/Subtype.");
                  fileType = type;
                  fileSubtype = subtype;
                }
                return [fileType, fileSubtype];
              }
              function applyStandardFontGlyphMap(map, glyphMap) {
                for (const charCode in glyphMap) {
                  map[+charCode] = glyphMap[charCode];
                }
              }
              function buildToFontChar(encoding, glyphsUnicodeMap, differences) {
                const toFontChar = [];
                let unicode;
                for (let i = 0, ii = encoding.length; i < ii; i++) {
                  unicode = (0, _unicode.getUnicodeForGlyph)(encoding[i], glyphsUnicodeMap);
                  if (unicode !== -1) {
                    toFontChar[i] = unicode;
                  }
                }
                for (const charCode in differences) {
                  unicode = (0, _unicode.getUnicodeForGlyph)(differences[charCode], glyphsUnicodeMap);
                  if (unicode !== -1) {
                    toFontChar[+charCode] = unicode;
                  }
                }
                return toFontChar;
              }
              function isMacNameRecord(r) {
                return r.platform === 1 && r.encoding === 0 && r.language === 0;
              }
              function isWinNameRecord(r) {
                return r.platform === 3 && r.encoding === 1 && r.language === 1033;
              }
              function convertCidString(charCode, cid, shouldThrow = false) {
                switch (cid.length) {
                  case 1:
                    return cid.charCodeAt(0);
                  case 2:
                    return cid.charCodeAt(0) << 8 | cid.charCodeAt(1);
                }
                const msg = `Unsupported CID string (charCode ${charCode}): "${cid}".`;
                if (shouldThrow) {
                  throw new _util.FormatError(msg);
                }
                (0, _util.warn)(msg);
                return cid;
              }
              function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId, toUnicode) {
                const newMap = /* @__PURE__ */ Object.create(null);
                const toUnicodeExtraMap = /* @__PURE__ */ new Map();
                const toFontChar = [];
                const usedGlyphIds = /* @__PURE__ */ new Set();
                let privateUseAreaIndex = 0;
                const privateUseOffetStart = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
                let nextAvailableFontCharCode = privateUseOffetStart;
                let privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
                const isInPrivateArea = (code) => PRIVATE_USE_AREAS[0][0] <= code && code <= PRIVATE_USE_AREAS[0][1] || PRIVATE_USE_AREAS[1][0] <= code && code <= PRIVATE_USE_AREAS[1][1];
                for (let originalCharCode in charCodeToGlyphId) {
                  originalCharCode |= 0;
                  let glyphId = charCodeToGlyphId[originalCharCode];
                  if (!hasGlyph(glyphId)) {
                    continue;
                  }
                  if (nextAvailableFontCharCode > privateUseOffetEnd) {
                    privateUseAreaIndex++;
                    if (privateUseAreaIndex >= PRIVATE_USE_AREAS.length) {
                      (0, _util.warn)("Ran out of space in font private use area.");
                      break;
                    }
                    nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
                    privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
                  }
                  const fontCharCode = nextAvailableFontCharCode++;
                  if (glyphId === 0) {
                    glyphId = newGlyphZeroId;
                  }
                  let unicode = toUnicode.get(originalCharCode);
                  if (typeof unicode === "string") {
                    unicode = unicode.codePointAt(0);
                  }
                  if (unicode && !isInPrivateArea(unicode) && !usedGlyphIds.has(glyphId)) {
                    toUnicodeExtraMap.set(unicode, glyphId);
                    usedGlyphIds.add(glyphId);
                  }
                  newMap[fontCharCode] = glyphId;
                  toFontChar[originalCharCode] = fontCharCode;
                }
                return {
                  toFontChar,
                  charCodeToGlyphId: newMap,
                  toUnicodeExtraMap,
                  nextAvailableFontCharCode
                };
              }
              function getRanges(glyphs, toUnicodeExtraMap, numGlyphs) {
                const codes = [];
                for (const charCode in glyphs) {
                  if (glyphs[charCode] >= numGlyphs) {
                    continue;
                  }
                  codes.push({
                    fontCharCode: charCode | 0,
                    glyphId: glyphs[charCode]
                  });
                }
                if (toUnicodeExtraMap) {
                  for (const [unicode, glyphId] of toUnicodeExtraMap) {
                    if (glyphId >= numGlyphs) {
                      continue;
                    }
                    codes.push({
                      fontCharCode: unicode,
                      glyphId
                    });
                  }
                }
                if (codes.length === 0) {
                  codes.push({
                    fontCharCode: 0,
                    glyphId: 0
                  });
                }
                codes.sort(function fontGetRangesSort(a, b) {
                  return a.fontCharCode - b.fontCharCode;
                });
                const ranges = [];
                const length = codes.length;
                for (let n = 0; n < length; ) {
                  const start = codes[n].fontCharCode;
                  const codeIndices = [codes[n].glyphId];
                  ++n;
                  let end = start;
                  while (n < length && end + 1 === codes[n].fontCharCode) {
                    codeIndices.push(codes[n].glyphId);
                    ++end;
                    ++n;
                    if (end === 65535) {
                      break;
                    }
                  }
                  ranges.push([start, end, codeIndices]);
                }
                return ranges;
              }
              function createCmapTable(glyphs, toUnicodeExtraMap, numGlyphs) {
                const ranges = getRanges(glyphs, toUnicodeExtraMap, numGlyphs);
                const numTables = ranges.at(-1)[1] > 65535 ? 2 : 1;
                let cmap = "\0\0" + string16(numTables) + "\0\0" + (0, _util.string32)(4 + numTables * 8);
                let i, ii, j, jj;
                for (i = ranges.length - 1; i >= 0; --i) {
                  if (ranges[i][0] <= 65535) {
                    break;
                  }
                }
                const bmpLength = i + 1;
                if (ranges[i][0] < 65535 && ranges[i][1] === 65535) {
                  ranges[i][1] = 65534;
                }
                const trailingRangesCount = ranges[i][1] < 65535 ? 1 : 0;
                const segCount = bmpLength + trailingRangesCount;
                const searchParams = _opentype_file_builder.OpenTypeFileBuilder.getSearchParams(segCount, 2);
                let startCount = "";
                let endCount = "";
                let idDeltas = "";
                let idRangeOffsets = "";
                let glyphsIds = "";
                let bias = 0;
                let range, start, end, codes;
                for (i = 0, ii = bmpLength; i < ii; i++) {
                  range = ranges[i];
                  start = range[0];
                  end = range[1];
                  startCount += string16(start);
                  endCount += string16(end);
                  codes = range[2];
                  let contiguous = true;
                  for (j = 1, jj = codes.length; j < jj; ++j) {
                    if (codes[j] !== codes[j - 1] + 1) {
                      contiguous = false;
                      break;
                    }
                  }
                  if (!contiguous) {
                    const offset = (segCount - i) * 2 + bias * 2;
                    bias += end - start + 1;
                    idDeltas += string16(0);
                    idRangeOffsets += string16(offset);
                    for (j = 0, jj = codes.length; j < jj; ++j) {
                      glyphsIds += string16(codes[j]);
                    }
                  } else {
                    const startCode = codes[0];
                    idDeltas += string16(startCode - start & 65535);
                    idRangeOffsets += string16(0);
                  }
                }
                if (trailingRangesCount > 0) {
                  endCount += "";
                  startCount += "";
                  idDeltas += "\0";
                  idRangeOffsets += "\0\0";
                }
                const format314 = "\0\0" + string16(2 * segCount) + string16(searchParams.range) + string16(searchParams.entry) + string16(searchParams.rangeShift) + endCount + "\0\0" + startCount + idDeltas + idRangeOffsets + glyphsIds;
                let format31012 = "";
                let header31012 = "";
                if (numTables > 1) {
                  cmap += "\0\0\n" + (0, _util.string32)(4 + numTables * 8 + 4 + format314.length);
                  format31012 = "";
                  for (i = 0, ii = ranges.length; i < ii; i++) {
                    range = ranges[i];
                    start = range[0];
                    codes = range[2];
                    let code = codes[0];
                    for (j = 1, jj = codes.length; j < jj; ++j) {
                      if (codes[j] !== codes[j - 1] + 1) {
                        end = range[0] + j - 1;
                        format31012 += (0, _util.string32)(start) + (0, _util.string32)(end) + (0, _util.string32)(code);
                        start = end + 1;
                        code = codes[j];
                      }
                    }
                    format31012 += (0, _util.string32)(start) + (0, _util.string32)(range[1]) + (0, _util.string32)(code);
                  }
                  header31012 = "\0\f\0\0" + (0, _util.string32)(format31012.length + 16) + "\0\0\0\0" + (0, _util.string32)(format31012.length / 12);
                }
                return cmap + "\0" + string16(format314.length + 4) + format314 + header31012 + format31012;
              }
              function validateOS2Table(os2, file) {
                file.pos = (file.start || 0) + os2.offset;
                const version = file.getUint16();
                file.skip(60);
                const selection = file.getUint16();
                if (version < 4 && selection & 768) {
                  return false;
                }
                const firstChar = file.getUint16();
                const lastChar = file.getUint16();
                if (firstChar > lastChar) {
                  return false;
                }
                file.skip(6);
                const usWinAscent = file.getUint16();
                if (usWinAscent === 0) {
                  return false;
                }
                os2.data[8] = os2.data[9] = 0;
                return true;
              }
              function createOS2Table(properties, charstrings, override) {
                override || (override = {
                  unitsPerEm: 0,
                  yMax: 0,
                  yMin: 0,
                  ascent: 0,
                  descent: 0
                });
                let ulUnicodeRange1 = 0;
                let ulUnicodeRange2 = 0;
                let ulUnicodeRange3 = 0;
                let ulUnicodeRange4 = 0;
                let firstCharIndex = null;
                let lastCharIndex = 0;
                let position = -1;
                if (charstrings) {
                  for (let code in charstrings) {
                    code |= 0;
                    if (firstCharIndex > code || !firstCharIndex) {
                      firstCharIndex = code;
                    }
                    if (lastCharIndex < code) {
                      lastCharIndex = code;
                    }
                    position = (0, _unicode.getUnicodeRangeFor)(code, position);
                    if (position < 32) {
                      ulUnicodeRange1 |= 1 << position;
                    } else if (position < 64) {
                      ulUnicodeRange2 |= 1 << position - 32;
                    } else if (position < 96) {
                      ulUnicodeRange3 |= 1 << position - 64;
                    } else if (position < 123) {
                      ulUnicodeRange4 |= 1 << position - 96;
                    } else {
                      throw new _util.FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
                    }
                  }
                  if (lastCharIndex > 65535) {
                    lastCharIndex = 65535;
                  }
                } else {
                  firstCharIndex = 0;
                  lastCharIndex = 255;
                }
                const bbox = properties.bbox || [0, 0, 0, 0];
                const unitsPerEm = override.unitsPerEm || 1 / (properties.fontMatrix || _util.FONT_IDENTITY_MATRIX)[0];
                const scale = properties.ascentScaled ? 1 : unitsPerEm / PDF_GLYPH_SPACE_UNITS;
                const typoAscent = override.ascent || Math.round(scale * (properties.ascent || bbox[3]));
                let typoDescent = override.descent || Math.round(scale * (properties.descent || bbox[1]));
                if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
                  typoDescent = -typoDescent;
                }
                const winAscent = override.yMax || typoAscent;
                const winDescent = -override.yMin || -typoDescent;
                return "\0$\0\0\0\0\0\0\0\0\x001\0\0\0\0" + String.fromCharCode(properties.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + (0, _util.string32)(ulUnicodeRange1) + (0, _util.string32)(ulUnicodeRange2) + (0, _util.string32)(ulUnicodeRange3) + (0, _util.string32)(ulUnicodeRange4) + "*21*" + string16(properties.italicAngle ? 1 : 0) + string16(firstCharIndex || properties.firstChar) + string16(lastCharIndex || properties.lastChar) + string16(typoAscent) + string16(typoDescent) + "\0d" + string16(winAscent) + string16(winDescent) + "\0\0\0\0\0\0\0\0" + string16(properties.xHeight) + string16(properties.capHeight) + string16(0) + string16(firstCharIndex || properties.firstChar) + "\0";
              }
              function createPostTable(properties) {
                const angle = Math.floor(properties.italicAngle * 2 ** 16);
                return "\0\0\0" + (0, _util.string32)(angle) + "\0\0\0\0" + (0, _util.string32)(properties.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
              }
              function createPostscriptName(name) {
                return name.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
              }
              function createNameTable(name, proto) {
                if (!proto) {
                  proto = [[], []];
                }
                const strings = [proto[0][0] || "Original licence", proto[0][1] || name, proto[0][2] || "Unknown", proto[0][3] || "uniqueID", proto[0][4] || name, proto[0][5] || "Version 0.11", proto[0][6] || createPostscriptName(name), proto[0][7] || "Unknown", proto[0][8] || "Unknown", proto[0][9] || "Unknown"];
                const stringsUnicode = [];
                let i, ii, j, jj, str;
                for (i = 0, ii = strings.length; i < ii; i++) {
                  str = proto[1][i] || strings[i];
                  const strBufUnicode = [];
                  for (j = 0, jj = str.length; j < jj; j++) {
                    strBufUnicode.push(string16(str.charCodeAt(j)));
                  }
                  stringsUnicode.push(strBufUnicode.join(""));
                }
                const names = [strings, stringsUnicode];
                const platforms = ["\0", "\0"];
                const encodings = ["\0\0", "\0"];
                const languages = ["\0\0", "	"];
                const namesRecordCount = strings.length * platforms.length;
                let nameTable = "\0\0" + string16(namesRecordCount) + string16(namesRecordCount * 12 + 6);
                let strOffset = 0;
                for (i = 0, ii = platforms.length; i < ii; i++) {
                  const strs = names[i];
                  for (j = 0, jj = strs.length; j < jj; j++) {
                    str = strs[j];
                    const nameRecord = platforms[i] + encodings[i] + languages[i] + string16(j) + string16(str.length) + string16(strOffset);
                    nameTable += nameRecord;
                    strOffset += str.length;
                  }
                }
                nameTable += strings.join("") + stringsUnicode.join("");
                return nameTable;
              }
              class Font {
                constructor(name, file, properties) {
                  var _a;
                  this.name = name;
                  this.psName = null;
                  this.mimetype = null;
                  this.disableFontFace = false;
                  this.loadedName = properties.loadedName;
                  this.isType3Font = properties.isType3Font;
                  this.missingFile = false;
                  this.cssFontInfo = properties.cssFontInfo;
                  this._charsCache = /* @__PURE__ */ Object.create(null);
                  this._glyphCache = /* @__PURE__ */ Object.create(null);
                  let isSerifFont = !!(properties.flags & _fonts_utils.FontFlags.Serif);
                  if (!isSerifFont && !properties.isSimulatedFlags) {
                    const baseName = name.replaceAll(/[,_]/g, "-").split("-")[0], serifFonts = (0, _standard_fonts.getSerifFonts)();
                    for (const namePart of baseName.split("+")) {
                      if (serifFonts[namePart]) {
                        isSerifFont = true;
                        break;
                      }
                    }
                  }
                  this.isSerifFont = isSerifFont;
                  this.isSymbolicFont = !!(properties.flags & _fonts_utils.FontFlags.Symbolic);
                  this.isMonospace = !!(properties.flags & _fonts_utils.FontFlags.FixedPitch);
                  let {
                    type,
                    subtype
                  } = properties;
                  this.type = type;
                  this.subtype = subtype;
                  this.systemFontInfo = properties.systemFontInfo;
                  const matches = name.match(/^InvalidPDFjsFont_(.*)_\d+$/);
                  this.isInvalidPDFjsFont = !!matches;
                  if (this.isInvalidPDFjsFont) {
                    this.fallbackName = matches[1];
                  } else if (this.isMonospace) {
                    this.fallbackName = "monospace";
                  } else if (this.isSerifFont) {
                    this.fallbackName = "serif";
                  } else {
                    this.fallbackName = "sans-serif";
                  }
                  if ((_a = this.systemFontInfo) == null ? void 0 : _a.guessFallback) {
                    this.systemFontInfo.guessFallback = false;
                    this.systemFontInfo.css += `,${this.fallbackName}`;
                  }
                  this.differences = properties.differences;
                  this.widths = properties.widths;
                  this.defaultWidth = properties.defaultWidth;
                  this.composite = properties.composite;
                  this.cMap = properties.cMap;
                  this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS;
                  this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
                  this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
                  this.lineHeight = this.ascent - this.descent;
                  this.fontMatrix = properties.fontMatrix;
                  this.bbox = properties.bbox;
                  this.defaultEncoding = properties.defaultEncoding;
                  this.toUnicode = properties.toUnicode;
                  this.toFontChar = [];
                  if (properties.type === "Type3") {
                    for (let charCode = 0; charCode < 256; charCode++) {
                      this.toFontChar[charCode] = this.differences[charCode] || properties.defaultEncoding[charCode];
                    }
                    return;
                  }
                  this.cidEncoding = properties.cidEncoding || "";
                  this.vertical = !!properties.vertical;
                  if (this.vertical) {
                    this.vmetrics = properties.vmetrics;
                    this.defaultVMetrics = properties.defaultVMetrics;
                  }
                  if (!file || file.isEmpty) {
                    if (file) {
                      (0, _util.warn)('Font file is empty in "' + name + '" (' + this.loadedName + ")");
                    }
                    this.fallbackToSystemFont(properties);
                    return;
                  }
                  [type, subtype] = getFontFileType(file, properties);
                  if (type !== this.type || subtype !== this.subtype) {
                    (0, _util.info)(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${type}/${subtype}.`);
                  }
                  let data;
                  try {
                    switch (type) {
                      case "MMType1":
                        (0, _util.info)("MMType1 font (" + name + "), falling back to Type1.");
                      case "Type1":
                      case "CIDFontType0":
                        this.mimetype = "font/opentype";
                        const cff = subtype === "Type1C" || subtype === "CIDFontType0C" ? new _cff_font.CFFFont(file, properties) : new _type1_font.Type1Font(name, file, properties);
                        adjustWidths(properties);
                        data = this.convert(name, cff, properties);
                        break;
                      case "OpenType":
                      case "TrueType":
                      case "CIDFontType2":
                        this.mimetype = "font/opentype";
                        data = this.checkAndRepair(name, file, properties);
                        if (this.isOpenType) {
                          adjustWidths(properties);
                          type = "OpenType";
                        }
                        break;
                      default:
                        throw new _util.FormatError(`Font ${type} is not supported`);
                    }
                  } catch (e) {
                    (0, _util.warn)(e);
                    this.fallbackToSystemFont(properties);
                    return;
                  }
                  amendFallbackToUnicode(properties);
                  this.data = data;
                  this.type = type;
                  this.subtype = subtype;
                  this.fontMatrix = properties.fontMatrix;
                  this.widths = properties.widths;
                  this.defaultWidth = properties.defaultWidth;
                  this.toUnicode = properties.toUnicode;
                  this.seacMap = properties.seacMap;
                }
                get renderer() {
                  const renderer = _font_renderer.FontRendererFactory.create(this, _fonts_utils.SEAC_ANALYSIS_ENABLED);
                  return (0, _util.shadow)(this, "renderer", renderer);
                }
                exportData(extraProperties = false) {
                  const exportDataProperties = extraProperties ? [...EXPORT_DATA_PROPERTIES, ...EXPORT_DATA_EXTRA_PROPERTIES] : EXPORT_DATA_PROPERTIES;
                  const data = /* @__PURE__ */ Object.create(null);
                  let property, value;
                  for (property of exportDataProperties) {
                    value = this[property];
                    if (value !== void 0) {
                      data[property] = value;
                    }
                  }
                  return data;
                }
                fallbackToSystemFont(properties) {
                  this.missingFile = true;
                  const {
                    name,
                    type
                  } = this;
                  let fontName = (0, _fonts_utils.normalizeFontName)(name);
                  const stdFontMap = (0, _standard_fonts.getStdFontMap)(), nonStdFontMap = (0, _standard_fonts.getNonStdFontMap)();
                  const isStandardFont = !!stdFontMap[fontName];
                  const isMappedToStandardFont = !!(nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]);
                  fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;
                  const fontBasicMetricsMap = (0, _metrics.getFontBasicMetrics)();
                  const metrics = fontBasicMetricsMap[fontName];
                  if (metrics) {
                    if (isNaN(this.ascent)) {
                      this.ascent = metrics.ascent / PDF_GLYPH_SPACE_UNITS;
                    }
                    if (isNaN(this.descent)) {
                      this.descent = metrics.descent / PDF_GLYPH_SPACE_UNITS;
                    }
                    if (isNaN(this.capHeight)) {
                      this.capHeight = metrics.capHeight / PDF_GLYPH_SPACE_UNITS;
                    }
                  }
                  this.bold = /bold/gi.test(fontName);
                  this.italic = /oblique|italic/gi.test(fontName);
                  this.black = /Black/g.test(name);
                  const isNarrow = /Narrow/g.test(name);
                  this.remeasure = (!isStandardFont || isNarrow) && Object.keys(this.widths).length > 0;
                  if ((isStandardFont || isMappedToStandardFont) && type === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
                    const cidToGidMap = properties.cidToGidMap;
                    const map = [];
                    applyStandardFontGlyphMap(map, (0, _standard_fonts.getGlyphMapForStandardFonts)());
                    if (/Arial-?Black/i.test(name)) {
                      applyStandardFontGlyphMap(map, (0, _standard_fonts.getSupplementalGlyphMapForArialBlack)());
                    } else if (/Calibri/i.test(name)) {
                      applyStandardFontGlyphMap(map, (0, _standard_fonts.getSupplementalGlyphMapForCalibri)());
                    }
                    if (cidToGidMap) {
                      for (const charCode in map) {
                        const cid = map[charCode];
                        if (cidToGidMap[cid] !== void 0) {
                          map[+charCode] = cidToGidMap[cid];
                        }
                      }
                      if (cidToGidMap.length !== this.toUnicode.length && properties.hasIncludedToUnicodeMap && this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
                        this.toUnicode.forEach(function(charCode, unicodeCharCode) {
                          const cid = map[charCode];
                          if (cidToGidMap[cid] === void 0) {
                            map[+charCode] = unicodeCharCode;
                          }
                        });
                      }
                    }
                    if (!(this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap)) {
                      this.toUnicode.forEach(function(charCode, unicodeCharCode) {
                        map[+charCode] = unicodeCharCode;
                      });
                    }
                    this.toFontChar = map;
                    this.toUnicode = new _to_unicode_map.ToUnicodeMap(map);
                  } else if (/Symbol/i.test(fontName)) {
                    this.toFontChar = buildToFontChar(_encodings.SymbolSetEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
                  } else if (/Dingbats/i.test(fontName)) {
                    this.toFontChar = buildToFontChar(_encodings.ZapfDingbatsEncoding, (0, _glyphlist.getDingbatsGlyphsUnicode)(), this.differences);
                  } else if (isStandardFont) {
                    const map = buildToFontChar(this.defaultEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
                    if (type === "CIDFontType2" && !this.cidEncoding.startsWith("Identity-") && !(this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap)) {
                      this.toUnicode.forEach(function(charCode, unicodeCharCode) {
                        map[+charCode] = unicodeCharCode;
                      });
                    }
                    this.toFontChar = map;
                  } else {
                    const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                    const map = [];
                    this.toUnicode.forEach((charCode, unicodeCharCode) => {
                      if (!this.composite) {
                        const glyphName = this.differences[charCode] || this.defaultEncoding[charCode];
                        const unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
                        if (unicode !== -1) {
                          unicodeCharCode = unicode;
                        }
                      }
                      map[+charCode] = unicodeCharCode;
                    });
                    if (this.composite && this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
                      if (/Tahoma|Verdana/i.test(name)) {
                        applyStandardFontGlyphMap(map, (0, _standard_fonts.getGlyphMapForStandardFonts)());
                      }
                    }
                    this.toFontChar = map;
                  }
                  amendFallbackToUnicode(properties);
                  this.loadedName = fontName.split("-")[0];
                }
                checkAndRepair(name, font, properties) {
                  var _a, _b, _c;
                  const VALID_TABLES = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
                  function readTables(file, numTables) {
                    const tables2 = /* @__PURE__ */ Object.create(null);
                    tables2["OS/2"] = null;
                    tables2.cmap = null;
                    tables2.head = null;
                    tables2.hhea = null;
                    tables2.hmtx = null;
                    tables2.maxp = null;
                    tables2.name = null;
                    tables2.post = null;
                    for (let i = 0; i < numTables; i++) {
                      const table = readTableEntry(file);
                      if (!VALID_TABLES.includes(table.tag)) {
                        continue;
                      }
                      if (table.length === 0) {
                        continue;
                      }
                      tables2[table.tag] = table;
                    }
                    return tables2;
                  }
                  function readTableEntry(file) {
                    const tag = file.getString(4);
                    const checksum = file.getInt32() >>> 0;
                    const offset = file.getInt32() >>> 0;
                    const length = file.getInt32() >>> 0;
                    const previousPosition = file.pos;
                    file.pos = file.start || 0;
                    file.skip(offset);
                    const data = file.getBytes(length);
                    file.pos = previousPosition;
                    if (tag === "head") {
                      data[8] = data[9] = data[10] = data[11] = 0;
                      data[17] |= 32;
                    }
                    return {
                      tag,
                      checksum,
                      length,
                      offset,
                      data
                    };
                  }
                  function readOpenTypeHeader(ttf) {
                    return {
                      version: ttf.getString(4),
                      numTables: ttf.getUint16(),
                      searchRange: ttf.getUint16(),
                      entrySelector: ttf.getUint16(),
                      rangeShift: ttf.getUint16()
                    };
                  }
                  function readTrueTypeCollectionHeader(ttc) {
                    const ttcTag = ttc.getString(4);
                    (0, _util.assert)(ttcTag === "ttcf", "Must be a TrueType Collection font.");
                    const majorVersion = ttc.getUint16();
                    const minorVersion = ttc.getUint16();
                    const numFonts = ttc.getInt32() >>> 0;
                    const offsetTable = [];
                    for (let i = 0; i < numFonts; i++) {
                      offsetTable.push(ttc.getInt32() >>> 0);
                    }
                    const header2 = {
                      ttcTag,
                      majorVersion,
                      minorVersion,
                      numFonts,
                      offsetTable
                    };
                    switch (majorVersion) {
                      case 1:
                        return header2;
                      case 2:
                        header2.dsigTag = ttc.getInt32() >>> 0;
                        header2.dsigLength = ttc.getInt32() >>> 0;
                        header2.dsigOffset = ttc.getInt32() >>> 0;
                        return header2;
                    }
                    throw new _util.FormatError(`Invalid TrueType Collection majorVersion: ${majorVersion}.`);
                  }
                  function readTrueTypeCollectionData(ttc, fontName) {
                    var _a2;
                    const {
                      numFonts,
                      offsetTable
                    } = readTrueTypeCollectionHeader(ttc);
                    const fontNameParts = fontName.split("+");
                    let fallbackData;
                    for (let i = 0; i < numFonts; i++) {
                      ttc.pos = (ttc.start || 0) + offsetTable[i];
                      const potentialHeader = readOpenTypeHeader(ttc);
                      const potentialTables = readTables(ttc, potentialHeader.numTables);
                      if (!potentialTables.name) {
                        throw new _util.FormatError('TrueType Collection font must contain a "name" table.');
                      }
                      const [nameTable] = readNameTable(potentialTables.name);
                      for (let j = 0, jj = nameTable.length; j < jj; j++) {
                        for (let k = 0, kk = nameTable[j].length; k < kk; k++) {
                          const nameEntry = (_a2 = nameTable[j][k]) == null ? void 0 : _a2.replaceAll(/\s/g, "");
                          if (!nameEntry) {
                            continue;
                          }
                          if (nameEntry === fontName) {
                            return {
                              header: potentialHeader,
                              tables: potentialTables
                            };
                          }
                          if (fontNameParts.length < 2) {
                            continue;
                          }
                          for (const part of fontNameParts) {
                            if (nameEntry === part) {
                              fallbackData = {
                                name: part,
                                header: potentialHeader,
                                tables: potentialTables
                              };
                            }
                          }
                        }
                      }
                    }
                    if (fallbackData) {
                      (0, _util.warn)(`TrueType Collection does not contain "${fontName}" font, falling back to "${fallbackData.name}" font instead.`);
                      return {
                        header: fallbackData.header,
                        tables: fallbackData.tables
                      };
                    }
                    throw new _util.FormatError(`TrueType Collection does not contain "${fontName}" font.`);
                  }
                  function readCmapTable(cmap, file, isSymbolicFont, hasEncoding) {
                    if (!cmap) {
                      (0, _util.warn)("No cmap table available.");
                      return {
                        platformId: -1,
                        encodingId: -1,
                        mappings: [],
                        hasShortCmap: false
                      };
                    }
                    let segment;
                    let start = (file.start || 0) + cmap.offset;
                    file.pos = start;
                    file.skip(2);
                    const numTables = file.getUint16();
                    let potentialTable;
                    let canBreak = false;
                    for (let i = 0; i < numTables; i++) {
                      const platformId = file.getUint16();
                      const encodingId = file.getUint16();
                      const offset = file.getInt32() >>> 0;
                      let useTable = false;
                      if ((potentialTable == null ? void 0 : potentialTable.platformId) === platformId && (potentialTable == null ? void 0 : potentialTable.encodingId) === encodingId) {
                        continue;
                      }
                      if (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 3)) {
                        useTable = true;
                      } else if (platformId === 1 && encodingId === 0) {
                        useTable = true;
                      } else if (platformId === 3 && encodingId === 1 && (hasEncoding || !potentialTable)) {
                        useTable = true;
                        if (!isSymbolicFont) {
                          canBreak = true;
                        }
                      } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
                        useTable = true;
                        let correctlySorted = true;
                        if (i < numTables - 1) {
                          const nextBytes = file.peekBytes(2), nextPlatformId = int16(nextBytes[0], nextBytes[1]);
                          if (nextPlatformId < platformId) {
                            correctlySorted = false;
                          }
                        }
                        if (correctlySorted) {
                          canBreak = true;
                        }
                      }
                      if (useTable) {
                        potentialTable = {
                          platformId,
                          encodingId,
                          offset
                        };
                      }
                      if (canBreak) {
                        break;
                      }
                    }
                    if (potentialTable) {
                      file.pos = start + potentialTable.offset;
                    }
                    if (!potentialTable || file.peekByte() === -1) {
                      (0, _util.warn)("Could not find a preferred cmap table.");
                      return {
                        platformId: -1,
                        encodingId: -1,
                        mappings: [],
                        hasShortCmap: false
                      };
                    }
                    const format = file.getUint16();
                    let hasShortCmap = false;
                    const mappings = [];
                    let j, glyphId;
                    if (format === 0) {
                      file.skip(2 + 2);
                      for (j = 0; j < 256; j++) {
                        const index = file.getByte();
                        if (!index) {
                          continue;
                        }
                        mappings.push({
                          charCode: j,
                          glyphId: index
                        });
                      }
                      hasShortCmap = true;
                    } else if (format === 2) {
                      file.skip(2 + 2);
                      const subHeaderKeys = [];
                      let maxSubHeaderKey = 0;
                      for (let i = 0; i < 256; i++) {
                        const subHeaderKey = file.getUint16() >> 3;
                        subHeaderKeys.push(subHeaderKey);
                        maxSubHeaderKey = Math.max(subHeaderKey, maxSubHeaderKey);
                      }
                      const subHeaders = [];
                      for (let i = 0; i <= maxSubHeaderKey; i++) {
                        subHeaders.push({
                          firstCode: file.getUint16(),
                          entryCount: file.getUint16(),
                          idDelta: signedInt16(file.getByte(), file.getByte()),
                          idRangePos: file.pos + file.getUint16()
                        });
                      }
                      for (let i = 0; i < 256; i++) {
                        if (subHeaderKeys[i] === 0) {
                          file.pos = subHeaders[0].idRangePos + 2 * i;
                          glyphId = file.getUint16();
                          mappings.push({
                            charCode: i,
                            glyphId
                          });
                        } else {
                          const s = subHeaders[subHeaderKeys[i]];
                          for (j = 0; j < s.entryCount; j++) {
                            const charCode = (i << 8) + j + s.firstCode;
                            file.pos = s.idRangePos + 2 * j;
                            glyphId = file.getUint16();
                            if (glyphId !== 0) {
                              glyphId = (glyphId + s.idDelta) % 65536;
                            }
                            mappings.push({
                              charCode,
                              glyphId
                            });
                          }
                        }
                      }
                    } else if (format === 4) {
                      file.skip(2 + 2);
                      const segCount = file.getUint16() >> 1;
                      file.skip(6);
                      const segments = [];
                      let segIndex;
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segments.push({
                          end: file.getUint16()
                        });
                      }
                      file.skip(2);
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segments[segIndex].start = file.getUint16();
                      }
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segments[segIndex].delta = file.getUint16();
                      }
                      let offsetsCount = 0, offsetIndex;
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segment = segments[segIndex];
                        const rangeOffset = file.getUint16();
                        if (!rangeOffset) {
                          segment.offsetIndex = -1;
                          continue;
                        }
                        offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
                        segment.offsetIndex = offsetIndex;
                        offsetsCount = Math.max(offsetsCount, offsetIndex + segment.end - segment.start + 1);
                      }
                      const offsets = [];
                      for (j = 0; j < offsetsCount; j++) {
                        offsets.push(file.getUint16());
                      }
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segment = segments[segIndex];
                        start = segment.start;
                        const end = segment.end;
                        const delta = segment.delta;
                        offsetIndex = segment.offsetIndex;
                        for (j = start; j <= end; j++) {
                          if (j === 65535) {
                            continue;
                          }
                          glyphId = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];
                          glyphId = glyphId + delta & 65535;
                          mappings.push({
                            charCode: j,
                            glyphId
                          });
                        }
                      }
                    } else if (format === 6) {
                      file.skip(2 + 2);
                      const firstCode = file.getUint16();
                      const entryCount = file.getUint16();
                      for (j = 0; j < entryCount; j++) {
                        glyphId = file.getUint16();
                        const charCode = firstCode + j;
                        mappings.push({
                          charCode,
                          glyphId
                        });
                      }
                    } else if (format === 12) {
                      file.skip(2 + 4 + 4);
                      const nGroups = file.getInt32() >>> 0;
                      for (j = 0; j < nGroups; j++) {
                        const startCharCode = file.getInt32() >>> 0;
                        const endCharCode = file.getInt32() >>> 0;
                        let glyphCode = file.getInt32() >>> 0;
                        for (let charCode = startCharCode; charCode <= endCharCode; charCode++) {
                          mappings.push({
                            charCode,
                            glyphId: glyphCode++
                          });
                        }
                      }
                    } else {
                      (0, _util.warn)("cmap table has unsupported format: " + format);
                      return {
                        platformId: -1,
                        encodingId: -1,
                        mappings: [],
                        hasShortCmap: false
                      };
                    }
                    mappings.sort(function(a, b) {
                      return a.charCode - b.charCode;
                    });
                    for (let i = 1; i < mappings.length; i++) {
                      if (mappings[i - 1].charCode === mappings[i].charCode) {
                        mappings.splice(i, 1);
                        i--;
                      }
                    }
                    return {
                      platformId: potentialTable.platformId,
                      encodingId: potentialTable.encodingId,
                      mappings,
                      hasShortCmap
                    };
                  }
                  function sanitizeMetrics(file, header2, metrics, headTable, numGlyphs2, dupFirstEntry2) {
                    if (!header2) {
                      if (metrics) {
                        metrics.data = null;
                      }
                      return;
                    }
                    file.pos = (file.start || 0) + header2.offset;
                    file.pos += 4;
                    file.pos += 2;
                    file.pos += 2;
                    file.pos += 2;
                    file.pos += 2;
                    file.pos += 2;
                    file.pos += 2;
                    file.pos += 2;
                    file.pos += 2;
                    file.pos += 2;
                    const caretOffset = file.getUint16();
                    file.pos += 8;
                    file.pos += 2;
                    let numOfMetrics = file.getUint16();
                    if (caretOffset !== 0) {
                      const macStyle = int16(headTable.data[44], headTable.data[45]);
                      if (!(macStyle & 2)) {
                        header2.data[22] = 0;
                        header2.data[23] = 0;
                      }
                    }
                    if (numOfMetrics > numGlyphs2) {
                      (0, _util.info)(`The numOfMetrics (${numOfMetrics}) should not be greater than the numGlyphs (${numGlyphs2}).`);
                      numOfMetrics = numGlyphs2;
                      header2.data[34] = (numOfMetrics & 65280) >> 8;
                      header2.data[35] = numOfMetrics & 255;
                    }
                    const numOfSidebearings = numGlyphs2 - numOfMetrics;
                    const numMissing = numOfSidebearings - (metrics.length - numOfMetrics * 4 >> 1);
                    if (numMissing > 0) {
                      const entries = new Uint8Array(metrics.length + numMissing * 2);
                      entries.set(metrics.data);
                      if (dupFirstEntry2) {
                        entries[metrics.length] = metrics.data[2];
                        entries[metrics.length + 1] = metrics.data[3];
                      }
                      metrics.data = entries;
                    }
                  }
                  function sanitizeGlyph(source, sourceStart, sourceEnd, dest, destStart, hintsValid2) {
                    const glyphProfile = {
                      length: 0,
                      sizeOfInstructions: 0
                    };
                    if (sourceStart < 0 || sourceStart >= source.length || sourceEnd > source.length || sourceEnd - sourceStart <= 12) {
                      return glyphProfile;
                    }
                    const glyf = source.subarray(sourceStart, sourceEnd);
                    const xMin = signedInt16(glyf[2], glyf[3]);
                    const yMin = signedInt16(glyf[4], glyf[5]);
                    const xMax = signedInt16(glyf[6], glyf[7]);
                    const yMax = signedInt16(glyf[8], glyf[9]);
                    if (xMin > xMax) {
                      writeSignedInt16(glyf, 2, xMax);
                      writeSignedInt16(glyf, 6, xMin);
                    }
                    if (yMin > yMax) {
                      writeSignedInt16(glyf, 4, yMax);
                      writeSignedInt16(glyf, 8, yMin);
                    }
                    const contoursCount = signedInt16(glyf[0], glyf[1]);
                    if (contoursCount < 0) {
                      if (contoursCount < -1) {
                        return glyphProfile;
                      }
                      dest.set(glyf, destStart);
                      glyphProfile.length = glyf.length;
                      return glyphProfile;
                    }
                    let i, j = 10, flagsCount = 0;
                    for (i = 0; i < contoursCount; i++) {
                      const endPoint = glyf[j] << 8 | glyf[j + 1];
                      flagsCount = endPoint + 1;
                      j += 2;
                    }
                    const instructionsStart = j;
                    const instructionsLength = glyf[j] << 8 | glyf[j + 1];
                    glyphProfile.sizeOfInstructions = instructionsLength;
                    j += 2 + instructionsLength;
                    const instructionsEnd = j;
                    let coordinatesLength = 0;
                    for (i = 0; i < flagsCount; i++) {
                      const flag = glyf[j++];
                      if (flag & 192) {
                        glyf[j - 1] = flag & 63;
                      }
                      let xLength = 2;
                      if (flag & 2) {
                        xLength = 1;
                      } else if (flag & 16) {
                        xLength = 0;
                      }
                      let yLength = 2;
                      if (flag & 4) {
                        yLength = 1;
                      } else if (flag & 32) {
                        yLength = 0;
                      }
                      const xyLength = xLength + yLength;
                      coordinatesLength += xyLength;
                      if (flag & 8) {
                        const repeat = glyf[j++];
                        if (repeat === 0) {
                          glyf[j - 1] ^= 8;
                        }
                        i += repeat;
                        coordinatesLength += repeat * xyLength;
                      }
                    }
                    if (coordinatesLength === 0) {
                      return glyphProfile;
                    }
                    let glyphDataLength = j + coordinatesLength;
                    if (glyphDataLength > glyf.length) {
                      return glyphProfile;
                    }
                    if (!hintsValid2 && instructionsLength > 0) {
                      dest.set(glyf.subarray(0, instructionsStart), destStart);
                      dest.set([0, 0], destStart + instructionsStart);
                      dest.set(glyf.subarray(instructionsEnd, glyphDataLength), destStart + instructionsStart + 2);
                      glyphDataLength -= instructionsLength;
                      if (glyf.length - glyphDataLength > 3) {
                        glyphDataLength = glyphDataLength + 3 & ~3;
                      }
                      glyphProfile.length = glyphDataLength;
                      return glyphProfile;
                    }
                    if (glyf.length - glyphDataLength > 3) {
                      glyphDataLength = glyphDataLength + 3 & ~3;
                      dest.set(glyf.subarray(0, glyphDataLength), destStart);
                      glyphProfile.length = glyphDataLength;
                      return glyphProfile;
                    }
                    dest.set(glyf, destStart);
                    glyphProfile.length = glyf.length;
                    return glyphProfile;
                  }
                  function sanitizeHead(head, numGlyphs2, locaLength) {
                    const data = head.data;
                    const version2 = int32(data[0], data[1], data[2], data[3]);
                    if (version2 >> 16 !== 1) {
                      (0, _util.info)("Attempting to fix invalid version in head table: " + version2);
                      data[0] = 0;
                      data[1] = 1;
                      data[2] = 0;
                      data[3] = 0;
                    }
                    const indexToLocFormat = int16(data[50], data[51]);
                    if (indexToLocFormat < 0 || indexToLocFormat > 1) {
                      (0, _util.info)("Attempting to fix invalid indexToLocFormat in head table: " + indexToLocFormat);
                      const numGlyphsPlusOne = numGlyphs2 + 1;
                      if (locaLength === numGlyphsPlusOne << 1) {
                        data[50] = 0;
                        data[51] = 0;
                      } else if (locaLength === numGlyphsPlusOne << 2) {
                        data[50] = 0;
                        data[51] = 1;
                      } else {
                        throw new _util.FormatError("Could not fix indexToLocFormat: " + indexToLocFormat);
                      }
                    }
                  }
                  function sanitizeGlyphLocations(loca, glyf, numGlyphs2, isGlyphLocationsLong, hintsValid2, dupFirstEntry2, maxSizeOfInstructions2) {
                    let itemSize, itemDecode, itemEncode;
                    if (isGlyphLocationsLong) {
                      itemSize = 4;
                      itemDecode = function fontItemDecodeLong(data, offset) {
                        return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
                      };
                      itemEncode = function fontItemEncodeLong(data, offset, value) {
                        data[offset] = value >>> 24 & 255;
                        data[offset + 1] = value >> 16 & 255;
                        data[offset + 2] = value >> 8 & 255;
                        data[offset + 3] = value & 255;
                      };
                    } else {
                      itemSize = 2;
                      itemDecode = function fontItemDecode(data, offset) {
                        return data[offset] << 9 | data[offset + 1] << 1;
                      };
                      itemEncode = function fontItemEncode(data, offset, value) {
                        data[offset] = value >> 9 & 255;
                        data[offset + 1] = value >> 1 & 255;
                      };
                    }
                    const numGlyphsOut2 = dupFirstEntry2 ? numGlyphs2 + 1 : numGlyphs2;
                    const locaDataSize = itemSize * (1 + numGlyphsOut2);
                    const locaData = new Uint8Array(locaDataSize);
                    locaData.set(loca.data.subarray(0, locaDataSize));
                    loca.data = locaData;
                    const oldGlyfData = glyf.data;
                    const oldGlyfDataLength = oldGlyfData.length;
                    const newGlyfData = new Uint8Array(oldGlyfDataLength);
                    let i, j;
                    const locaEntries = [];
                    for (i = 0, j = 0; i < numGlyphs2 + 1; i++, j += itemSize) {
                      let offset = itemDecode(locaData, j);
                      if (offset > oldGlyfDataLength) {
                        offset = oldGlyfDataLength;
                      }
                      locaEntries.push({
                        index: i,
                        offset,
                        endOffset: 0
                      });
                    }
                    locaEntries.sort((a, b) => {
                      return a.offset - b.offset;
                    });
                    for (i = 0; i < numGlyphs2; i++) {
                      locaEntries[i].endOffset = locaEntries[i + 1].offset;
                    }
                    locaEntries.sort((a, b) => {
                      return a.index - b.index;
                    });
                    for (i = 0; i < numGlyphs2; i++) {
                      const {
                        offset,
                        endOffset
                      } = locaEntries[i];
                      if (offset !== 0 || endOffset !== 0) {
                        break;
                      }
                      const nextOffset = locaEntries[i + 1].offset;
                      if (nextOffset === 0) {
                        continue;
                      }
                      locaEntries[i].endOffset = nextOffset;
                      break;
                    }
                    const missingGlyphs2 = /* @__PURE__ */ Object.create(null);
                    let writeOffset = 0;
                    itemEncode(locaData, 0, writeOffset);
                    for (i = 0, j = itemSize; i < numGlyphs2; i++, j += itemSize) {
                      const glyphProfile = sanitizeGlyph(oldGlyfData, locaEntries[i].offset, locaEntries[i].endOffset, newGlyfData, writeOffset, hintsValid2);
                      const newLength = glyphProfile.length;
                      if (newLength === 0) {
                        missingGlyphs2[i] = true;
                      }
                      if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions2) {
                        maxSizeOfInstructions2 = glyphProfile.sizeOfInstructions;
                      }
                      writeOffset += newLength;
                      itemEncode(locaData, j, writeOffset);
                    }
                    if (writeOffset === 0) {
                      const simpleGlyph = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
                      for (i = 0, j = itemSize; i < numGlyphsOut2; i++, j += itemSize) {
                        itemEncode(locaData, j, simpleGlyph.length);
                      }
                      glyf.data = simpleGlyph;
                    } else if (dupFirstEntry2) {
                      const firstEntryLength = itemDecode(locaData, itemSize);
                      if (newGlyfData.length > firstEntryLength + writeOffset) {
                        glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
                      } else {
                        glyf.data = new Uint8Array(firstEntryLength + writeOffset);
                        glyf.data.set(newGlyfData.subarray(0, writeOffset));
                      }
                      glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
                      itemEncode(loca.data, locaData.length - itemSize, writeOffset + firstEntryLength);
                    } else {
                      glyf.data = newGlyfData.subarray(0, writeOffset);
                    }
                    return {
                      missingGlyphs: missingGlyphs2,
                      maxSizeOfInstructions: maxSizeOfInstructions2
                    };
                  }
                  function readPostScriptTable(post, propertiesObj, maxpNumGlyphs) {
                    const start = (font.start || 0) + post.offset;
                    font.pos = start;
                    const length = post.length, end = start + length;
                    const version2 = font.getInt32();
                    font.skip(28);
                    let glyphNames;
                    let valid = true;
                    let i;
                    switch (version2) {
                      case 65536:
                        glyphNames = _fonts_utils.MacStandardGlyphOrdering;
                        break;
                      case 131072:
                        const numGlyphs2 = font.getUint16();
                        if (numGlyphs2 !== maxpNumGlyphs) {
                          valid = false;
                          break;
                        }
                        const glyphNameIndexes = [];
                        for (i = 0; i < numGlyphs2; ++i) {
                          const index = font.getUint16();
                          if (index >= 32768) {
                            valid = false;
                            break;
                          }
                          glyphNameIndexes.push(index);
                        }
                        if (!valid) {
                          break;
                        }
                        const customNames = [], strBuf = [];
                        while (font.pos < end) {
                          const stringLength = font.getByte();
                          strBuf.length = stringLength;
                          for (i = 0; i < stringLength; ++i) {
                            strBuf[i] = String.fromCharCode(font.getByte());
                          }
                          customNames.push(strBuf.join(""));
                        }
                        glyphNames = [];
                        for (i = 0; i < numGlyphs2; ++i) {
                          const j = glyphNameIndexes[i];
                          if (j < 258) {
                            glyphNames.push(_fonts_utils.MacStandardGlyphOrdering[j]);
                            continue;
                          }
                          glyphNames.push(customNames[j - 258]);
                        }
                        break;
                      case 196608:
                        break;
                      default:
                        (0, _util.warn)("Unknown/unsupported post table version " + version2);
                        valid = false;
                        if (propertiesObj.defaultEncoding) {
                          glyphNames = propertiesObj.defaultEncoding;
                        }
                        break;
                    }
                    propertiesObj.glyphNames = glyphNames;
                    return valid;
                  }
                  function readNameTable(nameTable) {
                    const start = (font.start || 0) + nameTable.offset;
                    font.pos = start;
                    const names = [[], []], records = [];
                    const length = nameTable.length, end = start + length;
                    const format = font.getUint16();
                    const FORMAT_0_HEADER_LENGTH = 6;
                    if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
                      return [names, records];
                    }
                    const numRecords = font.getUint16();
                    const stringsStart = font.getUint16();
                    const NAME_RECORD_LENGTH = 12;
                    let i, ii;
                    for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
                      const r = {
                        platform: font.getUint16(),
                        encoding: font.getUint16(),
                        language: font.getUint16(),
                        name: font.getUint16(),
                        length: font.getUint16(),
                        offset: font.getUint16()
                      };
                      if (isMacNameRecord(r) || isWinNameRecord(r)) {
                        records.push(r);
                      }
                    }
                    for (i = 0, ii = records.length; i < ii; i++) {
                      const record = records[i];
                      if (record.length <= 0) {
                        continue;
                      }
                      const pos = start + stringsStart + record.offset;
                      if (pos + record.length > end) {
                        continue;
                      }
                      font.pos = pos;
                      const nameIndex = record.name;
                      if (record.encoding) {
                        let str = "";
                        for (let j = 0, jj = record.length; j < jj; j += 2) {
                          str += String.fromCharCode(font.getUint16());
                        }
                        names[1][nameIndex] = str;
                      } else {
                        names[0][nameIndex] = font.getString(record.length);
                      }
                    }
                    return [names, records];
                  }
                  const TTOpsStackDeltas = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
                  function sanitizeTTProgram(table, ttContext) {
                    let data = table.data;
                    let i = 0, j, n, b, funcId, pc, lastEndf = 0, lastDeff = 0;
                    const stack = [];
                    const callstack = [];
                    const functionsCalled = [];
                    let tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
                    let inFDEF = false, ifLevel = 0, inELSE = 0;
                    for (let ii = data.length; i < ii; ) {
                      const op = data[i++];
                      if (op === 64) {
                        n = data[i++];
                        if (inFDEF || inELSE) {
                          i += n;
                        } else {
                          for (j = 0; j < n; j++) {
                            stack.push(data[i++]);
                          }
                        }
                      } else if (op === 65) {
                        n = data[i++];
                        if (inFDEF || inELSE) {
                          i += n * 2;
                        } else {
                          for (j = 0; j < n; j++) {
                            b = data[i++];
                            stack.push(b << 8 | data[i++]);
                          }
                        }
                      } else if ((op & 248) === 176) {
                        n = op - 176 + 1;
                        if (inFDEF || inELSE) {
                          i += n;
                        } else {
                          for (j = 0; j < n; j++) {
                            stack.push(data[i++]);
                          }
                        }
                      } else if ((op & 248) === 184) {
                        n = op - 184 + 1;
                        if (inFDEF || inELSE) {
                          i += n * 2;
                        } else {
                          for (j = 0; j < n; j++) {
                            b = data[i++];
                            stack.push(b << 8 | data[i++]);
                          }
                        }
                      } else if (op === 43 && !tooComplexToFollowFunctions) {
                        if (!inFDEF && !inELSE) {
                          funcId = stack.at(-1);
                          if (isNaN(funcId)) {
                            (0, _util.info)("TT: CALL empty stack (or invalid entry).");
                          } else {
                            ttContext.functionsUsed[funcId] = true;
                            if (funcId in ttContext.functionsStackDeltas) {
                              const newStackLength = stack.length + ttContext.functionsStackDeltas[funcId];
                              if (newStackLength < 0) {
                                (0, _util.warn)("TT: CALL invalid functions stack delta.");
                                ttContext.hintsValid = false;
                                return;
                              }
                              stack.length = newStackLength;
                            } else if (funcId in ttContext.functionsDefined && !functionsCalled.includes(funcId)) {
                              callstack.push({
                                data,
                                i,
                                stackTop: stack.length - 1
                              });
                              functionsCalled.push(funcId);
                              pc = ttContext.functionsDefined[funcId];
                              if (!pc) {
                                (0, _util.warn)("TT: CALL non-existent function");
                                ttContext.hintsValid = false;
                                return;
                              }
                              data = pc.data;
                              i = pc.i;
                            }
                          }
                        }
                      } else if (op === 44 && !tooComplexToFollowFunctions) {
                        if (inFDEF || inELSE) {
                          (0, _util.warn)("TT: nested FDEFs not allowed");
                          tooComplexToFollowFunctions = true;
                        }
                        inFDEF = true;
                        lastDeff = i;
                        funcId = stack.pop();
                        ttContext.functionsDefined[funcId] = {
                          data,
                          i
                        };
                      } else if (op === 45) {
                        if (inFDEF) {
                          inFDEF = false;
                          lastEndf = i;
                        } else {
                          pc = callstack.pop();
                          if (!pc) {
                            (0, _util.warn)("TT: ENDF bad stack");
                            ttContext.hintsValid = false;
                            return;
                          }
                          funcId = functionsCalled.pop();
                          data = pc.data;
                          i = pc.i;
                          ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
                        }
                      } else if (op === 137) {
                        if (inFDEF || inELSE) {
                          (0, _util.warn)("TT: nested IDEFs not allowed");
                          tooComplexToFollowFunctions = true;
                        }
                        inFDEF = true;
                        lastDeff = i;
                      } else if (op === 88) {
                        ++ifLevel;
                      } else if (op === 27) {
                        inELSE = ifLevel;
                      } else if (op === 89) {
                        if (inELSE === ifLevel) {
                          inELSE = 0;
                        }
                        --ifLevel;
                      } else if (op === 28) {
                        if (!inFDEF && !inELSE) {
                          const offset = stack.at(-1);
                          if (offset > 0) {
                            i += offset - 1;
                          }
                        }
                      }
                      if (!inFDEF && !inELSE) {
                        let stackDelta = 0;
                        if (op <= 142) {
                          stackDelta = TTOpsStackDeltas[op];
                        } else if (op >= 192 && op <= 223) {
                          stackDelta = -1;
                        } else if (op >= 224) {
                          stackDelta = -2;
                        }
                        if (op >= 113 && op <= 117) {
                          n = stack.pop();
                          if (!isNaN(n)) {
                            stackDelta = -n * 2;
                          }
                        }
                        while (stackDelta < 0 && stack.length > 0) {
                          stack.pop();
                          stackDelta++;
                        }
                        while (stackDelta > 0) {
                          stack.push(NaN);
                          stackDelta--;
                        }
                      }
                    }
                    ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
                    const content = [data];
                    if (i > data.length) {
                      content.push(new Uint8Array(i - data.length));
                    }
                    if (lastDeff > lastEndf) {
                      (0, _util.warn)("TT: complementing a missing function tail");
                      content.push(new Uint8Array([34, 45]));
                    }
                    foldTTTable(table, content);
                  }
                  function checkInvalidFunctions(ttContext, maxFunctionDefs2) {
                    if (ttContext.tooComplexToFollowFunctions) {
                      return;
                    }
                    if (ttContext.functionsDefined.length > maxFunctionDefs2) {
                      (0, _util.warn)("TT: more functions defined than expected");
                      ttContext.hintsValid = false;
                      return;
                    }
                    for (let j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
                      if (j > maxFunctionDefs2) {
                        (0, _util.warn)("TT: invalid function id: " + j);
                        ttContext.hintsValid = false;
                        return;
                      }
                      if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
                        (0, _util.warn)("TT: undefined function: " + j);
                        ttContext.hintsValid = false;
                        return;
                      }
                    }
                  }
                  function foldTTTable(table, content) {
                    if (content.length > 1) {
                      let newLength = 0;
                      let j, jj;
                      for (j = 0, jj = content.length; j < jj; j++) {
                        newLength += content[j].length;
                      }
                      newLength = newLength + 3 & ~3;
                      const result = new Uint8Array(newLength);
                      let pos = 0;
                      for (j = 0, jj = content.length; j < jj; j++) {
                        result.set(content[j], pos);
                        pos += content[j].length;
                      }
                      table.data = result;
                      table.length = newLength;
                    }
                  }
                  function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs2) {
                    const ttContext = {
                      functionsDefined: [],
                      functionsUsed: [],
                      functionsStackDeltas: [],
                      tooComplexToFollowFunctions: false,
                      hintsValid: true
                    };
                    if (fpgm) {
                      sanitizeTTProgram(fpgm, ttContext);
                    }
                    if (prep) {
                      sanitizeTTProgram(prep, ttContext);
                    }
                    if (fpgm) {
                      checkInvalidFunctions(ttContext, maxFunctionDefs2);
                    }
                    if (cvt && cvt.length & 1) {
                      const cvtData = new Uint8Array(cvt.length + 1);
                      cvtData.set(cvt.data);
                      cvt.data = cvtData;
                    }
                    return ttContext.hintsValid;
                  }
                  font = new _stream.Stream(new Uint8Array(font.getBytes()));
                  let header, tables;
                  if (isTrueTypeCollectionFile(font)) {
                    const ttcData = readTrueTypeCollectionData(font, this.name);
                    header = ttcData.header;
                    tables = ttcData.tables;
                  } else {
                    header = readOpenTypeHeader(font);
                    tables = readTables(font, header.numTables);
                  }
                  let cff, cffFile;
                  const isTrueType = !tables["CFF "];
                  if (!isTrueType) {
                    const isComposite = properties.composite && (((_a = properties.cidToGidMap) == null ? void 0 : _a.length) > 0 || !(properties.cMap instanceof _cmap.IdentityCMap));
                    if (header.version === "OTTO" && !isComposite || !tables.head || !tables.hhea || !tables.maxp || !tables.post) {
                      cffFile = new _stream.Stream(tables["CFF "].data);
                      cff = new _cff_font.CFFFont(cffFile, properties);
                      adjustWidths(properties);
                      return this.convert(name, cff, properties);
                    }
                    delete tables.glyf;
                    delete tables.loca;
                    delete tables.fpgm;
                    delete tables.prep;
                    delete tables["cvt "];
                    this.isOpenType = true;
                  } else {
                    if (!tables.loca) {
                      throw new _util.FormatError('Required "loca" table is not found');
                    }
                    if (!tables.glyf) {
                      (0, _util.warn)('Required "glyf" table is not found -- trying to recover.');
                      tables.glyf = {
                        tag: "glyf",
                        data: new Uint8Array(0)
                      };
                    }
                    this.isOpenType = false;
                  }
                  if (!tables.maxp) {
                    throw new _util.FormatError('Required "maxp" table is not found');
                  }
                  font.pos = (font.start || 0) + tables.maxp.offset;
                  const version = font.getInt32();
                  const numGlyphs = font.getUint16();
                  if (((_b = properties.scaleFactors) == null ? void 0 : _b.length) === numGlyphs && isTrueType) {
                    const {
                      scaleFactors
                    } = properties;
                    const isGlyphLocationsLong = int16(tables.head.data[50], tables.head.data[51]);
                    const glyphs = new _glyf.GlyfTable({
                      glyfTable: tables.glyf.data,
                      isGlyphLocationsLong,
                      locaTable: tables.loca.data,
                      numGlyphs
                    });
                    glyphs.scale(scaleFactors);
                    const {
                      glyf,
                      loca,
                      isLocationLong
                    } = glyphs.write();
                    tables.glyf.data = glyf;
                    tables.loca.data = loca;
                    if (isLocationLong !== !!isGlyphLocationsLong) {
                      tables.head.data[50] = 0;
                      tables.head.data[51] = isLocationLong ? 1 : 0;
                    }
                    const metrics = tables.hmtx.data;
                    for (let i = 0; i < numGlyphs; i++) {
                      const j = 4 * i;
                      const advanceWidth = Math.round(scaleFactors[i] * int16(metrics[j], metrics[j + 1]));
                      metrics[j] = advanceWidth >> 8 & 255;
                      metrics[j + 1] = advanceWidth & 255;
                      const lsb = Math.round(scaleFactors[i] * signedInt16(metrics[j + 2], metrics[j + 3]));
                      writeSignedInt16(metrics, j + 2, lsb);
                    }
                  }
                  let numGlyphsOut = numGlyphs + 1;
                  let dupFirstEntry = true;
                  if (numGlyphsOut > 65535) {
                    dupFirstEntry = false;
                    numGlyphsOut = numGlyphs;
                    (0, _util.warn)("Not enough space in glyfs to duplicate first glyph.");
                  }
                  let maxFunctionDefs = 0;
                  let maxSizeOfInstructions = 0;
                  if (version >= 65536 && tables.maxp.length >= 22) {
                    font.pos += 8;
                    const maxZones = font.getUint16();
                    if (maxZones > 2) {
                      tables.maxp.data[14] = 0;
                      tables.maxp.data[15] = 2;
                    }
                    font.pos += 4;
                    maxFunctionDefs = font.getUint16();
                    font.pos += 4;
                    maxSizeOfInstructions = font.getUint16();
                  }
                  tables.maxp.data[4] = numGlyphsOut >> 8;
                  tables.maxp.data[5] = numGlyphsOut & 255;
                  const hintsValid = sanitizeTTPrograms(tables.fpgm, tables.prep, tables["cvt "], maxFunctionDefs);
                  if (!hintsValid) {
                    delete tables.fpgm;
                    delete tables.prep;
                    delete tables["cvt "];
                  }
                  sanitizeMetrics(font, tables.hhea, tables.hmtx, tables.head, numGlyphsOut, dupFirstEntry);
                  if (!tables.head) {
                    throw new _util.FormatError('Required "head" table is not found');
                  }
                  sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);
                  let missingGlyphs = /* @__PURE__ */ Object.create(null);
                  if (isTrueType) {
                    const isGlyphLocationsLong = int16(tables.head.data[50], tables.head.data[51]);
                    const glyphsInfo = sanitizeGlyphLocations(tables.loca, tables.glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions);
                    missingGlyphs = glyphsInfo.missingGlyphs;
                    if (version >= 65536 && tables.maxp.length >= 22) {
                      tables.maxp.data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
                      tables.maxp.data[27] = glyphsInfo.maxSizeOfInstructions & 255;
                    }
                  }
                  if (!tables.hhea) {
                    throw new _util.FormatError('Required "hhea" table is not found');
                  }
                  if (tables.hhea.data[10] === 0 && tables.hhea.data[11] === 0) {
                    tables.hhea.data[10] = 255;
                    tables.hhea.data[11] = 255;
                  }
                  const metricsOverride = {
                    unitsPerEm: int16(tables.head.data[18], tables.head.data[19]),
                    yMax: signedInt16(tables.head.data[42], tables.head.data[43]),
                    yMin: signedInt16(tables.head.data[38], tables.head.data[39]),
                    ascent: signedInt16(tables.hhea.data[4], tables.hhea.data[5]),
                    descent: signedInt16(tables.hhea.data[6], tables.hhea.data[7]),
                    lineGap: signedInt16(tables.hhea.data[8], tables.hhea.data[9])
                  };
                  this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
                  this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
                  this.lineGap = metricsOverride.lineGap / metricsOverride.unitsPerEm;
                  if ((_c = this.cssFontInfo) == null ? void 0 : _c.lineHeight) {
                    this.lineHeight = this.cssFontInfo.metrics.lineHeight;
                    this.lineGap = this.cssFontInfo.metrics.lineGap;
                  } else {
                    this.lineHeight = this.ascent - this.descent + this.lineGap;
                  }
                  if (tables.post) {
                    readPostScriptTable(tables.post, properties, numGlyphs);
                  }
                  tables.post = {
                    tag: "post",
                    data: createPostTable(properties)
                  };
                  const charCodeToGlyphId = [];
                  function hasGlyph(glyphId) {
                    return !missingGlyphs[glyphId];
                  }
                  if (properties.composite) {
                    const cidToGidMap = properties.cidToGidMap || [];
                    const isCidToGidMapEmpty = cidToGidMap.length === 0;
                    properties.cMap.forEach(function(charCode, cid) {
                      if (typeof cid === "string") {
                        cid = convertCidString(charCode, cid, true);
                      }
                      if (cid > 65535) {
                        throw new _util.FormatError("Max size of CID is 65,535");
                      }
                      let glyphId = -1;
                      if (isCidToGidMapEmpty) {
                        glyphId = cid;
                      } else if (cidToGidMap[cid] !== void 0) {
                        glyphId = cidToGidMap[cid];
                      }
                      if (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId)) {
                        charCodeToGlyphId[charCode] = glyphId;
                      }
                    });
                  } else {
                    const cmapTable = readCmapTable(tables.cmap, font, this.isSymbolicFont, properties.hasEncoding);
                    const cmapPlatformId = cmapTable.platformId;
                    const cmapEncodingId = cmapTable.encodingId;
                    const cmapMappings = cmapTable.mappings;
                    let baseEncoding = [], forcePostTable = false;
                    if (properties.hasEncoding && (properties.baseEncodingName === "MacRomanEncoding" || properties.baseEncodingName === "WinAnsiEncoding")) {
                      baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);
                    }
                    if (properties.hasEncoding && !this.isSymbolicFont && (cmapPlatformId === 3 && cmapEncodingId === 1 || cmapPlatformId === 1 && cmapEncodingId === 0)) {
                      const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                      for (let charCode = 0; charCode < 256; charCode++) {
                        let glyphName;
                        if (this.differences[charCode] !== void 0) {
                          glyphName = this.differences[charCode];
                        } else if (baseEncoding.length && baseEncoding[charCode] !== "") {
                          glyphName = baseEncoding[charCode];
                        } else {
                          glyphName = _encodings.StandardEncoding[charCode];
                        }
                        if (!glyphName) {
                          continue;
                        }
                        const standardGlyphName = (0, _fonts_utils.recoverGlyphName)(glyphName, glyphsUnicodeMap);
                        let unicodeOrCharCode;
                        if (cmapPlatformId === 3 && cmapEncodingId === 1) {
                          unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
                        } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
                          unicodeOrCharCode = _encodings.MacRomanEncoding.indexOf(standardGlyphName);
                        }
                        if (unicodeOrCharCode === void 0) {
                          if (!properties.glyphNames && properties.hasIncludedToUnicodeMap && !(this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap)) {
                            const unicode = this.toUnicode.get(charCode);
                            if (unicode) {
                              unicodeOrCharCode = unicode.codePointAt(0);
                            }
                          }
                          if (unicodeOrCharCode === void 0) {
                            continue;
                          }
                        }
                        for (const mapping of cmapMappings) {
                          if (mapping.charCode !== unicodeOrCharCode) {
                            continue;
                          }
                          charCodeToGlyphId[charCode] = mapping.glyphId;
                          break;
                        }
                      }
                    } else if (cmapPlatformId === 0) {
                      for (const mapping of cmapMappings) {
                        charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
                      }
                      forcePostTable = true;
                    } else {
                      for (const mapping of cmapMappings) {
                        let charCode = mapping.charCode;
                        if (cmapPlatformId === 3 && charCode >= 61440 && charCode <= 61695) {
                          charCode &= 255;
                        }
                        charCodeToGlyphId[charCode] = mapping.glyphId;
                      }
                    }
                    if (properties.glyphNames && (baseEncoding.length || this.differences.length)) {
                      for (let i = 0; i < 256; ++i) {
                        if (!forcePostTable && charCodeToGlyphId[i] !== void 0) {
                          continue;
                        }
                        const glyphName = this.differences[i] || baseEncoding[i];
                        if (!glyphName) {
                          continue;
                        }
                        const glyphId = properties.glyphNames.indexOf(glyphName);
                        if (glyphId > 0 && hasGlyph(glyphId)) {
                          charCodeToGlyphId[i] = glyphId;
                        }
                      }
                    }
                  }
                  if (charCodeToGlyphId.length === 0) {
                    charCodeToGlyphId[0] = 0;
                  }
                  let glyphZeroId = numGlyphsOut - 1;
                  if (!dupFirstEntry) {
                    glyphZeroId = 0;
                  }
                  if (!properties.cssFontInfo) {
                    const newMapping = adjustMapping(charCodeToGlyphId, hasGlyph, glyphZeroId, this.toUnicode);
                    this.toFontChar = newMapping.toFontChar;
                    tables.cmap = {
                      tag: "cmap",
                      data: createCmapTable(newMapping.charCodeToGlyphId, newMapping.toUnicodeExtraMap, numGlyphsOut)
                    };
                    if (!tables["OS/2"] || !validateOS2Table(tables["OS/2"], font)) {
                      tables["OS/2"] = {
                        tag: "OS/2",
                        data: createOS2Table(properties, newMapping.charCodeToGlyphId, metricsOverride)
                      };
                    }
                  }
                  if (!isTrueType) {
                    try {
                      cffFile = new _stream.Stream(tables["CFF "].data);
                      const parser = new _cff_parser.CFFParser(cffFile, properties, _fonts_utils.SEAC_ANALYSIS_ENABLED);
                      cff = parser.parse();
                      cff.duplicateFirstGlyph();
                      const compiler = new _cff_parser.CFFCompiler(cff);
                      tables["CFF "].data = compiler.compile();
                    } catch {
                      (0, _util.warn)("Failed to compile font " + properties.loadedName);
                    }
                  }
                  if (!tables.name) {
                    tables.name = {
                      tag: "name",
                      data: createNameTable(this.name)
                    };
                  } else {
                    const [namePrototype, nameRecords] = readNameTable(tables.name);
                    tables.name.data = createNameTable(name, namePrototype);
                    this.psName = namePrototype[0][6] || null;
                    if (!properties.composite) {
                      adjustTrueTypeToUnicode(properties, this.isSymbolicFont, nameRecords);
                    }
                  }
                  const builder = new _opentype_file_builder.OpenTypeFileBuilder(header.version);
                  for (const tableTag in tables) {
                    builder.addTable(tableTag, tables[tableTag].data);
                  }
                  return builder.toArray();
                }
                convert(fontName, font, properties) {
                  properties.fixedPitch = false;
                  if (properties.builtInEncoding) {
                    adjustType1ToUnicode(properties, properties.builtInEncoding);
                  }
                  let glyphZeroId = 1;
                  if (font instanceof _cff_font.CFFFont) {
                    glyphZeroId = font.numGlyphs - 1;
                  }
                  const mapping = font.getGlyphMapping(properties);
                  let newMapping = null;
                  let newCharCodeToGlyphId = mapping;
                  let toUnicodeExtraMap = null;
                  if (!properties.cssFontInfo) {
                    newMapping = adjustMapping(mapping, font.hasGlyphId.bind(font), glyphZeroId, this.toUnicode);
                    this.toFontChar = newMapping.toFontChar;
                    newCharCodeToGlyphId = newMapping.charCodeToGlyphId;
                    toUnicodeExtraMap = newMapping.toUnicodeExtraMap;
                  }
                  const numGlyphs = font.numGlyphs;
                  function getCharCodes(charCodeToGlyphId, glyphId) {
                    let charCodes = null;
                    for (const charCode in charCodeToGlyphId) {
                      if (glyphId === charCodeToGlyphId[charCode]) {
                        (charCodes || (charCodes = [])).push(charCode | 0);
                      }
                    }
                    return charCodes;
                  }
                  function createCharCode(charCodeToGlyphId, glyphId) {
                    for (const charCode in charCodeToGlyphId) {
                      if (glyphId === charCodeToGlyphId[charCode]) {
                        return charCode | 0;
                      }
                    }
                    newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] = glyphId;
                    return newMapping.nextAvailableFontCharCode++;
                  }
                  const seacs = font.seacs;
                  if (newMapping && _fonts_utils.SEAC_ANALYSIS_ENABLED && (seacs == null ? void 0 : seacs.length)) {
                    const matrix = properties.fontMatrix || _util.FONT_IDENTITY_MATRIX;
                    const charset = font.getCharset();
                    const seacMap = /* @__PURE__ */ Object.create(null);
                    for (let glyphId in seacs) {
                      glyphId |= 0;
                      const seac = seacs[glyphId];
                      const baseGlyphName = _encodings.StandardEncoding[seac[2]];
                      const accentGlyphName = _encodings.StandardEncoding[seac[3]];
                      const baseGlyphId = charset.indexOf(baseGlyphName);
                      const accentGlyphId = charset.indexOf(accentGlyphName);
                      if (baseGlyphId < 0 || accentGlyphId < 0) {
                        continue;
                      }
                      const accentOffset = {
                        x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],
                        y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5]
                      };
                      const charCodes = getCharCodes(mapping, glyphId);
                      if (!charCodes) {
                        continue;
                      }
                      for (const charCode of charCodes) {
                        const charCodeToGlyphId = newMapping.charCodeToGlyphId;
                        const baseFontCharCode = createCharCode(charCodeToGlyphId, baseGlyphId);
                        const accentFontCharCode = createCharCode(charCodeToGlyphId, accentGlyphId);
                        seacMap[charCode] = {
                          baseFontCharCode,
                          accentFontCharCode,
                          accentOffset
                        };
                      }
                    }
                    properties.seacMap = seacMap;
                  }
                  const unitsPerEm = 1 / (properties.fontMatrix || _util.FONT_IDENTITY_MATRIX)[0];
                  const builder = new _opentype_file_builder.OpenTypeFileBuilder("OTTO");
                  builder.addTable("CFF ", font.data);
                  builder.addTable("OS/2", createOS2Table(properties, newCharCodeToGlyphId));
                  builder.addTable("cmap", createCmapTable(newCharCodeToGlyphId, toUnicodeExtraMap, numGlyphs));
                  builder.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<\0\0" + safeString16(unitsPerEm) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + safeString16(properties.descent) + "" + safeString16(properties.ascent) + string16(properties.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0");
                  builder.addTable("hhea", "\0\0\0" + safeString16(properties.ascent) + safeString16(properties.descent) + "\0\0\0\0\0\0\0\0" + safeString16(properties.capHeight) + safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + string16(numGlyphs));
                  builder.addTable("hmtx", function fontFieldsHmtx() {
                    const charstrings = font.charstrings;
                    const cffWidths = font.cff ? font.cff.widths : null;
                    let hmtx = "\0\0\0\0";
                    for (let i = 1, ii = numGlyphs; i < ii; i++) {
                      let width = 0;
                      if (charstrings) {
                        const charstring = charstrings[i - 1];
                        width = "width" in charstring ? charstring.width : 0;
                      } else if (cffWidths) {
                        width = Math.ceil(cffWidths[i] || 0);
                      }
                      hmtx += string16(width) + string16(0);
                    }
                    return hmtx;
                  }());
                  builder.addTable("maxp", "\0\0P\0" + string16(numGlyphs));
                  builder.addTable("name", createNameTable(fontName));
                  builder.addTable("post", createPostTable(properties));
                  return builder.toArray();
                }
                get spaceWidth() {
                  const possibleSpaceReplacements = ["space", "minus", "one", "i", "I"];
                  let width;
                  for (const glyphName of possibleSpaceReplacements) {
                    if (glyphName in this.widths) {
                      width = this.widths[glyphName];
                      break;
                    }
                    const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                    const glyphUnicode = glyphsUnicodeMap[glyphName];
                    let charcode = 0;
                    if (this.composite && this.cMap.contains(glyphUnicode)) {
                      charcode = this.cMap.lookup(glyphUnicode);
                      if (typeof charcode === "string") {
                        charcode = convertCidString(glyphUnicode, charcode);
                      }
                    }
                    if (!charcode && this.toUnicode) {
                      charcode = this.toUnicode.charCodeOf(glyphUnicode);
                    }
                    if (charcode <= 0) {
                      charcode = glyphUnicode;
                    }
                    width = this.widths[charcode];
                    if (width) {
                      break;
                    }
                  }
                  return (0, _util.shadow)(this, "spaceWidth", width || this.defaultWidth);
                }
                _charToGlyph(charcode, isSpace = false) {
                  var _a, _b, _c;
                  let glyph = this._glyphCache[charcode];
                  if ((glyph == null ? void 0 : glyph.isSpace) === isSpace) {
                    return glyph;
                  }
                  let fontCharCode, width, operatorListId;
                  let widthCode = charcode;
                  if ((_a = this.cMap) == null ? void 0 : _a.contains(charcode)) {
                    widthCode = this.cMap.lookup(charcode);
                    if (typeof widthCode === "string") {
                      widthCode = convertCidString(charcode, widthCode);
                    }
                  }
                  width = this.widths[widthCode];
                  if (typeof width !== "number") {
                    width = this.defaultWidth;
                  }
                  const vmetric = (_b = this.vmetrics) == null ? void 0 : _b[widthCode];
                  let unicode = this.toUnicode.get(charcode) || charcode;
                  if (typeof unicode === "number") {
                    unicode = String.fromCharCode(unicode);
                  }
                  let isInFont = this.toFontChar[charcode] !== void 0;
                  fontCharCode = this.toFontChar[charcode] || charcode;
                  if (this.missingFile) {
                    const glyphName = this.differences[charcode] || this.defaultEncoding[charcode];
                    if ((glyphName === ".notdef" || glyphName === "") && this.type === "Type1") {
                      fontCharCode = 32;
                    }
                    fontCharCode = (0, _unicode.mapSpecialUnicodeValues)(fontCharCode);
                  }
                  if (this.isType3Font) {
                    operatorListId = fontCharCode;
                  }
                  let accent = null;
                  if ((_c = this.seacMap) == null ? void 0 : _c[charcode]) {
                    isInFont = true;
                    const seac = this.seacMap[charcode];
                    fontCharCode = seac.baseFontCharCode;
                    accent = {
                      fontChar: String.fromCodePoint(seac.accentFontCharCode),
                      offset: seac.accentOffset
                    };
                  }
                  let fontChar = "";
                  if (typeof fontCharCode === "number") {
                    if (fontCharCode <= 1114111) {
                      fontChar = String.fromCodePoint(fontCharCode);
                    } else {
                      (0, _util.warn)(`charToGlyph - invalid fontCharCode: ${fontCharCode}`);
                    }
                  }
                  glyph = new Glyph(charcode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont);
                  return this._glyphCache[charcode] = glyph;
                }
                charsToGlyphs(chars) {
                  let glyphs = this._charsCache[chars];
                  if (glyphs) {
                    return glyphs;
                  }
                  glyphs = [];
                  if (this.cMap) {
                    const c = /* @__PURE__ */ Object.create(null), ii = chars.length;
                    let i = 0;
                    while (i < ii) {
                      this.cMap.readCharCode(chars, i, c);
                      const {
                        charcode,
                        length
                      } = c;
                      i += length;
                      const glyph = this._charToGlyph(charcode, length === 1 && chars.charCodeAt(i - 1) === 32);
                      glyphs.push(glyph);
                    }
                  } else {
                    for (let i = 0, ii = chars.length; i < ii; ++i) {
                      const charcode = chars.charCodeAt(i);
                      const glyph = this._charToGlyph(charcode, charcode === 32);
                      glyphs.push(glyph);
                    }
                  }
                  return this._charsCache[chars] = glyphs;
                }
                getCharPositions(chars) {
                  const positions = [];
                  if (this.cMap) {
                    const c = /* @__PURE__ */ Object.create(null);
                    let i = 0;
                    while (i < chars.length) {
                      this.cMap.readCharCode(chars, i, c);
                      const length = c.length;
                      positions.push([i, i + length]);
                      i += length;
                    }
                  } else {
                    for (let i = 0, ii = chars.length; i < ii; ++i) {
                      positions.push([i, i + 1]);
                    }
                  }
                  return positions;
                }
                get glyphCacheValues() {
                  return Object.values(this._glyphCache);
                }
                encodeString(str) {
                  const buffers = [];
                  const currentBuf = [];
                  const hasCurrentBufErrors = () => buffers.length % 2 === 1;
                  const getCharCode = this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap ? (unicode) => this.toUnicode.charCodeOf(unicode) : (unicode) => this.toUnicode.charCodeOf(String.fromCodePoint(unicode));
                  for (let i = 0, ii = str.length; i < ii; i++) {
                    const unicode = str.codePointAt(i);
                    if (unicode > 55295 && (unicode < 57344 || unicode > 65533)) {
                      i++;
                    }
                    if (this.toUnicode) {
                      const charCode = getCharCode(unicode);
                      if (charCode !== -1) {
                        if (hasCurrentBufErrors()) {
                          buffers.push(currentBuf.join(""));
                          currentBuf.length = 0;
                        }
                        const charCodeLength = this.cMap ? this.cMap.getCharCodeLength(charCode) : 1;
                        for (let j = charCodeLength - 1; j >= 0; j--) {
                          currentBuf.push(String.fromCharCode(charCode >> 8 * j & 255));
                        }
                        continue;
                      }
                    }
                    if (!hasCurrentBufErrors()) {
                      buffers.push(currentBuf.join(""));
                      currentBuf.length = 0;
                    }
                    currentBuf.push(String.fromCodePoint(unicode));
                  }
                  buffers.push(currentBuf.join(""));
                  return buffers;
                }
              }
              exports2.Font = Font;
              class ErrorFont {
                constructor(error) {
                  this.error = error;
                  this.loadedName = "g_font_error";
                  this.missingFile = true;
                }
                charsToGlyphs() {
                  return [];
                }
                encodeString(chars) {
                  return [chars];
                }
                exportData(extraProperties = false) {
                  return {
                    error: this.error
                  };
                }
              }
              exports2.ErrorFont = ErrorFont;
            },
            /* 35 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CFFTopDict = exports2.CFFStrings = exports2.CFFStandardStrings = exports2.CFFPrivateDict = exports2.CFFParser = exports2.CFFIndex = exports2.CFFHeader = exports2.CFFFDSelect = exports2.CFFCompiler = exports2.CFFCharset = exports2.CFF = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _charsets = __w_pdfjs_require__2(36);
              var _encodings = __w_pdfjs_require__2(37);
              const MAX_SUBR_NESTING = 10;
              const CFFStandardStrings = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
              exports2.CFFStandardStrings = CFFStandardStrings;
              const NUM_STANDARD_CFF_STRINGS = 391;
              const CharstringValidationData = [null, {
                id: "hstem",
                min: 2,
                stackClearing: true,
                stem: true
              }, null, {
                id: "vstem",
                min: 2,
                stackClearing: true,
                stem: true
              }, {
                id: "vmoveto",
                min: 1,
                stackClearing: true
              }, {
                id: "rlineto",
                min: 2,
                resetStack: true
              }, {
                id: "hlineto",
                min: 1,
                resetStack: true
              }, {
                id: "vlineto",
                min: 1,
                resetStack: true
              }, {
                id: "rrcurveto",
                min: 6,
                resetStack: true
              }, null, {
                id: "callsubr",
                min: 1,
                undefStack: true
              }, {
                id: "return",
                min: 0,
                undefStack: true
              }, null, null, {
                id: "endchar",
                min: 0,
                stackClearing: true
              }, null, null, null, {
                id: "hstemhm",
                min: 2,
                stackClearing: true,
                stem: true
              }, {
                id: "hintmask",
                min: 0,
                stackClearing: true
              }, {
                id: "cntrmask",
                min: 0,
                stackClearing: true
              }, {
                id: "rmoveto",
                min: 2,
                stackClearing: true
              }, {
                id: "hmoveto",
                min: 1,
                stackClearing: true
              }, {
                id: "vstemhm",
                min: 2,
                stackClearing: true,
                stem: true
              }, {
                id: "rcurveline",
                min: 8,
                resetStack: true
              }, {
                id: "rlinecurve",
                min: 8,
                resetStack: true
              }, {
                id: "vvcurveto",
                min: 4,
                resetStack: true
              }, {
                id: "hhcurveto",
                min: 4,
                resetStack: true
              }, null, {
                id: "callgsubr",
                min: 1,
                undefStack: true
              }, {
                id: "vhcurveto",
                min: 4,
                resetStack: true
              }, {
                id: "hvcurveto",
                min: 4,
                resetStack: true
              }];
              const CharstringValidationData12 = [null, null, null, {
                id: "and",
                min: 2,
                stackDelta: -1
              }, {
                id: "or",
                min: 2,
                stackDelta: -1
              }, {
                id: "not",
                min: 1,
                stackDelta: 0
              }, null, null, null, {
                id: "abs",
                min: 1,
                stackDelta: 0
              }, {
                id: "add",
                min: 2,
                stackDelta: -1,
                stackFn(stack, index) {
                  stack[index - 2] = stack[index - 2] + stack[index - 1];
                }
              }, {
                id: "sub",
                min: 2,
                stackDelta: -1,
                stackFn(stack, index) {
                  stack[index - 2] = stack[index - 2] - stack[index - 1];
                }
              }, {
                id: "div",
                min: 2,
                stackDelta: -1,
                stackFn(stack, index) {
                  stack[index - 2] = stack[index - 2] / stack[index - 1];
                }
              }, null, {
                id: "neg",
                min: 1,
                stackDelta: 0,
                stackFn(stack, index) {
                  stack[index - 1] = -stack[index - 1];
                }
              }, {
                id: "eq",
                min: 2,
                stackDelta: -1
              }, null, null, {
                id: "drop",
                min: 1,
                stackDelta: -1
              }, null, {
                id: "put",
                min: 2,
                stackDelta: -2
              }, {
                id: "get",
                min: 1,
                stackDelta: 0
              }, {
                id: "ifelse",
                min: 4,
                stackDelta: -3
              }, {
                id: "random",
                min: 0,
                stackDelta: 1
              }, {
                id: "mul",
                min: 2,
                stackDelta: -1,
                stackFn(stack, index) {
                  stack[index - 2] = stack[index - 2] * stack[index - 1];
                }
              }, null, {
                id: "sqrt",
                min: 1,
                stackDelta: 0
              }, {
                id: "dup",
                min: 1,
                stackDelta: 1
              }, {
                id: "exch",
                min: 2,
                stackDelta: 0
              }, {
                id: "index",
                min: 2,
                stackDelta: 0
              }, {
                id: "roll",
                min: 3,
                stackDelta: -2
              }, null, null, null, {
                id: "hflex",
                min: 7,
                resetStack: true
              }, {
                id: "flex",
                min: 13,
                resetStack: true
              }, {
                id: "hflex1",
                min: 9,
                resetStack: true
              }, {
                id: "flex1",
                min: 11,
                resetStack: true
              }];
              class CFFParser {
                constructor(file, properties, seacAnalysisEnabled) {
                  this.bytes = file.getBytes();
                  this.properties = properties;
                  this.seacAnalysisEnabled = !!seacAnalysisEnabled;
                }
                parse() {
                  const properties = this.properties;
                  const cff = new CFF();
                  this.cff = cff;
                  const header = this.parseHeader();
                  const nameIndex = this.parseIndex(header.endPos);
                  const topDictIndex = this.parseIndex(nameIndex.endPos);
                  const stringIndex = this.parseIndex(topDictIndex.endPos);
                  const globalSubrIndex = this.parseIndex(stringIndex.endPos);
                  const topDictParsed = this.parseDict(topDictIndex.obj.get(0));
                  const topDict = this.createDict(CFFTopDict, topDictParsed, cff.strings);
                  cff.header = header.obj;
                  cff.names = this.parseNameIndex(nameIndex.obj);
                  cff.strings = this.parseStringIndex(stringIndex.obj);
                  cff.topDict = topDict;
                  cff.globalSubrIndex = globalSubrIndex.obj;
                  this.parsePrivateDict(cff.topDict);
                  cff.isCIDFont = topDict.hasName("ROS");
                  const charStringOffset = topDict.getByName("CharStrings");
                  const charStringIndex = this.parseIndex(charStringOffset).obj;
                  const fontMatrix = topDict.getByName("FontMatrix");
                  if (fontMatrix) {
                    properties.fontMatrix = fontMatrix;
                  }
                  const fontBBox = topDict.getByName("FontBBox");
                  if (fontBBox) {
                    properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
                    properties.descent = Math.min(fontBBox[1], fontBBox[3]);
                    properties.ascentScaled = true;
                  }
                  let charset, encoding;
                  if (cff.isCIDFont) {
                    const fdArrayIndex = this.parseIndex(topDict.getByName("FDArray")).obj;
                    for (let i = 0, ii = fdArrayIndex.count; i < ii; ++i) {
                      const dictRaw = fdArrayIndex.get(i);
                      const fontDict = this.createDict(CFFTopDict, this.parseDict(dictRaw), cff.strings);
                      this.parsePrivateDict(fontDict);
                      cff.fdArray.push(fontDict);
                    }
                    encoding = null;
                    charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, true);
                    cff.fdSelect = this.parseFDSelect(topDict.getByName("FDSelect"), charStringIndex.count);
                  } else {
                    charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, false);
                    encoding = this.parseEncoding(topDict.getByName("Encoding"), properties, cff.strings, charset.charset);
                  }
                  cff.charset = charset;
                  cff.encoding = encoding;
                  const charStringsAndSeacs = this.parseCharStrings({
                    charStrings: charStringIndex,
                    localSubrIndex: topDict.privateDict.subrsIndex,
                    globalSubrIndex: globalSubrIndex.obj,
                    fdSelect: cff.fdSelect,
                    fdArray: cff.fdArray,
                    privateDict: topDict.privateDict
                  });
                  cff.charStrings = charStringsAndSeacs.charStrings;
                  cff.seacs = charStringsAndSeacs.seacs;
                  cff.widths = charStringsAndSeacs.widths;
                  return cff;
                }
                parseHeader() {
                  let bytes = this.bytes;
                  const bytesLength = bytes.length;
                  let offset = 0;
                  while (offset < bytesLength && bytes[offset] !== 1) {
                    ++offset;
                  }
                  if (offset >= bytesLength) {
                    throw new _util.FormatError("Invalid CFF header");
                  }
                  if (offset !== 0) {
                    (0, _util.info)("cff data is shifted");
                    bytes = bytes.subarray(offset);
                    this.bytes = bytes;
                  }
                  const major = bytes[0];
                  const minor = bytes[1];
                  const hdrSize = bytes[2];
                  const offSize = bytes[3];
                  const header = new CFFHeader(major, minor, hdrSize, offSize);
                  return {
                    obj: header,
                    endPos: hdrSize
                  };
                }
                parseDict(dict) {
                  let pos = 0;
                  function parseOperand() {
                    let value = dict[pos++];
                    if (value === 30) {
                      return parseFloatOperand();
                    } else if (value === 28) {
                      value = dict[pos++];
                      value = (value << 24 | dict[pos++] << 16) >> 16;
                      return value;
                    } else if (value === 29) {
                      value = dict[pos++];
                      value = value << 8 | dict[pos++];
                      value = value << 8 | dict[pos++];
                      value = value << 8 | dict[pos++];
                      return value;
                    } else if (value >= 32 && value <= 246) {
                      return value - 139;
                    } else if (value >= 247 && value <= 250) {
                      return (value - 247) * 256 + dict[pos++] + 108;
                    } else if (value >= 251 && value <= 254) {
                      return -((value - 251) * 256) - dict[pos++] - 108;
                    }
                    (0, _util.warn)('CFFParser_parseDict: "' + value + '" is a reserved command.');
                    return NaN;
                  }
                  function parseFloatOperand() {
                    let str = "";
                    const eof = 15;
                    const lookup = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
                    const length = dict.length;
                    while (pos < length) {
                      const b = dict[pos++];
                      const b1 = b >> 4;
                      const b2 = b & 15;
                      if (b1 === eof) {
                        break;
                      }
                      str += lookup[b1];
                      if (b2 === eof) {
                        break;
                      }
                      str += lookup[b2];
                    }
                    return parseFloat(str);
                  }
                  let operands = [];
                  const entries = [];
                  pos = 0;
                  const end = dict.length;
                  while (pos < end) {
                    let b = dict[pos];
                    if (b <= 21) {
                      if (b === 12) {
                        b = b << 8 | dict[++pos];
                      }
                      entries.push([b, operands]);
                      operands = [];
                      ++pos;
                    } else {
                      operands.push(parseOperand());
                    }
                  }
                  return entries;
                }
                parseIndex(pos) {
                  const cffIndex = new CFFIndex();
                  const bytes = this.bytes;
                  const count = bytes[pos++] << 8 | bytes[pos++];
                  const offsets = [];
                  let end = pos;
                  let i, ii;
                  if (count !== 0) {
                    const offsetSize = bytes[pos++];
                    const startPos = pos + (count + 1) * offsetSize - 1;
                    for (i = 0, ii = count + 1; i < ii; ++i) {
                      let offset = 0;
                      for (let j = 0; j < offsetSize; ++j) {
                        offset <<= 8;
                        offset += bytes[pos++];
                      }
                      offsets.push(startPos + offset);
                    }
                    end = offsets[count];
                  }
                  for (i = 0, ii = offsets.length - 1; i < ii; ++i) {
                    const offsetStart = offsets[i];
                    const offsetEnd = offsets[i + 1];
                    cffIndex.add(bytes.subarray(offsetStart, offsetEnd));
                  }
                  return {
                    obj: cffIndex,
                    endPos: end
                  };
                }
                parseNameIndex(index) {
                  const names = [];
                  for (let i = 0, ii = index.count; i < ii; ++i) {
                    const name = index.get(i);
                    names.push((0, _util.bytesToString)(name));
                  }
                  return names;
                }
                parseStringIndex(index) {
                  const strings = new CFFStrings();
                  for (let i = 0, ii = index.count; i < ii; ++i) {
                    const data = index.get(i);
                    strings.add((0, _util.bytesToString)(data));
                  }
                  return strings;
                }
                createDict(Type, dict, strings) {
                  const cffDict = new Type(strings);
                  for (const [key, value] of dict) {
                    cffDict.setByKey(key, value);
                  }
                  return cffDict;
                }
                parseCharString(state, data, localSubrIndex, globalSubrIndex) {
                  if (!data || state.callDepth > MAX_SUBR_NESTING) {
                    return false;
                  }
                  let stackSize = state.stackSize;
                  const stack = state.stack;
                  let length = data.length;
                  for (let j = 0; j < length; ) {
                    const value = data[j++];
                    let validationCommand = null;
                    if (value === 12) {
                      const q = data[j++];
                      if (q === 0) {
                        data[j - 2] = 139;
                        data[j - 1] = 22;
                        stackSize = 0;
                      } else {
                        validationCommand = CharstringValidationData12[q];
                      }
                    } else if (value === 28) {
                      stack[stackSize] = (data[j] << 24 | data[j + 1] << 16) >> 16;
                      j += 2;
                      stackSize++;
                    } else if (value === 14) {
                      if (stackSize >= 4) {
                        stackSize -= 4;
                        if (this.seacAnalysisEnabled) {
                          state.seac = stack.slice(stackSize, stackSize + 4);
                          return false;
                        }
                      }
                      validationCommand = CharstringValidationData[value];
                    } else if (value >= 32 && value <= 246) {
                      stack[stackSize] = value - 139;
                      stackSize++;
                    } else if (value >= 247 && value <= 254) {
                      stack[stackSize] = value < 251 ? (value - 247 << 8) + data[j] + 108 : -(value - 251 << 8) - data[j] - 108;
                      j++;
                      stackSize++;
                    } else if (value === 255) {
                      stack[stackSize] = (data[j] << 24 | data[j + 1] << 16 | data[j + 2] << 8 | data[j + 3]) / 65536;
                      j += 4;
                      stackSize++;
                    } else if (value === 19 || value === 20) {
                      state.hints += stackSize >> 1;
                      if (state.hints === 0) {
                        data.copyWithin(j - 1, j, -1);
                        j -= 1;
                        length -= 1;
                        continue;
                      }
                      j += state.hints + 7 >> 3;
                      stackSize %= 2;
                      validationCommand = CharstringValidationData[value];
                    } else if (value === 10 || value === 29) {
                      const subrsIndex = value === 10 ? localSubrIndex : globalSubrIndex;
                      if (!subrsIndex) {
                        validationCommand = CharstringValidationData[value];
                        (0, _util.warn)("Missing subrsIndex for " + validationCommand.id);
                        return false;
                      }
                      let bias = 32768;
                      if (subrsIndex.count < 1240) {
                        bias = 107;
                      } else if (subrsIndex.count < 33900) {
                        bias = 1131;
                      }
                      const subrNumber = stack[--stackSize] + bias;
                      if (subrNumber < 0 || subrNumber >= subrsIndex.count || isNaN(subrNumber)) {
                        validationCommand = CharstringValidationData[value];
                        (0, _util.warn)("Out of bounds subrIndex for " + validationCommand.id);
                        return false;
                      }
                      state.stackSize = stackSize;
                      state.callDepth++;
                      const valid = this.parseCharString(state, subrsIndex.get(subrNumber), localSubrIndex, globalSubrIndex);
                      if (!valid) {
                        return false;
                      }
                      state.callDepth--;
                      stackSize = state.stackSize;
                      continue;
                    } else if (value === 11) {
                      state.stackSize = stackSize;
                      return true;
                    } else if (value === 0 && j === data.length) {
                      data[j - 1] = 14;
                      validationCommand = CharstringValidationData[14];
                    } else if (value === 9) {
                      data.copyWithin(j - 1, j, -1);
                      j -= 1;
                      length -= 1;
                      continue;
                    } else {
                      validationCommand = CharstringValidationData[value];
                    }
                    if (validationCommand) {
                      if (validationCommand.stem) {
                        state.hints += stackSize >> 1;
                        if (value === 3 || value === 23) {
                          state.hasVStems = true;
                        } else if (state.hasVStems && (value === 1 || value === 18)) {
                          (0, _util.warn)("CFF stem hints are in wrong order");
                          data[j - 1] = value === 1 ? 3 : 23;
                        }
                      }
                      if ("min" in validationCommand) {
                        if (!state.undefStack && stackSize < validationCommand.min) {
                          (0, _util.warn)("Not enough parameters for " + validationCommand.id + "; actual: " + stackSize + ", expected: " + validationCommand.min);
                          if (stackSize === 0) {
                            data[j - 1] = 14;
                            return true;
                          }
                          return false;
                        }
                      }
                      if (state.firstStackClearing && validationCommand.stackClearing) {
                        state.firstStackClearing = false;
                        stackSize -= validationCommand.min;
                        if (stackSize >= 2 && validationCommand.stem) {
                          stackSize %= 2;
                        } else if (stackSize > 1) {
                          (0, _util.warn)("Found too many parameters for stack-clearing command");
                        }
                        if (stackSize > 0) {
                          state.width = stack[stackSize - 1];
                        }
                      }
                      if ("stackDelta" in validationCommand) {
                        if ("stackFn" in validationCommand) {
                          validationCommand.stackFn(stack, stackSize);
                        }
                        stackSize += validationCommand.stackDelta;
                      } else if (validationCommand.stackClearing) {
                        stackSize = 0;
                      } else if (validationCommand.resetStack) {
                        stackSize = 0;
                        state.undefStack = false;
                      } else if (validationCommand.undefStack) {
                        stackSize = 0;
                        state.undefStack = true;
                        state.firstStackClearing = false;
                      }
                    }
                  }
                  if (length < data.length) {
                    data.fill(14, length);
                  }
                  state.stackSize = stackSize;
                  return true;
                }
                parseCharStrings({
                  charStrings,
                  localSubrIndex,
                  globalSubrIndex,
                  fdSelect,
                  fdArray,
                  privateDict
                }) {
                  const seacs = [];
                  const widths = [];
                  const count = charStrings.count;
                  for (let i = 0; i < count; i++) {
                    const charstring = charStrings.get(i);
                    const state = {
                      callDepth: 0,
                      stackSize: 0,
                      stack: [],
                      undefStack: true,
                      hints: 0,
                      firstStackClearing: true,
                      seac: null,
                      width: null,
                      hasVStems: false
                    };
                    let valid = true;
                    let localSubrToUse = null;
                    let privateDictToUse = privateDict;
                    if (fdSelect && fdArray.length) {
                      const fdIndex = fdSelect.getFDIndex(i);
                      if (fdIndex === -1) {
                        (0, _util.warn)("Glyph index is not in fd select.");
                        valid = false;
                      }
                      if (fdIndex >= fdArray.length) {
                        (0, _util.warn)("Invalid fd index for glyph index.");
                        valid = false;
                      }
                      if (valid) {
                        privateDictToUse = fdArray[fdIndex].privateDict;
                        localSubrToUse = privateDictToUse.subrsIndex;
                      }
                    } else if (localSubrIndex) {
                      localSubrToUse = localSubrIndex;
                    }
                    if (valid) {
                      valid = this.parseCharString(state, charstring, localSubrToUse, globalSubrIndex);
                    }
                    if (state.width !== null) {
                      const nominalWidth = privateDictToUse.getByName("nominalWidthX");
                      widths[i] = nominalWidth + state.width;
                    } else {
                      const defaultWidth = privateDictToUse.getByName("defaultWidthX");
                      widths[i] = defaultWidth;
                    }
                    if (state.seac !== null) {
                      seacs[i] = state.seac;
                    }
                    if (!valid) {
                      charStrings.set(i, new Uint8Array([14]));
                    }
                  }
                  return {
                    charStrings,
                    seacs,
                    widths
                  };
                }
                emptyPrivateDictionary(parentDict) {
                  const privateDict = this.createDict(CFFPrivateDict, [], parentDict.strings);
                  parentDict.setByKey(18, [0, 0]);
                  parentDict.privateDict = privateDict;
                }
                parsePrivateDict(parentDict) {
                  if (!parentDict.hasName("Private")) {
                    this.emptyPrivateDictionary(parentDict);
                    return;
                  }
                  const privateOffset = parentDict.getByName("Private");
                  if (!Array.isArray(privateOffset) || privateOffset.length !== 2) {
                    parentDict.removeByName("Private");
                    return;
                  }
                  const size = privateOffset[0];
                  const offset = privateOffset[1];
                  if (size === 0 || offset >= this.bytes.length) {
                    this.emptyPrivateDictionary(parentDict);
                    return;
                  }
                  const privateDictEnd = offset + size;
                  const dictData = this.bytes.subarray(offset, privateDictEnd);
                  const dict = this.parseDict(dictData);
                  const privateDict = this.createDict(CFFPrivateDict, dict, parentDict.strings);
                  parentDict.privateDict = privateDict;
                  if (privateDict.getByName("ExpansionFactor") === 0) {
                    privateDict.setByName("ExpansionFactor", 0.06);
                  }
                  if (!privateDict.getByName("Subrs")) {
                    return;
                  }
                  const subrsOffset = privateDict.getByName("Subrs");
                  const relativeOffset = offset + subrsOffset;
                  if (subrsOffset === 0 || relativeOffset >= this.bytes.length) {
                    this.emptyPrivateDictionary(parentDict);
                    return;
                  }
                  const subrsIndex = this.parseIndex(relativeOffset);
                  privateDict.subrsIndex = subrsIndex.obj;
                }
                parseCharsets(pos, length, strings, cid) {
                  if (pos === 0) {
                    return new CFFCharset(true, CFFCharsetPredefinedTypes.ISO_ADOBE, _charsets.ISOAdobeCharset);
                  } else if (pos === 1) {
                    return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT, _charsets.ExpertCharset);
                  } else if (pos === 2) {
                    return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT_SUBSET, _charsets.ExpertSubsetCharset);
                  }
                  const bytes = this.bytes;
                  const start = pos;
                  const format = bytes[pos++];
                  const charset = [cid ? 0 : ".notdef"];
                  let id, count, i;
                  length -= 1;
                  switch (format) {
                    case 0:
                      for (i = 0; i < length; i++) {
                        id = bytes[pos++] << 8 | bytes[pos++];
                        charset.push(cid ? id : strings.get(id));
                      }
                      break;
                    case 1:
                      while (charset.length <= length) {
                        id = bytes[pos++] << 8 | bytes[pos++];
                        count = bytes[pos++];
                        for (i = 0; i <= count; i++) {
                          charset.push(cid ? id++ : strings.get(id++));
                        }
                      }
                      break;
                    case 2:
                      while (charset.length <= length) {
                        id = bytes[pos++] << 8 | bytes[pos++];
                        count = bytes[pos++] << 8 | bytes[pos++];
                        for (i = 0; i <= count; i++) {
                          charset.push(cid ? id++ : strings.get(id++));
                        }
                      }
                      break;
                    default:
                      throw new _util.FormatError("Unknown charset format");
                  }
                  const end = pos;
                  const raw = bytes.subarray(start, end);
                  return new CFFCharset(false, format, charset, raw);
                }
                parseEncoding(pos, properties, strings, charset) {
                  const encoding = /* @__PURE__ */ Object.create(null);
                  const bytes = this.bytes;
                  let predefined = false;
                  let format, i, ii;
                  let raw = null;
                  function readSupplement() {
                    const supplementsCount = bytes[pos++];
                    for (i = 0; i < supplementsCount; i++) {
                      const code = bytes[pos++];
                      const sid = (bytes[pos++] << 8) + (bytes[pos++] & 255);
                      encoding[code] = charset.indexOf(strings.get(sid));
                    }
                  }
                  if (pos === 0 || pos === 1) {
                    predefined = true;
                    format = pos;
                    const baseEncoding = pos ? _encodings.ExpertEncoding : _encodings.StandardEncoding;
                    for (i = 0, ii = charset.length; i < ii; i++) {
                      const index = baseEncoding.indexOf(charset[i]);
                      if (index !== -1) {
                        encoding[index] = i;
                      }
                    }
                  } else {
                    const dataStart = pos;
                    format = bytes[pos++];
                    switch (format & 127) {
                      case 0:
                        const glyphsCount = bytes[pos++];
                        for (i = 1; i <= glyphsCount; i++) {
                          encoding[bytes[pos++]] = i;
                        }
                        break;
                      case 1:
                        const rangesCount = bytes[pos++];
                        let gid = 1;
                        for (i = 0; i < rangesCount; i++) {
                          const start = bytes[pos++];
                          const left = bytes[pos++];
                          for (let j = start; j <= start + left; j++) {
                            encoding[j] = gid++;
                          }
                        }
                        break;
                      default:
                        throw new _util.FormatError(`Unknown encoding format: ${format} in CFF`);
                    }
                    const dataEnd = pos;
                    if (format & 128) {
                      bytes[dataStart] &= 127;
                      readSupplement();
                    }
                    raw = bytes.subarray(dataStart, dataEnd);
                  }
                  format &= 127;
                  return new CFFEncoding(predefined, format, encoding, raw);
                }
                parseFDSelect(pos, length) {
                  const bytes = this.bytes;
                  const format = bytes[pos++];
                  const fdSelect = [];
                  let i;
                  switch (format) {
                    case 0:
                      for (i = 0; i < length; ++i) {
                        const id = bytes[pos++];
                        fdSelect.push(id);
                      }
                      break;
                    case 3:
                      const rangesCount = bytes[pos++] << 8 | bytes[pos++];
                      for (i = 0; i < rangesCount; ++i) {
                        let first = bytes[pos++] << 8 | bytes[pos++];
                        if (i === 0 && first !== 0) {
                          (0, _util.warn)("parseFDSelect: The first range must have a first GID of 0 -- trying to recover.");
                          first = 0;
                        }
                        const fdIndex = bytes[pos++];
                        const next = bytes[pos] << 8 | bytes[pos + 1];
                        for (let j = first; j < next; ++j) {
                          fdSelect.push(fdIndex);
                        }
                      }
                      pos += 2;
                      break;
                    default:
                      throw new _util.FormatError(`parseFDSelect: Unknown format "${format}".`);
                  }
                  if (fdSelect.length !== length) {
                    throw new _util.FormatError("parseFDSelect: Invalid font data.");
                  }
                  return new CFFFDSelect(format, fdSelect);
                }
              }
              exports2.CFFParser = CFFParser;
              class CFF {
                constructor() {
                  this.header = null;
                  this.names = [];
                  this.topDict = null;
                  this.strings = new CFFStrings();
                  this.globalSubrIndex = null;
                  this.encoding = null;
                  this.charset = null;
                  this.charStrings = null;
                  this.fdArray = [];
                  this.fdSelect = null;
                  this.isCIDFont = false;
                }
                duplicateFirstGlyph() {
                  if (this.charStrings.count >= 65535) {
                    (0, _util.warn)("Not enough space in charstrings to duplicate first glyph.");
                    return;
                  }
                  const glyphZero = this.charStrings.get(0);
                  this.charStrings.add(glyphZero);
                  if (this.isCIDFont) {
                    this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
                  }
                }
                hasGlyphId(id) {
                  if (id < 0 || id >= this.charStrings.count) {
                    return false;
                  }
                  const glyph = this.charStrings.get(id);
                  return glyph.length > 0;
                }
              }
              exports2.CFF = CFF;
              class CFFHeader {
                constructor(major, minor, hdrSize, offSize) {
                  this.major = major;
                  this.minor = minor;
                  this.hdrSize = hdrSize;
                  this.offSize = offSize;
                }
              }
              exports2.CFFHeader = CFFHeader;
              class CFFStrings {
                constructor() {
                  this.strings = [];
                }
                get(index) {
                  if (index >= 0 && index <= NUM_STANDARD_CFF_STRINGS - 1) {
                    return CFFStandardStrings[index];
                  }
                  if (index - NUM_STANDARD_CFF_STRINGS <= this.strings.length) {
                    return this.strings[index - NUM_STANDARD_CFF_STRINGS];
                  }
                  return CFFStandardStrings[0];
                }
                getSID(str) {
                  let index = CFFStandardStrings.indexOf(str);
                  if (index !== -1) {
                    return index;
                  }
                  index = this.strings.indexOf(str);
                  if (index !== -1) {
                    return index + NUM_STANDARD_CFF_STRINGS;
                  }
                  return -1;
                }
                add(value) {
                  this.strings.push(value);
                }
                get count() {
                  return this.strings.length;
                }
              }
              exports2.CFFStrings = CFFStrings;
              class CFFIndex {
                constructor() {
                  this.objects = [];
                  this.length = 0;
                }
                add(data) {
                  this.length += data.length;
                  this.objects.push(data);
                }
                set(index, data) {
                  this.length += data.length - this.objects[index].length;
                  this.objects[index] = data;
                }
                get(index) {
                  return this.objects[index];
                }
                get count() {
                  return this.objects.length;
                }
              }
              exports2.CFFIndex = CFFIndex;
              class CFFDict {
                constructor(tables, strings) {
                  this.keyToNameMap = tables.keyToNameMap;
                  this.nameToKeyMap = tables.nameToKeyMap;
                  this.defaults = tables.defaults;
                  this.types = tables.types;
                  this.opcodes = tables.opcodes;
                  this.order = tables.order;
                  this.strings = strings;
                  this.values = /* @__PURE__ */ Object.create(null);
                }
                setByKey(key, value) {
                  if (!(key in this.keyToNameMap)) {
                    return false;
                  }
                  if (value.length === 0) {
                    return true;
                  }
                  for (const val of value) {
                    if (isNaN(val)) {
                      (0, _util.warn)(`Invalid CFFDict value: "${value}" for key "${key}".`);
                      return true;
                    }
                  }
                  const type = this.types[key];
                  if (type === "num" || type === "sid" || type === "offset") {
                    value = value[0];
                  }
                  this.values[key] = value;
                  return true;
                }
                setByName(name, value) {
                  if (!(name in this.nameToKeyMap)) {
                    throw new _util.FormatError(`Invalid dictionary name "${name}"`);
                  }
                  this.values[this.nameToKeyMap[name]] = value;
                }
                hasName(name) {
                  return this.nameToKeyMap[name] in this.values;
                }
                getByName(name) {
                  if (!(name in this.nameToKeyMap)) {
                    throw new _util.FormatError(`Invalid dictionary name ${name}"`);
                  }
                  const key = this.nameToKeyMap[name];
                  if (!(key in this.values)) {
                    return this.defaults[key];
                  }
                  return this.values[key];
                }
                removeByName(name) {
                  delete this.values[this.nameToKeyMap[name]];
                }
                static createTables(layout) {
                  const tables = {
                    keyToNameMap: {},
                    nameToKeyMap: {},
                    defaults: {},
                    types: {},
                    opcodes: {},
                    order: []
                  };
                  for (const entry of layout) {
                    const key = Array.isArray(entry[0]) ? (entry[0][0] << 8) + entry[0][1] : entry[0];
                    tables.keyToNameMap[key] = entry[1];
                    tables.nameToKeyMap[entry[1]] = key;
                    tables.types[key] = entry[2];
                    tables.defaults[key] = entry[3];
                    tables.opcodes[key] = Array.isArray(entry[0]) ? entry[0] : [entry[0]];
                    tables.order.push(key);
                  }
                  return tables;
                }
              }
              const CFFTopDictLayout = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
              class CFFTopDict extends CFFDict {
                static get tables() {
                  return (0, _util.shadow)(this, "tables", this.createTables(CFFTopDictLayout));
                }
                constructor(strings) {
                  super(CFFTopDict.tables, strings);
                  this.privateDict = null;
                }
              }
              exports2.CFFTopDict = CFFTopDict;
              const CFFPrivateDictLayout = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
              class CFFPrivateDict extends CFFDict {
                static get tables() {
                  return (0, _util.shadow)(this, "tables", this.createTables(CFFPrivateDictLayout));
                }
                constructor(strings) {
                  super(CFFPrivateDict.tables, strings);
                  this.subrsIndex = null;
                }
              }
              exports2.CFFPrivateDict = CFFPrivateDict;
              const CFFCharsetPredefinedTypes = {
                ISO_ADOBE: 0,
                EXPERT: 1,
                EXPERT_SUBSET: 2
              };
              class CFFCharset {
                constructor(predefined, format, charset, raw) {
                  this.predefined = predefined;
                  this.format = format;
                  this.charset = charset;
                  this.raw = raw;
                }
              }
              exports2.CFFCharset = CFFCharset;
              class CFFEncoding {
                constructor(predefined, format, encoding, raw) {
                  this.predefined = predefined;
                  this.format = format;
                  this.encoding = encoding;
                  this.raw = raw;
                }
              }
              class CFFFDSelect {
                constructor(format, fdSelect) {
                  this.format = format;
                  this.fdSelect = fdSelect;
                }
                getFDIndex(glyphIndex) {
                  if (glyphIndex < 0 || glyphIndex >= this.fdSelect.length) {
                    return -1;
                  }
                  return this.fdSelect[glyphIndex];
                }
              }
              exports2.CFFFDSelect = CFFFDSelect;
              class CFFOffsetTracker {
                constructor() {
                  this.offsets = /* @__PURE__ */ Object.create(null);
                }
                isTracking(key) {
                  return key in this.offsets;
                }
                track(key, location) {
                  if (key in this.offsets) {
                    throw new _util.FormatError(`Already tracking location of ${key}`);
                  }
                  this.offsets[key] = location;
                }
                offset(value) {
                  for (const key in this.offsets) {
                    this.offsets[key] += value;
                  }
                }
                setEntryLocation(key, values, output) {
                  if (!(key in this.offsets)) {
                    throw new _util.FormatError(`Not tracking location of ${key}`);
                  }
                  const data = output.data;
                  const dataOffset = this.offsets[key];
                  const size = 5;
                  for (let i = 0, ii = values.length; i < ii; ++i) {
                    const offset0 = i * size + dataOffset;
                    const offset1 = offset0 + 1;
                    const offset2 = offset0 + 2;
                    const offset3 = offset0 + 3;
                    const offset4 = offset0 + 4;
                    if (data[offset0] !== 29 || data[offset1] !== 0 || data[offset2] !== 0 || data[offset3] !== 0 || data[offset4] !== 0) {
                      throw new _util.FormatError("writing to an offset that is not empty");
                    }
                    const value = values[i];
                    data[offset0] = 29;
                    data[offset1] = value >> 24 & 255;
                    data[offset2] = value >> 16 & 255;
                    data[offset3] = value >> 8 & 255;
                    data[offset4] = value & 255;
                  }
                }
              }
              class CFFCompiler {
                constructor(cff) {
                  this.cff = cff;
                }
                compile() {
                  const cff = this.cff;
                  const output = {
                    data: [],
                    length: 0,
                    add(data) {
                      try {
                        this.data.push(...data);
                      } catch {
                        this.data = this.data.concat(data);
                      }
                      this.length = this.data.length;
                    }
                  };
                  const header = this.compileHeader(cff.header);
                  output.add(header);
                  const nameIndex = this.compileNameIndex(cff.names);
                  output.add(nameIndex);
                  if (cff.isCIDFont) {
                    if (cff.topDict.hasName("FontMatrix")) {
                      const base = cff.topDict.getByName("FontMatrix");
                      cff.topDict.removeByName("FontMatrix");
                      for (const subDict of cff.fdArray) {
                        let matrix = base.slice(0);
                        if (subDict.hasName("FontMatrix")) {
                          matrix = _util.Util.transform(matrix, subDict.getByName("FontMatrix"));
                        }
                        subDict.setByName("FontMatrix", matrix);
                      }
                    }
                  }
                  const xuid = cff.topDict.getByName("XUID");
                  if ((xuid == null ? void 0 : xuid.length) > 16) {
                    cff.topDict.removeByName("XUID");
                  }
                  cff.topDict.setByName("charset", 0);
                  let compiled = this.compileTopDicts([cff.topDict], output.length, cff.isCIDFont);
                  output.add(compiled.output);
                  const topDictTracker = compiled.trackers[0];
                  const stringIndex = this.compileStringIndex(cff.strings.strings);
                  output.add(stringIndex);
                  const globalSubrIndex = this.compileIndex(cff.globalSubrIndex);
                  output.add(globalSubrIndex);
                  if (cff.encoding && cff.topDict.hasName("Encoding")) {
                    if (cff.encoding.predefined) {
                      topDictTracker.setEntryLocation("Encoding", [cff.encoding.format], output);
                    } else {
                      const encoding = this.compileEncoding(cff.encoding);
                      topDictTracker.setEntryLocation("Encoding", [output.length], output);
                      output.add(encoding);
                    }
                  }
                  const charset = this.compileCharset(cff.charset, cff.charStrings.count, cff.strings, cff.isCIDFont);
                  topDictTracker.setEntryLocation("charset", [output.length], output);
                  output.add(charset);
                  const charStrings = this.compileCharStrings(cff.charStrings);
                  topDictTracker.setEntryLocation("CharStrings", [output.length], output);
                  output.add(charStrings);
                  if (cff.isCIDFont) {
                    topDictTracker.setEntryLocation("FDSelect", [output.length], output);
                    const fdSelect = this.compileFDSelect(cff.fdSelect);
                    output.add(fdSelect);
                    compiled = this.compileTopDicts(cff.fdArray, output.length, true);
                    topDictTracker.setEntryLocation("FDArray", [output.length], output);
                    output.add(compiled.output);
                    const fontDictTrackers = compiled.trackers;
                    this.compilePrivateDicts(cff.fdArray, fontDictTrackers, output);
                  }
                  this.compilePrivateDicts([cff.topDict], [topDictTracker], output);
                  output.add([0]);
                  return output.data;
                }
                encodeNumber(value) {
                  if (Number.isInteger(value)) {
                    return this.encodeInteger(value);
                  }
                  return this.encodeFloat(value);
                }
                static get EncodeFloatRegExp() {
                  return (0, _util.shadow)(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
                }
                encodeFloat(num) {
                  let value = num.toString();
                  const m = CFFCompiler.EncodeFloatRegExp.exec(value);
                  if (m) {
                    const epsilon = parseFloat("1e" + ((m[2] ? +m[2] : 0) + m[1].length));
                    value = (Math.round(num * epsilon) / epsilon).toString();
                  }
                  let nibbles = "";
                  let i, ii;
                  for (i = 0, ii = value.length; i < ii; ++i) {
                    const a = value[i];
                    if (a === "e") {
                      nibbles += value[++i] === "-" ? "c" : "b";
                    } else if (a === ".") {
                      nibbles += "a";
                    } else if (a === "-") {
                      nibbles += "e";
                    } else {
                      nibbles += a;
                    }
                  }
                  nibbles += nibbles.length & 1 ? "f" : "ff";
                  const out = [30];
                  for (i = 0, ii = nibbles.length; i < ii; i += 2) {
                    out.push(parseInt(nibbles.substring(i, i + 2), 16));
                  }
                  return out;
                }
                encodeInteger(value) {
                  let code;
                  if (value >= -107 && value <= 107) {
                    code = [value + 139];
                  } else if (value >= 108 && value <= 1131) {
                    value -= 108;
                    code = [(value >> 8) + 247, value & 255];
                  } else if (value >= -1131 && value <= -108) {
                    value = -value - 108;
                    code = [(value >> 8) + 251, value & 255];
                  } else if (value >= -32768 && value <= 32767) {
                    code = [28, value >> 8 & 255, value & 255];
                  } else {
                    code = [29, value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255];
                  }
                  return code;
                }
                compileHeader(header) {
                  return [header.major, header.minor, 4, header.offSize];
                }
                compileNameIndex(names) {
                  const nameIndex = new CFFIndex();
                  for (const name of names) {
                    const length = Math.min(name.length, 127);
                    let sanitizedName = new Array(length);
                    for (let j = 0; j < length; j++) {
                      let char = name[j];
                      if (char < "!" || char > "~" || char === "[" || char === "]" || char === "(" || char === ")" || char === "{" || char === "}" || char === "<" || char === ">" || char === "/" || char === "%") {
                        char = "_";
                      }
                      sanitizedName[j] = char;
                    }
                    sanitizedName = sanitizedName.join("");
                    if (sanitizedName === "") {
                      sanitizedName = "Bad_Font_Name";
                    }
                    nameIndex.add((0, _util.stringToBytes)(sanitizedName));
                  }
                  return this.compileIndex(nameIndex);
                }
                compileTopDicts(dicts, length, removeCidKeys) {
                  const fontDictTrackers = [];
                  let fdArrayIndex = new CFFIndex();
                  for (const fontDict of dicts) {
                    if (removeCidKeys) {
                      fontDict.removeByName("CIDFontVersion");
                      fontDict.removeByName("CIDFontRevision");
                      fontDict.removeByName("CIDFontType");
                      fontDict.removeByName("CIDCount");
                      fontDict.removeByName("UIDBase");
                    }
                    const fontDictTracker = new CFFOffsetTracker();
                    const fontDictData = this.compileDict(fontDict, fontDictTracker);
                    fontDictTrackers.push(fontDictTracker);
                    fdArrayIndex.add(fontDictData);
                    fontDictTracker.offset(length);
                  }
                  fdArrayIndex = this.compileIndex(fdArrayIndex, fontDictTrackers);
                  return {
                    trackers: fontDictTrackers,
                    output: fdArrayIndex
                  };
                }
                compilePrivateDicts(dicts, trackers, output) {
                  for (let i = 0, ii = dicts.length; i < ii; ++i) {
                    const fontDict = dicts[i];
                    const privateDict = fontDict.privateDict;
                    if (!privateDict || !fontDict.hasName("Private")) {
                      throw new _util.FormatError("There must be a private dictionary.");
                    }
                    const privateDictTracker = new CFFOffsetTracker();
                    const privateDictData = this.compileDict(privateDict, privateDictTracker);
                    let outputLength = output.length;
                    privateDictTracker.offset(outputLength);
                    if (!privateDictData.length) {
                      outputLength = 0;
                    }
                    trackers[i].setEntryLocation("Private", [privateDictData.length, outputLength], output);
                    output.add(privateDictData);
                    if (privateDict.subrsIndex && privateDict.hasName("Subrs")) {
                      const subrs = this.compileIndex(privateDict.subrsIndex);
                      privateDictTracker.setEntryLocation("Subrs", [privateDictData.length], output);
                      output.add(subrs);
                    }
                  }
                }
                compileDict(dict, offsetTracker) {
                  const out = [];
                  for (const key of dict.order) {
                    if (!(key in dict.values)) {
                      continue;
                    }
                    let values = dict.values[key];
                    let types = dict.types[key];
                    if (!Array.isArray(types)) {
                      types = [types];
                    }
                    if (!Array.isArray(values)) {
                      values = [values];
                    }
                    if (values.length === 0) {
                      continue;
                    }
                    for (let j = 0, jj = types.length; j < jj; ++j) {
                      const type = types[j];
                      const value = values[j];
                      switch (type) {
                        case "num":
                        case "sid":
                          out.push(...this.encodeNumber(value));
                          break;
                        case "offset":
                          const name = dict.keyToNameMap[key];
                          if (!offsetTracker.isTracking(name)) {
                            offsetTracker.track(name, out.length);
                          }
                          out.push(29, 0, 0, 0, 0);
                          break;
                        case "array":
                        case "delta":
                          out.push(...this.encodeNumber(value));
                          for (let k = 1, kk = values.length; k < kk; ++k) {
                            out.push(...this.encodeNumber(values[k]));
                          }
                          break;
                        default:
                          throw new _util.FormatError(`Unknown data type of ${type}`);
                      }
                    }
                    out.push(...dict.opcodes[key]);
                  }
                  return out;
                }
                compileStringIndex(strings) {
                  const stringIndex = new CFFIndex();
                  for (const string of strings) {
                    stringIndex.add((0, _util.stringToBytes)(string));
                  }
                  return this.compileIndex(stringIndex);
                }
                compileCharStrings(charStrings) {
                  const charStringsIndex = new CFFIndex();
                  for (let i = 0; i < charStrings.count; i++) {
                    const glyph = charStrings.get(i);
                    if (glyph.length === 0) {
                      charStringsIndex.add(new Uint8Array([139, 14]));
                      continue;
                    }
                    charStringsIndex.add(glyph);
                  }
                  return this.compileIndex(charStringsIndex);
                }
                compileCharset(charset, numGlyphs, strings, isCIDFont) {
                  let out;
                  const numGlyphsLessNotDef = numGlyphs - 1;
                  if (isCIDFont) {
                    out = new Uint8Array([2, 0, 0, numGlyphsLessNotDef >> 8 & 255, numGlyphsLessNotDef & 255]);
                  } else {
                    const length = 1 + numGlyphsLessNotDef * 2;
                    out = new Uint8Array(length);
                    out[0] = 0;
                    let charsetIndex = 0;
                    const numCharsets = charset.charset.length;
                    let warned = false;
                    for (let i = 1; i < out.length; i += 2) {
                      let sid = 0;
                      if (charsetIndex < numCharsets) {
                        const name = charset.charset[charsetIndex++];
                        sid = strings.getSID(name);
                        if (sid === -1) {
                          sid = 0;
                          if (!warned) {
                            warned = true;
                            (0, _util.warn)(`Couldn't find ${name} in CFF strings`);
                          }
                        }
                      }
                      out[i] = sid >> 8 & 255;
                      out[i + 1] = sid & 255;
                    }
                  }
                  return this.compileTypedArray(out);
                }
                compileEncoding(encoding) {
                  return this.compileTypedArray(encoding.raw);
                }
                compileFDSelect(fdSelect) {
                  const format = fdSelect.format;
                  let out, i;
                  switch (format) {
                    case 0:
                      out = new Uint8Array(1 + fdSelect.fdSelect.length);
                      out[0] = format;
                      for (i = 0; i < fdSelect.fdSelect.length; i++) {
                        out[i + 1] = fdSelect.fdSelect[i];
                      }
                      break;
                    case 3:
                      const start = 0;
                      let lastFD = fdSelect.fdSelect[0];
                      const ranges = [format, 0, 0, start >> 8 & 255, start & 255, lastFD];
                      for (i = 1; i < fdSelect.fdSelect.length; i++) {
                        const currentFD = fdSelect.fdSelect[i];
                        if (currentFD !== lastFD) {
                          ranges.push(i >> 8 & 255, i & 255, currentFD);
                          lastFD = currentFD;
                        }
                      }
                      const numRanges = (ranges.length - 3) / 3;
                      ranges[1] = numRanges >> 8 & 255;
                      ranges[2] = numRanges & 255;
                      ranges.push(i >> 8 & 255, i & 255);
                      out = new Uint8Array(ranges);
                      break;
                  }
                  return this.compileTypedArray(out);
                }
                compileTypedArray(data) {
                  return Array.from(data);
                }
                compileIndex(index, trackers = []) {
                  const objects = index.objects;
                  const count = objects.length;
                  if (count === 0) {
                    return [0, 0];
                  }
                  const data = [count >> 8 & 255, count & 255];
                  let lastOffset = 1, i;
                  for (i = 0; i < count; ++i) {
                    lastOffset += objects[i].length;
                  }
                  let offsetSize;
                  if (lastOffset < 256) {
                    offsetSize = 1;
                  } else if (lastOffset < 65536) {
                    offsetSize = 2;
                  } else if (lastOffset < 16777216) {
                    offsetSize = 3;
                  } else {
                    offsetSize = 4;
                  }
                  data.push(offsetSize);
                  let relativeOffset = 1;
                  for (i = 0; i < count + 1; i++) {
                    if (offsetSize === 1) {
                      data.push(relativeOffset & 255);
                    } else if (offsetSize === 2) {
                      data.push(relativeOffset >> 8 & 255, relativeOffset & 255);
                    } else if (offsetSize === 3) {
                      data.push(relativeOffset >> 16 & 255, relativeOffset >> 8 & 255, relativeOffset & 255);
                    } else {
                      data.push(relativeOffset >>> 24 & 255, relativeOffset >> 16 & 255, relativeOffset >> 8 & 255, relativeOffset & 255);
                    }
                    if (objects[i]) {
                      relativeOffset += objects[i].length;
                    }
                  }
                  for (i = 0; i < count; i++) {
                    if (trackers[i]) {
                      trackers[i].offset(data.length);
                    }
                    data.push(...objects[i]);
                  }
                  return data;
                }
              }
              exports2.CFFCompiler = CFFCompiler;
            },
            /* 36 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ISOAdobeCharset = exports2.ExpertSubsetCharset = exports2.ExpertCharset = void 0;
              const ISOAdobeCharset = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
              exports2.ISOAdobeCharset = ISOAdobeCharset;
              const ExpertCharset = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
              exports2.ExpertCharset = ExpertCharset;
              const ExpertSubsetCharset = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
              exports2.ExpertSubsetCharset = ExpertSubsetCharset;
            },
            /* 37 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ZapfDingbatsEncoding = exports2.WinAnsiEncoding = exports2.SymbolSetEncoding = exports2.StandardEncoding = exports2.MacRomanEncoding = exports2.ExpertEncoding = void 0;
              exports2.getEncoding = getEncoding;
              const ExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
              exports2.ExpertEncoding = ExpertEncoding;
              const MacExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];
              const MacRomanEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
              exports2.MacRomanEncoding = MacRomanEncoding;
              const StandardEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
              exports2.StandardEncoding = StandardEncoding;
              const WinAnsiEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
              exports2.WinAnsiEncoding = WinAnsiEncoding;
              const SymbolSetEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
              exports2.SymbolSetEncoding = SymbolSetEncoding;
              const ZapfDingbatsEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
              exports2.ZapfDingbatsEncoding = ZapfDingbatsEncoding;
              function getEncoding(encodingName) {
                switch (encodingName) {
                  case "WinAnsiEncoding":
                    return WinAnsiEncoding;
                  case "StandardEncoding":
                    return StandardEncoding;
                  case "MacRomanEncoding":
                    return MacRomanEncoding;
                  case "SymbolSetEncoding":
                    return SymbolSetEncoding;
                  case "ZapfDingbatsEncoding":
                    return ZapfDingbatsEncoding;
                  case "ExpertEncoding":
                    return ExpertEncoding;
                  case "MacExpertEncoding":
                    return MacExpertEncoding;
                  default:
                    return null;
                }
              }
            },
            /* 38 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SEAC_ANALYSIS_ENABLED = exports2.MacStandardGlyphOrdering = exports2.FontFlags = void 0;
              exports2.normalizeFontName = normalizeFontName;
              exports2.recoverGlyphName = recoverGlyphName;
              exports2.type1FontGlyphMapping = type1FontGlyphMapping;
              var _encodings = __w_pdfjs_require__2(37);
              var _glyphlist = __w_pdfjs_require__2(39);
              var _unicode = __w_pdfjs_require__2(40);
              var _util = __w_pdfjs_require__2(2);
              const SEAC_ANALYSIS_ENABLED = true;
              exports2.SEAC_ANALYSIS_ENABLED = SEAC_ANALYSIS_ENABLED;
              const FontFlags = {
                FixedPitch: 1,
                Serif: 2,
                Symbolic: 4,
                Script: 8,
                Nonsymbolic: 32,
                Italic: 64,
                AllCap: 65536,
                SmallCap: 131072,
                ForceBold: 262144
              };
              exports2.FontFlags = FontFlags;
              const MacStandardGlyphOrdering = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
              exports2.MacStandardGlyphOrdering = MacStandardGlyphOrdering;
              function recoverGlyphName(name, glyphsUnicodeMap) {
                if (glyphsUnicodeMap[name] !== void 0) {
                  return name;
                }
                const unicode = (0, _unicode.getUnicodeForGlyph)(name, glyphsUnicodeMap);
                if (unicode !== -1) {
                  for (const key in glyphsUnicodeMap) {
                    if (glyphsUnicodeMap[key] === unicode) {
                      return key;
                    }
                  }
                }
                (0, _util.info)("Unable to recover a standard glyph name for: " + name);
                return name;
              }
              function type1FontGlyphMapping(properties, builtInEncoding, glyphNames) {
                const charCodeToGlyphId = /* @__PURE__ */ Object.create(null);
                let glyphId, charCode, baseEncoding;
                const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
                if (properties.isInternalFont) {
                  baseEncoding = builtInEncoding;
                  for (charCode = 0; charCode < baseEncoding.length; charCode++) {
                    glyphId = glyphNames.indexOf(baseEncoding[charCode]);
                    charCodeToGlyphId[charCode] = glyphId >= 0 ? glyphId : 0;
                  }
                } else if (properties.baseEncodingName) {
                  baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);
                  for (charCode = 0; charCode < baseEncoding.length; charCode++) {
                    glyphId = glyphNames.indexOf(baseEncoding[charCode]);
                    charCodeToGlyphId[charCode] = glyphId >= 0 ? glyphId : 0;
                  }
                } else if (isSymbolicFont) {
                  for (charCode in builtInEncoding) {
                    charCodeToGlyphId[charCode] = builtInEncoding[charCode];
                  }
                } else {
                  baseEncoding = _encodings.StandardEncoding;
                  for (charCode = 0; charCode < baseEncoding.length; charCode++) {
                    glyphId = glyphNames.indexOf(baseEncoding[charCode]);
                    charCodeToGlyphId[charCode] = glyphId >= 0 ? glyphId : 0;
                  }
                }
                const differences = properties.differences;
                let glyphsUnicodeMap;
                if (differences) {
                  for (charCode in differences) {
                    const glyphName = differences[charCode];
                    glyphId = glyphNames.indexOf(glyphName);
                    if (glyphId === -1) {
                      if (!glyphsUnicodeMap) {
                        glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                      }
                      const standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);
                      if (standardGlyphName !== glyphName) {
                        glyphId = glyphNames.indexOf(standardGlyphName);
                      }
                    }
                    charCodeToGlyphId[charCode] = glyphId >= 0 ? glyphId : 0;
                  }
                }
                return charCodeToGlyphId;
              }
              function normalizeFontName(name) {
                return name.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
              }
            },
            /* 39 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.getGlyphsUnicode = exports2.getDingbatsGlyphsUnicode = void 0;
              var _core_utils = __w_pdfjs_require__2(3);
              const getGlyphsUnicode = (0, _core_utils.getLookupTableFactory)(function(t) {
                t.A = 65;
                t.AE = 198;
                t.AEacute = 508;
                t.AEmacron = 482;
                t.AEsmall = 63462;
                t.Aacute = 193;
                t.Aacutesmall = 63457;
                t.Abreve = 258;
                t.Abreveacute = 7854;
                t.Abrevecyrillic = 1232;
                t.Abrevedotbelow = 7862;
                t.Abrevegrave = 7856;
                t.Abrevehookabove = 7858;
                t.Abrevetilde = 7860;
                t.Acaron = 461;
                t.Acircle = 9398;
                t.Acircumflex = 194;
                t.Acircumflexacute = 7844;
                t.Acircumflexdotbelow = 7852;
                t.Acircumflexgrave = 7846;
                t.Acircumflexhookabove = 7848;
                t.Acircumflexsmall = 63458;
                t.Acircumflextilde = 7850;
                t.Acute = 63177;
                t.Acutesmall = 63412;
                t.Acyrillic = 1040;
                t.Adblgrave = 512;
                t.Adieresis = 196;
                t.Adieresiscyrillic = 1234;
                t.Adieresismacron = 478;
                t.Adieresissmall = 63460;
                t.Adotbelow = 7840;
                t.Adotmacron = 480;
                t.Agrave = 192;
                t.Agravesmall = 63456;
                t.Ahookabove = 7842;
                t.Aiecyrillic = 1236;
                t.Ainvertedbreve = 514;
                t.Alpha = 913;
                t.Alphatonos = 902;
                t.Amacron = 256;
                t.Amonospace = 65313;
                t.Aogonek = 260;
                t.Aring = 197;
                t.Aringacute = 506;
                t.Aringbelow = 7680;
                t.Aringsmall = 63461;
                t.Asmall = 63329;
                t.Atilde = 195;
                t.Atildesmall = 63459;
                t.Aybarmenian = 1329;
                t.B = 66;
                t.Bcircle = 9399;
                t.Bdotaccent = 7682;
                t.Bdotbelow = 7684;
                t.Becyrillic = 1041;
                t.Benarmenian = 1330;
                t.Beta = 914;
                t.Bhook = 385;
                t.Blinebelow = 7686;
                t.Bmonospace = 65314;
                t.Brevesmall = 63220;
                t.Bsmall = 63330;
                t.Btopbar = 386;
                t.C = 67;
                t.Caarmenian = 1342;
                t.Cacute = 262;
                t.Caron = 63178;
                t.Caronsmall = 63221;
                t.Ccaron = 268;
                t.Ccedilla = 199;
                t.Ccedillaacute = 7688;
                t.Ccedillasmall = 63463;
                t.Ccircle = 9400;
                t.Ccircumflex = 264;
                t.Cdot = 266;
                t.Cdotaccent = 266;
                t.Cedillasmall = 63416;
                t.Chaarmenian = 1353;
                t.Cheabkhasiancyrillic = 1212;
                t.Checyrillic = 1063;
                t.Chedescenderabkhasiancyrillic = 1214;
                t.Chedescendercyrillic = 1206;
                t.Chedieresiscyrillic = 1268;
                t.Cheharmenian = 1347;
                t.Chekhakassiancyrillic = 1227;
                t.Cheverticalstrokecyrillic = 1208;
                t.Chi = 935;
                t.Chook = 391;
                t.Circumflexsmall = 63222;
                t.Cmonospace = 65315;
                t.Coarmenian = 1361;
                t.Csmall = 63331;
                t.D = 68;
                t.DZ = 497;
                t.DZcaron = 452;
                t.Daarmenian = 1332;
                t.Dafrican = 393;
                t.Dcaron = 270;
                t.Dcedilla = 7696;
                t.Dcircle = 9401;
                t.Dcircumflexbelow = 7698;
                t.Dcroat = 272;
                t.Ddotaccent = 7690;
                t.Ddotbelow = 7692;
                t.Decyrillic = 1044;
                t.Deicoptic = 1006;
                t.Delta = 8710;
                t.Deltagreek = 916;
                t.Dhook = 394;
                t.Dieresis = 63179;
                t.DieresisAcute = 63180;
                t.DieresisGrave = 63181;
                t.Dieresissmall = 63400;
                t.Digammagreek = 988;
                t.Djecyrillic = 1026;
                t.Dlinebelow = 7694;
                t.Dmonospace = 65316;
                t.Dotaccentsmall = 63223;
                t.Dslash = 272;
                t.Dsmall = 63332;
                t.Dtopbar = 395;
                t.Dz = 498;
                t.Dzcaron = 453;
                t.Dzeabkhasiancyrillic = 1248;
                t.Dzecyrillic = 1029;
                t.Dzhecyrillic = 1039;
                t.E = 69;
                t.Eacute = 201;
                t.Eacutesmall = 63465;
                t.Ebreve = 276;
                t.Ecaron = 282;
                t.Ecedillabreve = 7708;
                t.Echarmenian = 1333;
                t.Ecircle = 9402;
                t.Ecircumflex = 202;
                t.Ecircumflexacute = 7870;
                t.Ecircumflexbelow = 7704;
                t.Ecircumflexdotbelow = 7878;
                t.Ecircumflexgrave = 7872;
                t.Ecircumflexhookabove = 7874;
                t.Ecircumflexsmall = 63466;
                t.Ecircumflextilde = 7876;
                t.Ecyrillic = 1028;
                t.Edblgrave = 516;
                t.Edieresis = 203;
                t.Edieresissmall = 63467;
                t.Edot = 278;
                t.Edotaccent = 278;
                t.Edotbelow = 7864;
                t.Efcyrillic = 1060;
                t.Egrave = 200;
                t.Egravesmall = 63464;
                t.Eharmenian = 1335;
                t.Ehookabove = 7866;
                t.Eightroman = 8551;
                t.Einvertedbreve = 518;
                t.Eiotifiedcyrillic = 1124;
                t.Elcyrillic = 1051;
                t.Elevenroman = 8554;
                t.Emacron = 274;
                t.Emacronacute = 7702;
                t.Emacrongrave = 7700;
                t.Emcyrillic = 1052;
                t.Emonospace = 65317;
                t.Encyrillic = 1053;
                t.Endescendercyrillic = 1186;
                t.Eng = 330;
                t.Enghecyrillic = 1188;
                t.Enhookcyrillic = 1223;
                t.Eogonek = 280;
                t.Eopen = 400;
                t.Epsilon = 917;
                t.Epsilontonos = 904;
                t.Ercyrillic = 1056;
                t.Ereversed = 398;
                t.Ereversedcyrillic = 1069;
                t.Escyrillic = 1057;
                t.Esdescendercyrillic = 1194;
                t.Esh = 425;
                t.Esmall = 63333;
                t.Eta = 919;
                t.Etarmenian = 1336;
                t.Etatonos = 905;
                t.Eth = 208;
                t.Ethsmall = 63472;
                t.Etilde = 7868;
                t.Etildebelow = 7706;
                t.Euro = 8364;
                t.Ezh = 439;
                t.Ezhcaron = 494;
                t.Ezhreversed = 440;
                t.F = 70;
                t.Fcircle = 9403;
                t.Fdotaccent = 7710;
                t.Feharmenian = 1366;
                t.Feicoptic = 996;
                t.Fhook = 401;
                t.Fitacyrillic = 1138;
                t.Fiveroman = 8548;
                t.Fmonospace = 65318;
                t.Fourroman = 8547;
                t.Fsmall = 63334;
                t.G = 71;
                t.GBsquare = 13191;
                t.Gacute = 500;
                t.Gamma = 915;
                t.Gammaafrican = 404;
                t.Gangiacoptic = 1002;
                t.Gbreve = 286;
                t.Gcaron = 486;
                t.Gcedilla = 290;
                t.Gcircle = 9404;
                t.Gcircumflex = 284;
                t.Gcommaaccent = 290;
                t.Gdot = 288;
                t.Gdotaccent = 288;
                t.Gecyrillic = 1043;
                t.Ghadarmenian = 1346;
                t.Ghemiddlehookcyrillic = 1172;
                t.Ghestrokecyrillic = 1170;
                t.Gheupturncyrillic = 1168;
                t.Ghook = 403;
                t.Gimarmenian = 1331;
                t.Gjecyrillic = 1027;
                t.Gmacron = 7712;
                t.Gmonospace = 65319;
                t.Grave = 63182;
                t.Gravesmall = 63328;
                t.Gsmall = 63335;
                t.Gsmallhook = 667;
                t.Gstroke = 484;
                t.H = 72;
                t.H18533 = 9679;
                t.H18543 = 9642;
                t.H18551 = 9643;
                t.H22073 = 9633;
                t.HPsquare = 13259;
                t.Haabkhasiancyrillic = 1192;
                t.Hadescendercyrillic = 1202;
                t.Hardsigncyrillic = 1066;
                t.Hbar = 294;
                t.Hbrevebelow = 7722;
                t.Hcedilla = 7720;
                t.Hcircle = 9405;
                t.Hcircumflex = 292;
                t.Hdieresis = 7718;
                t.Hdotaccent = 7714;
                t.Hdotbelow = 7716;
                t.Hmonospace = 65320;
                t.Hoarmenian = 1344;
                t.Horicoptic = 1e3;
                t.Hsmall = 63336;
                t.Hungarumlaut = 63183;
                t.Hungarumlautsmall = 63224;
                t.Hzsquare = 13200;
                t.I = 73;
                t.IAcyrillic = 1071;
                t.IJ = 306;
                t.IUcyrillic = 1070;
                t.Iacute = 205;
                t.Iacutesmall = 63469;
                t.Ibreve = 300;
                t.Icaron = 463;
                t.Icircle = 9406;
                t.Icircumflex = 206;
                t.Icircumflexsmall = 63470;
                t.Icyrillic = 1030;
                t.Idblgrave = 520;
                t.Idieresis = 207;
                t.Idieresisacute = 7726;
                t.Idieresiscyrillic = 1252;
                t.Idieresissmall = 63471;
                t.Idot = 304;
                t.Idotaccent = 304;
                t.Idotbelow = 7882;
                t.Iebrevecyrillic = 1238;
                t.Iecyrillic = 1045;
                t.Ifraktur = 8465;
                t.Igrave = 204;
                t.Igravesmall = 63468;
                t.Ihookabove = 7880;
                t.Iicyrillic = 1048;
                t.Iinvertedbreve = 522;
                t.Iishortcyrillic = 1049;
                t.Imacron = 298;
                t.Imacroncyrillic = 1250;
                t.Imonospace = 65321;
                t.Iniarmenian = 1339;
                t.Iocyrillic = 1025;
                t.Iogonek = 302;
                t.Iota = 921;
                t.Iotaafrican = 406;
                t.Iotadieresis = 938;
                t.Iotatonos = 906;
                t.Ismall = 63337;
                t.Istroke = 407;
                t.Itilde = 296;
                t.Itildebelow = 7724;
                t.Izhitsacyrillic = 1140;
                t.Izhitsadblgravecyrillic = 1142;
                t.J = 74;
                t.Jaarmenian = 1345;
                t.Jcircle = 9407;
                t.Jcircumflex = 308;
                t.Jecyrillic = 1032;
                t.Jheharmenian = 1355;
                t.Jmonospace = 65322;
                t.Jsmall = 63338;
                t.K = 75;
                t.KBsquare = 13189;
                t.KKsquare = 13261;
                t.Kabashkircyrillic = 1184;
                t.Kacute = 7728;
                t.Kacyrillic = 1050;
                t.Kadescendercyrillic = 1178;
                t.Kahookcyrillic = 1219;
                t.Kappa = 922;
                t.Kastrokecyrillic = 1182;
                t.Kaverticalstrokecyrillic = 1180;
                t.Kcaron = 488;
                t.Kcedilla = 310;
                t.Kcircle = 9408;
                t.Kcommaaccent = 310;
                t.Kdotbelow = 7730;
                t.Keharmenian = 1364;
                t.Kenarmenian = 1343;
                t.Khacyrillic = 1061;
                t.Kheicoptic = 998;
                t.Khook = 408;
                t.Kjecyrillic = 1036;
                t.Klinebelow = 7732;
                t.Kmonospace = 65323;
                t.Koppacyrillic = 1152;
                t.Koppagreek = 990;
                t.Ksicyrillic = 1134;
                t.Ksmall = 63339;
                t.L = 76;
                t.LJ = 455;
                t.LL = 63167;
                t.Lacute = 313;
                t.Lambda = 923;
                t.Lcaron = 317;
                t.Lcedilla = 315;
                t.Lcircle = 9409;
                t.Lcircumflexbelow = 7740;
                t.Lcommaaccent = 315;
                t.Ldot = 319;
                t.Ldotaccent = 319;
                t.Ldotbelow = 7734;
                t.Ldotbelowmacron = 7736;
                t.Liwnarmenian = 1340;
                t.Lj = 456;
                t.Ljecyrillic = 1033;
                t.Llinebelow = 7738;
                t.Lmonospace = 65324;
                t.Lslash = 321;
                t.Lslashsmall = 63225;
                t.Lsmall = 63340;
                t.M = 77;
                t.MBsquare = 13190;
                t.Macron = 63184;
                t.Macronsmall = 63407;
                t.Macute = 7742;
                t.Mcircle = 9410;
                t.Mdotaccent = 7744;
                t.Mdotbelow = 7746;
                t.Menarmenian = 1348;
                t.Mmonospace = 65325;
                t.Msmall = 63341;
                t.Mturned = 412;
                t.Mu = 924;
                t.N = 78;
                t.NJ = 458;
                t.Nacute = 323;
                t.Ncaron = 327;
                t.Ncedilla = 325;
                t.Ncircle = 9411;
                t.Ncircumflexbelow = 7754;
                t.Ncommaaccent = 325;
                t.Ndotaccent = 7748;
                t.Ndotbelow = 7750;
                t.Nhookleft = 413;
                t.Nineroman = 8552;
                t.Nj = 459;
                t.Njecyrillic = 1034;
                t.Nlinebelow = 7752;
                t.Nmonospace = 65326;
                t.Nowarmenian = 1350;
                t.Nsmall = 63342;
                t.Ntilde = 209;
                t.Ntildesmall = 63473;
                t.Nu = 925;
                t.O = 79;
                t.OE = 338;
                t.OEsmall = 63226;
                t.Oacute = 211;
                t.Oacutesmall = 63475;
                t.Obarredcyrillic = 1256;
                t.Obarreddieresiscyrillic = 1258;
                t.Obreve = 334;
                t.Ocaron = 465;
                t.Ocenteredtilde = 415;
                t.Ocircle = 9412;
                t.Ocircumflex = 212;
                t.Ocircumflexacute = 7888;
                t.Ocircumflexdotbelow = 7896;
                t.Ocircumflexgrave = 7890;
                t.Ocircumflexhookabove = 7892;
                t.Ocircumflexsmall = 63476;
                t.Ocircumflextilde = 7894;
                t.Ocyrillic = 1054;
                t.Odblacute = 336;
                t.Odblgrave = 524;
                t.Odieresis = 214;
                t.Odieresiscyrillic = 1254;
                t.Odieresissmall = 63478;
                t.Odotbelow = 7884;
                t.Ogoneksmall = 63227;
                t.Ograve = 210;
                t.Ogravesmall = 63474;
                t.Oharmenian = 1365;
                t.Ohm = 8486;
                t.Ohookabove = 7886;
                t.Ohorn = 416;
                t.Ohornacute = 7898;
                t.Ohorndotbelow = 7906;
                t.Ohorngrave = 7900;
                t.Ohornhookabove = 7902;
                t.Ohorntilde = 7904;
                t.Ohungarumlaut = 336;
                t.Oi = 418;
                t.Oinvertedbreve = 526;
                t.Omacron = 332;
                t.Omacronacute = 7762;
                t.Omacrongrave = 7760;
                t.Omega = 8486;
                t.Omegacyrillic = 1120;
                t.Omegagreek = 937;
                t.Omegaroundcyrillic = 1146;
                t.Omegatitlocyrillic = 1148;
                t.Omegatonos = 911;
                t.Omicron = 927;
                t.Omicrontonos = 908;
                t.Omonospace = 65327;
                t.Oneroman = 8544;
                t.Oogonek = 490;
                t.Oogonekmacron = 492;
                t.Oopen = 390;
                t.Oslash = 216;
                t.Oslashacute = 510;
                t.Oslashsmall = 63480;
                t.Osmall = 63343;
                t.Ostrokeacute = 510;
                t.Otcyrillic = 1150;
                t.Otilde = 213;
                t.Otildeacute = 7756;
                t.Otildedieresis = 7758;
                t.Otildesmall = 63477;
                t.P = 80;
                t.Pacute = 7764;
                t.Pcircle = 9413;
                t.Pdotaccent = 7766;
                t.Pecyrillic = 1055;
                t.Peharmenian = 1354;
                t.Pemiddlehookcyrillic = 1190;
                t.Phi = 934;
                t.Phook = 420;
                t.Pi = 928;
                t.Piwrarmenian = 1363;
                t.Pmonospace = 65328;
                t.Psi = 936;
                t.Psicyrillic = 1136;
                t.Psmall = 63344;
                t.Q = 81;
                t.Qcircle = 9414;
                t.Qmonospace = 65329;
                t.Qsmall = 63345;
                t.R = 82;
                t.Raarmenian = 1356;
                t.Racute = 340;
                t.Rcaron = 344;
                t.Rcedilla = 342;
                t.Rcircle = 9415;
                t.Rcommaaccent = 342;
                t.Rdblgrave = 528;
                t.Rdotaccent = 7768;
                t.Rdotbelow = 7770;
                t.Rdotbelowmacron = 7772;
                t.Reharmenian = 1360;
                t.Rfraktur = 8476;
                t.Rho = 929;
                t.Ringsmall = 63228;
                t.Rinvertedbreve = 530;
                t.Rlinebelow = 7774;
                t.Rmonospace = 65330;
                t.Rsmall = 63346;
                t.Rsmallinverted = 641;
                t.Rsmallinvertedsuperior = 694;
                t.S = 83;
                t.SF010000 = 9484;
                t.SF020000 = 9492;
                t.SF030000 = 9488;
                t.SF040000 = 9496;
                t.SF050000 = 9532;
                t.SF060000 = 9516;
                t.SF070000 = 9524;
                t.SF080000 = 9500;
                t.SF090000 = 9508;
                t.SF100000 = 9472;
                t.SF110000 = 9474;
                t.SF190000 = 9569;
                t.SF200000 = 9570;
                t.SF210000 = 9558;
                t.SF220000 = 9557;
                t.SF230000 = 9571;
                t.SF240000 = 9553;
                t.SF250000 = 9559;
                t.SF260000 = 9565;
                t.SF270000 = 9564;
                t.SF280000 = 9563;
                t.SF360000 = 9566;
                t.SF370000 = 9567;
                t.SF380000 = 9562;
                t.SF390000 = 9556;
                t.SF400000 = 9577;
                t.SF410000 = 9574;
                t.SF420000 = 9568;
                t.SF430000 = 9552;
                t.SF440000 = 9580;
                t.SF450000 = 9575;
                t.SF460000 = 9576;
                t.SF470000 = 9572;
                t.SF480000 = 9573;
                t.SF490000 = 9561;
                t.SF500000 = 9560;
                t.SF510000 = 9554;
                t.SF520000 = 9555;
                t.SF530000 = 9579;
                t.SF540000 = 9578;
                t.Sacute = 346;
                t.Sacutedotaccent = 7780;
                t.Sampigreek = 992;
                t.Scaron = 352;
                t.Scarondotaccent = 7782;
                t.Scaronsmall = 63229;
                t.Scedilla = 350;
                t.Schwa = 399;
                t.Schwacyrillic = 1240;
                t.Schwadieresiscyrillic = 1242;
                t.Scircle = 9416;
                t.Scircumflex = 348;
                t.Scommaaccent = 536;
                t.Sdotaccent = 7776;
                t.Sdotbelow = 7778;
                t.Sdotbelowdotaccent = 7784;
                t.Seharmenian = 1357;
                t.Sevenroman = 8550;
                t.Shaarmenian = 1351;
                t.Shacyrillic = 1064;
                t.Shchacyrillic = 1065;
                t.Sheicoptic = 994;
                t.Shhacyrillic = 1210;
                t.Shimacoptic = 1004;
                t.Sigma = 931;
                t.Sixroman = 8549;
                t.Smonospace = 65331;
                t.Softsigncyrillic = 1068;
                t.Ssmall = 63347;
                t.Stigmagreek = 986;
                t.T = 84;
                t.Tau = 932;
                t.Tbar = 358;
                t.Tcaron = 356;
                t.Tcedilla = 354;
                t.Tcircle = 9417;
                t.Tcircumflexbelow = 7792;
                t.Tcommaaccent = 354;
                t.Tdotaccent = 7786;
                t.Tdotbelow = 7788;
                t.Tecyrillic = 1058;
                t.Tedescendercyrillic = 1196;
                t.Tenroman = 8553;
                t.Tetsecyrillic = 1204;
                t.Theta = 920;
                t.Thook = 428;
                t.Thorn = 222;
                t.Thornsmall = 63486;
                t.Threeroman = 8546;
                t.Tildesmall = 63230;
                t.Tiwnarmenian = 1359;
                t.Tlinebelow = 7790;
                t.Tmonospace = 65332;
                t.Toarmenian = 1337;
                t.Tonefive = 444;
                t.Tonesix = 388;
                t.Tonetwo = 423;
                t.Tretroflexhook = 430;
                t.Tsecyrillic = 1062;
                t.Tshecyrillic = 1035;
                t.Tsmall = 63348;
                t.Twelveroman = 8555;
                t.Tworoman = 8545;
                t.U = 85;
                t.Uacute = 218;
                t.Uacutesmall = 63482;
                t.Ubreve = 364;
                t.Ucaron = 467;
                t.Ucircle = 9418;
                t.Ucircumflex = 219;
                t.Ucircumflexbelow = 7798;
                t.Ucircumflexsmall = 63483;
                t.Ucyrillic = 1059;
                t.Udblacute = 368;
                t.Udblgrave = 532;
                t.Udieresis = 220;
                t.Udieresisacute = 471;
                t.Udieresisbelow = 7794;
                t.Udieresiscaron = 473;
                t.Udieresiscyrillic = 1264;
                t.Udieresisgrave = 475;
                t.Udieresismacron = 469;
                t.Udieresissmall = 63484;
                t.Udotbelow = 7908;
                t.Ugrave = 217;
                t.Ugravesmall = 63481;
                t.Uhookabove = 7910;
                t.Uhorn = 431;
                t.Uhornacute = 7912;
                t.Uhorndotbelow = 7920;
                t.Uhorngrave = 7914;
                t.Uhornhookabove = 7916;
                t.Uhorntilde = 7918;
                t.Uhungarumlaut = 368;
                t.Uhungarumlautcyrillic = 1266;
                t.Uinvertedbreve = 534;
                t.Ukcyrillic = 1144;
                t.Umacron = 362;
                t.Umacroncyrillic = 1262;
                t.Umacrondieresis = 7802;
                t.Umonospace = 65333;
                t.Uogonek = 370;
                t.Upsilon = 933;
                t.Upsilon1 = 978;
                t.Upsilonacutehooksymbolgreek = 979;
                t.Upsilonafrican = 433;
                t.Upsilondieresis = 939;
                t.Upsilondieresishooksymbolgreek = 980;
                t.Upsilonhooksymbol = 978;
                t.Upsilontonos = 910;
                t.Uring = 366;
                t.Ushortcyrillic = 1038;
                t.Usmall = 63349;
                t.Ustraightcyrillic = 1198;
                t.Ustraightstrokecyrillic = 1200;
                t.Utilde = 360;
                t.Utildeacute = 7800;
                t.Utildebelow = 7796;
                t.V = 86;
                t.Vcircle = 9419;
                t.Vdotbelow = 7806;
                t.Vecyrillic = 1042;
                t.Vewarmenian = 1358;
                t.Vhook = 434;
                t.Vmonospace = 65334;
                t.Voarmenian = 1352;
                t.Vsmall = 63350;
                t.Vtilde = 7804;
                t.W = 87;
                t.Wacute = 7810;
                t.Wcircle = 9420;
                t.Wcircumflex = 372;
                t.Wdieresis = 7812;
                t.Wdotaccent = 7814;
                t.Wdotbelow = 7816;
                t.Wgrave = 7808;
                t.Wmonospace = 65335;
                t.Wsmall = 63351;
                t.X = 88;
                t.Xcircle = 9421;
                t.Xdieresis = 7820;
                t.Xdotaccent = 7818;
                t.Xeharmenian = 1341;
                t.Xi = 926;
                t.Xmonospace = 65336;
                t.Xsmall = 63352;
                t.Y = 89;
                t.Yacute = 221;
                t.Yacutesmall = 63485;
                t.Yatcyrillic = 1122;
                t.Ycircle = 9422;
                t.Ycircumflex = 374;
                t.Ydieresis = 376;
                t.Ydieresissmall = 63487;
                t.Ydotaccent = 7822;
                t.Ydotbelow = 7924;
                t.Yericyrillic = 1067;
                t.Yerudieresiscyrillic = 1272;
                t.Ygrave = 7922;
                t.Yhook = 435;
                t.Yhookabove = 7926;
                t.Yiarmenian = 1349;
                t.Yicyrillic = 1031;
                t.Yiwnarmenian = 1362;
                t.Ymonospace = 65337;
                t.Ysmall = 63353;
                t.Ytilde = 7928;
                t.Yusbigcyrillic = 1130;
                t.Yusbigiotifiedcyrillic = 1132;
                t.Yuslittlecyrillic = 1126;
                t.Yuslittleiotifiedcyrillic = 1128;
                t.Z = 90;
                t.Zaarmenian = 1334;
                t.Zacute = 377;
                t.Zcaron = 381;
                t.Zcaronsmall = 63231;
                t.Zcircle = 9423;
                t.Zcircumflex = 7824;
                t.Zdot = 379;
                t.Zdotaccent = 379;
                t.Zdotbelow = 7826;
                t.Zecyrillic = 1047;
                t.Zedescendercyrillic = 1176;
                t.Zedieresiscyrillic = 1246;
                t.Zeta = 918;
                t.Zhearmenian = 1338;
                t.Zhebrevecyrillic = 1217;
                t.Zhecyrillic = 1046;
                t.Zhedescendercyrillic = 1174;
                t.Zhedieresiscyrillic = 1244;
                t.Zlinebelow = 7828;
                t.Zmonospace = 65338;
                t.Zsmall = 63354;
                t.Zstroke = 437;
                t.a = 97;
                t.aabengali = 2438;
                t.aacute = 225;
                t.aadeva = 2310;
                t.aagujarati = 2694;
                t.aagurmukhi = 2566;
                t.aamatragurmukhi = 2622;
                t.aarusquare = 13059;
                t.aavowelsignbengali = 2494;
                t.aavowelsigndeva = 2366;
                t.aavowelsigngujarati = 2750;
                t.abbreviationmarkarmenian = 1375;
                t.abbreviationsigndeva = 2416;
                t.abengali = 2437;
                t.abopomofo = 12570;
                t.abreve = 259;
                t.abreveacute = 7855;
                t.abrevecyrillic = 1233;
                t.abrevedotbelow = 7863;
                t.abrevegrave = 7857;
                t.abrevehookabove = 7859;
                t.abrevetilde = 7861;
                t.acaron = 462;
                t.acircle = 9424;
                t.acircumflex = 226;
                t.acircumflexacute = 7845;
                t.acircumflexdotbelow = 7853;
                t.acircumflexgrave = 7847;
                t.acircumflexhookabove = 7849;
                t.acircumflextilde = 7851;
                t.acute = 180;
                t.acutebelowcmb = 791;
                t.acutecmb = 769;
                t.acutecomb = 769;
                t.acutedeva = 2388;
                t.acutelowmod = 719;
                t.acutetonecmb = 833;
                t.acyrillic = 1072;
                t.adblgrave = 513;
                t.addakgurmukhi = 2673;
                t.adeva = 2309;
                t.adieresis = 228;
                t.adieresiscyrillic = 1235;
                t.adieresismacron = 479;
                t.adotbelow = 7841;
                t.adotmacron = 481;
                t.ae = 230;
                t.aeacute = 509;
                t.aekorean = 12624;
                t.aemacron = 483;
                t.afii00208 = 8213;
                t.afii08941 = 8356;
                t.afii10017 = 1040;
                t.afii10018 = 1041;
                t.afii10019 = 1042;
                t.afii10020 = 1043;
                t.afii10021 = 1044;
                t.afii10022 = 1045;
                t.afii10023 = 1025;
                t.afii10024 = 1046;
                t.afii10025 = 1047;
                t.afii10026 = 1048;
                t.afii10027 = 1049;
                t.afii10028 = 1050;
                t.afii10029 = 1051;
                t.afii10030 = 1052;
                t.afii10031 = 1053;
                t.afii10032 = 1054;
                t.afii10033 = 1055;
                t.afii10034 = 1056;
                t.afii10035 = 1057;
                t.afii10036 = 1058;
                t.afii10037 = 1059;
                t.afii10038 = 1060;
                t.afii10039 = 1061;
                t.afii10040 = 1062;
                t.afii10041 = 1063;
                t.afii10042 = 1064;
                t.afii10043 = 1065;
                t.afii10044 = 1066;
                t.afii10045 = 1067;
                t.afii10046 = 1068;
                t.afii10047 = 1069;
                t.afii10048 = 1070;
                t.afii10049 = 1071;
                t.afii10050 = 1168;
                t.afii10051 = 1026;
                t.afii10052 = 1027;
                t.afii10053 = 1028;
                t.afii10054 = 1029;
                t.afii10055 = 1030;
                t.afii10056 = 1031;
                t.afii10057 = 1032;
                t.afii10058 = 1033;
                t.afii10059 = 1034;
                t.afii10060 = 1035;
                t.afii10061 = 1036;
                t.afii10062 = 1038;
                t.afii10063 = 63172;
                t.afii10064 = 63173;
                t.afii10065 = 1072;
                t.afii10066 = 1073;
                t.afii10067 = 1074;
                t.afii10068 = 1075;
                t.afii10069 = 1076;
                t.afii10070 = 1077;
                t.afii10071 = 1105;
                t.afii10072 = 1078;
                t.afii10073 = 1079;
                t.afii10074 = 1080;
                t.afii10075 = 1081;
                t.afii10076 = 1082;
                t.afii10077 = 1083;
                t.afii10078 = 1084;
                t.afii10079 = 1085;
                t.afii10080 = 1086;
                t.afii10081 = 1087;
                t.afii10082 = 1088;
                t.afii10083 = 1089;
                t.afii10084 = 1090;
                t.afii10085 = 1091;
                t.afii10086 = 1092;
                t.afii10087 = 1093;
                t.afii10088 = 1094;
                t.afii10089 = 1095;
                t.afii10090 = 1096;
                t.afii10091 = 1097;
                t.afii10092 = 1098;
                t.afii10093 = 1099;
                t.afii10094 = 1100;
                t.afii10095 = 1101;
                t.afii10096 = 1102;
                t.afii10097 = 1103;
                t.afii10098 = 1169;
                t.afii10099 = 1106;
                t.afii10100 = 1107;
                t.afii10101 = 1108;
                t.afii10102 = 1109;
                t.afii10103 = 1110;
                t.afii10104 = 1111;
                t.afii10105 = 1112;
                t.afii10106 = 1113;
                t.afii10107 = 1114;
                t.afii10108 = 1115;
                t.afii10109 = 1116;
                t.afii10110 = 1118;
                t.afii10145 = 1039;
                t.afii10146 = 1122;
                t.afii10147 = 1138;
                t.afii10148 = 1140;
                t.afii10192 = 63174;
                t.afii10193 = 1119;
                t.afii10194 = 1123;
                t.afii10195 = 1139;
                t.afii10196 = 1141;
                t.afii10831 = 63175;
                t.afii10832 = 63176;
                t.afii10846 = 1241;
                t.afii299 = 8206;
                t.afii300 = 8207;
                t.afii301 = 8205;
                t.afii57381 = 1642;
                t.afii57388 = 1548;
                t.afii57392 = 1632;
                t.afii57393 = 1633;
                t.afii57394 = 1634;
                t.afii57395 = 1635;
                t.afii57396 = 1636;
                t.afii57397 = 1637;
                t.afii57398 = 1638;
                t.afii57399 = 1639;
                t.afii57400 = 1640;
                t.afii57401 = 1641;
                t.afii57403 = 1563;
                t.afii57407 = 1567;
                t.afii57409 = 1569;
                t.afii57410 = 1570;
                t.afii57411 = 1571;
                t.afii57412 = 1572;
                t.afii57413 = 1573;
                t.afii57414 = 1574;
                t.afii57415 = 1575;
                t.afii57416 = 1576;
                t.afii57417 = 1577;
                t.afii57418 = 1578;
                t.afii57419 = 1579;
                t.afii57420 = 1580;
                t.afii57421 = 1581;
                t.afii57422 = 1582;
                t.afii57423 = 1583;
                t.afii57424 = 1584;
                t.afii57425 = 1585;
                t.afii57426 = 1586;
                t.afii57427 = 1587;
                t.afii57428 = 1588;
                t.afii57429 = 1589;
                t.afii57430 = 1590;
                t.afii57431 = 1591;
                t.afii57432 = 1592;
                t.afii57433 = 1593;
                t.afii57434 = 1594;
                t.afii57440 = 1600;
                t.afii57441 = 1601;
                t.afii57442 = 1602;
                t.afii57443 = 1603;
                t.afii57444 = 1604;
                t.afii57445 = 1605;
                t.afii57446 = 1606;
                t.afii57448 = 1608;
                t.afii57449 = 1609;
                t.afii57450 = 1610;
                t.afii57451 = 1611;
                t.afii57452 = 1612;
                t.afii57453 = 1613;
                t.afii57454 = 1614;
                t.afii57455 = 1615;
                t.afii57456 = 1616;
                t.afii57457 = 1617;
                t.afii57458 = 1618;
                t.afii57470 = 1607;
                t.afii57505 = 1700;
                t.afii57506 = 1662;
                t.afii57507 = 1670;
                t.afii57508 = 1688;
                t.afii57509 = 1711;
                t.afii57511 = 1657;
                t.afii57512 = 1672;
                t.afii57513 = 1681;
                t.afii57514 = 1722;
                t.afii57519 = 1746;
                t.afii57534 = 1749;
                t.afii57636 = 8362;
                t.afii57645 = 1470;
                t.afii57658 = 1475;
                t.afii57664 = 1488;
                t.afii57665 = 1489;
                t.afii57666 = 1490;
                t.afii57667 = 1491;
                t.afii57668 = 1492;
                t.afii57669 = 1493;
                t.afii57670 = 1494;
                t.afii57671 = 1495;
                t.afii57672 = 1496;
                t.afii57673 = 1497;
                t.afii57674 = 1498;
                t.afii57675 = 1499;
                t.afii57676 = 1500;
                t.afii57677 = 1501;
                t.afii57678 = 1502;
                t.afii57679 = 1503;
                t.afii57680 = 1504;
                t.afii57681 = 1505;
                t.afii57682 = 1506;
                t.afii57683 = 1507;
                t.afii57684 = 1508;
                t.afii57685 = 1509;
                t.afii57686 = 1510;
                t.afii57687 = 1511;
                t.afii57688 = 1512;
                t.afii57689 = 1513;
                t.afii57690 = 1514;
                t.afii57694 = 64298;
                t.afii57695 = 64299;
                t.afii57700 = 64331;
                t.afii57705 = 64287;
                t.afii57716 = 1520;
                t.afii57717 = 1521;
                t.afii57718 = 1522;
                t.afii57723 = 64309;
                t.afii57793 = 1460;
                t.afii57794 = 1461;
                t.afii57795 = 1462;
                t.afii57796 = 1467;
                t.afii57797 = 1464;
                t.afii57798 = 1463;
                t.afii57799 = 1456;
                t.afii57800 = 1458;
                t.afii57801 = 1457;
                t.afii57802 = 1459;
                t.afii57803 = 1474;
                t.afii57804 = 1473;
                t.afii57806 = 1465;
                t.afii57807 = 1468;
                t.afii57839 = 1469;
                t.afii57841 = 1471;
                t.afii57842 = 1472;
                t.afii57929 = 700;
                t.afii61248 = 8453;
                t.afii61289 = 8467;
                t.afii61352 = 8470;
                t.afii61573 = 8236;
                t.afii61574 = 8237;
                t.afii61575 = 8238;
                t.afii61664 = 8204;
                t.afii63167 = 1645;
                t.afii64937 = 701;
                t.agrave = 224;
                t.agujarati = 2693;
                t.agurmukhi = 2565;
                t.ahiragana = 12354;
                t.ahookabove = 7843;
                t.aibengali = 2448;
                t.aibopomofo = 12574;
                t.aideva = 2320;
                t.aiecyrillic = 1237;
                t.aigujarati = 2704;
                t.aigurmukhi = 2576;
                t.aimatragurmukhi = 2632;
                t.ainarabic = 1593;
                t.ainfinalarabic = 65226;
                t.aininitialarabic = 65227;
                t.ainmedialarabic = 65228;
                t.ainvertedbreve = 515;
                t.aivowelsignbengali = 2504;
                t.aivowelsigndeva = 2376;
                t.aivowelsigngujarati = 2760;
                t.akatakana = 12450;
                t.akatakanahalfwidth = 65393;
                t.akorean = 12623;
                t.alef = 1488;
                t.alefarabic = 1575;
                t.alefdageshhebrew = 64304;
                t.aleffinalarabic = 65166;
                t.alefhamzaabovearabic = 1571;
                t.alefhamzaabovefinalarabic = 65156;
                t.alefhamzabelowarabic = 1573;
                t.alefhamzabelowfinalarabic = 65160;
                t.alefhebrew = 1488;
                t.aleflamedhebrew = 64335;
                t.alefmaddaabovearabic = 1570;
                t.alefmaddaabovefinalarabic = 65154;
                t.alefmaksuraarabic = 1609;
                t.alefmaksurafinalarabic = 65264;
                t.alefmaksurainitialarabic = 65267;
                t.alefmaksuramedialarabic = 65268;
                t.alefpatahhebrew = 64302;
                t.alefqamatshebrew = 64303;
                t.aleph = 8501;
                t.allequal = 8780;
                t.alpha = 945;
                t.alphatonos = 940;
                t.amacron = 257;
                t.amonospace = 65345;
                t.ampersand = 38;
                t.ampersandmonospace = 65286;
                t.ampersandsmall = 63270;
                t.amsquare = 13250;
                t.anbopomofo = 12578;
                t.angbopomofo = 12580;
                t.angbracketleft = 12296;
                t.angbracketright = 12297;
                t.angkhankhuthai = 3674;
                t.angle = 8736;
                t.anglebracketleft = 12296;
                t.anglebracketleftvertical = 65087;
                t.anglebracketright = 12297;
                t.anglebracketrightvertical = 65088;
                t.angleleft = 9001;
                t.angleright = 9002;
                t.angstrom = 8491;
                t.anoteleia = 903;
                t.anudattadeva = 2386;
                t.anusvarabengali = 2434;
                t.anusvaradeva = 2306;
                t.anusvaragujarati = 2690;
                t.aogonek = 261;
                t.apaatosquare = 13056;
                t.aparen = 9372;
                t.apostrophearmenian = 1370;
                t.apostrophemod = 700;
                t.apple = 63743;
                t.approaches = 8784;
                t.approxequal = 8776;
                t.approxequalorimage = 8786;
                t.approximatelyequal = 8773;
                t.araeaekorean = 12686;
                t.araeakorean = 12685;
                t.arc = 8978;
                t.arighthalfring = 7834;
                t.aring = 229;
                t.aringacute = 507;
                t.aringbelow = 7681;
                t.arrowboth = 8596;
                t.arrowdashdown = 8675;
                t.arrowdashleft = 8672;
                t.arrowdashright = 8674;
                t.arrowdashup = 8673;
                t.arrowdblboth = 8660;
                t.arrowdbldown = 8659;
                t.arrowdblleft = 8656;
                t.arrowdblright = 8658;
                t.arrowdblup = 8657;
                t.arrowdown = 8595;
                t.arrowdownleft = 8601;
                t.arrowdownright = 8600;
                t.arrowdownwhite = 8681;
                t.arrowheaddownmod = 709;
                t.arrowheadleftmod = 706;
                t.arrowheadrightmod = 707;
                t.arrowheadupmod = 708;
                t.arrowhorizex = 63719;
                t.arrowleft = 8592;
                t.arrowleftdbl = 8656;
                t.arrowleftdblstroke = 8653;
                t.arrowleftoverright = 8646;
                t.arrowleftwhite = 8678;
                t.arrowright = 8594;
                t.arrowrightdblstroke = 8655;
                t.arrowrightheavy = 10142;
                t.arrowrightoverleft = 8644;
                t.arrowrightwhite = 8680;
                t.arrowtableft = 8676;
                t.arrowtabright = 8677;
                t.arrowup = 8593;
                t.arrowupdn = 8597;
                t.arrowupdnbse = 8616;
                t.arrowupdownbase = 8616;
                t.arrowupleft = 8598;
                t.arrowupleftofdown = 8645;
                t.arrowupright = 8599;
                t.arrowupwhite = 8679;
                t.arrowvertex = 63718;
                t.asciicircum = 94;
                t.asciicircummonospace = 65342;
                t.asciitilde = 126;
                t.asciitildemonospace = 65374;
                t.ascript = 593;
                t.ascriptturned = 594;
                t.asmallhiragana = 12353;
                t.asmallkatakana = 12449;
                t.asmallkatakanahalfwidth = 65383;
                t.asterisk = 42;
                t.asteriskaltonearabic = 1645;
                t.asteriskarabic = 1645;
                t.asteriskmath = 8727;
                t.asteriskmonospace = 65290;
                t.asterisksmall = 65121;
                t.asterism = 8258;
                t.asuperior = 63209;
                t.asymptoticallyequal = 8771;
                t.at = 64;
                t.atilde = 227;
                t.atmonospace = 65312;
                t.atsmall = 65131;
                t.aturned = 592;
                t.aubengali = 2452;
                t.aubopomofo = 12576;
                t.audeva = 2324;
                t.augujarati = 2708;
                t.augurmukhi = 2580;
                t.aulengthmarkbengali = 2519;
                t.aumatragurmukhi = 2636;
                t.auvowelsignbengali = 2508;
                t.auvowelsigndeva = 2380;
                t.auvowelsigngujarati = 2764;
                t.avagrahadeva = 2365;
                t.aybarmenian = 1377;
                t.ayin = 1506;
                t.ayinaltonehebrew = 64288;
                t.ayinhebrew = 1506;
                t.b = 98;
                t.babengali = 2476;
                t.backslash = 92;
                t.backslashmonospace = 65340;
                t.badeva = 2348;
                t.bagujarati = 2732;
                t.bagurmukhi = 2604;
                t.bahiragana = 12400;
                t.bahtthai = 3647;
                t.bakatakana = 12496;
                t.bar = 124;
                t.barmonospace = 65372;
                t.bbopomofo = 12549;
                t.bcircle = 9425;
                t.bdotaccent = 7683;
                t.bdotbelow = 7685;
                t.beamedsixteenthnotes = 9836;
                t.because = 8757;
                t.becyrillic = 1073;
                t.beharabic = 1576;
                t.behfinalarabic = 65168;
                t.behinitialarabic = 65169;
                t.behiragana = 12409;
                t.behmedialarabic = 65170;
                t.behmeeminitialarabic = 64671;
                t.behmeemisolatedarabic = 64520;
                t.behnoonfinalarabic = 64621;
                t.bekatakana = 12505;
                t.benarmenian = 1378;
                t.bet = 1489;
                t.beta = 946;
                t.betasymbolgreek = 976;
                t.betdagesh = 64305;
                t.betdageshhebrew = 64305;
                t.bethebrew = 1489;
                t.betrafehebrew = 64332;
                t.bhabengali = 2477;
                t.bhadeva = 2349;
                t.bhagujarati = 2733;
                t.bhagurmukhi = 2605;
                t.bhook = 595;
                t.bihiragana = 12403;
                t.bikatakana = 12499;
                t.bilabialclick = 664;
                t.bindigurmukhi = 2562;
                t.birusquare = 13105;
                t.blackcircle = 9679;
                t.blackdiamond = 9670;
                t.blackdownpointingtriangle = 9660;
                t.blackleftpointingpointer = 9668;
                t.blackleftpointingtriangle = 9664;
                t.blacklenticularbracketleft = 12304;
                t.blacklenticularbracketleftvertical = 65083;
                t.blacklenticularbracketright = 12305;
                t.blacklenticularbracketrightvertical = 65084;
                t.blacklowerlefttriangle = 9699;
                t.blacklowerrighttriangle = 9698;
                t.blackrectangle = 9644;
                t.blackrightpointingpointer = 9658;
                t.blackrightpointingtriangle = 9654;
                t.blacksmallsquare = 9642;
                t.blacksmilingface = 9787;
                t.blacksquare = 9632;
                t.blackstar = 9733;
                t.blackupperlefttriangle = 9700;
                t.blackupperrighttriangle = 9701;
                t.blackuppointingsmalltriangle = 9652;
                t.blackuppointingtriangle = 9650;
                t.blank = 9251;
                t.blinebelow = 7687;
                t.block = 9608;
                t.bmonospace = 65346;
                t.bobaimaithai = 3610;
                t.bohiragana = 12412;
                t.bokatakana = 12508;
                t.bparen = 9373;
                t.bqsquare = 13251;
                t.braceex = 63732;
                t.braceleft = 123;
                t.braceleftbt = 63731;
                t.braceleftmid = 63730;
                t.braceleftmonospace = 65371;
                t.braceleftsmall = 65115;
                t.bracelefttp = 63729;
                t.braceleftvertical = 65079;
                t.braceright = 125;
                t.bracerightbt = 63742;
                t.bracerightmid = 63741;
                t.bracerightmonospace = 65373;
                t.bracerightsmall = 65116;
                t.bracerighttp = 63740;
                t.bracerightvertical = 65080;
                t.bracketleft = 91;
                t.bracketleftbt = 63728;
                t.bracketleftex = 63727;
                t.bracketleftmonospace = 65339;
                t.bracketlefttp = 63726;
                t.bracketright = 93;
                t.bracketrightbt = 63739;
                t.bracketrightex = 63738;
                t.bracketrightmonospace = 65341;
                t.bracketrighttp = 63737;
                t.breve = 728;
                t.brevebelowcmb = 814;
                t.brevecmb = 774;
                t.breveinvertedbelowcmb = 815;
                t.breveinvertedcmb = 785;
                t.breveinverteddoublecmb = 865;
                t.bridgebelowcmb = 810;
                t.bridgeinvertedbelowcmb = 826;
                t.brokenbar = 166;
                t.bstroke = 384;
                t.bsuperior = 63210;
                t.btopbar = 387;
                t.buhiragana = 12406;
                t.bukatakana = 12502;
                t.bullet = 8226;
                t.bulletinverse = 9688;
                t.bulletoperator = 8729;
                t.bullseye = 9678;
                t.c = 99;
                t.caarmenian = 1390;
                t.cabengali = 2458;
                t.cacute = 263;
                t.cadeva = 2330;
                t.cagujarati = 2714;
                t.cagurmukhi = 2586;
                t.calsquare = 13192;
                t.candrabindubengali = 2433;
                t.candrabinducmb = 784;
                t.candrabindudeva = 2305;
                t.candrabindugujarati = 2689;
                t.capslock = 8682;
                t.careof = 8453;
                t.caron = 711;
                t.caronbelowcmb = 812;
                t.caroncmb = 780;
                t.carriagereturn = 8629;
                t.cbopomofo = 12568;
                t.ccaron = 269;
                t.ccedilla = 231;
                t.ccedillaacute = 7689;
                t.ccircle = 9426;
                t.ccircumflex = 265;
                t.ccurl = 597;
                t.cdot = 267;
                t.cdotaccent = 267;
                t.cdsquare = 13253;
                t.cedilla = 184;
                t.cedillacmb = 807;
                t.cent = 162;
                t.centigrade = 8451;
                t.centinferior = 63199;
                t.centmonospace = 65504;
                t.centoldstyle = 63394;
                t.centsuperior = 63200;
                t.chaarmenian = 1401;
                t.chabengali = 2459;
                t.chadeva = 2331;
                t.chagujarati = 2715;
                t.chagurmukhi = 2587;
                t.chbopomofo = 12564;
                t.cheabkhasiancyrillic = 1213;
                t.checkmark = 10003;
                t.checyrillic = 1095;
                t.chedescenderabkhasiancyrillic = 1215;
                t.chedescendercyrillic = 1207;
                t.chedieresiscyrillic = 1269;
                t.cheharmenian = 1395;
                t.chekhakassiancyrillic = 1228;
                t.cheverticalstrokecyrillic = 1209;
                t.chi = 967;
                t.chieuchacirclekorean = 12919;
                t.chieuchaparenkorean = 12823;
                t.chieuchcirclekorean = 12905;
                t.chieuchkorean = 12618;
                t.chieuchparenkorean = 12809;
                t.chochangthai = 3594;
                t.chochanthai = 3592;
                t.chochingthai = 3593;
                t.chochoethai = 3596;
                t.chook = 392;
                t.cieucacirclekorean = 12918;
                t.cieucaparenkorean = 12822;
                t.cieuccirclekorean = 12904;
                t.cieuckorean = 12616;
                t.cieucparenkorean = 12808;
                t.cieucuparenkorean = 12828;
                t.circle = 9675;
                t.circlecopyrt = 169;
                t.circlemultiply = 8855;
                t.circleot = 8857;
                t.circleplus = 8853;
                t.circlepostalmark = 12342;
                t.circlewithlefthalfblack = 9680;
                t.circlewithrighthalfblack = 9681;
                t.circumflex = 710;
                t.circumflexbelowcmb = 813;
                t.circumflexcmb = 770;
                t.clear = 8999;
                t.clickalveolar = 450;
                t.clickdental = 448;
                t.clicklateral = 449;
                t.clickretroflex = 451;
                t.club = 9827;
                t.clubsuitblack = 9827;
                t.clubsuitwhite = 9831;
                t.cmcubedsquare = 13220;
                t.cmonospace = 65347;
                t.cmsquaredsquare = 13216;
                t.coarmenian = 1409;
                t.colon = 58;
                t.colonmonetary = 8353;
                t.colonmonospace = 65306;
                t.colonsign = 8353;
                t.colonsmall = 65109;
                t.colontriangularhalfmod = 721;
                t.colontriangularmod = 720;
                t.comma = 44;
                t.commaabovecmb = 787;
                t.commaaboverightcmb = 789;
                t.commaaccent = 63171;
                t.commaarabic = 1548;
                t.commaarmenian = 1373;
                t.commainferior = 63201;
                t.commamonospace = 65292;
                t.commareversedabovecmb = 788;
                t.commareversedmod = 701;
                t.commasmall = 65104;
                t.commasuperior = 63202;
                t.commaturnedabovecmb = 786;
                t.commaturnedmod = 699;
                t.compass = 9788;
                t.congruent = 8773;
                t.contourintegral = 8750;
                t.control = 8963;
                t.controlACK = 6;
                t.controlBEL = 7;
                t.controlBS = 8;
                t.controlCAN = 24;
                t.controlCR = 13;
                t.controlDC1 = 17;
                t.controlDC2 = 18;
                t.controlDC3 = 19;
                t.controlDC4 = 20;
                t.controlDEL = 127;
                t.controlDLE = 16;
                t.controlEM = 25;
                t.controlENQ = 5;
                t.controlEOT = 4;
                t.controlESC = 27;
                t.controlETB = 23;
                t.controlETX = 3;
                t.controlFF = 12;
                t.controlFS = 28;
                t.controlGS = 29;
                t.controlHT = 9;
                t.controlLF = 10;
                t.controlNAK = 21;
                t.controlNULL = 0;
                t.controlRS = 30;
                t.controlSI = 15;
                t.controlSO = 14;
                t.controlSOT = 2;
                t.controlSTX = 1;
                t.controlSUB = 26;
                t.controlSYN = 22;
                t.controlUS = 31;
                t.controlVT = 11;
                t.copyright = 169;
                t.copyrightsans = 63721;
                t.copyrightserif = 63193;
                t.cornerbracketleft = 12300;
                t.cornerbracketlefthalfwidth = 65378;
                t.cornerbracketleftvertical = 65089;
                t.cornerbracketright = 12301;
                t.cornerbracketrighthalfwidth = 65379;
                t.cornerbracketrightvertical = 65090;
                t.corporationsquare = 13183;
                t.cosquare = 13255;
                t.coverkgsquare = 13254;
                t.cparen = 9374;
                t.cruzeiro = 8354;
                t.cstretched = 663;
                t.curlyand = 8911;
                t.curlyor = 8910;
                t.currency = 164;
                t.cyrBreve = 63185;
                t.cyrFlex = 63186;
                t.cyrbreve = 63188;
                t.cyrflex = 63189;
                t.d = 100;
                t.daarmenian = 1380;
                t.dabengali = 2470;
                t.dadarabic = 1590;
                t.dadeva = 2342;
                t.dadfinalarabic = 65214;
                t.dadinitialarabic = 65215;
                t.dadmedialarabic = 65216;
                t.dagesh = 1468;
                t.dageshhebrew = 1468;
                t.dagger = 8224;
                t.daggerdbl = 8225;
                t.dagujarati = 2726;
                t.dagurmukhi = 2598;
                t.dahiragana = 12384;
                t.dakatakana = 12480;
                t.dalarabic = 1583;
                t.dalet = 1491;
                t.daletdagesh = 64307;
                t.daletdageshhebrew = 64307;
                t.dalethebrew = 1491;
                t.dalfinalarabic = 65194;
                t.dammaarabic = 1615;
                t.dammalowarabic = 1615;
                t.dammatanaltonearabic = 1612;
                t.dammatanarabic = 1612;
                t.danda = 2404;
                t.dargahebrew = 1447;
                t.dargalefthebrew = 1447;
                t.dasiapneumatacyrilliccmb = 1157;
                t.dblGrave = 63187;
                t.dblanglebracketleft = 12298;
                t.dblanglebracketleftvertical = 65085;
                t.dblanglebracketright = 12299;
                t.dblanglebracketrightvertical = 65086;
                t.dblarchinvertedbelowcmb = 811;
                t.dblarrowleft = 8660;
                t.dblarrowright = 8658;
                t.dbldanda = 2405;
                t.dblgrave = 63190;
                t.dblgravecmb = 783;
                t.dblintegral = 8748;
                t.dbllowline = 8215;
                t.dbllowlinecmb = 819;
                t.dbloverlinecmb = 831;
                t.dblprimemod = 698;
                t.dblverticalbar = 8214;
                t.dblverticallineabovecmb = 782;
                t.dbopomofo = 12553;
                t.dbsquare = 13256;
                t.dcaron = 271;
                t.dcedilla = 7697;
                t.dcircle = 9427;
                t.dcircumflexbelow = 7699;
                t.dcroat = 273;
                t.ddabengali = 2465;
                t.ddadeva = 2337;
                t.ddagujarati = 2721;
                t.ddagurmukhi = 2593;
                t.ddalarabic = 1672;
                t.ddalfinalarabic = 64393;
                t.dddhadeva = 2396;
                t.ddhabengali = 2466;
                t.ddhadeva = 2338;
                t.ddhagujarati = 2722;
                t.ddhagurmukhi = 2594;
                t.ddotaccent = 7691;
                t.ddotbelow = 7693;
                t.decimalseparatorarabic = 1643;
                t.decimalseparatorpersian = 1643;
                t.decyrillic = 1076;
                t.degree = 176;
                t.dehihebrew = 1453;
                t.dehiragana = 12391;
                t.deicoptic = 1007;
                t.dekatakana = 12487;
                t.deleteleft = 9003;
                t.deleteright = 8998;
                t.delta = 948;
                t.deltaturned = 397;
                t.denominatorminusonenumeratorbengali = 2552;
                t.dezh = 676;
                t.dhabengali = 2471;
                t.dhadeva = 2343;
                t.dhagujarati = 2727;
                t.dhagurmukhi = 2599;
                t.dhook = 599;
                t.dialytikatonos = 901;
                t.dialytikatonoscmb = 836;
                t.diamond = 9830;
                t.diamondsuitwhite = 9826;
                t.dieresis = 168;
                t.dieresisacute = 63191;
                t.dieresisbelowcmb = 804;
                t.dieresiscmb = 776;
                t.dieresisgrave = 63192;
                t.dieresistonos = 901;
                t.dihiragana = 12386;
                t.dikatakana = 12482;
                t.dittomark = 12291;
                t.divide = 247;
                t.divides = 8739;
                t.divisionslash = 8725;
                t.djecyrillic = 1106;
                t.dkshade = 9619;
                t.dlinebelow = 7695;
                t.dlsquare = 13207;
                t.dmacron = 273;
                t.dmonospace = 65348;
                t.dnblock = 9604;
                t.dochadathai = 3598;
                t.dodekthai = 3604;
                t.dohiragana = 12393;
                t.dokatakana = 12489;
                t.dollar = 36;
                t.dollarinferior = 63203;
                t.dollarmonospace = 65284;
                t.dollaroldstyle = 63268;
                t.dollarsmall = 65129;
                t.dollarsuperior = 63204;
                t.dong = 8363;
                t.dorusquare = 13094;
                t.dotaccent = 729;
                t.dotaccentcmb = 775;
                t.dotbelowcmb = 803;
                t.dotbelowcomb = 803;
                t.dotkatakana = 12539;
                t.dotlessi = 305;
                t.dotlessj = 63166;
                t.dotlessjstrokehook = 644;
                t.dotmath = 8901;
                t.dottedcircle = 9676;
                t.doubleyodpatah = 64287;
                t.doubleyodpatahhebrew = 64287;
                t.downtackbelowcmb = 798;
                t.downtackmod = 725;
                t.dparen = 9375;
                t.dsuperior = 63211;
                t.dtail = 598;
                t.dtopbar = 396;
                t.duhiragana = 12389;
                t.dukatakana = 12485;
                t.dz = 499;
                t.dzaltone = 675;
                t.dzcaron = 454;
                t.dzcurl = 677;
                t.dzeabkhasiancyrillic = 1249;
                t.dzecyrillic = 1109;
                t.dzhecyrillic = 1119;
                t.e = 101;
                t.eacute = 233;
                t.earth = 9793;
                t.ebengali = 2447;
                t.ebopomofo = 12572;
                t.ebreve = 277;
                t.ecandradeva = 2317;
                t.ecandragujarati = 2701;
                t.ecandravowelsigndeva = 2373;
                t.ecandravowelsigngujarati = 2757;
                t.ecaron = 283;
                t.ecedillabreve = 7709;
                t.echarmenian = 1381;
                t.echyiwnarmenian = 1415;
                t.ecircle = 9428;
                t.ecircumflex = 234;
                t.ecircumflexacute = 7871;
                t.ecircumflexbelow = 7705;
                t.ecircumflexdotbelow = 7879;
                t.ecircumflexgrave = 7873;
                t.ecircumflexhookabove = 7875;
                t.ecircumflextilde = 7877;
                t.ecyrillic = 1108;
                t.edblgrave = 517;
                t.edeva = 2319;
                t.edieresis = 235;
                t.edot = 279;
                t.edotaccent = 279;
                t.edotbelow = 7865;
                t.eegurmukhi = 2575;
                t.eematragurmukhi = 2631;
                t.efcyrillic = 1092;
                t.egrave = 232;
                t.egujarati = 2703;
                t.eharmenian = 1383;
                t.ehbopomofo = 12573;
                t.ehiragana = 12360;
                t.ehookabove = 7867;
                t.eibopomofo = 12575;
                t.eight = 56;
                t.eightarabic = 1640;
                t.eightbengali = 2542;
                t.eightcircle = 9319;
                t.eightcircleinversesansserif = 10129;
                t.eightdeva = 2414;
                t.eighteencircle = 9329;
                t.eighteenparen = 9349;
                t.eighteenperiod = 9369;
                t.eightgujarati = 2798;
                t.eightgurmukhi = 2670;
                t.eighthackarabic = 1640;
                t.eighthangzhou = 12328;
                t.eighthnotebeamed = 9835;
                t.eightideographicparen = 12839;
                t.eightinferior = 8328;
                t.eightmonospace = 65304;
                t.eightoldstyle = 63288;
                t.eightparen = 9339;
                t.eightperiod = 9359;
                t.eightpersian = 1784;
                t.eightroman = 8567;
                t.eightsuperior = 8312;
                t.eightthai = 3672;
                t.einvertedbreve = 519;
                t.eiotifiedcyrillic = 1125;
                t.ekatakana = 12456;
                t.ekatakanahalfwidth = 65396;
                t.ekonkargurmukhi = 2676;
                t.ekorean = 12628;
                t.elcyrillic = 1083;
                t.element = 8712;
                t.elevencircle = 9322;
                t.elevenparen = 9342;
                t.elevenperiod = 9362;
                t.elevenroman = 8570;
                t.ellipsis = 8230;
                t.ellipsisvertical = 8942;
                t.emacron = 275;
                t.emacronacute = 7703;
                t.emacrongrave = 7701;
                t.emcyrillic = 1084;
                t.emdash = 8212;
                t.emdashvertical = 65073;
                t.emonospace = 65349;
                t.emphasismarkarmenian = 1371;
                t.emptyset = 8709;
                t.enbopomofo = 12579;
                t.encyrillic = 1085;
                t.endash = 8211;
                t.endashvertical = 65074;
                t.endescendercyrillic = 1187;
                t.eng = 331;
                t.engbopomofo = 12581;
                t.enghecyrillic = 1189;
                t.enhookcyrillic = 1224;
                t.enspace = 8194;
                t.eogonek = 281;
                t.eokorean = 12627;
                t.eopen = 603;
                t.eopenclosed = 666;
                t.eopenreversed = 604;
                t.eopenreversedclosed = 606;
                t.eopenreversedhook = 605;
                t.eparen = 9376;
                t.epsilon = 949;
                t.epsilontonos = 941;
                t.equal = 61;
                t.equalmonospace = 65309;
                t.equalsmall = 65126;
                t.equalsuperior = 8316;
                t.equivalence = 8801;
                t.erbopomofo = 12582;
                t.ercyrillic = 1088;
                t.ereversed = 600;
                t.ereversedcyrillic = 1101;
                t.escyrillic = 1089;
                t.esdescendercyrillic = 1195;
                t.esh = 643;
                t.eshcurl = 646;
                t.eshortdeva = 2318;
                t.eshortvowelsigndeva = 2374;
                t.eshreversedloop = 426;
                t.eshsquatreversed = 645;
                t.esmallhiragana = 12359;
                t.esmallkatakana = 12455;
                t.esmallkatakanahalfwidth = 65386;
                t.estimated = 8494;
                t.esuperior = 63212;
                t.eta = 951;
                t.etarmenian = 1384;
                t.etatonos = 942;
                t.eth = 240;
                t.etilde = 7869;
                t.etildebelow = 7707;
                t.etnahtafoukhhebrew = 1425;
                t.etnahtafoukhlefthebrew = 1425;
                t.etnahtahebrew = 1425;
                t.etnahtalefthebrew = 1425;
                t.eturned = 477;
                t.eukorean = 12641;
                t.euro = 8364;
                t.evowelsignbengali = 2503;
                t.evowelsigndeva = 2375;
                t.evowelsigngujarati = 2759;
                t.exclam = 33;
                t.exclamarmenian = 1372;
                t.exclamdbl = 8252;
                t.exclamdown = 161;
                t.exclamdownsmall = 63393;
                t.exclammonospace = 65281;
                t.exclamsmall = 63265;
                t.existential = 8707;
                t.ezh = 658;
                t.ezhcaron = 495;
                t.ezhcurl = 659;
                t.ezhreversed = 441;
                t.ezhtail = 442;
                t.f = 102;
                t.fadeva = 2398;
                t.fagurmukhi = 2654;
                t.fahrenheit = 8457;
                t.fathaarabic = 1614;
                t.fathalowarabic = 1614;
                t.fathatanarabic = 1611;
                t.fbopomofo = 12552;
                t.fcircle = 9429;
                t.fdotaccent = 7711;
                t.feharabic = 1601;
                t.feharmenian = 1414;
                t.fehfinalarabic = 65234;
                t.fehinitialarabic = 65235;
                t.fehmedialarabic = 65236;
                t.feicoptic = 997;
                t.female = 9792;
                t.ff = 64256;
                t.f_f = 64256;
                t.ffi = 64259;
                t.f_f_i = 64259;
                t.ffl = 64260;
                t.f_f_l = 64260;
                t.fi = 64257;
                t.f_i = 64257;
                t.fifteencircle = 9326;
                t.fifteenparen = 9346;
                t.fifteenperiod = 9366;
                t.figuredash = 8210;
                t.filledbox = 9632;
                t.filledrect = 9644;
                t.finalkaf = 1498;
                t.finalkafdagesh = 64314;
                t.finalkafdageshhebrew = 64314;
                t.finalkafhebrew = 1498;
                t.finalmem = 1501;
                t.finalmemhebrew = 1501;
                t.finalnun = 1503;
                t.finalnunhebrew = 1503;
                t.finalpe = 1507;
                t.finalpehebrew = 1507;
                t.finaltsadi = 1509;
                t.finaltsadihebrew = 1509;
                t.firsttonechinese = 713;
                t.fisheye = 9673;
                t.fitacyrillic = 1139;
                t.five = 53;
                t.fivearabic = 1637;
                t.fivebengali = 2539;
                t.fivecircle = 9316;
                t.fivecircleinversesansserif = 10126;
                t.fivedeva = 2411;
                t.fiveeighths = 8541;
                t.fivegujarati = 2795;
                t.fivegurmukhi = 2667;
                t.fivehackarabic = 1637;
                t.fivehangzhou = 12325;
                t.fiveideographicparen = 12836;
                t.fiveinferior = 8325;
                t.fivemonospace = 65301;
                t.fiveoldstyle = 63285;
                t.fiveparen = 9336;
                t.fiveperiod = 9356;
                t.fivepersian = 1781;
                t.fiveroman = 8564;
                t.fivesuperior = 8309;
                t.fivethai = 3669;
                t.fl = 64258;
                t.f_l = 64258;
                t.florin = 402;
                t.fmonospace = 65350;
                t.fmsquare = 13209;
                t.fofanthai = 3615;
                t.fofathai = 3613;
                t.fongmanthai = 3663;
                t.forall = 8704;
                t.four = 52;
                t.fourarabic = 1636;
                t.fourbengali = 2538;
                t.fourcircle = 9315;
                t.fourcircleinversesansserif = 10125;
                t.fourdeva = 2410;
                t.fourgujarati = 2794;
                t.fourgurmukhi = 2666;
                t.fourhackarabic = 1636;
                t.fourhangzhou = 12324;
                t.fourideographicparen = 12835;
                t.fourinferior = 8324;
                t.fourmonospace = 65300;
                t.fournumeratorbengali = 2551;
                t.fouroldstyle = 63284;
                t.fourparen = 9335;
                t.fourperiod = 9355;
                t.fourpersian = 1780;
                t.fourroman = 8563;
                t.foursuperior = 8308;
                t.fourteencircle = 9325;
                t.fourteenparen = 9345;
                t.fourteenperiod = 9365;
                t.fourthai = 3668;
                t.fourthtonechinese = 715;
                t.fparen = 9377;
                t.fraction = 8260;
                t.franc = 8355;
                t.g = 103;
                t.gabengali = 2455;
                t.gacute = 501;
                t.gadeva = 2327;
                t.gafarabic = 1711;
                t.gaffinalarabic = 64403;
                t.gafinitialarabic = 64404;
                t.gafmedialarabic = 64405;
                t.gagujarati = 2711;
                t.gagurmukhi = 2583;
                t.gahiragana = 12364;
                t.gakatakana = 12460;
                t.gamma = 947;
                t.gammalatinsmall = 611;
                t.gammasuperior = 736;
                t.gangiacoptic = 1003;
                t.gbopomofo = 12557;
                t.gbreve = 287;
                t.gcaron = 487;
                t.gcedilla = 291;
                t.gcircle = 9430;
                t.gcircumflex = 285;
                t.gcommaaccent = 291;
                t.gdot = 289;
                t.gdotaccent = 289;
                t.gecyrillic = 1075;
                t.gehiragana = 12370;
                t.gekatakana = 12466;
                t.geometricallyequal = 8785;
                t.gereshaccenthebrew = 1436;
                t.gereshhebrew = 1523;
                t.gereshmuqdamhebrew = 1437;
                t.germandbls = 223;
                t.gershayimaccenthebrew = 1438;
                t.gershayimhebrew = 1524;
                t.getamark = 12307;
                t.ghabengali = 2456;
                t.ghadarmenian = 1394;
                t.ghadeva = 2328;
                t.ghagujarati = 2712;
                t.ghagurmukhi = 2584;
                t.ghainarabic = 1594;
                t.ghainfinalarabic = 65230;
                t.ghaininitialarabic = 65231;
                t.ghainmedialarabic = 65232;
                t.ghemiddlehookcyrillic = 1173;
                t.ghestrokecyrillic = 1171;
                t.gheupturncyrillic = 1169;
                t.ghhadeva = 2394;
                t.ghhagurmukhi = 2650;
                t.ghook = 608;
                t.ghzsquare = 13203;
                t.gihiragana = 12366;
                t.gikatakana = 12462;
                t.gimarmenian = 1379;
                t.gimel = 1490;
                t.gimeldagesh = 64306;
                t.gimeldageshhebrew = 64306;
                t.gimelhebrew = 1490;
                t.gjecyrillic = 1107;
                t.glottalinvertedstroke = 446;
                t.glottalstop = 660;
                t.glottalstopinverted = 662;
                t.glottalstopmod = 704;
                t.glottalstopreversed = 661;
                t.glottalstopreversedmod = 705;
                t.glottalstopreversedsuperior = 740;
                t.glottalstopstroke = 673;
                t.glottalstopstrokereversed = 674;
                t.gmacron = 7713;
                t.gmonospace = 65351;
                t.gohiragana = 12372;
                t.gokatakana = 12468;
                t.gparen = 9378;
                t.gpasquare = 13228;
                t.gradient = 8711;
                t.grave = 96;
                t.gravebelowcmb = 790;
                t.gravecmb = 768;
                t.gravecomb = 768;
                t.gravedeva = 2387;
                t.gravelowmod = 718;
                t.gravemonospace = 65344;
                t.gravetonecmb = 832;
                t.greater = 62;
                t.greaterequal = 8805;
                t.greaterequalorless = 8923;
                t.greatermonospace = 65310;
                t.greaterorequivalent = 8819;
                t.greaterorless = 8823;
                t.greateroverequal = 8807;
                t.greatersmall = 65125;
                t.gscript = 609;
                t.gstroke = 485;
                t.guhiragana = 12368;
                t.guillemotleft = 171;
                t.guillemotright = 187;
                t.guilsinglleft = 8249;
                t.guilsinglright = 8250;
                t.gukatakana = 12464;
                t.guramusquare = 13080;
                t.gysquare = 13257;
                t.h = 104;
                t.haabkhasiancyrillic = 1193;
                t.haaltonearabic = 1729;
                t.habengali = 2489;
                t.hadescendercyrillic = 1203;
                t.hadeva = 2361;
                t.hagujarati = 2745;
                t.hagurmukhi = 2617;
                t.haharabic = 1581;
                t.hahfinalarabic = 65186;
                t.hahinitialarabic = 65187;
                t.hahiragana = 12399;
                t.hahmedialarabic = 65188;
                t.haitusquare = 13098;
                t.hakatakana = 12495;
                t.hakatakanahalfwidth = 65418;
                t.halantgurmukhi = 2637;
                t.hamzaarabic = 1569;
                t.hamzalowarabic = 1569;
                t.hangulfiller = 12644;
                t.hardsigncyrillic = 1098;
                t.harpoonleftbarbup = 8636;
                t.harpoonrightbarbup = 8640;
                t.hasquare = 13258;
                t.hatafpatah = 1458;
                t.hatafpatah16 = 1458;
                t.hatafpatah23 = 1458;
                t.hatafpatah2f = 1458;
                t.hatafpatahhebrew = 1458;
                t.hatafpatahnarrowhebrew = 1458;
                t.hatafpatahquarterhebrew = 1458;
                t.hatafpatahwidehebrew = 1458;
                t.hatafqamats = 1459;
                t.hatafqamats1b = 1459;
                t.hatafqamats28 = 1459;
                t.hatafqamats34 = 1459;
                t.hatafqamatshebrew = 1459;
                t.hatafqamatsnarrowhebrew = 1459;
                t.hatafqamatsquarterhebrew = 1459;
                t.hatafqamatswidehebrew = 1459;
                t.hatafsegol = 1457;
                t.hatafsegol17 = 1457;
                t.hatafsegol24 = 1457;
                t.hatafsegol30 = 1457;
                t.hatafsegolhebrew = 1457;
                t.hatafsegolnarrowhebrew = 1457;
                t.hatafsegolquarterhebrew = 1457;
                t.hatafsegolwidehebrew = 1457;
                t.hbar = 295;
                t.hbopomofo = 12559;
                t.hbrevebelow = 7723;
                t.hcedilla = 7721;
                t.hcircle = 9431;
                t.hcircumflex = 293;
                t.hdieresis = 7719;
                t.hdotaccent = 7715;
                t.hdotbelow = 7717;
                t.he = 1492;
                t.heart = 9829;
                t.heartsuitblack = 9829;
                t.heartsuitwhite = 9825;
                t.hedagesh = 64308;
                t.hedageshhebrew = 64308;
                t.hehaltonearabic = 1729;
                t.heharabic = 1607;
                t.hehebrew = 1492;
                t.hehfinalaltonearabic = 64423;
                t.hehfinalalttwoarabic = 65258;
                t.hehfinalarabic = 65258;
                t.hehhamzaabovefinalarabic = 64421;
                t.hehhamzaaboveisolatedarabic = 64420;
                t.hehinitialaltonearabic = 64424;
                t.hehinitialarabic = 65259;
                t.hehiragana = 12408;
                t.hehmedialaltonearabic = 64425;
                t.hehmedialarabic = 65260;
                t.heiseierasquare = 13179;
                t.hekatakana = 12504;
                t.hekatakanahalfwidth = 65421;
                t.hekutaarusquare = 13110;
                t.henghook = 615;
                t.herutusquare = 13113;
                t.het = 1495;
                t.hethebrew = 1495;
                t.hhook = 614;
                t.hhooksuperior = 689;
                t.hieuhacirclekorean = 12923;
                t.hieuhaparenkorean = 12827;
                t.hieuhcirclekorean = 12909;
                t.hieuhkorean = 12622;
                t.hieuhparenkorean = 12813;
                t.hihiragana = 12402;
                t.hikatakana = 12498;
                t.hikatakanahalfwidth = 65419;
                t.hiriq = 1460;
                t.hiriq14 = 1460;
                t.hiriq21 = 1460;
                t.hiriq2d = 1460;
                t.hiriqhebrew = 1460;
                t.hiriqnarrowhebrew = 1460;
                t.hiriqquarterhebrew = 1460;
                t.hiriqwidehebrew = 1460;
                t.hlinebelow = 7830;
                t.hmonospace = 65352;
                t.hoarmenian = 1392;
                t.hohipthai = 3627;
                t.hohiragana = 12411;
                t.hokatakana = 12507;
                t.hokatakanahalfwidth = 65422;
                t.holam = 1465;
                t.holam19 = 1465;
                t.holam26 = 1465;
                t.holam32 = 1465;
                t.holamhebrew = 1465;
                t.holamnarrowhebrew = 1465;
                t.holamquarterhebrew = 1465;
                t.holamwidehebrew = 1465;
                t.honokhukthai = 3630;
                t.hookabovecomb = 777;
                t.hookcmb = 777;
                t.hookpalatalizedbelowcmb = 801;
                t.hookretroflexbelowcmb = 802;
                t.hoonsquare = 13122;
                t.horicoptic = 1001;
                t.horizontalbar = 8213;
                t.horncmb = 795;
                t.hotsprings = 9832;
                t.house = 8962;
                t.hparen = 9379;
                t.hsuperior = 688;
                t.hturned = 613;
                t.huhiragana = 12405;
                t.huiitosquare = 13107;
                t.hukatakana = 12501;
                t.hukatakanahalfwidth = 65420;
                t.hungarumlaut = 733;
                t.hungarumlautcmb = 779;
                t.hv = 405;
                t.hyphen = 45;
                t.hypheninferior = 63205;
                t.hyphenmonospace = 65293;
                t.hyphensmall = 65123;
                t.hyphensuperior = 63206;
                t.hyphentwo = 8208;
                t.i = 105;
                t.iacute = 237;
                t.iacyrillic = 1103;
                t.ibengali = 2439;
                t.ibopomofo = 12583;
                t.ibreve = 301;
                t.icaron = 464;
                t.icircle = 9432;
                t.icircumflex = 238;
                t.icyrillic = 1110;
                t.idblgrave = 521;
                t.ideographearthcircle = 12943;
                t.ideographfirecircle = 12939;
                t.ideographicallianceparen = 12863;
                t.ideographiccallparen = 12858;
                t.ideographiccentrecircle = 12965;
                t.ideographicclose = 12294;
                t.ideographiccomma = 12289;
                t.ideographiccommaleft = 65380;
                t.ideographiccongratulationparen = 12855;
                t.ideographiccorrectcircle = 12963;
                t.ideographicearthparen = 12847;
                t.ideographicenterpriseparen = 12861;
                t.ideographicexcellentcircle = 12957;
                t.ideographicfestivalparen = 12864;
                t.ideographicfinancialcircle = 12950;
                t.ideographicfinancialparen = 12854;
                t.ideographicfireparen = 12843;
                t.ideographichaveparen = 12850;
                t.ideographichighcircle = 12964;
                t.ideographiciterationmark = 12293;
                t.ideographiclaborcircle = 12952;
                t.ideographiclaborparen = 12856;
                t.ideographicleftcircle = 12967;
                t.ideographiclowcircle = 12966;
                t.ideographicmedicinecircle = 12969;
                t.ideographicmetalparen = 12846;
                t.ideographicmoonparen = 12842;
                t.ideographicnameparen = 12852;
                t.ideographicperiod = 12290;
                t.ideographicprintcircle = 12958;
                t.ideographicreachparen = 12867;
                t.ideographicrepresentparen = 12857;
                t.ideographicresourceparen = 12862;
                t.ideographicrightcircle = 12968;
                t.ideographicsecretcircle = 12953;
                t.ideographicselfparen = 12866;
                t.ideographicsocietyparen = 12851;
                t.ideographicspace = 12288;
                t.ideographicspecialparen = 12853;
                t.ideographicstockparen = 12849;
                t.ideographicstudyparen = 12859;
                t.ideographicsunparen = 12848;
                t.ideographicsuperviseparen = 12860;
                t.ideographicwaterparen = 12844;
                t.ideographicwoodparen = 12845;
                t.ideographiczero = 12295;
                t.ideographmetalcircle = 12942;
                t.ideographmooncircle = 12938;
                t.ideographnamecircle = 12948;
                t.ideographsuncircle = 12944;
                t.ideographwatercircle = 12940;
                t.ideographwoodcircle = 12941;
                t.ideva = 2311;
                t.idieresis = 239;
                t.idieresisacute = 7727;
                t.idieresiscyrillic = 1253;
                t.idotbelow = 7883;
                t.iebrevecyrillic = 1239;
                t.iecyrillic = 1077;
                t.ieungacirclekorean = 12917;
                t.ieungaparenkorean = 12821;
                t.ieungcirclekorean = 12903;
                t.ieungkorean = 12615;
                t.ieungparenkorean = 12807;
                t.igrave = 236;
                t.igujarati = 2695;
                t.igurmukhi = 2567;
                t.ihiragana = 12356;
                t.ihookabove = 7881;
                t.iibengali = 2440;
                t.iicyrillic = 1080;
                t.iideva = 2312;
                t.iigujarati = 2696;
                t.iigurmukhi = 2568;
                t.iimatragurmukhi = 2624;
                t.iinvertedbreve = 523;
                t.iishortcyrillic = 1081;
                t.iivowelsignbengali = 2496;
                t.iivowelsigndeva = 2368;
                t.iivowelsigngujarati = 2752;
                t.ij = 307;
                t.ikatakana = 12452;
                t.ikatakanahalfwidth = 65394;
                t.ikorean = 12643;
                t.ilde = 732;
                t.iluyhebrew = 1452;
                t.imacron = 299;
                t.imacroncyrillic = 1251;
                t.imageorapproximatelyequal = 8787;
                t.imatragurmukhi = 2623;
                t.imonospace = 65353;
                t.increment = 8710;
                t.infinity = 8734;
                t.iniarmenian = 1387;
                t.integral = 8747;
                t.integralbottom = 8993;
                t.integralbt = 8993;
                t.integralex = 63733;
                t.integraltop = 8992;
                t.integraltp = 8992;
                t.intersection = 8745;
                t.intisquare = 13061;
                t.invbullet = 9688;
                t.invcircle = 9689;
                t.invsmileface = 9787;
                t.iocyrillic = 1105;
                t.iogonek = 303;
                t.iota = 953;
                t.iotadieresis = 970;
                t.iotadieresistonos = 912;
                t.iotalatin = 617;
                t.iotatonos = 943;
                t.iparen = 9380;
                t.irigurmukhi = 2674;
                t.ismallhiragana = 12355;
                t.ismallkatakana = 12451;
                t.ismallkatakanahalfwidth = 65384;
                t.issharbengali = 2554;
                t.istroke = 616;
                t.isuperior = 63213;
                t.iterationhiragana = 12445;
                t.iterationkatakana = 12541;
                t.itilde = 297;
                t.itildebelow = 7725;
                t.iubopomofo = 12585;
                t.iucyrillic = 1102;
                t.ivowelsignbengali = 2495;
                t.ivowelsigndeva = 2367;
                t.ivowelsigngujarati = 2751;
                t.izhitsacyrillic = 1141;
                t.izhitsadblgravecyrillic = 1143;
                t.j = 106;
                t.jaarmenian = 1393;
                t.jabengali = 2460;
                t.jadeva = 2332;
                t.jagujarati = 2716;
                t.jagurmukhi = 2588;
                t.jbopomofo = 12560;
                t.jcaron = 496;
                t.jcircle = 9433;
                t.jcircumflex = 309;
                t.jcrossedtail = 669;
                t.jdotlessstroke = 607;
                t.jecyrillic = 1112;
                t.jeemarabic = 1580;
                t.jeemfinalarabic = 65182;
                t.jeeminitialarabic = 65183;
                t.jeemmedialarabic = 65184;
                t.jeharabic = 1688;
                t.jehfinalarabic = 64395;
                t.jhabengali = 2461;
                t.jhadeva = 2333;
                t.jhagujarati = 2717;
                t.jhagurmukhi = 2589;
                t.jheharmenian = 1403;
                t.jis = 12292;
                t.jmonospace = 65354;
                t.jparen = 9381;
                t.jsuperior = 690;
                t.k = 107;
                t.kabashkircyrillic = 1185;
                t.kabengali = 2453;
                t.kacute = 7729;
                t.kacyrillic = 1082;
                t.kadescendercyrillic = 1179;
                t.kadeva = 2325;
                t.kaf = 1499;
                t.kafarabic = 1603;
                t.kafdagesh = 64315;
                t.kafdageshhebrew = 64315;
                t.kaffinalarabic = 65242;
                t.kafhebrew = 1499;
                t.kafinitialarabic = 65243;
                t.kafmedialarabic = 65244;
                t.kafrafehebrew = 64333;
                t.kagujarati = 2709;
                t.kagurmukhi = 2581;
                t.kahiragana = 12363;
                t.kahookcyrillic = 1220;
                t.kakatakana = 12459;
                t.kakatakanahalfwidth = 65398;
                t.kappa = 954;
                t.kappasymbolgreek = 1008;
                t.kapyeounmieumkorean = 12657;
                t.kapyeounphieuphkorean = 12676;
                t.kapyeounpieupkorean = 12664;
                t.kapyeounssangpieupkorean = 12665;
                t.karoriisquare = 13069;
                t.kashidaautoarabic = 1600;
                t.kashidaautonosidebearingarabic = 1600;
                t.kasmallkatakana = 12533;
                t.kasquare = 13188;
                t.kasraarabic = 1616;
                t.kasratanarabic = 1613;
                t.kastrokecyrillic = 1183;
                t.katahiraprolongmarkhalfwidth = 65392;
                t.kaverticalstrokecyrillic = 1181;
                t.kbopomofo = 12558;
                t.kcalsquare = 13193;
                t.kcaron = 489;
                t.kcedilla = 311;
                t.kcircle = 9434;
                t.kcommaaccent = 311;
                t.kdotbelow = 7731;
                t.keharmenian = 1412;
                t.kehiragana = 12369;
                t.kekatakana = 12465;
                t.kekatakanahalfwidth = 65401;
                t.kenarmenian = 1391;
                t.kesmallkatakana = 12534;
                t.kgreenlandic = 312;
                t.khabengali = 2454;
                t.khacyrillic = 1093;
                t.khadeva = 2326;
                t.khagujarati = 2710;
                t.khagurmukhi = 2582;
                t.khaharabic = 1582;
                t.khahfinalarabic = 65190;
                t.khahinitialarabic = 65191;
                t.khahmedialarabic = 65192;
                t.kheicoptic = 999;
                t.khhadeva = 2393;
                t.khhagurmukhi = 2649;
                t.khieukhacirclekorean = 12920;
                t.khieukhaparenkorean = 12824;
                t.khieukhcirclekorean = 12906;
                t.khieukhkorean = 12619;
                t.khieukhparenkorean = 12810;
                t.khokhaithai = 3586;
                t.khokhonthai = 3589;
                t.khokhuatthai = 3587;
                t.khokhwaithai = 3588;
                t.khomutthai = 3675;
                t.khook = 409;
                t.khorakhangthai = 3590;
                t.khzsquare = 13201;
                t.kihiragana = 12365;
                t.kikatakana = 12461;
                t.kikatakanahalfwidth = 65399;
                t.kiroguramusquare = 13077;
                t.kiromeetorusquare = 13078;
                t.kirosquare = 13076;
                t.kiyeokacirclekorean = 12910;
                t.kiyeokaparenkorean = 12814;
                t.kiyeokcirclekorean = 12896;
                t.kiyeokkorean = 12593;
                t.kiyeokparenkorean = 12800;
                t.kiyeoksioskorean = 12595;
                t.kjecyrillic = 1116;
                t.klinebelow = 7733;
                t.klsquare = 13208;
                t.kmcubedsquare = 13222;
                t.kmonospace = 65355;
                t.kmsquaredsquare = 13218;
                t.kohiragana = 12371;
                t.kohmsquare = 13248;
                t.kokaithai = 3585;
                t.kokatakana = 12467;
                t.kokatakanahalfwidth = 65402;
                t.kooposquare = 13086;
                t.koppacyrillic = 1153;
                t.koreanstandardsymbol = 12927;
                t.koroniscmb = 835;
                t.kparen = 9382;
                t.kpasquare = 13226;
                t.ksicyrillic = 1135;
                t.ktsquare = 13263;
                t.kturned = 670;
                t.kuhiragana = 12367;
                t.kukatakana = 12463;
                t.kukatakanahalfwidth = 65400;
                t.kvsquare = 13240;
                t.kwsquare = 13246;
                t.l = 108;
                t.labengali = 2482;
                t.lacute = 314;
                t.ladeva = 2354;
                t.lagujarati = 2738;
                t.lagurmukhi = 2610;
                t.lakkhangyaothai = 3653;
                t.lamaleffinalarabic = 65276;
                t.lamalefhamzaabovefinalarabic = 65272;
                t.lamalefhamzaaboveisolatedarabic = 65271;
                t.lamalefhamzabelowfinalarabic = 65274;
                t.lamalefhamzabelowisolatedarabic = 65273;
                t.lamalefisolatedarabic = 65275;
                t.lamalefmaddaabovefinalarabic = 65270;
                t.lamalefmaddaaboveisolatedarabic = 65269;
                t.lamarabic = 1604;
                t.lambda = 955;
                t.lambdastroke = 411;
                t.lamed = 1500;
                t.lameddagesh = 64316;
                t.lameddageshhebrew = 64316;
                t.lamedhebrew = 1500;
                t.lamfinalarabic = 65246;
                t.lamhahinitialarabic = 64714;
                t.laminitialarabic = 65247;
                t.lamjeeminitialarabic = 64713;
                t.lamkhahinitialarabic = 64715;
                t.lamlamhehisolatedarabic = 65010;
                t.lammedialarabic = 65248;
                t.lammeemhahinitialarabic = 64904;
                t.lammeeminitialarabic = 64716;
                t.largecircle = 9711;
                t.lbar = 410;
                t.lbelt = 620;
                t.lbopomofo = 12556;
                t.lcaron = 318;
                t.lcedilla = 316;
                t.lcircle = 9435;
                t.lcircumflexbelow = 7741;
                t.lcommaaccent = 316;
                t.ldot = 320;
                t.ldotaccent = 320;
                t.ldotbelow = 7735;
                t.ldotbelowmacron = 7737;
                t.leftangleabovecmb = 794;
                t.lefttackbelowcmb = 792;
                t.less = 60;
                t.lessequal = 8804;
                t.lessequalorgreater = 8922;
                t.lessmonospace = 65308;
                t.lessorequivalent = 8818;
                t.lessorgreater = 8822;
                t.lessoverequal = 8806;
                t.lesssmall = 65124;
                t.lezh = 622;
                t.lfblock = 9612;
                t.lhookretroflex = 621;
                t.lira = 8356;
                t.liwnarmenian = 1388;
                t.lj = 457;
                t.ljecyrillic = 1113;
                t.ll = 63168;
                t.lladeva = 2355;
                t.llagujarati = 2739;
                t.llinebelow = 7739;
                t.llladeva = 2356;
                t.llvocalicbengali = 2529;
                t.llvocalicdeva = 2401;
                t.llvocalicvowelsignbengali = 2531;
                t.llvocalicvowelsigndeva = 2403;
                t.lmiddletilde = 619;
                t.lmonospace = 65356;
                t.lmsquare = 13264;
                t.lochulathai = 3628;
                t.logicaland = 8743;
                t.logicalnot = 172;
                t.logicalnotreversed = 8976;
                t.logicalor = 8744;
                t.lolingthai = 3621;
                t.longs = 383;
                t.lowlinecenterline = 65102;
                t.lowlinecmb = 818;
                t.lowlinedashed = 65101;
                t.lozenge = 9674;
                t.lparen = 9383;
                t.lslash = 322;
                t.lsquare = 8467;
                t.lsuperior = 63214;
                t.ltshade = 9617;
                t.luthai = 3622;
                t.lvocalicbengali = 2444;
                t.lvocalicdeva = 2316;
                t.lvocalicvowelsignbengali = 2530;
                t.lvocalicvowelsigndeva = 2402;
                t.lxsquare = 13267;
                t.m = 109;
                t.mabengali = 2478;
                t.macron = 175;
                t.macronbelowcmb = 817;
                t.macroncmb = 772;
                t.macronlowmod = 717;
                t.macronmonospace = 65507;
                t.macute = 7743;
                t.madeva = 2350;
                t.magujarati = 2734;
                t.magurmukhi = 2606;
                t.mahapakhhebrew = 1444;
                t.mahapakhlefthebrew = 1444;
                t.mahiragana = 12414;
                t.maichattawalowleftthai = 63637;
                t.maichattawalowrightthai = 63636;
                t.maichattawathai = 3659;
                t.maichattawaupperleftthai = 63635;
                t.maieklowleftthai = 63628;
                t.maieklowrightthai = 63627;
                t.maiekthai = 3656;
                t.maiekupperleftthai = 63626;
                t.maihanakatleftthai = 63620;
                t.maihanakatthai = 3633;
                t.maitaikhuleftthai = 63625;
                t.maitaikhuthai = 3655;
                t.maitholowleftthai = 63631;
                t.maitholowrightthai = 63630;
                t.maithothai = 3657;
                t.maithoupperleftthai = 63629;
                t.maitrilowleftthai = 63634;
                t.maitrilowrightthai = 63633;
                t.maitrithai = 3658;
                t.maitriupperleftthai = 63632;
                t.maiyamokthai = 3654;
                t.makatakana = 12510;
                t.makatakanahalfwidth = 65423;
                t.male = 9794;
                t.mansyonsquare = 13127;
                t.maqafhebrew = 1470;
                t.mars = 9794;
                t.masoracirclehebrew = 1455;
                t.masquare = 13187;
                t.mbopomofo = 12551;
                t.mbsquare = 13268;
                t.mcircle = 9436;
                t.mcubedsquare = 13221;
                t.mdotaccent = 7745;
                t.mdotbelow = 7747;
                t.meemarabic = 1605;
                t.meemfinalarabic = 65250;
                t.meeminitialarabic = 65251;
                t.meemmedialarabic = 65252;
                t.meemmeeminitialarabic = 64721;
                t.meemmeemisolatedarabic = 64584;
                t.meetorusquare = 13133;
                t.mehiragana = 12417;
                t.meizierasquare = 13182;
                t.mekatakana = 12513;
                t.mekatakanahalfwidth = 65426;
                t.mem = 1502;
                t.memdagesh = 64318;
                t.memdageshhebrew = 64318;
                t.memhebrew = 1502;
                t.menarmenian = 1396;
                t.merkhahebrew = 1445;
                t.merkhakefulahebrew = 1446;
                t.merkhakefulalefthebrew = 1446;
                t.merkhalefthebrew = 1445;
                t.mhook = 625;
                t.mhzsquare = 13202;
                t.middledotkatakanahalfwidth = 65381;
                t.middot = 183;
                t.mieumacirclekorean = 12914;
                t.mieumaparenkorean = 12818;
                t.mieumcirclekorean = 12900;
                t.mieumkorean = 12609;
                t.mieumpansioskorean = 12656;
                t.mieumparenkorean = 12804;
                t.mieumpieupkorean = 12654;
                t.mieumsioskorean = 12655;
                t.mihiragana = 12415;
                t.mikatakana = 12511;
                t.mikatakanahalfwidth = 65424;
                t.minus = 8722;
                t.minusbelowcmb = 800;
                t.minuscircle = 8854;
                t.minusmod = 727;
                t.minusplus = 8723;
                t.minute = 8242;
                t.miribaarusquare = 13130;
                t.mirisquare = 13129;
                t.mlonglegturned = 624;
                t.mlsquare = 13206;
                t.mmcubedsquare = 13219;
                t.mmonospace = 65357;
                t.mmsquaredsquare = 13215;
                t.mohiragana = 12418;
                t.mohmsquare = 13249;
                t.mokatakana = 12514;
                t.mokatakanahalfwidth = 65427;
                t.molsquare = 13270;
                t.momathai = 3617;
                t.moverssquare = 13223;
                t.moverssquaredsquare = 13224;
                t.mparen = 9384;
                t.mpasquare = 13227;
                t.mssquare = 13235;
                t.msuperior = 63215;
                t.mturned = 623;
                t.mu = 181;
                t.mu1 = 181;
                t.muasquare = 13186;
                t.muchgreater = 8811;
                t.muchless = 8810;
                t.mufsquare = 13196;
                t.mugreek = 956;
                t.mugsquare = 13197;
                t.muhiragana = 12416;
                t.mukatakana = 12512;
                t.mukatakanahalfwidth = 65425;
                t.mulsquare = 13205;
                t.multiply = 215;
                t.mumsquare = 13211;
                t.munahhebrew = 1443;
                t.munahlefthebrew = 1443;
                t.musicalnote = 9834;
                t.musicalnotedbl = 9835;
                t.musicflatsign = 9837;
                t.musicsharpsign = 9839;
                t.mussquare = 13234;
                t.muvsquare = 13238;
                t.muwsquare = 13244;
                t.mvmegasquare = 13241;
                t.mvsquare = 13239;
                t.mwmegasquare = 13247;
                t.mwsquare = 13245;
                t.n = 110;
                t.nabengali = 2472;
                t.nabla = 8711;
                t.nacute = 324;
                t.nadeva = 2344;
                t.nagujarati = 2728;
                t.nagurmukhi = 2600;
                t.nahiragana = 12394;
                t.nakatakana = 12490;
                t.nakatakanahalfwidth = 65413;
                t.napostrophe = 329;
                t.nasquare = 13185;
                t.nbopomofo = 12555;
                t.nbspace = 160;
                t.ncaron = 328;
                t.ncedilla = 326;
                t.ncircle = 9437;
                t.ncircumflexbelow = 7755;
                t.ncommaaccent = 326;
                t.ndotaccent = 7749;
                t.ndotbelow = 7751;
                t.nehiragana = 12397;
                t.nekatakana = 12493;
                t.nekatakanahalfwidth = 65416;
                t.newsheqelsign = 8362;
                t.nfsquare = 13195;
                t.ngabengali = 2457;
                t.ngadeva = 2329;
                t.ngagujarati = 2713;
                t.ngagurmukhi = 2585;
                t.ngonguthai = 3591;
                t.nhiragana = 12435;
                t.nhookleft = 626;
                t.nhookretroflex = 627;
                t.nieunacirclekorean = 12911;
                t.nieunaparenkorean = 12815;
                t.nieuncieuckorean = 12597;
                t.nieuncirclekorean = 12897;
                t.nieunhieuhkorean = 12598;
                t.nieunkorean = 12596;
                t.nieunpansioskorean = 12648;
                t.nieunparenkorean = 12801;
                t.nieunsioskorean = 12647;
                t.nieuntikeutkorean = 12646;
                t.nihiragana = 12395;
                t.nikatakana = 12491;
                t.nikatakanahalfwidth = 65414;
                t.nikhahitleftthai = 63641;
                t.nikhahitthai = 3661;
                t.nine = 57;
                t.ninearabic = 1641;
                t.ninebengali = 2543;
                t.ninecircle = 9320;
                t.ninecircleinversesansserif = 10130;
                t.ninedeva = 2415;
                t.ninegujarati = 2799;
                t.ninegurmukhi = 2671;
                t.ninehackarabic = 1641;
                t.ninehangzhou = 12329;
                t.nineideographicparen = 12840;
                t.nineinferior = 8329;
                t.ninemonospace = 65305;
                t.nineoldstyle = 63289;
                t.nineparen = 9340;
                t.nineperiod = 9360;
                t.ninepersian = 1785;
                t.nineroman = 8568;
                t.ninesuperior = 8313;
                t.nineteencircle = 9330;
                t.nineteenparen = 9350;
                t.nineteenperiod = 9370;
                t.ninethai = 3673;
                t.nj = 460;
                t.njecyrillic = 1114;
                t.nkatakana = 12531;
                t.nkatakanahalfwidth = 65437;
                t.nlegrightlong = 414;
                t.nlinebelow = 7753;
                t.nmonospace = 65358;
                t.nmsquare = 13210;
                t.nnabengali = 2467;
                t.nnadeva = 2339;
                t.nnagujarati = 2723;
                t.nnagurmukhi = 2595;
                t.nnnadeva = 2345;
                t.nohiragana = 12398;
                t.nokatakana = 12494;
                t.nokatakanahalfwidth = 65417;
                t.nonbreakingspace = 160;
                t.nonenthai = 3603;
                t.nonuthai = 3609;
                t.noonarabic = 1606;
                t.noonfinalarabic = 65254;
                t.noonghunnaarabic = 1722;
                t.noonghunnafinalarabic = 64415;
                t.nooninitialarabic = 65255;
                t.noonjeeminitialarabic = 64722;
                t.noonjeemisolatedarabic = 64587;
                t.noonmedialarabic = 65256;
                t.noonmeeminitialarabic = 64725;
                t.noonmeemisolatedarabic = 64590;
                t.noonnoonfinalarabic = 64653;
                t.notcontains = 8716;
                t.notelement = 8713;
                t.notelementof = 8713;
                t.notequal = 8800;
                t.notgreater = 8815;
                t.notgreaternorequal = 8817;
                t.notgreaternorless = 8825;
                t.notidentical = 8802;
                t.notless = 8814;
                t.notlessnorequal = 8816;
                t.notparallel = 8742;
                t.notprecedes = 8832;
                t.notsubset = 8836;
                t.notsucceeds = 8833;
                t.notsuperset = 8837;
                t.nowarmenian = 1398;
                t.nparen = 9385;
                t.nssquare = 13233;
                t.nsuperior = 8319;
                t.ntilde = 241;
                t.nu = 957;
                t.nuhiragana = 12396;
                t.nukatakana = 12492;
                t.nukatakanahalfwidth = 65415;
                t.nuktabengali = 2492;
                t.nuktadeva = 2364;
                t.nuktagujarati = 2748;
                t.nuktagurmukhi = 2620;
                t.numbersign = 35;
                t.numbersignmonospace = 65283;
                t.numbersignsmall = 65119;
                t.numeralsigngreek = 884;
                t.numeralsignlowergreek = 885;
                t.numero = 8470;
                t.nun = 1504;
                t.nundagesh = 64320;
                t.nundageshhebrew = 64320;
                t.nunhebrew = 1504;
                t.nvsquare = 13237;
                t.nwsquare = 13243;
                t.nyabengali = 2462;
                t.nyadeva = 2334;
                t.nyagujarati = 2718;
                t.nyagurmukhi = 2590;
                t.o = 111;
                t.oacute = 243;
                t.oangthai = 3629;
                t.obarred = 629;
                t.obarredcyrillic = 1257;
                t.obarreddieresiscyrillic = 1259;
                t.obengali = 2451;
                t.obopomofo = 12571;
                t.obreve = 335;
                t.ocandradeva = 2321;
                t.ocandragujarati = 2705;
                t.ocandravowelsigndeva = 2377;
                t.ocandravowelsigngujarati = 2761;
                t.ocaron = 466;
                t.ocircle = 9438;
                t.ocircumflex = 244;
                t.ocircumflexacute = 7889;
                t.ocircumflexdotbelow = 7897;
                t.ocircumflexgrave = 7891;
                t.ocircumflexhookabove = 7893;
                t.ocircumflextilde = 7895;
                t.ocyrillic = 1086;
                t.odblacute = 337;
                t.odblgrave = 525;
                t.odeva = 2323;
                t.odieresis = 246;
                t.odieresiscyrillic = 1255;
                t.odotbelow = 7885;
                t.oe = 339;
                t.oekorean = 12634;
                t.ogonek = 731;
                t.ogonekcmb = 808;
                t.ograve = 242;
                t.ogujarati = 2707;
                t.oharmenian = 1413;
                t.ohiragana = 12362;
                t.ohookabove = 7887;
                t.ohorn = 417;
                t.ohornacute = 7899;
                t.ohorndotbelow = 7907;
                t.ohorngrave = 7901;
                t.ohornhookabove = 7903;
                t.ohorntilde = 7905;
                t.ohungarumlaut = 337;
                t.oi = 419;
                t.oinvertedbreve = 527;
                t.okatakana = 12458;
                t.okatakanahalfwidth = 65397;
                t.okorean = 12631;
                t.olehebrew = 1451;
                t.omacron = 333;
                t.omacronacute = 7763;
                t.omacrongrave = 7761;
                t.omdeva = 2384;
                t.omega = 969;
                t.omega1 = 982;
                t.omegacyrillic = 1121;
                t.omegalatinclosed = 631;
                t.omegaroundcyrillic = 1147;
                t.omegatitlocyrillic = 1149;
                t.omegatonos = 974;
                t.omgujarati = 2768;
                t.omicron = 959;
                t.omicrontonos = 972;
                t.omonospace = 65359;
                t.one = 49;
                t.onearabic = 1633;
                t.onebengali = 2535;
                t.onecircle = 9312;
                t.onecircleinversesansserif = 10122;
                t.onedeva = 2407;
                t.onedotenleader = 8228;
                t.oneeighth = 8539;
                t.onefitted = 63196;
                t.onegujarati = 2791;
                t.onegurmukhi = 2663;
                t.onehackarabic = 1633;
                t.onehalf = 189;
                t.onehangzhou = 12321;
                t.oneideographicparen = 12832;
                t.oneinferior = 8321;
                t.onemonospace = 65297;
                t.onenumeratorbengali = 2548;
                t.oneoldstyle = 63281;
                t.oneparen = 9332;
                t.oneperiod = 9352;
                t.onepersian = 1777;
                t.onequarter = 188;
                t.oneroman = 8560;
                t.onesuperior = 185;
                t.onethai = 3665;
                t.onethird = 8531;
                t.oogonek = 491;
                t.oogonekmacron = 493;
                t.oogurmukhi = 2579;
                t.oomatragurmukhi = 2635;
                t.oopen = 596;
                t.oparen = 9386;
                t.openbullet = 9702;
                t.option = 8997;
                t.ordfeminine = 170;
                t.ordmasculine = 186;
                t.orthogonal = 8735;
                t.oshortdeva = 2322;
                t.oshortvowelsigndeva = 2378;
                t.oslash = 248;
                t.oslashacute = 511;
                t.osmallhiragana = 12361;
                t.osmallkatakana = 12457;
                t.osmallkatakanahalfwidth = 65387;
                t.ostrokeacute = 511;
                t.osuperior = 63216;
                t.otcyrillic = 1151;
                t.otilde = 245;
                t.otildeacute = 7757;
                t.otildedieresis = 7759;
                t.oubopomofo = 12577;
                t.overline = 8254;
                t.overlinecenterline = 65098;
                t.overlinecmb = 773;
                t.overlinedashed = 65097;
                t.overlinedblwavy = 65100;
                t.overlinewavy = 65099;
                t.overscore = 175;
                t.ovowelsignbengali = 2507;
                t.ovowelsigndeva = 2379;
                t.ovowelsigngujarati = 2763;
                t.p = 112;
                t.paampssquare = 13184;
                t.paasentosquare = 13099;
                t.pabengali = 2474;
                t.pacute = 7765;
                t.padeva = 2346;
                t.pagedown = 8671;
                t.pageup = 8670;
                t.pagujarati = 2730;
                t.pagurmukhi = 2602;
                t.pahiragana = 12401;
                t.paiyannoithai = 3631;
                t.pakatakana = 12497;
                t.palatalizationcyrilliccmb = 1156;
                t.palochkacyrillic = 1216;
                t.pansioskorean = 12671;
                t.paragraph = 182;
                t.parallel = 8741;
                t.parenleft = 40;
                t.parenleftaltonearabic = 64830;
                t.parenleftbt = 63725;
                t.parenleftex = 63724;
                t.parenleftinferior = 8333;
                t.parenleftmonospace = 65288;
                t.parenleftsmall = 65113;
                t.parenleftsuperior = 8317;
                t.parenlefttp = 63723;
                t.parenleftvertical = 65077;
                t.parenright = 41;
                t.parenrightaltonearabic = 64831;
                t.parenrightbt = 63736;
                t.parenrightex = 63735;
                t.parenrightinferior = 8334;
                t.parenrightmonospace = 65289;
                t.parenrightsmall = 65114;
                t.parenrightsuperior = 8318;
                t.parenrighttp = 63734;
                t.parenrightvertical = 65078;
                t.partialdiff = 8706;
                t.paseqhebrew = 1472;
                t.pashtahebrew = 1433;
                t.pasquare = 13225;
                t.patah = 1463;
                t.patah11 = 1463;
                t.patah1d = 1463;
                t.patah2a = 1463;
                t.patahhebrew = 1463;
                t.patahnarrowhebrew = 1463;
                t.patahquarterhebrew = 1463;
                t.patahwidehebrew = 1463;
                t.pazerhebrew = 1441;
                t.pbopomofo = 12550;
                t.pcircle = 9439;
                t.pdotaccent = 7767;
                t.pe = 1508;
                t.pecyrillic = 1087;
                t.pedagesh = 64324;
                t.pedageshhebrew = 64324;
                t.peezisquare = 13115;
                t.pefinaldageshhebrew = 64323;
                t.peharabic = 1662;
                t.peharmenian = 1402;
                t.pehebrew = 1508;
                t.pehfinalarabic = 64343;
                t.pehinitialarabic = 64344;
                t.pehiragana = 12410;
                t.pehmedialarabic = 64345;
                t.pekatakana = 12506;
                t.pemiddlehookcyrillic = 1191;
                t.perafehebrew = 64334;
                t.percent = 37;
                t.percentarabic = 1642;
                t.percentmonospace = 65285;
                t.percentsmall = 65130;
                t.period = 46;
                t.periodarmenian = 1417;
                t.periodcentered = 183;
                t.periodhalfwidth = 65377;
                t.periodinferior = 63207;
                t.periodmonospace = 65294;
                t.periodsmall = 65106;
                t.periodsuperior = 63208;
                t.perispomenigreekcmb = 834;
                t.perpendicular = 8869;
                t.perthousand = 8240;
                t.peseta = 8359;
                t.pfsquare = 13194;
                t.phabengali = 2475;
                t.phadeva = 2347;
                t.phagujarati = 2731;
                t.phagurmukhi = 2603;
                t.phi = 966;
                t.phi1 = 981;
                t.phieuphacirclekorean = 12922;
                t.phieuphaparenkorean = 12826;
                t.phieuphcirclekorean = 12908;
                t.phieuphkorean = 12621;
                t.phieuphparenkorean = 12812;
                t.philatin = 632;
                t.phinthuthai = 3642;
                t.phisymbolgreek = 981;
                t.phook = 421;
                t.phophanthai = 3614;
                t.phophungthai = 3612;
                t.phosamphaothai = 3616;
                t.pi = 960;
                t.pieupacirclekorean = 12915;
                t.pieupaparenkorean = 12819;
                t.pieupcieuckorean = 12662;
                t.pieupcirclekorean = 12901;
                t.pieupkiyeokkorean = 12658;
                t.pieupkorean = 12610;
                t.pieupparenkorean = 12805;
                t.pieupsioskiyeokkorean = 12660;
                t.pieupsioskorean = 12612;
                t.pieupsiostikeutkorean = 12661;
                t.pieupthieuthkorean = 12663;
                t.pieuptikeutkorean = 12659;
                t.pihiragana = 12404;
                t.pikatakana = 12500;
                t.pisymbolgreek = 982;
                t.piwrarmenian = 1411;
                t.planckover2pi = 8463;
                t.planckover2pi1 = 8463;
                t.plus = 43;
                t.plusbelowcmb = 799;
                t.pluscircle = 8853;
                t.plusminus = 177;
                t.plusmod = 726;
                t.plusmonospace = 65291;
                t.plussmall = 65122;
                t.plussuperior = 8314;
                t.pmonospace = 65360;
                t.pmsquare = 13272;
                t.pohiragana = 12413;
                t.pointingindexdownwhite = 9759;
                t.pointingindexleftwhite = 9756;
                t.pointingindexrightwhite = 9758;
                t.pointingindexupwhite = 9757;
                t.pokatakana = 12509;
                t.poplathai = 3611;
                t.postalmark = 12306;
                t.postalmarkface = 12320;
                t.pparen = 9387;
                t.precedes = 8826;
                t.prescription = 8478;
                t.primemod = 697;
                t.primereversed = 8245;
                t.product = 8719;
                t.projective = 8965;
                t.prolongedkana = 12540;
                t.propellor = 8984;
                t.propersubset = 8834;
                t.propersuperset = 8835;
                t.proportion = 8759;
                t.proportional = 8733;
                t.psi = 968;
                t.psicyrillic = 1137;
                t.psilipneumatacyrilliccmb = 1158;
                t.pssquare = 13232;
                t.puhiragana = 12407;
                t.pukatakana = 12503;
                t.pvsquare = 13236;
                t.pwsquare = 13242;
                t.q = 113;
                t.qadeva = 2392;
                t.qadmahebrew = 1448;
                t.qafarabic = 1602;
                t.qaffinalarabic = 65238;
                t.qafinitialarabic = 65239;
                t.qafmedialarabic = 65240;
                t.qamats = 1464;
                t.qamats10 = 1464;
                t.qamats1a = 1464;
                t.qamats1c = 1464;
                t.qamats27 = 1464;
                t.qamats29 = 1464;
                t.qamats33 = 1464;
                t.qamatsde = 1464;
                t.qamatshebrew = 1464;
                t.qamatsnarrowhebrew = 1464;
                t.qamatsqatanhebrew = 1464;
                t.qamatsqatannarrowhebrew = 1464;
                t.qamatsqatanquarterhebrew = 1464;
                t.qamatsqatanwidehebrew = 1464;
                t.qamatsquarterhebrew = 1464;
                t.qamatswidehebrew = 1464;
                t.qarneyparahebrew = 1439;
                t.qbopomofo = 12561;
                t.qcircle = 9440;
                t.qhook = 672;
                t.qmonospace = 65361;
                t.qof = 1511;
                t.qofdagesh = 64327;
                t.qofdageshhebrew = 64327;
                t.qofhebrew = 1511;
                t.qparen = 9388;
                t.quarternote = 9833;
                t.qubuts = 1467;
                t.qubuts18 = 1467;
                t.qubuts25 = 1467;
                t.qubuts31 = 1467;
                t.qubutshebrew = 1467;
                t.qubutsnarrowhebrew = 1467;
                t.qubutsquarterhebrew = 1467;
                t.qubutswidehebrew = 1467;
                t.question = 63;
                t.questionarabic = 1567;
                t.questionarmenian = 1374;
                t.questiondown = 191;
                t.questiondownsmall = 63423;
                t.questiongreek = 894;
                t.questionmonospace = 65311;
                t.questionsmall = 63295;
                t.quotedbl = 34;
                t.quotedblbase = 8222;
                t.quotedblleft = 8220;
                t.quotedblmonospace = 65282;
                t.quotedblprime = 12318;
                t.quotedblprimereversed = 12317;
                t.quotedblright = 8221;
                t.quoteleft = 8216;
                t.quoteleftreversed = 8219;
                t.quotereversed = 8219;
                t.quoteright = 8217;
                t.quoterightn = 329;
                t.quotesinglbase = 8218;
                t.quotesingle = 39;
                t.quotesinglemonospace = 65287;
                t.r = 114;
                t.raarmenian = 1404;
                t.rabengali = 2480;
                t.racute = 341;
                t.radeva = 2352;
                t.radical = 8730;
                t.radicalex = 63717;
                t.radoverssquare = 13230;
                t.radoverssquaredsquare = 13231;
                t.radsquare = 13229;
                t.rafe = 1471;
                t.rafehebrew = 1471;
                t.ragujarati = 2736;
                t.ragurmukhi = 2608;
                t.rahiragana = 12425;
                t.rakatakana = 12521;
                t.rakatakanahalfwidth = 65431;
                t.ralowerdiagonalbengali = 2545;
                t.ramiddlediagonalbengali = 2544;
                t.ramshorn = 612;
                t.ratio = 8758;
                t.rbopomofo = 12566;
                t.rcaron = 345;
                t.rcedilla = 343;
                t.rcircle = 9441;
                t.rcommaaccent = 343;
                t.rdblgrave = 529;
                t.rdotaccent = 7769;
                t.rdotbelow = 7771;
                t.rdotbelowmacron = 7773;
                t.referencemark = 8251;
                t.reflexsubset = 8838;
                t.reflexsuperset = 8839;
                t.registered = 174;
                t.registersans = 63720;
                t.registerserif = 63194;
                t.reharabic = 1585;
                t.reharmenian = 1408;
                t.rehfinalarabic = 65198;
                t.rehiragana = 12428;
                t.rekatakana = 12524;
                t.rekatakanahalfwidth = 65434;
                t.resh = 1512;
                t.reshdageshhebrew = 64328;
                t.reshhebrew = 1512;
                t.reversedtilde = 8765;
                t.reviahebrew = 1431;
                t.reviamugrashhebrew = 1431;
                t.revlogicalnot = 8976;
                t.rfishhook = 638;
                t.rfishhookreversed = 639;
                t.rhabengali = 2525;
                t.rhadeva = 2397;
                t.rho = 961;
                t.rhook = 637;
                t.rhookturned = 635;
                t.rhookturnedsuperior = 693;
                t.rhosymbolgreek = 1009;
                t.rhotichookmod = 734;
                t.rieulacirclekorean = 12913;
                t.rieulaparenkorean = 12817;
                t.rieulcirclekorean = 12899;
                t.rieulhieuhkorean = 12608;
                t.rieulkiyeokkorean = 12602;
                t.rieulkiyeoksioskorean = 12649;
                t.rieulkorean = 12601;
                t.rieulmieumkorean = 12603;
                t.rieulpansioskorean = 12652;
                t.rieulparenkorean = 12803;
                t.rieulphieuphkorean = 12607;
                t.rieulpieupkorean = 12604;
                t.rieulpieupsioskorean = 12651;
                t.rieulsioskorean = 12605;
                t.rieulthieuthkorean = 12606;
                t.rieultikeutkorean = 12650;
                t.rieulyeorinhieuhkorean = 12653;
                t.rightangle = 8735;
                t.righttackbelowcmb = 793;
                t.righttriangle = 8895;
                t.rihiragana = 12426;
                t.rikatakana = 12522;
                t.rikatakanahalfwidth = 65432;
                t.ring = 730;
                t.ringbelowcmb = 805;
                t.ringcmb = 778;
                t.ringhalfleft = 703;
                t.ringhalfleftarmenian = 1369;
                t.ringhalfleftbelowcmb = 796;
                t.ringhalfleftcentered = 723;
                t.ringhalfright = 702;
                t.ringhalfrightbelowcmb = 825;
                t.ringhalfrightcentered = 722;
                t.rinvertedbreve = 531;
                t.rittorusquare = 13137;
                t.rlinebelow = 7775;
                t.rlongleg = 636;
                t.rlonglegturned = 634;
                t.rmonospace = 65362;
                t.rohiragana = 12429;
                t.rokatakana = 12525;
                t.rokatakanahalfwidth = 65435;
                t.roruathai = 3619;
                t.rparen = 9389;
                t.rrabengali = 2524;
                t.rradeva = 2353;
                t.rragurmukhi = 2652;
                t.rreharabic = 1681;
                t.rrehfinalarabic = 64397;
                t.rrvocalicbengali = 2528;
                t.rrvocalicdeva = 2400;
                t.rrvocalicgujarati = 2784;
                t.rrvocalicvowelsignbengali = 2500;
                t.rrvocalicvowelsigndeva = 2372;
                t.rrvocalicvowelsigngujarati = 2756;
                t.rsuperior = 63217;
                t.rtblock = 9616;
                t.rturned = 633;
                t.rturnedsuperior = 692;
                t.ruhiragana = 12427;
                t.rukatakana = 12523;
                t.rukatakanahalfwidth = 65433;
                t.rupeemarkbengali = 2546;
                t.rupeesignbengali = 2547;
                t.rupiah = 63197;
                t.ruthai = 3620;
                t.rvocalicbengali = 2443;
                t.rvocalicdeva = 2315;
                t.rvocalicgujarati = 2699;
                t.rvocalicvowelsignbengali = 2499;
                t.rvocalicvowelsigndeva = 2371;
                t.rvocalicvowelsigngujarati = 2755;
                t.s = 115;
                t.sabengali = 2488;
                t.sacute = 347;
                t.sacutedotaccent = 7781;
                t.sadarabic = 1589;
                t.sadeva = 2360;
                t.sadfinalarabic = 65210;
                t.sadinitialarabic = 65211;
                t.sadmedialarabic = 65212;
                t.sagujarati = 2744;
                t.sagurmukhi = 2616;
                t.sahiragana = 12373;
                t.sakatakana = 12469;
                t.sakatakanahalfwidth = 65403;
                t.sallallahoualayhewasallamarabic = 65018;
                t.samekh = 1505;
                t.samekhdagesh = 64321;
                t.samekhdageshhebrew = 64321;
                t.samekhhebrew = 1505;
                t.saraaathai = 3634;
                t.saraaethai = 3649;
                t.saraaimaimalaithai = 3652;
                t.saraaimaimuanthai = 3651;
                t.saraamthai = 3635;
                t.saraathai = 3632;
                t.saraethai = 3648;
                t.saraiileftthai = 63622;
                t.saraiithai = 3637;
                t.saraileftthai = 63621;
                t.saraithai = 3636;
                t.saraothai = 3650;
                t.saraueeleftthai = 63624;
                t.saraueethai = 3639;
                t.saraueleftthai = 63623;
                t.sarauethai = 3638;
                t.sarauthai = 3640;
                t.sarauuthai = 3641;
                t.sbopomofo = 12569;
                t.scaron = 353;
                t.scarondotaccent = 7783;
                t.scedilla = 351;
                t.schwa = 601;
                t.schwacyrillic = 1241;
                t.schwadieresiscyrillic = 1243;
                t.schwahook = 602;
                t.scircle = 9442;
                t.scircumflex = 349;
                t.scommaaccent = 537;
                t.sdotaccent = 7777;
                t.sdotbelow = 7779;
                t.sdotbelowdotaccent = 7785;
                t.seagullbelowcmb = 828;
                t.second = 8243;
                t.secondtonechinese = 714;
                t.section = 167;
                t.seenarabic = 1587;
                t.seenfinalarabic = 65202;
                t.seeninitialarabic = 65203;
                t.seenmedialarabic = 65204;
                t.segol = 1462;
                t.segol13 = 1462;
                t.segol1f = 1462;
                t.segol2c = 1462;
                t.segolhebrew = 1462;
                t.segolnarrowhebrew = 1462;
                t.segolquarterhebrew = 1462;
                t.segoltahebrew = 1426;
                t.segolwidehebrew = 1462;
                t.seharmenian = 1405;
                t.sehiragana = 12379;
                t.sekatakana = 12475;
                t.sekatakanahalfwidth = 65406;
                t.semicolon = 59;
                t.semicolonarabic = 1563;
                t.semicolonmonospace = 65307;
                t.semicolonsmall = 65108;
                t.semivoicedmarkkana = 12444;
                t.semivoicedmarkkanahalfwidth = 65439;
                t.sentisquare = 13090;
                t.sentosquare = 13091;
                t.seven = 55;
                t.sevenarabic = 1639;
                t.sevenbengali = 2541;
                t.sevencircle = 9318;
                t.sevencircleinversesansserif = 10128;
                t.sevendeva = 2413;
                t.seveneighths = 8542;
                t.sevengujarati = 2797;
                t.sevengurmukhi = 2669;
                t.sevenhackarabic = 1639;
                t.sevenhangzhou = 12327;
                t.sevenideographicparen = 12838;
                t.seveninferior = 8327;
                t.sevenmonospace = 65303;
                t.sevenoldstyle = 63287;
                t.sevenparen = 9338;
                t.sevenperiod = 9358;
                t.sevenpersian = 1783;
                t.sevenroman = 8566;
                t.sevensuperior = 8311;
                t.seventeencircle = 9328;
                t.seventeenparen = 9348;
                t.seventeenperiod = 9368;
                t.seventhai = 3671;
                t.sfthyphen = 173;
                t.shaarmenian = 1399;
                t.shabengali = 2486;
                t.shacyrillic = 1096;
                t.shaddaarabic = 1617;
                t.shaddadammaarabic = 64609;
                t.shaddadammatanarabic = 64606;
                t.shaddafathaarabic = 64608;
                t.shaddakasraarabic = 64610;
                t.shaddakasratanarabic = 64607;
                t.shade = 9618;
                t.shadedark = 9619;
                t.shadelight = 9617;
                t.shademedium = 9618;
                t.shadeva = 2358;
                t.shagujarati = 2742;
                t.shagurmukhi = 2614;
                t.shalshelethebrew = 1427;
                t.shbopomofo = 12565;
                t.shchacyrillic = 1097;
                t.sheenarabic = 1588;
                t.sheenfinalarabic = 65206;
                t.sheeninitialarabic = 65207;
                t.sheenmedialarabic = 65208;
                t.sheicoptic = 995;
                t.sheqel = 8362;
                t.sheqelhebrew = 8362;
                t.sheva = 1456;
                t.sheva115 = 1456;
                t.sheva15 = 1456;
                t.sheva22 = 1456;
                t.sheva2e = 1456;
                t.shevahebrew = 1456;
                t.shevanarrowhebrew = 1456;
                t.shevaquarterhebrew = 1456;
                t.shevawidehebrew = 1456;
                t.shhacyrillic = 1211;
                t.shimacoptic = 1005;
                t.shin = 1513;
                t.shindagesh = 64329;
                t.shindageshhebrew = 64329;
                t.shindageshshindot = 64300;
                t.shindageshshindothebrew = 64300;
                t.shindageshsindot = 64301;
                t.shindageshsindothebrew = 64301;
                t.shindothebrew = 1473;
                t.shinhebrew = 1513;
                t.shinshindot = 64298;
                t.shinshindothebrew = 64298;
                t.shinsindot = 64299;
                t.shinsindothebrew = 64299;
                t.shook = 642;
                t.sigma = 963;
                t.sigma1 = 962;
                t.sigmafinal = 962;
                t.sigmalunatesymbolgreek = 1010;
                t.sihiragana = 12375;
                t.sikatakana = 12471;
                t.sikatakanahalfwidth = 65404;
                t.siluqhebrew = 1469;
                t.siluqlefthebrew = 1469;
                t.similar = 8764;
                t.sindothebrew = 1474;
                t.siosacirclekorean = 12916;
                t.siosaparenkorean = 12820;
                t.sioscieuckorean = 12670;
                t.sioscirclekorean = 12902;
                t.sioskiyeokkorean = 12666;
                t.sioskorean = 12613;
                t.siosnieunkorean = 12667;
                t.siosparenkorean = 12806;
                t.siospieupkorean = 12669;
                t.siostikeutkorean = 12668;
                t.six = 54;
                t.sixarabic = 1638;
                t.sixbengali = 2540;
                t.sixcircle = 9317;
                t.sixcircleinversesansserif = 10127;
                t.sixdeva = 2412;
                t.sixgujarati = 2796;
                t.sixgurmukhi = 2668;
                t.sixhackarabic = 1638;
                t.sixhangzhou = 12326;
                t.sixideographicparen = 12837;
                t.sixinferior = 8326;
                t.sixmonospace = 65302;
                t.sixoldstyle = 63286;
                t.sixparen = 9337;
                t.sixperiod = 9357;
                t.sixpersian = 1782;
                t.sixroman = 8565;
                t.sixsuperior = 8310;
                t.sixteencircle = 9327;
                t.sixteencurrencydenominatorbengali = 2553;
                t.sixteenparen = 9347;
                t.sixteenperiod = 9367;
                t.sixthai = 3670;
                t.slash = 47;
                t.slashmonospace = 65295;
                t.slong = 383;
                t.slongdotaccent = 7835;
                t.smileface = 9786;
                t.smonospace = 65363;
                t.sofpasuqhebrew = 1475;
                t.softhyphen = 173;
                t.softsigncyrillic = 1100;
                t.sohiragana = 12381;
                t.sokatakana = 12477;
                t.sokatakanahalfwidth = 65407;
                t.soliduslongoverlaycmb = 824;
                t.solidusshortoverlaycmb = 823;
                t.sorusithai = 3625;
                t.sosalathai = 3624;
                t.sosothai = 3595;
                t.sosuathai = 3626;
                t.space = 32;
                t.spacehackarabic = 32;
                t.spade = 9824;
                t.spadesuitblack = 9824;
                t.spadesuitwhite = 9828;
                t.sparen = 9390;
                t.squarebelowcmb = 827;
                t.squarecc = 13252;
                t.squarecm = 13213;
                t.squarediagonalcrosshatchfill = 9641;
                t.squarehorizontalfill = 9636;
                t.squarekg = 13199;
                t.squarekm = 13214;
                t.squarekmcapital = 13262;
                t.squareln = 13265;
                t.squarelog = 13266;
                t.squaremg = 13198;
                t.squaremil = 13269;
                t.squaremm = 13212;
                t.squaremsquared = 13217;
                t.squareorthogonalcrosshatchfill = 9638;
                t.squareupperlefttolowerrightfill = 9639;
                t.squareupperrighttolowerleftfill = 9640;
                t.squareverticalfill = 9637;
                t.squarewhitewithsmallblack = 9635;
                t.srsquare = 13275;
                t.ssabengali = 2487;
                t.ssadeva = 2359;
                t.ssagujarati = 2743;
                t.ssangcieuckorean = 12617;
                t.ssanghieuhkorean = 12677;
                t.ssangieungkorean = 12672;
                t.ssangkiyeokkorean = 12594;
                t.ssangnieunkorean = 12645;
                t.ssangpieupkorean = 12611;
                t.ssangsioskorean = 12614;
                t.ssangtikeutkorean = 12600;
                t.ssuperior = 63218;
                t.sterling = 163;
                t.sterlingmonospace = 65505;
                t.strokelongoverlaycmb = 822;
                t.strokeshortoverlaycmb = 821;
                t.subset = 8834;
                t.subsetnotequal = 8842;
                t.subsetorequal = 8838;
                t.succeeds = 8827;
                t.suchthat = 8715;
                t.suhiragana = 12377;
                t.sukatakana = 12473;
                t.sukatakanahalfwidth = 65405;
                t.sukunarabic = 1618;
                t.summation = 8721;
                t.sun = 9788;
                t.superset = 8835;
                t.supersetnotequal = 8843;
                t.supersetorequal = 8839;
                t.svsquare = 13276;
                t.syouwaerasquare = 13180;
                t.t = 116;
                t.tabengali = 2468;
                t.tackdown = 8868;
                t.tackleft = 8867;
                t.tadeva = 2340;
                t.tagujarati = 2724;
                t.tagurmukhi = 2596;
                t.taharabic = 1591;
                t.tahfinalarabic = 65218;
                t.tahinitialarabic = 65219;
                t.tahiragana = 12383;
                t.tahmedialarabic = 65220;
                t.taisyouerasquare = 13181;
                t.takatakana = 12479;
                t.takatakanahalfwidth = 65408;
                t.tatweelarabic = 1600;
                t.tau = 964;
                t.tav = 1514;
                t.tavdages = 64330;
                t.tavdagesh = 64330;
                t.tavdageshhebrew = 64330;
                t.tavhebrew = 1514;
                t.tbar = 359;
                t.tbopomofo = 12554;
                t.tcaron = 357;
                t.tccurl = 680;
                t.tcedilla = 355;
                t.tcheharabic = 1670;
                t.tchehfinalarabic = 64379;
                t.tchehinitialarabic = 64380;
                t.tchehmedialarabic = 64381;
                t.tcircle = 9443;
                t.tcircumflexbelow = 7793;
                t.tcommaaccent = 355;
                t.tdieresis = 7831;
                t.tdotaccent = 7787;
                t.tdotbelow = 7789;
                t.tecyrillic = 1090;
                t.tedescendercyrillic = 1197;
                t.teharabic = 1578;
                t.tehfinalarabic = 65174;
                t.tehhahinitialarabic = 64674;
                t.tehhahisolatedarabic = 64524;
                t.tehinitialarabic = 65175;
                t.tehiragana = 12390;
                t.tehjeeminitialarabic = 64673;
                t.tehjeemisolatedarabic = 64523;
                t.tehmarbutaarabic = 1577;
                t.tehmarbutafinalarabic = 65172;
                t.tehmedialarabic = 65176;
                t.tehmeeminitialarabic = 64676;
                t.tehmeemisolatedarabic = 64526;
                t.tehnoonfinalarabic = 64627;
                t.tekatakana = 12486;
                t.tekatakanahalfwidth = 65411;
                t.telephone = 8481;
                t.telephoneblack = 9742;
                t.telishagedolahebrew = 1440;
                t.telishaqetanahebrew = 1449;
                t.tencircle = 9321;
                t.tenideographicparen = 12841;
                t.tenparen = 9341;
                t.tenperiod = 9361;
                t.tenroman = 8569;
                t.tesh = 679;
                t.tet = 1496;
                t.tetdagesh = 64312;
                t.tetdageshhebrew = 64312;
                t.tethebrew = 1496;
                t.tetsecyrillic = 1205;
                t.tevirhebrew = 1435;
                t.tevirlefthebrew = 1435;
                t.thabengali = 2469;
                t.thadeva = 2341;
                t.thagujarati = 2725;
                t.thagurmukhi = 2597;
                t.thalarabic = 1584;
                t.thalfinalarabic = 65196;
                t.thanthakhatlowleftthai = 63640;
                t.thanthakhatlowrightthai = 63639;
                t.thanthakhatthai = 3660;
                t.thanthakhatupperleftthai = 63638;
                t.theharabic = 1579;
                t.thehfinalarabic = 65178;
                t.thehinitialarabic = 65179;
                t.thehmedialarabic = 65180;
                t.thereexists = 8707;
                t.therefore = 8756;
                t.theta = 952;
                t.theta1 = 977;
                t.thetasymbolgreek = 977;
                t.thieuthacirclekorean = 12921;
                t.thieuthaparenkorean = 12825;
                t.thieuthcirclekorean = 12907;
                t.thieuthkorean = 12620;
                t.thieuthparenkorean = 12811;
                t.thirteencircle = 9324;
                t.thirteenparen = 9344;
                t.thirteenperiod = 9364;
                t.thonangmonthothai = 3601;
                t.thook = 429;
                t.thophuthaothai = 3602;
                t.thorn = 254;
                t.thothahanthai = 3607;
                t.thothanthai = 3600;
                t.thothongthai = 3608;
                t.thothungthai = 3606;
                t.thousandcyrillic = 1154;
                t.thousandsseparatorarabic = 1644;
                t.thousandsseparatorpersian = 1644;
                t.three = 51;
                t.threearabic = 1635;
                t.threebengali = 2537;
                t.threecircle = 9314;
                t.threecircleinversesansserif = 10124;
                t.threedeva = 2409;
                t.threeeighths = 8540;
                t.threegujarati = 2793;
                t.threegurmukhi = 2665;
                t.threehackarabic = 1635;
                t.threehangzhou = 12323;
                t.threeideographicparen = 12834;
                t.threeinferior = 8323;
                t.threemonospace = 65299;
                t.threenumeratorbengali = 2550;
                t.threeoldstyle = 63283;
                t.threeparen = 9334;
                t.threeperiod = 9354;
                t.threepersian = 1779;
                t.threequarters = 190;
                t.threequartersemdash = 63198;
                t.threeroman = 8562;
                t.threesuperior = 179;
                t.threethai = 3667;
                t.thzsquare = 13204;
                t.tihiragana = 12385;
                t.tikatakana = 12481;
                t.tikatakanahalfwidth = 65409;
                t.tikeutacirclekorean = 12912;
                t.tikeutaparenkorean = 12816;
                t.tikeutcirclekorean = 12898;
                t.tikeutkorean = 12599;
                t.tikeutparenkorean = 12802;
                t.tilde = 732;
                t.tildebelowcmb = 816;
                t.tildecmb = 771;
                t.tildecomb = 771;
                t.tildedoublecmb = 864;
                t.tildeoperator = 8764;
                t.tildeoverlaycmb = 820;
                t.tildeverticalcmb = 830;
                t.timescircle = 8855;
                t.tipehahebrew = 1430;
                t.tipehalefthebrew = 1430;
                t.tippigurmukhi = 2672;
                t.titlocyrilliccmb = 1155;
                t.tiwnarmenian = 1407;
                t.tlinebelow = 7791;
                t.tmonospace = 65364;
                t.toarmenian = 1385;
                t.tohiragana = 12392;
                t.tokatakana = 12488;
                t.tokatakanahalfwidth = 65412;
                t.tonebarextrahighmod = 741;
                t.tonebarextralowmod = 745;
                t.tonebarhighmod = 742;
                t.tonebarlowmod = 744;
                t.tonebarmidmod = 743;
                t.tonefive = 445;
                t.tonesix = 389;
                t.tonetwo = 424;
                t.tonos = 900;
                t.tonsquare = 13095;
                t.topatakthai = 3599;
                t.tortoiseshellbracketleft = 12308;
                t.tortoiseshellbracketleftsmall = 65117;
                t.tortoiseshellbracketleftvertical = 65081;
                t.tortoiseshellbracketright = 12309;
                t.tortoiseshellbracketrightsmall = 65118;
                t.tortoiseshellbracketrightvertical = 65082;
                t.totaothai = 3605;
                t.tpalatalhook = 427;
                t.tparen = 9391;
                t.trademark = 8482;
                t.trademarksans = 63722;
                t.trademarkserif = 63195;
                t.tretroflexhook = 648;
                t.triagdn = 9660;
                t.triaglf = 9668;
                t.triagrt = 9658;
                t.triagup = 9650;
                t.ts = 678;
                t.tsadi = 1510;
                t.tsadidagesh = 64326;
                t.tsadidageshhebrew = 64326;
                t.tsadihebrew = 1510;
                t.tsecyrillic = 1094;
                t.tsere = 1461;
                t.tsere12 = 1461;
                t.tsere1e = 1461;
                t.tsere2b = 1461;
                t.tserehebrew = 1461;
                t.tserenarrowhebrew = 1461;
                t.tserequarterhebrew = 1461;
                t.tserewidehebrew = 1461;
                t.tshecyrillic = 1115;
                t.tsuperior = 63219;
                t.ttabengali = 2463;
                t.ttadeva = 2335;
                t.ttagujarati = 2719;
                t.ttagurmukhi = 2591;
                t.tteharabic = 1657;
                t.ttehfinalarabic = 64359;
                t.ttehinitialarabic = 64360;
                t.ttehmedialarabic = 64361;
                t.tthabengali = 2464;
                t.tthadeva = 2336;
                t.tthagujarati = 2720;
                t.tthagurmukhi = 2592;
                t.tturned = 647;
                t.tuhiragana = 12388;
                t.tukatakana = 12484;
                t.tukatakanahalfwidth = 65410;
                t.tusmallhiragana = 12387;
                t.tusmallkatakana = 12483;
                t.tusmallkatakanahalfwidth = 65391;
                t.twelvecircle = 9323;
                t.twelveparen = 9343;
                t.twelveperiod = 9363;
                t.twelveroman = 8571;
                t.twentycircle = 9331;
                t.twentyhangzhou = 21316;
                t.twentyparen = 9351;
                t.twentyperiod = 9371;
                t.two = 50;
                t.twoarabic = 1634;
                t.twobengali = 2536;
                t.twocircle = 9313;
                t.twocircleinversesansserif = 10123;
                t.twodeva = 2408;
                t.twodotenleader = 8229;
                t.twodotleader = 8229;
                t.twodotleadervertical = 65072;
                t.twogujarati = 2792;
                t.twogurmukhi = 2664;
                t.twohackarabic = 1634;
                t.twohangzhou = 12322;
                t.twoideographicparen = 12833;
                t.twoinferior = 8322;
                t.twomonospace = 65298;
                t.twonumeratorbengali = 2549;
                t.twooldstyle = 63282;
                t.twoparen = 9333;
                t.twoperiod = 9353;
                t.twopersian = 1778;
                t.tworoman = 8561;
                t.twostroke = 443;
                t.twosuperior = 178;
                t.twothai = 3666;
                t.twothirds = 8532;
                t.u = 117;
                t.uacute = 250;
                t.ubar = 649;
                t.ubengali = 2441;
                t.ubopomofo = 12584;
                t.ubreve = 365;
                t.ucaron = 468;
                t.ucircle = 9444;
                t.ucircumflex = 251;
                t.ucircumflexbelow = 7799;
                t.ucyrillic = 1091;
                t.udattadeva = 2385;
                t.udblacute = 369;
                t.udblgrave = 533;
                t.udeva = 2313;
                t.udieresis = 252;
                t.udieresisacute = 472;
                t.udieresisbelow = 7795;
                t.udieresiscaron = 474;
                t.udieresiscyrillic = 1265;
                t.udieresisgrave = 476;
                t.udieresismacron = 470;
                t.udotbelow = 7909;
                t.ugrave = 249;
                t.ugujarati = 2697;
                t.ugurmukhi = 2569;
                t.uhiragana = 12358;
                t.uhookabove = 7911;
                t.uhorn = 432;
                t.uhornacute = 7913;
                t.uhorndotbelow = 7921;
                t.uhorngrave = 7915;
                t.uhornhookabove = 7917;
                t.uhorntilde = 7919;
                t.uhungarumlaut = 369;
                t.uhungarumlautcyrillic = 1267;
                t.uinvertedbreve = 535;
                t.ukatakana = 12454;
                t.ukatakanahalfwidth = 65395;
                t.ukcyrillic = 1145;
                t.ukorean = 12636;
                t.umacron = 363;
                t.umacroncyrillic = 1263;
                t.umacrondieresis = 7803;
                t.umatragurmukhi = 2625;
                t.umonospace = 65365;
                t.underscore = 95;
                t.underscoredbl = 8215;
                t.underscoremonospace = 65343;
                t.underscorevertical = 65075;
                t.underscorewavy = 65103;
                t.union = 8746;
                t.universal = 8704;
                t.uogonek = 371;
                t.uparen = 9392;
                t.upblock = 9600;
                t.upperdothebrew = 1476;
                t.upsilon = 965;
                t.upsilondieresis = 971;
                t.upsilondieresistonos = 944;
                t.upsilonlatin = 650;
                t.upsilontonos = 973;
                t.uptackbelowcmb = 797;
                t.uptackmod = 724;
                t.uragurmukhi = 2675;
                t.uring = 367;
                t.ushortcyrillic = 1118;
                t.usmallhiragana = 12357;
                t.usmallkatakana = 12453;
                t.usmallkatakanahalfwidth = 65385;
                t.ustraightcyrillic = 1199;
                t.ustraightstrokecyrillic = 1201;
                t.utilde = 361;
                t.utildeacute = 7801;
                t.utildebelow = 7797;
                t.uubengali = 2442;
                t.uudeva = 2314;
                t.uugujarati = 2698;
                t.uugurmukhi = 2570;
                t.uumatragurmukhi = 2626;
                t.uuvowelsignbengali = 2498;
                t.uuvowelsigndeva = 2370;
                t.uuvowelsigngujarati = 2754;
                t.uvowelsignbengali = 2497;
                t.uvowelsigndeva = 2369;
                t.uvowelsigngujarati = 2753;
                t.v = 118;
                t.vadeva = 2357;
                t.vagujarati = 2741;
                t.vagurmukhi = 2613;
                t.vakatakana = 12535;
                t.vav = 1493;
                t.vavdagesh = 64309;
                t.vavdagesh65 = 64309;
                t.vavdageshhebrew = 64309;
                t.vavhebrew = 1493;
                t.vavholam = 64331;
                t.vavholamhebrew = 64331;
                t.vavvavhebrew = 1520;
                t.vavyodhebrew = 1521;
                t.vcircle = 9445;
                t.vdotbelow = 7807;
                t.vecyrillic = 1074;
                t.veharabic = 1700;
                t.vehfinalarabic = 64363;
                t.vehinitialarabic = 64364;
                t.vehmedialarabic = 64365;
                t.vekatakana = 12537;
                t.venus = 9792;
                t.verticalbar = 124;
                t.verticallineabovecmb = 781;
                t.verticallinebelowcmb = 809;
                t.verticallinelowmod = 716;
                t.verticallinemod = 712;
                t.vewarmenian = 1406;
                t.vhook = 651;
                t.vikatakana = 12536;
                t.viramabengali = 2509;
                t.viramadeva = 2381;
                t.viramagujarati = 2765;
                t.visargabengali = 2435;
                t.visargadeva = 2307;
                t.visargagujarati = 2691;
                t.vmonospace = 65366;
                t.voarmenian = 1400;
                t.voicediterationhiragana = 12446;
                t.voicediterationkatakana = 12542;
                t.voicedmarkkana = 12443;
                t.voicedmarkkanahalfwidth = 65438;
                t.vokatakana = 12538;
                t.vparen = 9393;
                t.vtilde = 7805;
                t.vturned = 652;
                t.vuhiragana = 12436;
                t.vukatakana = 12532;
                t.w = 119;
                t.wacute = 7811;
                t.waekorean = 12633;
                t.wahiragana = 12431;
                t.wakatakana = 12527;
                t.wakatakanahalfwidth = 65436;
                t.wakorean = 12632;
                t.wasmallhiragana = 12430;
                t.wasmallkatakana = 12526;
                t.wattosquare = 13143;
                t.wavedash = 12316;
                t.wavyunderscorevertical = 65076;
                t.wawarabic = 1608;
                t.wawfinalarabic = 65262;
                t.wawhamzaabovearabic = 1572;
                t.wawhamzaabovefinalarabic = 65158;
                t.wbsquare = 13277;
                t.wcircle = 9446;
                t.wcircumflex = 373;
                t.wdieresis = 7813;
                t.wdotaccent = 7815;
                t.wdotbelow = 7817;
                t.wehiragana = 12433;
                t.weierstrass = 8472;
                t.wekatakana = 12529;
                t.wekorean = 12638;
                t.weokorean = 12637;
                t.wgrave = 7809;
                t.whitebullet = 9702;
                t.whitecircle = 9675;
                t.whitecircleinverse = 9689;
                t.whitecornerbracketleft = 12302;
                t.whitecornerbracketleftvertical = 65091;
                t.whitecornerbracketright = 12303;
                t.whitecornerbracketrightvertical = 65092;
                t.whitediamond = 9671;
                t.whitediamondcontainingblacksmalldiamond = 9672;
                t.whitedownpointingsmalltriangle = 9663;
                t.whitedownpointingtriangle = 9661;
                t.whiteleftpointingsmalltriangle = 9667;
                t.whiteleftpointingtriangle = 9665;
                t.whitelenticularbracketleft = 12310;
                t.whitelenticularbracketright = 12311;
                t.whiterightpointingsmalltriangle = 9657;
                t.whiterightpointingtriangle = 9655;
                t.whitesmallsquare = 9643;
                t.whitesmilingface = 9786;
                t.whitesquare = 9633;
                t.whitestar = 9734;
                t.whitetelephone = 9743;
                t.whitetortoiseshellbracketleft = 12312;
                t.whitetortoiseshellbracketright = 12313;
                t.whiteuppointingsmalltriangle = 9653;
                t.whiteuppointingtriangle = 9651;
                t.wihiragana = 12432;
                t.wikatakana = 12528;
                t.wikorean = 12639;
                t.wmonospace = 65367;
                t.wohiragana = 12434;
                t.wokatakana = 12530;
                t.wokatakanahalfwidth = 65382;
                t.won = 8361;
                t.wonmonospace = 65510;
                t.wowaenthai = 3623;
                t.wparen = 9394;
                t.wring = 7832;
                t.wsuperior = 695;
                t.wturned = 653;
                t.wynn = 447;
                t.x = 120;
                t.xabovecmb = 829;
                t.xbopomofo = 12562;
                t.xcircle = 9447;
                t.xdieresis = 7821;
                t.xdotaccent = 7819;
                t.xeharmenian = 1389;
                t.xi = 958;
                t.xmonospace = 65368;
                t.xparen = 9395;
                t.xsuperior = 739;
                t.y = 121;
                t.yaadosquare = 13134;
                t.yabengali = 2479;
                t.yacute = 253;
                t.yadeva = 2351;
                t.yaekorean = 12626;
                t.yagujarati = 2735;
                t.yagurmukhi = 2607;
                t.yahiragana = 12420;
                t.yakatakana = 12516;
                t.yakatakanahalfwidth = 65428;
                t.yakorean = 12625;
                t.yamakkanthai = 3662;
                t.yasmallhiragana = 12419;
                t.yasmallkatakana = 12515;
                t.yasmallkatakanahalfwidth = 65388;
                t.yatcyrillic = 1123;
                t.ycircle = 9448;
                t.ycircumflex = 375;
                t.ydieresis = 255;
                t.ydotaccent = 7823;
                t.ydotbelow = 7925;
                t.yeharabic = 1610;
                t.yehbarreearabic = 1746;
                t.yehbarreefinalarabic = 64431;
                t.yehfinalarabic = 65266;
                t.yehhamzaabovearabic = 1574;
                t.yehhamzaabovefinalarabic = 65162;
                t.yehhamzaaboveinitialarabic = 65163;
                t.yehhamzaabovemedialarabic = 65164;
                t.yehinitialarabic = 65267;
                t.yehmedialarabic = 65268;
                t.yehmeeminitialarabic = 64733;
                t.yehmeemisolatedarabic = 64600;
                t.yehnoonfinalarabic = 64660;
                t.yehthreedotsbelowarabic = 1745;
                t.yekorean = 12630;
                t.yen = 165;
                t.yenmonospace = 65509;
                t.yeokorean = 12629;
                t.yeorinhieuhkorean = 12678;
                t.yerahbenyomohebrew = 1450;
                t.yerahbenyomolefthebrew = 1450;
                t.yericyrillic = 1099;
                t.yerudieresiscyrillic = 1273;
                t.yesieungkorean = 12673;
                t.yesieungpansioskorean = 12675;
                t.yesieungsioskorean = 12674;
                t.yetivhebrew = 1434;
                t.ygrave = 7923;
                t.yhook = 436;
                t.yhookabove = 7927;
                t.yiarmenian = 1397;
                t.yicyrillic = 1111;
                t.yikorean = 12642;
                t.yinyang = 9775;
                t.yiwnarmenian = 1410;
                t.ymonospace = 65369;
                t.yod = 1497;
                t.yoddagesh = 64313;
                t.yoddageshhebrew = 64313;
                t.yodhebrew = 1497;
                t.yodyodhebrew = 1522;
                t.yodyodpatahhebrew = 64287;
                t.yohiragana = 12424;
                t.yoikorean = 12681;
                t.yokatakana = 12520;
                t.yokatakanahalfwidth = 65430;
                t.yokorean = 12635;
                t.yosmallhiragana = 12423;
                t.yosmallkatakana = 12519;
                t.yosmallkatakanahalfwidth = 65390;
                t.yotgreek = 1011;
                t.yoyaekorean = 12680;
                t.yoyakorean = 12679;
                t.yoyakthai = 3618;
                t.yoyingthai = 3597;
                t.yparen = 9396;
                t.ypogegrammeni = 890;
                t.ypogegrammenigreekcmb = 837;
                t.yr = 422;
                t.yring = 7833;
                t.ysuperior = 696;
                t.ytilde = 7929;
                t.yturned = 654;
                t.yuhiragana = 12422;
                t.yuikorean = 12684;
                t.yukatakana = 12518;
                t.yukatakanahalfwidth = 65429;
                t.yukorean = 12640;
                t.yusbigcyrillic = 1131;
                t.yusbigiotifiedcyrillic = 1133;
                t.yuslittlecyrillic = 1127;
                t.yuslittleiotifiedcyrillic = 1129;
                t.yusmallhiragana = 12421;
                t.yusmallkatakana = 12517;
                t.yusmallkatakanahalfwidth = 65389;
                t.yuyekorean = 12683;
                t.yuyeokorean = 12682;
                t.yyabengali = 2527;
                t.yyadeva = 2399;
                t.z = 122;
                t.zaarmenian = 1382;
                t.zacute = 378;
                t.zadeva = 2395;
                t.zagurmukhi = 2651;
                t.zaharabic = 1592;
                t.zahfinalarabic = 65222;
                t.zahinitialarabic = 65223;
                t.zahiragana = 12374;
                t.zahmedialarabic = 65224;
                t.zainarabic = 1586;
                t.zainfinalarabic = 65200;
                t.zakatakana = 12470;
                t.zaqefgadolhebrew = 1429;
                t.zaqefqatanhebrew = 1428;
                t.zarqahebrew = 1432;
                t.zayin = 1494;
                t.zayindagesh = 64310;
                t.zayindageshhebrew = 64310;
                t.zayinhebrew = 1494;
                t.zbopomofo = 12567;
                t.zcaron = 382;
                t.zcircle = 9449;
                t.zcircumflex = 7825;
                t.zcurl = 657;
                t.zdot = 380;
                t.zdotaccent = 380;
                t.zdotbelow = 7827;
                t.zecyrillic = 1079;
                t.zedescendercyrillic = 1177;
                t.zedieresiscyrillic = 1247;
                t.zehiragana = 12380;
                t.zekatakana = 12476;
                t.zero = 48;
                t.zeroarabic = 1632;
                t.zerobengali = 2534;
                t.zerodeva = 2406;
                t.zerogujarati = 2790;
                t.zerogurmukhi = 2662;
                t.zerohackarabic = 1632;
                t.zeroinferior = 8320;
                t.zeromonospace = 65296;
                t.zerooldstyle = 63280;
                t.zeropersian = 1776;
                t.zerosuperior = 8304;
                t.zerothai = 3664;
                t.zerowidthjoiner = 65279;
                t.zerowidthnonjoiner = 8204;
                t.zerowidthspace = 8203;
                t.zeta = 950;
                t.zhbopomofo = 12563;
                t.zhearmenian = 1386;
                t.zhebrevecyrillic = 1218;
                t.zhecyrillic = 1078;
                t.zhedescendercyrillic = 1175;
                t.zhedieresiscyrillic = 1245;
                t.zihiragana = 12376;
                t.zikatakana = 12472;
                t.zinorhebrew = 1454;
                t.zlinebelow = 7829;
                t.zmonospace = 65370;
                t.zohiragana = 12382;
                t.zokatakana = 12478;
                t.zparen = 9397;
                t.zretroflexhook = 656;
                t.zstroke = 438;
                t.zuhiragana = 12378;
                t.zukatakana = 12474;
                t[".notdef"] = 0;
                t.angbracketleftbig = 9001;
                t.angbracketleftBig = 9001;
                t.angbracketleftbigg = 9001;
                t.angbracketleftBigg = 9001;
                t.angbracketrightBig = 9002;
                t.angbracketrightbig = 9002;
                t.angbracketrightBigg = 9002;
                t.angbracketrightbigg = 9002;
                t.arrowhookleft = 8618;
                t.arrowhookright = 8617;
                t.arrowlefttophalf = 8636;
                t.arrowleftbothalf = 8637;
                t.arrownortheast = 8599;
                t.arrownorthwest = 8598;
                t.arrowrighttophalf = 8640;
                t.arrowrightbothalf = 8641;
                t.arrowsoutheast = 8600;
                t.arrowsouthwest = 8601;
                t.backslashbig = 8726;
                t.backslashBig = 8726;
                t.backslashBigg = 8726;
                t.backslashbigg = 8726;
                t.bardbl = 8214;
                t.bracehtipdownleft = 65079;
                t.bracehtipdownright = 65079;
                t.bracehtipupleft = 65080;
                t.bracehtipupright = 65080;
                t.braceleftBig = 123;
                t.braceleftbig = 123;
                t.braceleftbigg = 123;
                t.braceleftBigg = 123;
                t.bracerightBig = 125;
                t.bracerightbig = 125;
                t.bracerightbigg = 125;
                t.bracerightBigg = 125;
                t.bracketleftbig = 91;
                t.bracketleftBig = 91;
                t.bracketleftbigg = 91;
                t.bracketleftBigg = 91;
                t.bracketrightBig = 93;
                t.bracketrightbig = 93;
                t.bracketrightbigg = 93;
                t.bracketrightBigg = 93;
                t.ceilingleftbig = 8968;
                t.ceilingleftBig = 8968;
                t.ceilingleftBigg = 8968;
                t.ceilingleftbigg = 8968;
                t.ceilingrightbig = 8969;
                t.ceilingrightBig = 8969;
                t.ceilingrightbigg = 8969;
                t.ceilingrightBigg = 8969;
                t.circledotdisplay = 8857;
                t.circledottext = 8857;
                t.circlemultiplydisplay = 8855;
                t.circlemultiplytext = 8855;
                t.circleplusdisplay = 8853;
                t.circleplustext = 8853;
                t.contintegraldisplay = 8750;
                t.contintegraltext = 8750;
                t.coproductdisplay = 8720;
                t.coproducttext = 8720;
                t.floorleftBig = 8970;
                t.floorleftbig = 8970;
                t.floorleftbigg = 8970;
                t.floorleftBigg = 8970;
                t.floorrightbig = 8971;
                t.floorrightBig = 8971;
                t.floorrightBigg = 8971;
                t.floorrightbigg = 8971;
                t.hatwide = 770;
                t.hatwider = 770;
                t.hatwidest = 770;
                t.intercal = 7488;
                t.integraldisplay = 8747;
                t.integraltext = 8747;
                t.intersectiondisplay = 8898;
                t.intersectiontext = 8898;
                t.logicalanddisplay = 8743;
                t.logicalandtext = 8743;
                t.logicalordisplay = 8744;
                t.logicalortext = 8744;
                t.parenleftBig = 40;
                t.parenleftbig = 40;
                t.parenleftBigg = 40;
                t.parenleftbigg = 40;
                t.parenrightBig = 41;
                t.parenrightbig = 41;
                t.parenrightBigg = 41;
                t.parenrightbigg = 41;
                t.prime = 8242;
                t.productdisplay = 8719;
                t.producttext = 8719;
                t.radicalbig = 8730;
                t.radicalBig = 8730;
                t.radicalBigg = 8730;
                t.radicalbigg = 8730;
                t.radicalbt = 8730;
                t.radicaltp = 8730;
                t.radicalvertex = 8730;
                t.slashbig = 47;
                t.slashBig = 47;
                t.slashBigg = 47;
                t.slashbigg = 47;
                t.summationdisplay = 8721;
                t.summationtext = 8721;
                t.tildewide = 732;
                t.tildewider = 732;
                t.tildewidest = 732;
                t.uniondisplay = 8899;
                t.unionmultidisplay = 8846;
                t.unionmultitext = 8846;
                t.unionsqdisplay = 8852;
                t.unionsqtext = 8852;
                t.uniontext = 8899;
                t.vextenddouble = 8741;
                t.vextendsingle = 8739;
              });
              exports2.getGlyphsUnicode = getGlyphsUnicode;
              const getDingbatsGlyphsUnicode = (0, _core_utils.getLookupTableFactory)(function(t) {
                t.space = 32;
                t.a1 = 9985;
                t.a2 = 9986;
                t.a202 = 9987;
                t.a3 = 9988;
                t.a4 = 9742;
                t.a5 = 9990;
                t.a119 = 9991;
                t.a118 = 9992;
                t.a117 = 9993;
                t.a11 = 9755;
                t.a12 = 9758;
                t.a13 = 9996;
                t.a14 = 9997;
                t.a15 = 9998;
                t.a16 = 9999;
                t.a105 = 1e4;
                t.a17 = 10001;
                t.a18 = 10002;
                t.a19 = 10003;
                t.a20 = 10004;
                t.a21 = 10005;
                t.a22 = 10006;
                t.a23 = 10007;
                t.a24 = 10008;
                t.a25 = 10009;
                t.a26 = 10010;
                t.a27 = 10011;
                t.a28 = 10012;
                t.a6 = 10013;
                t.a7 = 10014;
                t.a8 = 10015;
                t.a9 = 10016;
                t.a10 = 10017;
                t.a29 = 10018;
                t.a30 = 10019;
                t.a31 = 10020;
                t.a32 = 10021;
                t.a33 = 10022;
                t.a34 = 10023;
                t.a35 = 9733;
                t.a36 = 10025;
                t.a37 = 10026;
                t.a38 = 10027;
                t.a39 = 10028;
                t.a40 = 10029;
                t.a41 = 10030;
                t.a42 = 10031;
                t.a43 = 10032;
                t.a44 = 10033;
                t.a45 = 10034;
                t.a46 = 10035;
                t.a47 = 10036;
                t.a48 = 10037;
                t.a49 = 10038;
                t.a50 = 10039;
                t.a51 = 10040;
                t.a52 = 10041;
                t.a53 = 10042;
                t.a54 = 10043;
                t.a55 = 10044;
                t.a56 = 10045;
                t.a57 = 10046;
                t.a58 = 10047;
                t.a59 = 10048;
                t.a60 = 10049;
                t.a61 = 10050;
                t.a62 = 10051;
                t.a63 = 10052;
                t.a64 = 10053;
                t.a65 = 10054;
                t.a66 = 10055;
                t.a67 = 10056;
                t.a68 = 10057;
                t.a69 = 10058;
                t.a70 = 10059;
                t.a71 = 9679;
                t.a72 = 10061;
                t.a73 = 9632;
                t.a74 = 10063;
                t.a203 = 10064;
                t.a75 = 10065;
                t.a204 = 10066;
                t.a76 = 9650;
                t.a77 = 9660;
                t.a78 = 9670;
                t.a79 = 10070;
                t.a81 = 9687;
                t.a82 = 10072;
                t.a83 = 10073;
                t.a84 = 10074;
                t.a97 = 10075;
                t.a98 = 10076;
                t.a99 = 10077;
                t.a100 = 10078;
                t.a101 = 10081;
                t.a102 = 10082;
                t.a103 = 10083;
                t.a104 = 10084;
                t.a106 = 10085;
                t.a107 = 10086;
                t.a108 = 10087;
                t.a112 = 9827;
                t.a111 = 9830;
                t.a110 = 9829;
                t.a109 = 9824;
                t.a120 = 9312;
                t.a121 = 9313;
                t.a122 = 9314;
                t.a123 = 9315;
                t.a124 = 9316;
                t.a125 = 9317;
                t.a126 = 9318;
                t.a127 = 9319;
                t.a128 = 9320;
                t.a129 = 9321;
                t.a130 = 10102;
                t.a131 = 10103;
                t.a132 = 10104;
                t.a133 = 10105;
                t.a134 = 10106;
                t.a135 = 10107;
                t.a136 = 10108;
                t.a137 = 10109;
                t.a138 = 10110;
                t.a139 = 10111;
                t.a140 = 10112;
                t.a141 = 10113;
                t.a142 = 10114;
                t.a143 = 10115;
                t.a144 = 10116;
                t.a145 = 10117;
                t.a146 = 10118;
                t.a147 = 10119;
                t.a148 = 10120;
                t.a149 = 10121;
                t.a150 = 10122;
                t.a151 = 10123;
                t.a152 = 10124;
                t.a153 = 10125;
                t.a154 = 10126;
                t.a155 = 10127;
                t.a156 = 10128;
                t.a157 = 10129;
                t.a158 = 10130;
                t.a159 = 10131;
                t.a160 = 10132;
                t.a161 = 8594;
                t.a163 = 8596;
                t.a164 = 8597;
                t.a196 = 10136;
                t.a165 = 10137;
                t.a192 = 10138;
                t.a166 = 10139;
                t.a167 = 10140;
                t.a168 = 10141;
                t.a169 = 10142;
                t.a170 = 10143;
                t.a171 = 10144;
                t.a172 = 10145;
                t.a173 = 10146;
                t.a162 = 10147;
                t.a174 = 10148;
                t.a175 = 10149;
                t.a176 = 10150;
                t.a177 = 10151;
                t.a178 = 10152;
                t.a179 = 10153;
                t.a193 = 10154;
                t.a180 = 10155;
                t.a199 = 10156;
                t.a181 = 10157;
                t.a200 = 10158;
                t.a182 = 10159;
                t.a201 = 10161;
                t.a183 = 10162;
                t.a184 = 10163;
                t.a197 = 10164;
                t.a185 = 10165;
                t.a194 = 10166;
                t.a198 = 10167;
                t.a186 = 10168;
                t.a195 = 10169;
                t.a187 = 10170;
                t.a188 = 10171;
                t.a189 = 10172;
                t.a190 = 10173;
                t.a191 = 10174;
                t.a89 = 10088;
                t.a90 = 10089;
                t.a93 = 10090;
                t.a94 = 10091;
                t.a91 = 10092;
                t.a92 = 10093;
                t.a205 = 10094;
                t.a85 = 10095;
                t.a206 = 10096;
                t.a86 = 10097;
                t.a87 = 10098;
                t.a88 = 10099;
                t.a95 = 10100;
                t.a96 = 10101;
                t[".notdef"] = 0;
              });
              exports2.getDingbatsGlyphsUnicode = getDingbatsGlyphsUnicode;
            },
            /* 40 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.clearUnicodeCaches = clearUnicodeCaches;
              exports2.getCharUnicodeCategory = getCharUnicodeCategory;
              exports2.getUnicodeForGlyph = getUnicodeForGlyph;
              exports2.getUnicodeRangeFor = getUnicodeRangeFor;
              exports2.mapSpecialUnicodeValues = mapSpecialUnicodeValues;
              var _core_utils = __w_pdfjs_require__2(3);
              const getSpecialPUASymbols = (0, _core_utils.getLookupTableFactory)(function(t) {
                t[63721] = 169;
                t[63193] = 169;
                t[63720] = 174;
                t[63194] = 174;
                t[63722] = 8482;
                t[63195] = 8482;
                t[63729] = 9127;
                t[63730] = 9128;
                t[63731] = 9129;
                t[63740] = 9131;
                t[63741] = 9132;
                t[63742] = 9133;
                t[63726] = 9121;
                t[63727] = 9122;
                t[63728] = 9123;
                t[63737] = 9124;
                t[63738] = 9125;
                t[63739] = 9126;
                t[63723] = 9115;
                t[63724] = 9116;
                t[63725] = 9117;
                t[63734] = 9118;
                t[63735] = 9119;
                t[63736] = 9120;
              });
              function mapSpecialUnicodeValues(code) {
                if (code >= 65520 && code <= 65535) {
                  return 0;
                } else if (code >= 62976 && code <= 63743) {
                  return getSpecialPUASymbols()[code] || code;
                } else if (code === 173) {
                  return 45;
                }
                return code;
              }
              function getUnicodeForGlyph(name, glyphsUnicodeMap) {
                let unicode = glyphsUnicodeMap[name];
                if (unicode !== void 0) {
                  return unicode;
                }
                if (!name) {
                  return -1;
                }
                if (name[0] === "u") {
                  const nameLen = name.length;
                  let hexStr;
                  if (nameLen === 7 && name[1] === "n" && name[2] === "i") {
                    hexStr = name.substring(3);
                  } else if (nameLen >= 5 && nameLen <= 7) {
                    hexStr = name.substring(1);
                  } else {
                    return -1;
                  }
                  if (hexStr === hexStr.toUpperCase()) {
                    unicode = parseInt(hexStr, 16);
                    if (unicode >= 0) {
                      return unicode;
                    }
                  }
                }
                return -1;
              }
              const UnicodeRanges = [[0, 127], [128, 255], [256, 383], [384, 591], [592, 687, 7424, 7551, 7552, 7615], [688, 767, 42752, 42783], [768, 879, 7616, 7679], [880, 1023], [11392, 11519], [1024, 1279, 1280, 1327, 11744, 11775, 42560, 42655], [1328, 1423], [1424, 1535], [42240, 42559], [1536, 1791, 1872, 1919], [1984, 2047], [2304, 2431], [2432, 2559], [2560, 2687], [2688, 2815], [2816, 2943], [2944, 3071], [3072, 3199], [3200, 3327], [3328, 3455], [3584, 3711], [3712, 3839], [4256, 4351, 11520, 11567], [6912, 7039], [4352, 4607], [7680, 7935, 11360, 11391, 42784, 43007], [7936, 8191], [8192, 8303, 11776, 11903], [8304, 8351], [8352, 8399], [8400, 8447], [8448, 8527], [8528, 8591], [8592, 8703, 10224, 10239, 10496, 10623, 11008, 11263], [8704, 8959, 10752, 11007, 10176, 10223, 10624, 10751], [8960, 9215], [9216, 9279], [9280, 9311], [9312, 9471], [9472, 9599], [9600, 9631], [9632, 9727], [9728, 9983], [9984, 10175], [12288, 12351], [12352, 12447], [12448, 12543, 12784, 12799], [12544, 12591, 12704, 12735], [12592, 12687], [43072, 43135], [12800, 13055], [13056, 13311], [44032, 55215], [55296, 57343], [67840, 67871], [19968, 40959, 11904, 12031, 12032, 12255, 12272, 12287, 13312, 19903, 131072, 173791, 12688, 12703], [57344, 63743], [12736, 12783, 63744, 64255, 194560, 195103], [64256, 64335], [64336, 65023], [65056, 65071], [65040, 65055], [65104, 65135], [65136, 65279], [65280, 65519], [65520, 65535], [3840, 4095], [1792, 1871], [1920, 1983], [3456, 3583], [4096, 4255], [4608, 4991, 4992, 5023, 11648, 11743], [5024, 5119], [5120, 5759], [5760, 5791], [5792, 5887], [6016, 6143], [6144, 6319], [10240, 10495], [40960, 42127], [5888, 5919, 5920, 5951, 5952, 5983, 5984, 6015], [66304, 66351], [66352, 66383], [66560, 66639], [118784, 119039, 119040, 119295, 119296, 119375], [119808, 120831], [1044480, 1048573], [65024, 65039, 917760, 917999], [917504, 917631], [6400, 6479], [6480, 6527], [6528, 6623], [6656, 6687], [11264, 11359], [11568, 11647], [19904, 19967], [43008, 43055], [65536, 65663, 65664, 65791, 65792, 65855], [65856, 65935], [66432, 66463], [66464, 66527], [66640, 66687], [66688, 66735], [67584, 67647], [68096, 68191], [119552, 119647], [73728, 74751, 74752, 74879], [119648, 119679], [7040, 7103], [7168, 7247], [7248, 7295], [43136, 43231], [43264, 43311], [43312, 43359], [43520, 43615], [65936, 65999], [66e3, 66047], [66208, 66271, 66176, 66207, 67872, 67903], [127024, 127135, 126976, 127023]];
              function getUnicodeRangeFor(value, lastPosition = -1) {
                if (lastPosition !== -1) {
                  const range = UnicodeRanges[lastPosition];
                  for (let i = 0, ii = range.length; i < ii; i += 2) {
                    if (value >= range[i] && value <= range[i + 1]) {
                      return lastPosition;
                    }
                  }
                }
                for (let i = 0, ii = UnicodeRanges.length; i < ii; i++) {
                  const range = UnicodeRanges[i];
                  for (let j = 0, jj = range.length; j < jj; j += 2) {
                    if (value >= range[j] && value <= range[j + 1]) {
                      return i;
                    }
                  }
                }
                return -1;
              }
              const SpecialCharRegExp = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u");
              const CategoryCache = /* @__PURE__ */ new Map();
              function getCharUnicodeCategory(char) {
                const cachedCategory = CategoryCache.get(char);
                if (cachedCategory) {
                  return cachedCategory;
                }
                const groups = char.match(SpecialCharRegExp);
                const category = {
                  isWhitespace: !!(groups == null ? void 0 : groups[1]),
                  isZeroWidthDiacritic: !!(groups == null ? void 0 : groups[2]),
                  isInvisibleFormatMark: !!(groups == null ? void 0 : groups[3])
                };
                CategoryCache.set(char, category);
                return category;
              }
              function clearUnicodeCaches() {
                CategoryCache.clear();
              }
            },
            /* 41 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.getSerifFonts = exports2.getNonStdFontMap = exports2.getGlyphMapForStandardFonts = exports2.getFontNameToFileMap = void 0;
              exports2.getStandardFontName = getStandardFontName;
              exports2.getSymbolsFonts = exports2.getSupplementalGlyphMapForCalibri = exports2.getSupplementalGlyphMapForArialBlack = exports2.getStdFontMap = void 0;
              exports2.isKnownFontName = isKnownFontName;
              var _core_utils = __w_pdfjs_require__2(3);
              var _fonts_utils = __w_pdfjs_require__2(38);
              const getStdFontMap = (0, _core_utils.getLookupTableFactory)(function(t) {
                t["Times-Roman"] = "Times-Roman";
                t.Helvetica = "Helvetica";
                t.Courier = "Courier";
                t.Symbol = "Symbol";
                t["Times-Bold"] = "Times-Bold";
                t["Helvetica-Bold"] = "Helvetica-Bold";
                t["Courier-Bold"] = "Courier-Bold";
                t.ZapfDingbats = "ZapfDingbats";
                t["Times-Italic"] = "Times-Italic";
                t["Helvetica-Oblique"] = "Helvetica-Oblique";
                t["Courier-Oblique"] = "Courier-Oblique";
                t["Times-BoldItalic"] = "Times-BoldItalic";
                t["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
                t["Courier-BoldOblique"] = "Courier-BoldOblique";
                t.ArialNarrow = "Helvetica";
                t["ArialNarrow-Bold"] = "Helvetica-Bold";
                t["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
                t["ArialNarrow-Italic"] = "Helvetica-Oblique";
                t.ArialBlack = "Helvetica";
                t["ArialBlack-Bold"] = "Helvetica-Bold";
                t["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
                t["ArialBlack-Italic"] = "Helvetica-Oblique";
                t["Arial-Black"] = "Helvetica";
                t["Arial-Black-Bold"] = "Helvetica-Bold";
                t["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
                t["Arial-Black-Italic"] = "Helvetica-Oblique";
                t.Arial = "Helvetica";
                t["Arial-Bold"] = "Helvetica-Bold";
                t["Arial-BoldItalic"] = "Helvetica-BoldOblique";
                t["Arial-Italic"] = "Helvetica-Oblique";
                t.ArialMT = "Helvetica";
                t["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
                t["Arial-BoldMT"] = "Helvetica-Bold";
                t["Arial-ItalicMT"] = "Helvetica-Oblique";
                t["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique";
                t["Arial-BoldMT-Bold"] = "Helvetica-Bold";
                t["Arial-ItalicMT-Italic"] = "Helvetica-Oblique";
                t.ArialUnicodeMS = "Helvetica";
                t["ArialUnicodeMS-Bold"] = "Helvetica-Bold";
                t["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique";
                t["ArialUnicodeMS-Italic"] = "Helvetica-Oblique";
                t["Courier-BoldItalic"] = "Courier-BoldOblique";
                t["Courier-Italic"] = "Courier-Oblique";
                t.CourierNew = "Courier";
                t["CourierNew-Bold"] = "Courier-Bold";
                t["CourierNew-BoldItalic"] = "Courier-BoldOblique";
                t["CourierNew-Italic"] = "Courier-Oblique";
                t["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
                t["CourierNewPS-BoldMT"] = "Courier-Bold";
                t["CourierNewPS-ItalicMT"] = "Courier-Oblique";
                t.CourierNewPSMT = "Courier";
                t["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
                t["Helvetica-Italic"] = "Helvetica-Oblique";
                t["Symbol-Bold"] = "Symbol";
                t["Symbol-BoldItalic"] = "Symbol";
                t["Symbol-Italic"] = "Symbol";
                t.TimesNewRoman = "Times-Roman";
                t["TimesNewRoman-Bold"] = "Times-Bold";
                t["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
                t["TimesNewRoman-Italic"] = "Times-Italic";
                t.TimesNewRomanPS = "Times-Roman";
                t["TimesNewRomanPS-Bold"] = "Times-Bold";
                t["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
                t["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
                t["TimesNewRomanPS-BoldMT"] = "Times-Bold";
                t["TimesNewRomanPS-Italic"] = "Times-Italic";
                t["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
                t.TimesNewRomanPSMT = "Times-Roman";
                t["TimesNewRomanPSMT-Bold"] = "Times-Bold";
                t["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
                t["TimesNewRomanPSMT-Italic"] = "Times-Italic";
              });
              exports2.getStdFontMap = getStdFontMap;
              const getFontNameToFileMap = (0, _core_utils.getLookupTableFactory)(function(t) {
                t.Courier = "FoxitFixed.pfb";
                t["Courier-Bold"] = "FoxitFixedBold.pfb";
                t["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb";
                t["Courier-Oblique"] = "FoxitFixedItalic.pfb";
                t.Helvetica = "LiberationSans-Regular.ttf";
                t["Helvetica-Bold"] = "LiberationSans-Bold.ttf";
                t["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf";
                t["Helvetica-Oblique"] = "LiberationSans-Italic.ttf";
                t["Times-Roman"] = "FoxitSerif.pfb";
                t["Times-Bold"] = "FoxitSerifBold.pfb";
                t["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb";
                t["Times-Italic"] = "FoxitSerifItalic.pfb";
                t.Symbol = "FoxitSymbol.pfb";
                t.ZapfDingbats = "FoxitDingbats.pfb";
                t["LiberationSans-Regular"] = "LiberationSans-Regular.ttf";
                t["LiberationSans-Bold"] = "LiberationSans-Bold.ttf";
                t["LiberationSans-Italic"] = "LiberationSans-Italic.ttf";
                t["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
              });
              exports2.getFontNameToFileMap = getFontNameToFileMap;
              const getNonStdFontMap = (0, _core_utils.getLookupTableFactory)(function(t) {
                t.Calibri = "Helvetica";
                t["Calibri-Bold"] = "Helvetica-Bold";
                t["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
                t["Calibri-Italic"] = "Helvetica-Oblique";
                t.CenturyGothic = "Helvetica";
                t["CenturyGothic-Bold"] = "Helvetica-Bold";
                t["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
                t["CenturyGothic-Italic"] = "Helvetica-Oblique";
                t.ComicSansMS = "Comic Sans MS";
                t["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
                t["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
                t["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
                t.Impact = "Helvetica";
                t["ItcSymbol-Bold"] = "Helvetica-Bold";
                t["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique";
                t["ItcSymbol-Book"] = "Helvetica";
                t["ItcSymbol-BookItalic"] = "Helvetica-Oblique";
                t["ItcSymbol-Medium"] = "Helvetica";
                t["ItcSymbol-MediumItalic"] = "Helvetica-Oblique";
                t.LucidaConsole = "Courier";
                t["LucidaConsole-Bold"] = "Courier-Bold";
                t["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
                t["LucidaConsole-Italic"] = "Courier-Oblique";
                t["LucidaSans-Demi"] = "Helvetica-Bold";
                t["MS-Gothic"] = "MS Gothic";
                t["MS-Gothic-Bold"] = "MS Gothic-Bold";
                t["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
                t["MS-Gothic-Italic"] = "MS Gothic-Italic";
                t["MS-Mincho"] = "MS Mincho";
                t["MS-Mincho-Bold"] = "MS Mincho-Bold";
                t["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
                t["MS-Mincho-Italic"] = "MS Mincho-Italic";
                t["MS-PGothic"] = "MS PGothic";
                t["MS-PGothic-Bold"] = "MS PGothic-Bold";
                t["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
                t["MS-PGothic-Italic"] = "MS PGothic-Italic";
                t["MS-PMincho"] = "MS PMincho";
                t["MS-PMincho-Bold"] = "MS PMincho-Bold";
                t["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
                t["MS-PMincho-Italic"] = "MS PMincho-Italic";
                t.NuptialScript = "Times-Italic";
                t.SegoeUISymbol = "Helvetica";
              });
              exports2.getNonStdFontMap = getNonStdFontMap;
              const getSerifFonts = (0, _core_utils.getLookupTableFactory)(function(t) {
                t["Adobe Jenson"] = true;
                t["Adobe Text"] = true;
                t.Albertus = true;
                t.Aldus = true;
                t.Alexandria = true;
                t.Algerian = true;
                t["American Typewriter"] = true;
                t.Antiqua = true;
                t.Apex = true;
                t.Arno = true;
                t.Aster = true;
                t.Aurora = true;
                t.Baskerville = true;
                t.Bell = true;
                t.Bembo = true;
                t["Bembo Schoolbook"] = true;
                t.Benguiat = true;
                t["Berkeley Old Style"] = true;
                t["Bernhard Modern"] = true;
                t["Berthold City"] = true;
                t.Bodoni = true;
                t["Bauer Bodoni"] = true;
                t["Book Antiqua"] = true;
                t.Bookman = true;
                t["Bordeaux Roman"] = true;
                t["Californian FB"] = true;
                t.Calisto = true;
                t.Calvert = true;
                t.Capitals = true;
                t.Cambria = true;
                t.Cartier = true;
                t.Caslon = true;
                t.Catull = true;
                t.Centaur = true;
                t["Century Old Style"] = true;
                t["Century Schoolbook"] = true;
                t.Chaparral = true;
                t["Charis SIL"] = true;
                t.Cheltenham = true;
                t["Cholla Slab"] = true;
                t.Clarendon = true;
                t.Clearface = true;
                t.Cochin = true;
                t.Colonna = true;
                t["Computer Modern"] = true;
                t["Concrete Roman"] = true;
                t.Constantia = true;
                t["Cooper Black"] = true;
                t.Corona = true;
                t.Ecotype = true;
                t.Egyptienne = true;
                t.Elephant = true;
                t.Excelsior = true;
                t.Fairfield = true;
                t["FF Scala"] = true;
                t.Folkard = true;
                t.Footlight = true;
                t.FreeSerif = true;
                t["Friz Quadrata"] = true;
                t.Garamond = true;
                t.Gentium = true;
                t.Georgia = true;
                t.Gloucester = true;
                t["Goudy Old Style"] = true;
                t["Goudy Schoolbook"] = true;
                t["Goudy Pro Font"] = true;
                t.Granjon = true;
                t["Guardian Egyptian"] = true;
                t.Heather = true;
                t.Hercules = true;
                t["High Tower Text"] = true;
                t.Hiroshige = true;
                t["Hoefler Text"] = true;
                t["Humana Serif"] = true;
                t.Imprint = true;
                t["Ionic No. 5"] = true;
                t.Janson = true;
                t.Joanna = true;
                t.Korinna = true;
                t.Lexicon = true;
                t.LiberationSerif = true;
                t["Liberation Serif"] = true;
                t["Linux Libertine"] = true;
                t.Literaturnaya = true;
                t.Lucida = true;
                t["Lucida Bright"] = true;
                t.Melior = true;
                t.Memphis = true;
                t.Miller = true;
                t.Minion = true;
                t.Modern = true;
                t["Mona Lisa"] = true;
                t["Mrs Eaves"] = true;
                t["MS Serif"] = true;
                t["Museo Slab"] = true;
                t["New York"] = true;
                t["Nimbus Roman"] = true;
                t["NPS Rawlinson Roadway"] = true;
                t.NuptialScript = true;
                t.Palatino = true;
                t.Perpetua = true;
                t.Plantin = true;
                t["Plantin Schoolbook"] = true;
                t.Playbill = true;
                t["Poor Richard"] = true;
                t["Rawlinson Roadway"] = true;
                t.Renault = true;
                t.Requiem = true;
                t.Rockwell = true;
                t.Roman = true;
                t["Rotis Serif"] = true;
                t.Sabon = true;
                t.Scala = true;
                t.Seagull = true;
                t.Sistina = true;
                t.Souvenir = true;
                t.STIX = true;
                t["Stone Informal"] = true;
                t["Stone Serif"] = true;
                t.Sylfaen = true;
                t.Times = true;
                t.Trajan = true;
                t["Trinit"] = true;
                t["Trump Mediaeval"] = true;
                t.Utopia = true;
                t["Vale Type"] = true;
                t["Bitstream Vera"] = true;
                t["Vera Serif"] = true;
                t.Versailles = true;
                t.Wanted = true;
                t.Weiss = true;
                t["Wide Latin"] = true;
                t.Windsor = true;
                t.XITS = true;
              });
              exports2.getSerifFonts = getSerifFonts;
              const getSymbolsFonts = (0, _core_utils.getLookupTableFactory)(function(t) {
                t.Dingbats = true;
                t.Symbol = true;
                t.ZapfDingbats = true;
                t.Wingdings = true;
                t["Wingdings-Bold"] = true;
                t["Wingdings-Regular"] = true;
              });
              exports2.getSymbolsFonts = getSymbolsFonts;
              const getGlyphMapForStandardFonts = (0, _core_utils.getLookupTableFactory)(function(t) {
                t[2] = 10;
                t[3] = 32;
                t[4] = 33;
                t[5] = 34;
                t[6] = 35;
                t[7] = 36;
                t[8] = 37;
                t[9] = 38;
                t[10] = 39;
                t[11] = 40;
                t[12] = 41;
                t[13] = 42;
                t[14] = 43;
                t[15] = 44;
                t[16] = 45;
                t[17] = 46;
                t[18] = 47;
                t[19] = 48;
                t[20] = 49;
                t[21] = 50;
                t[22] = 51;
                t[23] = 52;
                t[24] = 53;
                t[25] = 54;
                t[26] = 55;
                t[27] = 56;
                t[28] = 57;
                t[29] = 58;
                t[30] = 894;
                t[31] = 60;
                t[32] = 61;
                t[33] = 62;
                t[34] = 63;
                t[35] = 64;
                t[36] = 65;
                t[37] = 66;
                t[38] = 67;
                t[39] = 68;
                t[40] = 69;
                t[41] = 70;
                t[42] = 71;
                t[43] = 72;
                t[44] = 73;
                t[45] = 74;
                t[46] = 75;
                t[47] = 76;
                t[48] = 77;
                t[49] = 78;
                t[50] = 79;
                t[51] = 80;
                t[52] = 81;
                t[53] = 82;
                t[54] = 83;
                t[55] = 84;
                t[56] = 85;
                t[57] = 86;
                t[58] = 87;
                t[59] = 88;
                t[60] = 89;
                t[61] = 90;
                t[62] = 91;
                t[63] = 92;
                t[64] = 93;
                t[65] = 94;
                t[66] = 95;
                t[67] = 96;
                t[68] = 97;
                t[69] = 98;
                t[70] = 99;
                t[71] = 100;
                t[72] = 101;
                t[73] = 102;
                t[74] = 103;
                t[75] = 104;
                t[76] = 105;
                t[77] = 106;
                t[78] = 107;
                t[79] = 108;
                t[80] = 109;
                t[81] = 110;
                t[82] = 111;
                t[83] = 112;
                t[84] = 113;
                t[85] = 114;
                t[86] = 115;
                t[87] = 116;
                t[88] = 117;
                t[89] = 118;
                t[90] = 119;
                t[91] = 120;
                t[92] = 121;
                t[93] = 122;
                t[94] = 123;
                t[95] = 124;
                t[96] = 125;
                t[97] = 126;
                t[98] = 196;
                t[99] = 197;
                t[100] = 199;
                t[101] = 201;
                t[102] = 209;
                t[103] = 214;
                t[104] = 220;
                t[105] = 225;
                t[106] = 224;
                t[107] = 226;
                t[108] = 228;
                t[109] = 227;
                t[110] = 229;
                t[111] = 231;
                t[112] = 233;
                t[113] = 232;
                t[114] = 234;
                t[115] = 235;
                t[116] = 237;
                t[117] = 236;
                t[118] = 238;
                t[119] = 239;
                t[120] = 241;
                t[121] = 243;
                t[122] = 242;
                t[123] = 244;
                t[124] = 246;
                t[125] = 245;
                t[126] = 250;
                t[127] = 249;
                t[128] = 251;
                t[129] = 252;
                t[130] = 8224;
                t[131] = 176;
                t[132] = 162;
                t[133] = 163;
                t[134] = 167;
                t[135] = 8226;
                t[136] = 182;
                t[137] = 223;
                t[138] = 174;
                t[139] = 169;
                t[140] = 8482;
                t[141] = 180;
                t[142] = 168;
                t[143] = 8800;
                t[144] = 198;
                t[145] = 216;
                t[146] = 8734;
                t[147] = 177;
                t[148] = 8804;
                t[149] = 8805;
                t[150] = 165;
                t[151] = 181;
                t[152] = 8706;
                t[153] = 8721;
                t[154] = 8719;
                t[156] = 8747;
                t[157] = 170;
                t[158] = 186;
                t[159] = 8486;
                t[160] = 230;
                t[161] = 248;
                t[162] = 191;
                t[163] = 161;
                t[164] = 172;
                t[165] = 8730;
                t[166] = 402;
                t[167] = 8776;
                t[168] = 8710;
                t[169] = 171;
                t[170] = 187;
                t[171] = 8230;
                t[179] = 8220;
                t[180] = 8221;
                t[181] = 8216;
                t[182] = 8217;
                t[200] = 193;
                t[203] = 205;
                t[207] = 211;
                t[210] = 218;
                t[223] = 711;
                t[224] = 321;
                t[225] = 322;
                t[226] = 352;
                t[227] = 353;
                t[228] = 381;
                t[229] = 382;
                t[233] = 221;
                t[234] = 253;
                t[252] = 263;
                t[253] = 268;
                t[254] = 269;
                t[258] = 258;
                t[260] = 260;
                t[261] = 261;
                t[265] = 280;
                t[266] = 281;
                t[267] = 282;
                t[268] = 283;
                t[269] = 313;
                t[275] = 323;
                t[276] = 324;
                t[278] = 328;
                t[283] = 344;
                t[284] = 345;
                t[285] = 346;
                t[286] = 347;
                t[292] = 367;
                t[295] = 377;
                t[296] = 378;
                t[298] = 380;
                t[305] = 963;
                t[306] = 964;
                t[307] = 966;
                t[308] = 8215;
                t[309] = 8252;
                t[310] = 8319;
                t[311] = 8359;
                t[312] = 8592;
                t[313] = 8593;
                t[337] = 9552;
                t[493] = 1039;
                t[494] = 1040;
                t[672] = 1488;
                t[673] = 1489;
                t[674] = 1490;
                t[675] = 1491;
                t[676] = 1492;
                t[677] = 1493;
                t[678] = 1494;
                t[679] = 1495;
                t[680] = 1496;
                t[681] = 1497;
                t[682] = 1498;
                t[683] = 1499;
                t[684] = 1500;
                t[685] = 1501;
                t[686] = 1502;
                t[687] = 1503;
                t[688] = 1504;
                t[689] = 1505;
                t[690] = 1506;
                t[691] = 1507;
                t[692] = 1508;
                t[693] = 1509;
                t[694] = 1510;
                t[695] = 1511;
                t[696] = 1512;
                t[697] = 1513;
                t[698] = 1514;
                t[705] = 1524;
                t[706] = 8362;
                t[710] = 64288;
                t[711] = 64298;
                t[759] = 1617;
                t[761] = 1776;
                t[763] = 1778;
                t[775] = 1652;
                t[777] = 1764;
                t[778] = 1780;
                t[779] = 1781;
                t[780] = 1782;
                t[782] = 771;
                t[783] = 64726;
                t[786] = 8363;
                t[788] = 8532;
                t[790] = 768;
                t[791] = 769;
                t[792] = 768;
                t[795] = 803;
                t[797] = 64336;
                t[798] = 64337;
                t[799] = 64342;
                t[800] = 64343;
                t[801] = 64344;
                t[802] = 64345;
                t[803] = 64362;
                t[804] = 64363;
                t[805] = 64364;
                t[2424] = 7821;
                t[2425] = 7822;
                t[2426] = 7823;
                t[2427] = 7824;
                t[2428] = 7825;
                t[2429] = 7826;
                t[2430] = 7827;
                t[2433] = 7682;
                t[2678] = 8045;
                t[2679] = 8046;
                t[2830] = 1552;
                t[2838] = 686;
                t[2840] = 751;
                t[2842] = 753;
                t[2843] = 754;
                t[2844] = 755;
                t[2846] = 757;
                t[2856] = 767;
                t[2857] = 848;
                t[2858] = 849;
                t[2862] = 853;
                t[2863] = 854;
                t[2864] = 855;
                t[2865] = 861;
                t[2866] = 862;
                t[2906] = 7460;
                t[2908] = 7462;
                t[2909] = 7463;
                t[2910] = 7464;
                t[2912] = 7466;
                t[2913] = 7467;
                t[2914] = 7468;
                t[2916] = 7470;
                t[2917] = 7471;
                t[2918] = 7472;
                t[2920] = 7474;
                t[2921] = 7475;
                t[2922] = 7476;
                t[2924] = 7478;
                t[2925] = 7479;
                t[2926] = 7480;
                t[2928] = 7482;
                t[2929] = 7483;
                t[2930] = 7484;
                t[2932] = 7486;
                t[2933] = 7487;
                t[2934] = 7488;
                t[2936] = 7490;
                t[2937] = 7491;
                t[2938] = 7492;
                t[2940] = 7494;
                t[2941] = 7495;
                t[2942] = 7496;
                t[2944] = 7498;
                t[2946] = 7500;
                t[2948] = 7502;
                t[2950] = 7504;
                t[2951] = 7505;
                t[2952] = 7506;
                t[2954] = 7508;
                t[2955] = 7509;
                t[2956] = 7510;
                t[2958] = 7512;
                t[2959] = 7513;
                t[2960] = 7514;
                t[2962] = 7516;
                t[2963] = 7517;
                t[2964] = 7518;
                t[2966] = 7520;
                t[2967] = 7521;
                t[2968] = 7522;
                t[2970] = 7524;
                t[2971] = 7525;
                t[2972] = 7526;
                t[2974] = 7528;
                t[2975] = 7529;
                t[2976] = 7530;
                t[2978] = 1537;
                t[2979] = 1538;
                t[2980] = 1539;
                t[2982] = 1549;
                t[2983] = 1551;
                t[2984] = 1552;
                t[2986] = 1554;
                t[2987] = 1555;
                t[2988] = 1556;
                t[2990] = 1623;
                t[2991] = 1624;
                t[2995] = 1775;
                t[2999] = 1791;
                t[3002] = 64290;
                t[3003] = 64291;
                t[3004] = 64292;
                t[3006] = 64294;
                t[3007] = 64295;
                t[3008] = 64296;
                t[3011] = 1900;
                t[3014] = 8223;
                t[3015] = 8244;
                t[3017] = 7532;
                t[3018] = 7533;
                t[3019] = 7534;
                t[3075] = 7590;
                t[3076] = 7591;
                t[3079] = 7594;
                t[3080] = 7595;
                t[3083] = 7598;
                t[3084] = 7599;
                t[3087] = 7602;
                t[3088] = 7603;
                t[3091] = 7606;
                t[3092] = 7607;
                t[3095] = 7610;
                t[3096] = 7611;
                t[3099] = 7614;
                t[3100] = 7615;
                t[3103] = 7618;
                t[3104] = 7619;
                t[3107] = 8337;
                t[3108] = 8338;
                t[3116] = 1884;
                t[3119] = 1885;
                t[3120] = 1885;
                t[3123] = 1886;
                t[3124] = 1886;
                t[3127] = 1887;
                t[3128] = 1887;
                t[3131] = 1888;
                t[3132] = 1888;
                t[3135] = 1889;
                t[3136] = 1889;
                t[3139] = 1890;
                t[3140] = 1890;
                t[3143] = 1891;
                t[3144] = 1891;
                t[3147] = 1892;
                t[3148] = 1892;
                t[3153] = 580;
                t[3154] = 581;
                t[3157] = 584;
                t[3158] = 585;
                t[3161] = 588;
                t[3162] = 589;
                t[3165] = 891;
                t[3166] = 892;
                t[3169] = 1274;
                t[3170] = 1275;
                t[3173] = 1278;
                t[3174] = 1279;
                t[3181] = 7622;
                t[3182] = 7623;
                t[3282] = 11799;
                t[3316] = 578;
                t[3379] = 42785;
                t[3393] = 1159;
                t[3416] = 8377;
              });
              exports2.getGlyphMapForStandardFonts = getGlyphMapForStandardFonts;
              const getSupplementalGlyphMapForArialBlack = (0, _core_utils.getLookupTableFactory)(function(t) {
                t[227] = 322;
                t[264] = 261;
                t[291] = 346;
              });
              exports2.getSupplementalGlyphMapForArialBlack = getSupplementalGlyphMapForArialBlack;
              const getSupplementalGlyphMapForCalibri = (0, _core_utils.getLookupTableFactory)(function(t) {
                t[1] = 32;
                t[4] = 65;
                t[5] = 192;
                t[6] = 193;
                t[9] = 196;
                t[17] = 66;
                t[18] = 67;
                t[21] = 268;
                t[24] = 68;
                t[28] = 69;
                t[29] = 200;
                t[30] = 201;
                t[32] = 282;
                t[38] = 70;
                t[39] = 71;
                t[44] = 72;
                t[47] = 73;
                t[48] = 204;
                t[49] = 205;
                t[58] = 74;
                t[60] = 75;
                t[62] = 76;
                t[68] = 77;
                t[69] = 78;
                t[75] = 79;
                t[76] = 210;
                t[80] = 214;
                t[87] = 80;
                t[89] = 81;
                t[90] = 82;
                t[92] = 344;
                t[94] = 83;
                t[97] = 352;
                t[100] = 84;
                t[104] = 85;
                t[109] = 220;
                t[115] = 86;
                t[116] = 87;
                t[121] = 88;
                t[122] = 89;
                t[124] = 221;
                t[127] = 90;
                t[129] = 381;
                t[258] = 97;
                t[259] = 224;
                t[260] = 225;
                t[263] = 228;
                t[268] = 261;
                t[271] = 98;
                t[272] = 99;
                t[273] = 263;
                t[275] = 269;
                t[282] = 100;
                t[286] = 101;
                t[287] = 232;
                t[288] = 233;
                t[290] = 283;
                t[295] = 281;
                t[296] = 102;
                t[336] = 103;
                t[346] = 104;
                t[349] = 105;
                t[350] = 236;
                t[351] = 237;
                t[361] = 106;
                t[364] = 107;
                t[367] = 108;
                t[371] = 322;
                t[373] = 109;
                t[374] = 110;
                t[381] = 111;
                t[382] = 242;
                t[383] = 243;
                t[386] = 246;
                t[393] = 112;
                t[395] = 113;
                t[396] = 114;
                t[398] = 345;
                t[400] = 115;
                t[401] = 347;
                t[403] = 353;
                t[410] = 116;
                t[437] = 117;
                t[442] = 252;
                t[448] = 118;
                t[449] = 119;
                t[454] = 120;
                t[455] = 121;
                t[457] = 253;
                t[460] = 122;
                t[462] = 382;
                t[463] = 380;
                t[853] = 44;
                t[855] = 58;
                t[856] = 46;
                t[876] = 47;
                t[878] = 45;
                t[882] = 45;
                t[894] = 40;
                t[895] = 41;
                t[896] = 91;
                t[897] = 93;
                t[923] = 64;
                t[1004] = 48;
                t[1005] = 49;
                t[1006] = 50;
                t[1007] = 51;
                t[1008] = 52;
                t[1009] = 53;
                t[1010] = 54;
                t[1011] = 55;
                t[1012] = 56;
                t[1013] = 57;
                t[1081] = 37;
                t[1085] = 43;
                t[1086] = 45;
              });
              exports2.getSupplementalGlyphMapForCalibri = getSupplementalGlyphMapForCalibri;
              function getStandardFontName(name) {
                const fontName = (0, _fonts_utils.normalizeFontName)(name);
                const stdFontMap = getStdFontMap();
                return stdFontMap[fontName];
              }
              function isKnownFontName(name) {
                const fontName = (0, _fonts_utils.normalizeFontName)(name);
                return !!(getStdFontMap()[fontName] || getNonStdFontMap()[fontName] || getSerifFonts()[fontName] || getSymbolsFonts()[fontName]);
              }
            },
            /* 42 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ToUnicodeMap = exports2.IdentityToUnicodeMap = void 0;
              var _util = __w_pdfjs_require__2(2);
              class ToUnicodeMap {
                constructor(cmap = []) {
                  this._map = cmap;
                }
                get length() {
                  return this._map.length;
                }
                forEach(callback) {
                  for (const charCode in this._map) {
                    callback(charCode, this._map[charCode].charCodeAt(0));
                  }
                }
                has(i) {
                  return this._map[i] !== void 0;
                }
                get(i) {
                  return this._map[i];
                }
                charCodeOf(value) {
                  const map = this._map;
                  if (map.length <= 65536) {
                    return map.indexOf(value);
                  }
                  for (const charCode in map) {
                    if (map[charCode] === value) {
                      return charCode | 0;
                    }
                  }
                  return -1;
                }
                amend(map) {
                  for (const charCode in map) {
                    this._map[charCode] = map[charCode];
                  }
                }
              }
              exports2.ToUnicodeMap = ToUnicodeMap;
              class IdentityToUnicodeMap {
                constructor(firstChar, lastChar) {
                  this.firstChar = firstChar;
                  this.lastChar = lastChar;
                }
                get length() {
                  return this.lastChar + 1 - this.firstChar;
                }
                forEach(callback) {
                  for (let i = this.firstChar, ii = this.lastChar; i <= ii; i++) {
                    callback(i, i);
                  }
                }
                has(i) {
                  return this.firstChar <= i && i <= this.lastChar;
                }
                get(i) {
                  if (this.firstChar <= i && i <= this.lastChar) {
                    return String.fromCharCode(i);
                  }
                  return void 0;
                }
                charCodeOf(v) {
                  return Number.isInteger(v) && v >= this.firstChar && v <= this.lastChar ? v : -1;
                }
                amend(map) {
                  (0, _util.unreachable)("Should not call amend()");
                }
              }
              exports2.IdentityToUnicodeMap = IdentityToUnicodeMap;
            },
            /* 43 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CFFFont = void 0;
              var _cff_parser = __w_pdfjs_require__2(35);
              var _fonts_utils = __w_pdfjs_require__2(38);
              var _util = __w_pdfjs_require__2(2);
              class CFFFont {
                constructor(file, properties) {
                  this.properties = properties;
                  const parser = new _cff_parser.CFFParser(file, properties, _fonts_utils.SEAC_ANALYSIS_ENABLED);
                  this.cff = parser.parse();
                  this.cff.duplicateFirstGlyph();
                  const compiler = new _cff_parser.CFFCompiler(this.cff);
                  this.seacs = this.cff.seacs;
                  try {
                    this.data = compiler.compile();
                  } catch {
                    (0, _util.warn)("Failed to compile font " + properties.loadedName);
                    this.data = file;
                  }
                  this._createBuiltInEncoding();
                }
                get numGlyphs() {
                  return this.cff.charStrings.count;
                }
                getCharset() {
                  return this.cff.charset.charset;
                }
                getGlyphMapping() {
                  const cff = this.cff;
                  const properties = this.properties;
                  const {
                    cidToGidMap,
                    cMap
                  } = properties;
                  const charsets = cff.charset.charset;
                  let charCodeToGlyphId;
                  let glyphId;
                  if (properties.composite) {
                    let invCidToGidMap;
                    if ((cidToGidMap == null ? void 0 : cidToGidMap.length) > 0) {
                      invCidToGidMap = /* @__PURE__ */ Object.create(null);
                      for (let i = 0, ii = cidToGidMap.length; i < ii; i++) {
                        const gid = cidToGidMap[i];
                        if (gid !== void 0) {
                          invCidToGidMap[gid] = i;
                        }
                      }
                    }
                    charCodeToGlyphId = /* @__PURE__ */ Object.create(null);
                    let charCode;
                    if (cff.isCIDFont) {
                      for (glyphId = 0; glyphId < charsets.length; glyphId++) {
                        const cid = charsets[glyphId];
                        charCode = cMap.charCodeOf(cid);
                        if ((invCidToGidMap == null ? void 0 : invCidToGidMap[charCode]) !== void 0) {
                          charCode = invCidToGidMap[charCode];
                        }
                        charCodeToGlyphId[charCode] = glyphId;
                      }
                    } else {
                      for (glyphId = 0; glyphId < cff.charStrings.count; glyphId++) {
                        charCode = cMap.charCodeOf(glyphId);
                        charCodeToGlyphId[charCode] = glyphId;
                      }
                    }
                    return charCodeToGlyphId;
                  }
                  let encoding = cff.encoding ? cff.encoding.encoding : null;
                  if (properties.isInternalFont) {
                    encoding = properties.defaultEncoding;
                  }
                  charCodeToGlyphId = (0, _fonts_utils.type1FontGlyphMapping)(properties, encoding, charsets);
                  return charCodeToGlyphId;
                }
                hasGlyphId(id) {
                  return this.cff.hasGlyphId(id);
                }
                _createBuiltInEncoding() {
                  const {
                    charset,
                    encoding
                  } = this.cff;
                  if (!charset || !encoding) {
                    return;
                  }
                  const charsets = charset.charset, encodings = encoding.encoding;
                  const map = [];
                  for (const charCode in encodings) {
                    const glyphId = encodings[charCode];
                    if (glyphId >= 0) {
                      const glyphName = charsets[glyphId];
                      if (glyphName) {
                        map[charCode] = glyphName;
                      }
                    }
                  }
                  if (map.length > 0) {
                    this.properties.builtInEncoding = map;
                  }
                }
              }
              exports2.CFFFont = CFFFont;
            },
            /* 44 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FontRendererFactory = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _cff_parser = __w_pdfjs_require__2(35);
              var _glyphlist = __w_pdfjs_require__2(39);
              var _encodings = __w_pdfjs_require__2(37);
              var _stream = __w_pdfjs_require__2(8);
              function getUint32(data, offset) {
                return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
              }
              function getUint16(data, offset) {
                return data[offset] << 8 | data[offset + 1];
              }
              function getInt16(data, offset) {
                return (data[offset] << 24 | data[offset + 1] << 16) >> 16;
              }
              function getInt8(data, offset) {
                return data[offset] << 24 >> 24;
              }
              function getFloat214(data, offset) {
                return getInt16(data, offset) / 16384;
              }
              function getSubroutineBias(subrs) {
                const numSubrs = subrs.length;
                let bias = 32768;
                if (numSubrs < 1240) {
                  bias = 107;
                } else if (numSubrs < 33900) {
                  bias = 1131;
                }
                return bias;
              }
              function parseCmap(data, start, end) {
                const offset = getUint16(data, start + 2) === 1 ? getUint32(data, start + 8) : getUint32(data, start + 16);
                const format = getUint16(data, start + offset);
                let ranges, p, i;
                if (format === 4) {
                  getUint16(data, start + offset + 2);
                  const segCount = getUint16(data, start + offset + 6) >> 1;
                  p = start + offset + 14;
                  ranges = [];
                  for (i = 0; i < segCount; i++, p += 2) {
                    ranges[i] = {
                      end: getUint16(data, p)
                    };
                  }
                  p += 2;
                  for (i = 0; i < segCount; i++, p += 2) {
                    ranges[i].start = getUint16(data, p);
                  }
                  for (i = 0; i < segCount; i++, p += 2) {
                    ranges[i].idDelta = getUint16(data, p);
                  }
                  for (i = 0; i < segCount; i++, p += 2) {
                    let idOffset = getUint16(data, p);
                    if (idOffset === 0) {
                      continue;
                    }
                    ranges[i].ids = [];
                    for (let j = 0, jj = ranges[i].end - ranges[i].start + 1; j < jj; j++) {
                      ranges[i].ids[j] = getUint16(data, p + idOffset);
                      idOffset += 2;
                    }
                  }
                  return ranges;
                } else if (format === 12) {
                  const groups = getUint32(data, start + offset + 12);
                  p = start + offset + 16;
                  ranges = [];
                  for (i = 0; i < groups; i++) {
                    start = getUint32(data, p);
                    ranges.push({
                      start,
                      end: getUint32(data, p + 4),
                      idDelta: getUint32(data, p + 8) - start
                    });
                    p += 12;
                  }
                  return ranges;
                }
                throw new _util.FormatError(`unsupported cmap: ${format}`);
              }
              function parseCff(data, start, end, seacAnalysisEnabled) {
                var _a, _b, _c;
                const properties = {};
                const parser = new _cff_parser.CFFParser(new _stream.Stream(data, start, end - start), properties, seacAnalysisEnabled);
                const cff = parser.parse();
                return {
                  glyphs: cff.charStrings.objects,
                  subrs: (_b = (_a = cff.topDict.privateDict) == null ? void 0 : _a.subrsIndex) == null ? void 0 : _b.objects,
                  gsubrs: (_c = cff.globalSubrIndex) == null ? void 0 : _c.objects,
                  isCFFCIDFont: cff.isCIDFont,
                  fdSelect: cff.fdSelect,
                  fdArray: cff.fdArray
                };
              }
              function parseGlyfTable(glyf, loca, isGlyphLocationsLong) {
                let itemSize, itemDecode;
                if (isGlyphLocationsLong) {
                  itemSize = 4;
                  itemDecode = getUint32;
                } else {
                  itemSize = 2;
                  itemDecode = (data, offset) => 2 * getUint16(data, offset);
                }
                const glyphs = [];
                let startOffset = itemDecode(loca, 0);
                for (let j = itemSize; j < loca.length; j += itemSize) {
                  const endOffset = itemDecode(loca, j);
                  glyphs.push(glyf.subarray(startOffset, endOffset));
                  startOffset = endOffset;
                }
                return glyphs;
              }
              function lookupCmap(ranges, unicode) {
                const code = unicode.codePointAt(0);
                let gid = 0, l = 0, r = ranges.length - 1;
                while (l < r) {
                  const c = l + r + 1 >> 1;
                  if (code < ranges[c].start) {
                    r = c - 1;
                  } else {
                    l = c;
                  }
                }
                if (ranges[l].start <= code && code <= ranges[l].end) {
                  gid = ranges[l].idDelta + (ranges[l].ids ? ranges[l].ids[code - ranges[l].start] : code) & 65535;
                }
                return {
                  charCode: code,
                  glyphId: gid
                };
              }
              function compileGlyf(code, cmds, font) {
                function moveTo(x2, y2) {
                  cmds.push({
                    cmd: "moveTo",
                    args: [x2, y2]
                  });
                }
                function lineTo(x2, y2) {
                  cmds.push({
                    cmd: "lineTo",
                    args: [x2, y2]
                  });
                }
                function quadraticCurveTo(xa, ya, x2, y2) {
                  cmds.push({
                    cmd: "quadraticCurveTo",
                    args: [xa, ya, x2, y2]
                  });
                }
                let i = 0;
                const numberOfContours = getInt16(code, i);
                let flags;
                let x = 0, y = 0;
                i += 10;
                if (numberOfContours < 0) {
                  do {
                    flags = getUint16(code, i);
                    const glyphIndex = getUint16(code, i + 2);
                    i += 4;
                    let arg1, arg2;
                    if (flags & 1) {
                      if (flags & 2) {
                        arg1 = getInt16(code, i);
                        arg2 = getInt16(code, i + 2);
                      } else {
                        arg1 = getUint16(code, i);
                        arg2 = getUint16(code, i + 2);
                      }
                      i += 4;
                    } else if (flags & 2) {
                      arg1 = getInt8(code, i++);
                      arg2 = getInt8(code, i++);
                    } else {
                      arg1 = code[i++];
                      arg2 = code[i++];
                    }
                    if (flags & 2) {
                      x = arg1;
                      y = arg2;
                    } else {
                      x = 0;
                      y = 0;
                    }
                    let scaleX = 1, scaleY = 1, scale01 = 0, scale10 = 0;
                    if (flags & 8) {
                      scaleX = scaleY = getFloat214(code, i);
                      i += 2;
                    } else if (flags & 64) {
                      scaleX = getFloat214(code, i);
                      scaleY = getFloat214(code, i + 2);
                      i += 4;
                    } else if (flags & 128) {
                      scaleX = getFloat214(code, i);
                      scale01 = getFloat214(code, i + 2);
                      scale10 = getFloat214(code, i + 4);
                      scaleY = getFloat214(code, i + 6);
                      i += 8;
                    }
                    const subglyph = font.glyphs[glyphIndex];
                    if (subglyph) {
                      cmds.push({
                        cmd: "save"
                      }, {
                        cmd: "transform",
                        args: [scaleX, scale01, scale10, scaleY, x, y]
                      });
                      if (!(flags & 2)) {
                      }
                      compileGlyf(subglyph, cmds, font);
                      cmds.push({
                        cmd: "restore"
                      });
                    }
                  } while (flags & 32);
                } else {
                  const endPtsOfContours = [];
                  let j, jj;
                  for (j = 0; j < numberOfContours; j++) {
                    endPtsOfContours.push(getUint16(code, i));
                    i += 2;
                  }
                  const instructionLength = getUint16(code, i);
                  i += 2 + instructionLength;
                  const numberOfPoints = endPtsOfContours.at(-1) + 1;
                  const points = [];
                  while (points.length < numberOfPoints) {
                    flags = code[i++];
                    let repeat = 1;
                    if (flags & 8) {
                      repeat += code[i++];
                    }
                    while (repeat-- > 0) {
                      points.push({
                        flags
                      });
                    }
                  }
                  for (j = 0; j < numberOfPoints; j++) {
                    switch (points[j].flags & 18) {
                      case 0:
                        x += getInt16(code, i);
                        i += 2;
                        break;
                      case 2:
                        x -= code[i++];
                        break;
                      case 18:
                        x += code[i++];
                        break;
                    }
                    points[j].x = x;
                  }
                  for (j = 0; j < numberOfPoints; j++) {
                    switch (points[j].flags & 36) {
                      case 0:
                        y += getInt16(code, i);
                        i += 2;
                        break;
                      case 4:
                        y -= code[i++];
                        break;
                      case 36:
                        y += code[i++];
                        break;
                    }
                    points[j].y = y;
                  }
                  let startPoint = 0;
                  for (i = 0; i < numberOfContours; i++) {
                    const endPoint = endPtsOfContours[i];
                    const contour = points.slice(startPoint, endPoint + 1);
                    if (contour[0].flags & 1) {
                      contour.push(contour[0]);
                    } else if (contour.at(-1).flags & 1) {
                      contour.unshift(contour.at(-1));
                    } else {
                      const p = {
                        flags: 1,
                        x: (contour[0].x + contour.at(-1).x) / 2,
                        y: (contour[0].y + contour.at(-1).y) / 2
                      };
                      contour.unshift(p);
                      contour.push(p);
                    }
                    moveTo(contour[0].x, contour[0].y);
                    for (j = 1, jj = contour.length; j < jj; j++) {
                      if (contour[j].flags & 1) {
                        lineTo(contour[j].x, contour[j].y);
                      } else if (contour[j + 1].flags & 1) {
                        quadraticCurveTo(contour[j].x, contour[j].y, contour[j + 1].x, contour[j + 1].y);
                        j++;
                      } else {
                        quadraticCurveTo(contour[j].x, contour[j].y, (contour[j].x + contour[j + 1].x) / 2, (contour[j].y + contour[j + 1].y) / 2);
                      }
                    }
                    startPoint = endPoint + 1;
                  }
                }
              }
              function compileCharString(charStringCode, cmds, font, glyphId) {
                function moveTo(x2, y2) {
                  cmds.push({
                    cmd: "moveTo",
                    args: [x2, y2]
                  });
                }
                function lineTo(x2, y2) {
                  cmds.push({
                    cmd: "lineTo",
                    args: [x2, y2]
                  });
                }
                function bezierCurveTo(x1, y1, x2, y2, x3, y3) {
                  cmds.push({
                    cmd: "bezierCurveTo",
                    args: [x1, y1, x2, y2, x3, y3]
                  });
                }
                const stack = [];
                let x = 0, y = 0;
                let stems = 0;
                function parse(code) {
                  var _a;
                  let i = 0;
                  while (i < code.length) {
                    let stackClean = false;
                    let v = code[i++];
                    let xa, xb, ya, yb, y1, y2, y3, n, subrCode;
                    switch (v) {
                      case 1:
                        stems += stack.length >> 1;
                        stackClean = true;
                        break;
                      case 3:
                        stems += stack.length >> 1;
                        stackClean = true;
                        break;
                      case 4:
                        y += stack.pop();
                        moveTo(x, y);
                        stackClean = true;
                        break;
                      case 5:
                        while (stack.length > 0) {
                          x += stack.shift();
                          y += stack.shift();
                          lineTo(x, y);
                        }
                        break;
                      case 6:
                        while (stack.length > 0) {
                          x += stack.shift();
                          lineTo(x, y);
                          if (stack.length === 0) {
                            break;
                          }
                          y += stack.shift();
                          lineTo(x, y);
                        }
                        break;
                      case 7:
                        while (stack.length > 0) {
                          y += stack.shift();
                          lineTo(x, y);
                          if (stack.length === 0) {
                            break;
                          }
                          x += stack.shift();
                          lineTo(x, y);
                        }
                        break;
                      case 8:
                        while (stack.length > 0) {
                          xa = x + stack.shift();
                          ya = y + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb + stack.shift();
                          y = yb + stack.shift();
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        break;
                      case 10:
                        n = stack.pop();
                        subrCode = null;
                        if (font.isCFFCIDFont) {
                          const fdIndex = font.fdSelect.getFDIndex(glyphId);
                          if (fdIndex >= 0 && fdIndex < font.fdArray.length) {
                            const fontDict = font.fdArray[fdIndex];
                            let subrs;
                            if ((_a = fontDict.privateDict) == null ? void 0 : _a.subrsIndex) {
                              subrs = fontDict.privateDict.subrsIndex.objects;
                            }
                            if (subrs) {
                              n += getSubroutineBias(subrs);
                              subrCode = subrs[n];
                            }
                          } else {
                            (0, _util.warn)("Invalid fd index for glyph index.");
                          }
                        } else {
                          subrCode = font.subrs[n + font.subrsBias];
                        }
                        if (subrCode) {
                          parse(subrCode);
                        }
                        break;
                      case 11:
                        return;
                      case 12:
                        v = code[i++];
                        switch (v) {
                          case 34:
                            xa = x + stack.shift();
                            xb = xa + stack.shift();
                            y1 = y + stack.shift();
                            x = xb + stack.shift();
                            bezierCurveTo(xa, y, xb, y1, x, y1);
                            xa = x + stack.shift();
                            xb = xa + stack.shift();
                            x = xb + stack.shift();
                            bezierCurveTo(xa, y1, xb, y, x, y);
                            break;
                          case 35:
                            xa = x + stack.shift();
                            ya = y + stack.shift();
                            xb = xa + stack.shift();
                            yb = ya + stack.shift();
                            x = xb + stack.shift();
                            y = yb + stack.shift();
                            bezierCurveTo(xa, ya, xb, yb, x, y);
                            xa = x + stack.shift();
                            ya = y + stack.shift();
                            xb = xa + stack.shift();
                            yb = ya + stack.shift();
                            x = xb + stack.shift();
                            y = yb + stack.shift();
                            bezierCurveTo(xa, ya, xb, yb, x, y);
                            stack.pop();
                            break;
                          case 36:
                            xa = x + stack.shift();
                            y1 = y + stack.shift();
                            xb = xa + stack.shift();
                            y2 = y1 + stack.shift();
                            x = xb + stack.shift();
                            bezierCurveTo(xa, y1, xb, y2, x, y2);
                            xa = x + stack.shift();
                            xb = xa + stack.shift();
                            y3 = y2 + stack.shift();
                            x = xb + stack.shift();
                            bezierCurveTo(xa, y2, xb, y3, x, y);
                            break;
                          case 37:
                            const x0 = x, y0 = y;
                            xa = x + stack.shift();
                            ya = y + stack.shift();
                            xb = xa + stack.shift();
                            yb = ya + stack.shift();
                            x = xb + stack.shift();
                            y = yb + stack.shift();
                            bezierCurveTo(xa, ya, xb, yb, x, y);
                            xa = x + stack.shift();
                            ya = y + stack.shift();
                            xb = xa + stack.shift();
                            yb = ya + stack.shift();
                            x = xb;
                            y = yb;
                            if (Math.abs(x - x0) > Math.abs(y - y0)) {
                              x += stack.shift();
                            } else {
                              y += stack.shift();
                            }
                            bezierCurveTo(xa, ya, xb, yb, x, y);
                            break;
                          default:
                            throw new _util.FormatError(`unknown operator: 12 ${v}`);
                        }
                        break;
                      case 14:
                        if (stack.length >= 4) {
                          const achar = stack.pop();
                          const bchar = stack.pop();
                          y = stack.pop();
                          x = stack.pop();
                          cmds.push({
                            cmd: "save"
                          }, {
                            cmd: "translate",
                            args: [x, y]
                          });
                          let cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[achar]]));
                          compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
                          cmds.push({
                            cmd: "restore"
                          });
                          cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[bchar]]));
                          compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
                        }
                        return;
                      case 18:
                        stems += stack.length >> 1;
                        stackClean = true;
                        break;
                      case 19:
                        stems += stack.length >> 1;
                        i += stems + 7 >> 3;
                        stackClean = true;
                        break;
                      case 20:
                        stems += stack.length >> 1;
                        i += stems + 7 >> 3;
                        stackClean = true;
                        break;
                      case 21:
                        y += stack.pop();
                        x += stack.pop();
                        moveTo(x, y);
                        stackClean = true;
                        break;
                      case 22:
                        x += stack.pop();
                        moveTo(x, y);
                        stackClean = true;
                        break;
                      case 23:
                        stems += stack.length >> 1;
                        stackClean = true;
                        break;
                      case 24:
                        while (stack.length > 2) {
                          xa = x + stack.shift();
                          ya = y + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb + stack.shift();
                          y = yb + stack.shift();
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        x += stack.shift();
                        y += stack.shift();
                        lineTo(x, y);
                        break;
                      case 25:
                        while (stack.length > 6) {
                          x += stack.shift();
                          y += stack.shift();
                          lineTo(x, y);
                        }
                        xa = x + stack.shift();
                        ya = y + stack.shift();
                        xb = xa + stack.shift();
                        yb = ya + stack.shift();
                        x = xb + stack.shift();
                        y = yb + stack.shift();
                        bezierCurveTo(xa, ya, xb, yb, x, y);
                        break;
                      case 26:
                        if (stack.length % 2) {
                          x += stack.shift();
                        }
                        while (stack.length > 0) {
                          xa = x;
                          ya = y + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb;
                          y = yb + stack.shift();
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        break;
                      case 27:
                        if (stack.length % 2) {
                          y += stack.shift();
                        }
                        while (stack.length > 0) {
                          xa = x + stack.shift();
                          ya = y;
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb + stack.shift();
                          y = yb;
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        break;
                      case 28:
                        stack.push((code[i] << 24 | code[i + 1] << 16) >> 16);
                        i += 2;
                        break;
                      case 29:
                        n = stack.pop() + font.gsubrsBias;
                        subrCode = font.gsubrs[n];
                        if (subrCode) {
                          parse(subrCode);
                        }
                        break;
                      case 30:
                        while (stack.length > 0) {
                          xa = x;
                          ya = y + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb + stack.shift();
                          y = yb + (stack.length === 1 ? stack.shift() : 0);
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                          if (stack.length === 0) {
                            break;
                          }
                          xa = x + stack.shift();
                          ya = y;
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          y = yb + stack.shift();
                          x = xb + (stack.length === 1 ? stack.shift() : 0);
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        break;
                      case 31:
                        while (stack.length > 0) {
                          xa = x + stack.shift();
                          ya = y;
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          y = yb + stack.shift();
                          x = xb + (stack.length === 1 ? stack.shift() : 0);
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                          if (stack.length === 0) {
                            break;
                          }
                          xa = x;
                          ya = y + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb + stack.shift();
                          y = yb + (stack.length === 1 ? stack.shift() : 0);
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        break;
                      default:
                        if (v < 32) {
                          throw new _util.FormatError(`unknown operator: ${v}`);
                        }
                        if (v < 247) {
                          stack.push(v - 139);
                        } else if (v < 251) {
                          stack.push((v - 247) * 256 + code[i++] + 108);
                        } else if (v < 255) {
                          stack.push(-(v - 251) * 256 - code[i++] - 108);
                        } else {
                          stack.push((code[i] << 24 | code[i + 1] << 16 | code[i + 2] << 8 | code[i + 3]) / 65536);
                          i += 4;
                        }
                        break;
                    }
                    if (stackClean) {
                      stack.length = 0;
                    }
                  }
                }
                parse(charStringCode);
              }
              const NOOP = [];
              class CompiledFont {
                constructor(fontMatrix) {
                  if (this.constructor === CompiledFont) {
                    (0, _util.unreachable)("Cannot initialize CompiledFont.");
                  }
                  this.fontMatrix = fontMatrix;
                  this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                  this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
                }
                getPathJs(unicode) {
                  const {
                    charCode,
                    glyphId
                  } = lookupCmap(this.cmap, unicode);
                  let fn = this.compiledGlyphs[glyphId];
                  if (!fn) {
                    try {
                      fn = this.compileGlyph(this.glyphs[glyphId], glyphId);
                      this.compiledGlyphs[glyphId] = fn;
                    } catch (ex) {
                      this.compiledGlyphs[glyphId] = NOOP;
                      if (this.compiledCharCodeToGlyphId[charCode] === void 0) {
                        this.compiledCharCodeToGlyphId[charCode] = glyphId;
                      }
                      throw ex;
                    }
                  }
                  if (this.compiledCharCodeToGlyphId[charCode] === void 0) {
                    this.compiledCharCodeToGlyphId[charCode] = glyphId;
                  }
                  return fn;
                }
                compileGlyph(code, glyphId) {
                  if (!code || code.length === 0 || code[0] === 14) {
                    return NOOP;
                  }
                  let fontMatrix = this.fontMatrix;
                  if (this.isCFFCIDFont) {
                    const fdIndex = this.fdSelect.getFDIndex(glyphId);
                    if (fdIndex >= 0 && fdIndex < this.fdArray.length) {
                      const fontDict = this.fdArray[fdIndex];
                      fontMatrix = fontDict.getByName("FontMatrix") || _util.FONT_IDENTITY_MATRIX;
                    } else {
                      (0, _util.warn)("Invalid fd index for glyph index.");
                    }
                  }
                  const cmds = [{
                    cmd: "save"
                  }, {
                    cmd: "transform",
                    args: fontMatrix.slice()
                  }, {
                    cmd: "scale",
                    args: ["size", "-size"]
                  }];
                  this.compileGlyphImpl(code, cmds, glyphId);
                  cmds.push({
                    cmd: "restore"
                  });
                  return cmds;
                }
                compileGlyphImpl() {
                  (0, _util.unreachable)("Children classes should implement this.");
                }
                hasBuiltPath(unicode) {
                  const {
                    charCode,
                    glyphId
                  } = lookupCmap(this.cmap, unicode);
                  return this.compiledGlyphs[glyphId] !== void 0 && this.compiledCharCodeToGlyphId[charCode] !== void 0;
                }
              }
              class TrueTypeCompiled extends CompiledFont {
                constructor(glyphs, cmap, fontMatrix) {
                  super(fontMatrix || [488e-6, 0, 0, 488e-6, 0, 0]);
                  this.glyphs = glyphs;
                  this.cmap = cmap;
                }
                compileGlyphImpl(code, cmds) {
                  compileGlyf(code, cmds, this);
                }
              }
              class Type2Compiled extends CompiledFont {
                constructor(cffInfo, cmap, fontMatrix, glyphNameMap) {
                  super(fontMatrix || [1e-3, 0, 0, 1e-3, 0, 0]);
                  this.glyphs = cffInfo.glyphs;
                  this.gsubrs = cffInfo.gsubrs || [];
                  this.subrs = cffInfo.subrs || [];
                  this.cmap = cmap;
                  this.glyphNameMap = glyphNameMap || (0, _glyphlist.getGlyphsUnicode)();
                  this.gsubrsBias = getSubroutineBias(this.gsubrs);
                  this.subrsBias = getSubroutineBias(this.subrs);
                  this.isCFFCIDFont = cffInfo.isCFFCIDFont;
                  this.fdSelect = cffInfo.fdSelect;
                  this.fdArray = cffInfo.fdArray;
                }
                compileGlyphImpl(code, cmds, glyphId) {
                  compileCharString(code, cmds, this, glyphId);
                }
              }
              class FontRendererFactory {
                static create(font, seacAnalysisEnabled) {
                  const data = new Uint8Array(font.data);
                  let cmap, glyf, loca, cff, indexToLocFormat, unitsPerEm;
                  const numTables = getUint16(data, 4);
                  for (let i = 0, p = 12; i < numTables; i++, p += 16) {
                    const tag = (0, _util.bytesToString)(data.subarray(p, p + 4));
                    const offset = getUint32(data, p + 8);
                    const length = getUint32(data, p + 12);
                    switch (tag) {
                      case "cmap":
                        cmap = parseCmap(data, offset, offset + length);
                        break;
                      case "glyf":
                        glyf = data.subarray(offset, offset + length);
                        break;
                      case "loca":
                        loca = data.subarray(offset, offset + length);
                        break;
                      case "head":
                        unitsPerEm = getUint16(data, offset + 18);
                        indexToLocFormat = getUint16(data, offset + 50);
                        break;
                      case "CFF ":
                        cff = parseCff(data, offset, offset + length, seacAnalysisEnabled);
                        break;
                    }
                  }
                  if (glyf) {
                    const fontMatrix = !unitsPerEm ? font.fontMatrix : [1 / unitsPerEm, 0, 0, 1 / unitsPerEm, 0, 0];
                    return new TrueTypeCompiled(parseGlyfTable(glyf, loca, indexToLocFormat), cmap, fontMatrix);
                  }
                  return new Type2Compiled(cff, cmap, font.fontMatrix, font.glyphNameMap);
                }
              }
              exports2.FontRendererFactory = FontRendererFactory;
            },
            /* 45 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.getMetrics = exports2.getFontBasicMetrics = void 0;
              var _core_utils = __w_pdfjs_require__2(3);
              const getMetrics = (0, _core_utils.getLookupTableFactory)(function(t) {
                t.Courier = 600;
                t["Courier-Bold"] = 600;
                t["Courier-BoldOblique"] = 600;
                t["Courier-Oblique"] = 600;
                t.Helvetica = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 278;
                  t2.exclam = 278;
                  t2.quotedbl = 355;
                  t2.numbersign = 556;
                  t2.dollar = 556;
                  t2.percent = 889;
                  t2.ampersand = 667;
                  t2.quoteright = 222;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asterisk = 389;
                  t2.plus = 584;
                  t2.comma = 278;
                  t2.hyphen = 333;
                  t2.period = 278;
                  t2.slash = 278;
                  t2.zero = 556;
                  t2.one = 556;
                  t2.two = 556;
                  t2.three = 556;
                  t2.four = 556;
                  t2.five = 556;
                  t2.six = 556;
                  t2.seven = 556;
                  t2.eight = 556;
                  t2.nine = 556;
                  t2.colon = 278;
                  t2.semicolon = 278;
                  t2.less = 584;
                  t2.equal = 584;
                  t2.greater = 584;
                  t2.question = 556;
                  t2.at = 1015;
                  t2.A = 667;
                  t2.B = 667;
                  t2.C = 722;
                  t2.D = 722;
                  t2.E = 667;
                  t2.F = 611;
                  t2.G = 778;
                  t2.H = 722;
                  t2.I = 278;
                  t2.J = 500;
                  t2.K = 667;
                  t2.L = 556;
                  t2.M = 833;
                  t2.N = 722;
                  t2.O = 778;
                  t2.P = 667;
                  t2.Q = 778;
                  t2.R = 722;
                  t2.S = 667;
                  t2.T = 611;
                  t2.U = 722;
                  t2.V = 667;
                  t2.W = 944;
                  t2.X = 667;
                  t2.Y = 667;
                  t2.Z = 611;
                  t2.bracketleft = 278;
                  t2.backslash = 278;
                  t2.bracketright = 278;
                  t2.asciicircum = 469;
                  t2.underscore = 556;
                  t2.quoteleft = 222;
                  t2.a = 556;
                  t2.b = 556;
                  t2.c = 500;
                  t2.d = 556;
                  t2.e = 556;
                  t2.f = 278;
                  t2.g = 556;
                  t2.h = 556;
                  t2.i = 222;
                  t2.j = 222;
                  t2.k = 500;
                  t2.l = 222;
                  t2.m = 833;
                  t2.n = 556;
                  t2.o = 556;
                  t2.p = 556;
                  t2.q = 556;
                  t2.r = 333;
                  t2.s = 500;
                  t2.t = 278;
                  t2.u = 556;
                  t2.v = 500;
                  t2.w = 722;
                  t2.x = 500;
                  t2.y = 500;
                  t2.z = 500;
                  t2.braceleft = 334;
                  t2.bar = 260;
                  t2.braceright = 334;
                  t2.asciitilde = 584;
                  t2.exclamdown = 333;
                  t2.cent = 556;
                  t2.sterling = 556;
                  t2.fraction = 167;
                  t2.yen = 556;
                  t2.florin = 556;
                  t2.section = 556;
                  t2.currency = 556;
                  t2.quotesingle = 191;
                  t2.quotedblleft = 333;
                  t2.guillemotleft = 556;
                  t2.guilsinglleft = 333;
                  t2.guilsinglright = 333;
                  t2.fi = 500;
                  t2.fl = 500;
                  t2.endash = 556;
                  t2.dagger = 556;
                  t2.daggerdbl = 556;
                  t2.periodcentered = 278;
                  t2.paragraph = 537;
                  t2.bullet = 350;
                  t2.quotesinglbase = 222;
                  t2.quotedblbase = 333;
                  t2.quotedblright = 333;
                  t2.guillemotright = 556;
                  t2.ellipsis = 1e3;
                  t2.perthousand = 1e3;
                  t2.questiondown = 611;
                  t2.grave = 333;
                  t2.acute = 333;
                  t2.circumflex = 333;
                  t2.tilde = 333;
                  t2.macron = 333;
                  t2.breve = 333;
                  t2.dotaccent = 333;
                  t2.dieresis = 333;
                  t2.ring = 333;
                  t2.cedilla = 333;
                  t2.hungarumlaut = 333;
                  t2.ogonek = 333;
                  t2.caron = 333;
                  t2.emdash = 1e3;
                  t2.AE = 1e3;
                  t2.ordfeminine = 370;
                  t2.Lslash = 556;
                  t2.Oslash = 778;
                  t2.OE = 1e3;
                  t2.ordmasculine = 365;
                  t2.ae = 889;
                  t2.dotlessi = 278;
                  t2.lslash = 222;
                  t2.oslash = 611;
                  t2.oe = 944;
                  t2.germandbls = 611;
                  t2.Idieresis = 278;
                  t2.eacute = 556;
                  t2.abreve = 556;
                  t2.uhungarumlaut = 556;
                  t2.ecaron = 556;
                  t2.Ydieresis = 667;
                  t2.divide = 584;
                  t2.Yacute = 667;
                  t2.Acircumflex = 667;
                  t2.aacute = 556;
                  t2.Ucircumflex = 722;
                  t2.yacute = 500;
                  t2.scommaaccent = 500;
                  t2.ecircumflex = 556;
                  t2.Uring = 722;
                  t2.Udieresis = 722;
                  t2.aogonek = 556;
                  t2.Uacute = 722;
                  t2.uogonek = 556;
                  t2.Edieresis = 667;
                  t2.Dcroat = 722;
                  t2.commaaccent = 250;
                  t2.copyright = 737;
                  t2.Emacron = 667;
                  t2.ccaron = 500;
                  t2.aring = 556;
                  t2.Ncommaaccent = 722;
                  t2.lacute = 222;
                  t2.agrave = 556;
                  t2.Tcommaaccent = 611;
                  t2.Cacute = 722;
                  t2.atilde = 556;
                  t2.Edotaccent = 667;
                  t2.scaron = 500;
                  t2.scedilla = 500;
                  t2.iacute = 278;
                  t2.lozenge = 471;
                  t2.Rcaron = 722;
                  t2.Gcommaaccent = 778;
                  t2.ucircumflex = 556;
                  t2.acircumflex = 556;
                  t2.Amacron = 667;
                  t2.rcaron = 333;
                  t2.ccedilla = 500;
                  t2.Zdotaccent = 611;
                  t2.Thorn = 667;
                  t2.Omacron = 778;
                  t2.Racute = 722;
                  t2.Sacute = 667;
                  t2.dcaron = 643;
                  t2.Umacron = 722;
                  t2.uring = 556;
                  t2.threesuperior = 333;
                  t2.Ograve = 778;
                  t2.Agrave = 667;
                  t2.Abreve = 667;
                  t2.multiply = 584;
                  t2.uacute = 556;
                  t2.Tcaron = 611;
                  t2.partialdiff = 476;
                  t2.ydieresis = 500;
                  t2.Nacute = 722;
                  t2.icircumflex = 278;
                  t2.Ecircumflex = 667;
                  t2.adieresis = 556;
                  t2.edieresis = 556;
                  t2.cacute = 500;
                  t2.nacute = 556;
                  t2.umacron = 556;
                  t2.Ncaron = 722;
                  t2.Iacute = 278;
                  t2.plusminus = 584;
                  t2.brokenbar = 260;
                  t2.registered = 737;
                  t2.Gbreve = 778;
                  t2.Idotaccent = 278;
                  t2.summation = 600;
                  t2.Egrave = 667;
                  t2.racute = 333;
                  t2.omacron = 556;
                  t2.Zacute = 611;
                  t2.Zcaron = 611;
                  t2.greaterequal = 549;
                  t2.Eth = 722;
                  t2.Ccedilla = 722;
                  t2.lcommaaccent = 222;
                  t2.tcaron = 317;
                  t2.eogonek = 556;
                  t2.Uogonek = 722;
                  t2.Aacute = 667;
                  t2.Adieresis = 667;
                  t2.egrave = 556;
                  t2.zacute = 500;
                  t2.iogonek = 222;
                  t2.Oacute = 778;
                  t2.oacute = 556;
                  t2.amacron = 556;
                  t2.sacute = 500;
                  t2.idieresis = 278;
                  t2.Ocircumflex = 778;
                  t2.Ugrave = 722;
                  t2.Delta = 612;
                  t2.thorn = 556;
                  t2.twosuperior = 333;
                  t2.Odieresis = 778;
                  t2.mu = 556;
                  t2.igrave = 278;
                  t2.ohungarumlaut = 556;
                  t2.Eogonek = 667;
                  t2.dcroat = 556;
                  t2.threequarters = 834;
                  t2.Scedilla = 667;
                  t2.lcaron = 299;
                  t2.Kcommaaccent = 667;
                  t2.Lacute = 556;
                  t2.trademark = 1e3;
                  t2.edotaccent = 556;
                  t2.Igrave = 278;
                  t2.Imacron = 278;
                  t2.Lcaron = 556;
                  t2.onehalf = 834;
                  t2.lessequal = 549;
                  t2.ocircumflex = 556;
                  t2.ntilde = 556;
                  t2.Uhungarumlaut = 722;
                  t2.Eacute = 667;
                  t2.emacron = 556;
                  t2.gbreve = 556;
                  t2.onequarter = 834;
                  t2.Scaron = 667;
                  t2.Scommaaccent = 667;
                  t2.Ohungarumlaut = 778;
                  t2.degree = 400;
                  t2.ograve = 556;
                  t2.Ccaron = 722;
                  t2.ugrave = 556;
                  t2.radical = 453;
                  t2.Dcaron = 722;
                  t2.rcommaaccent = 333;
                  t2.Ntilde = 722;
                  t2.otilde = 556;
                  t2.Rcommaaccent = 722;
                  t2.Lcommaaccent = 556;
                  t2.Atilde = 667;
                  t2.Aogonek = 667;
                  t2.Aring = 667;
                  t2.Otilde = 778;
                  t2.zdotaccent = 500;
                  t2.Ecaron = 667;
                  t2.Iogonek = 278;
                  t2.kcommaaccent = 500;
                  t2.minus = 584;
                  t2.Icircumflex = 278;
                  t2.ncaron = 556;
                  t2.tcommaaccent = 278;
                  t2.logicalnot = 584;
                  t2.odieresis = 556;
                  t2.udieresis = 556;
                  t2.notequal = 549;
                  t2.gcommaaccent = 556;
                  t2.eth = 556;
                  t2.zcaron = 500;
                  t2.ncommaaccent = 556;
                  t2.onesuperior = 333;
                  t2.imacron = 278;
                  t2.Euro = 556;
                });
                t["Helvetica-Bold"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 278;
                  t2.exclam = 333;
                  t2.quotedbl = 474;
                  t2.numbersign = 556;
                  t2.dollar = 556;
                  t2.percent = 889;
                  t2.ampersand = 722;
                  t2.quoteright = 278;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asterisk = 389;
                  t2.plus = 584;
                  t2.comma = 278;
                  t2.hyphen = 333;
                  t2.period = 278;
                  t2.slash = 278;
                  t2.zero = 556;
                  t2.one = 556;
                  t2.two = 556;
                  t2.three = 556;
                  t2.four = 556;
                  t2.five = 556;
                  t2.six = 556;
                  t2.seven = 556;
                  t2.eight = 556;
                  t2.nine = 556;
                  t2.colon = 333;
                  t2.semicolon = 333;
                  t2.less = 584;
                  t2.equal = 584;
                  t2.greater = 584;
                  t2.question = 611;
                  t2.at = 975;
                  t2.A = 722;
                  t2.B = 722;
                  t2.C = 722;
                  t2.D = 722;
                  t2.E = 667;
                  t2.F = 611;
                  t2.G = 778;
                  t2.H = 722;
                  t2.I = 278;
                  t2.J = 556;
                  t2.K = 722;
                  t2.L = 611;
                  t2.M = 833;
                  t2.N = 722;
                  t2.O = 778;
                  t2.P = 667;
                  t2.Q = 778;
                  t2.R = 722;
                  t2.S = 667;
                  t2.T = 611;
                  t2.U = 722;
                  t2.V = 667;
                  t2.W = 944;
                  t2.X = 667;
                  t2.Y = 667;
                  t2.Z = 611;
                  t2.bracketleft = 333;
                  t2.backslash = 278;
                  t2.bracketright = 333;
                  t2.asciicircum = 584;
                  t2.underscore = 556;
                  t2.quoteleft = 278;
                  t2.a = 556;
                  t2.b = 611;
                  t2.c = 556;
                  t2.d = 611;
                  t2.e = 556;
                  t2.f = 333;
                  t2.g = 611;
                  t2.h = 611;
                  t2.i = 278;
                  t2.j = 278;
                  t2.k = 556;
                  t2.l = 278;
                  t2.m = 889;
                  t2.n = 611;
                  t2.o = 611;
                  t2.p = 611;
                  t2.q = 611;
                  t2.r = 389;
                  t2.s = 556;
                  t2.t = 333;
                  t2.u = 611;
                  t2.v = 556;
                  t2.w = 778;
                  t2.x = 556;
                  t2.y = 556;
                  t2.z = 500;
                  t2.braceleft = 389;
                  t2.bar = 280;
                  t2.braceright = 389;
                  t2.asciitilde = 584;
                  t2.exclamdown = 333;
                  t2.cent = 556;
                  t2.sterling = 556;
                  t2.fraction = 167;
                  t2.yen = 556;
                  t2.florin = 556;
                  t2.section = 556;
                  t2.currency = 556;
                  t2.quotesingle = 238;
                  t2.quotedblleft = 500;
                  t2.guillemotleft = 556;
                  t2.guilsinglleft = 333;
                  t2.guilsinglright = 333;
                  t2.fi = 611;
                  t2.fl = 611;
                  t2.endash = 556;
                  t2.dagger = 556;
                  t2.daggerdbl = 556;
                  t2.periodcentered = 278;
                  t2.paragraph = 556;
                  t2.bullet = 350;
                  t2.quotesinglbase = 278;
                  t2.quotedblbase = 500;
                  t2.quotedblright = 500;
                  t2.guillemotright = 556;
                  t2.ellipsis = 1e3;
                  t2.perthousand = 1e3;
                  t2.questiondown = 611;
                  t2.grave = 333;
                  t2.acute = 333;
                  t2.circumflex = 333;
                  t2.tilde = 333;
                  t2.macron = 333;
                  t2.breve = 333;
                  t2.dotaccent = 333;
                  t2.dieresis = 333;
                  t2.ring = 333;
                  t2.cedilla = 333;
                  t2.hungarumlaut = 333;
                  t2.ogonek = 333;
                  t2.caron = 333;
                  t2.emdash = 1e3;
                  t2.AE = 1e3;
                  t2.ordfeminine = 370;
                  t2.Lslash = 611;
                  t2.Oslash = 778;
                  t2.OE = 1e3;
                  t2.ordmasculine = 365;
                  t2.ae = 889;
                  t2.dotlessi = 278;
                  t2.lslash = 278;
                  t2.oslash = 611;
                  t2.oe = 944;
                  t2.germandbls = 611;
                  t2.Idieresis = 278;
                  t2.eacute = 556;
                  t2.abreve = 556;
                  t2.uhungarumlaut = 611;
                  t2.ecaron = 556;
                  t2.Ydieresis = 667;
                  t2.divide = 584;
                  t2.Yacute = 667;
                  t2.Acircumflex = 722;
                  t2.aacute = 556;
                  t2.Ucircumflex = 722;
                  t2.yacute = 556;
                  t2.scommaaccent = 556;
                  t2.ecircumflex = 556;
                  t2.Uring = 722;
                  t2.Udieresis = 722;
                  t2.aogonek = 556;
                  t2.Uacute = 722;
                  t2.uogonek = 611;
                  t2.Edieresis = 667;
                  t2.Dcroat = 722;
                  t2.commaaccent = 250;
                  t2.copyright = 737;
                  t2.Emacron = 667;
                  t2.ccaron = 556;
                  t2.aring = 556;
                  t2.Ncommaaccent = 722;
                  t2.lacute = 278;
                  t2.agrave = 556;
                  t2.Tcommaaccent = 611;
                  t2.Cacute = 722;
                  t2.atilde = 556;
                  t2.Edotaccent = 667;
                  t2.scaron = 556;
                  t2.scedilla = 556;
                  t2.iacute = 278;
                  t2.lozenge = 494;
                  t2.Rcaron = 722;
                  t2.Gcommaaccent = 778;
                  t2.ucircumflex = 611;
                  t2.acircumflex = 556;
                  t2.Amacron = 722;
                  t2.rcaron = 389;
                  t2.ccedilla = 556;
                  t2.Zdotaccent = 611;
                  t2.Thorn = 667;
                  t2.Omacron = 778;
                  t2.Racute = 722;
                  t2.Sacute = 667;
                  t2.dcaron = 743;
                  t2.Umacron = 722;
                  t2.uring = 611;
                  t2.threesuperior = 333;
                  t2.Ograve = 778;
                  t2.Agrave = 722;
                  t2.Abreve = 722;
                  t2.multiply = 584;
                  t2.uacute = 611;
                  t2.Tcaron = 611;
                  t2.partialdiff = 494;
                  t2.ydieresis = 556;
                  t2.Nacute = 722;
                  t2.icircumflex = 278;
                  t2.Ecircumflex = 667;
                  t2.adieresis = 556;
                  t2.edieresis = 556;
                  t2.cacute = 556;
                  t2.nacute = 611;
                  t2.umacron = 611;
                  t2.Ncaron = 722;
                  t2.Iacute = 278;
                  t2.plusminus = 584;
                  t2.brokenbar = 280;
                  t2.registered = 737;
                  t2.Gbreve = 778;
                  t2.Idotaccent = 278;
                  t2.summation = 600;
                  t2.Egrave = 667;
                  t2.racute = 389;
                  t2.omacron = 611;
                  t2.Zacute = 611;
                  t2.Zcaron = 611;
                  t2.greaterequal = 549;
                  t2.Eth = 722;
                  t2.Ccedilla = 722;
                  t2.lcommaaccent = 278;
                  t2.tcaron = 389;
                  t2.eogonek = 556;
                  t2.Uogonek = 722;
                  t2.Aacute = 722;
                  t2.Adieresis = 722;
                  t2.egrave = 556;
                  t2.zacute = 500;
                  t2.iogonek = 278;
                  t2.Oacute = 778;
                  t2.oacute = 611;
                  t2.amacron = 556;
                  t2.sacute = 556;
                  t2.idieresis = 278;
                  t2.Ocircumflex = 778;
                  t2.Ugrave = 722;
                  t2.Delta = 612;
                  t2.thorn = 611;
                  t2.twosuperior = 333;
                  t2.Odieresis = 778;
                  t2.mu = 611;
                  t2.igrave = 278;
                  t2.ohungarumlaut = 611;
                  t2.Eogonek = 667;
                  t2.dcroat = 611;
                  t2.threequarters = 834;
                  t2.Scedilla = 667;
                  t2.lcaron = 400;
                  t2.Kcommaaccent = 722;
                  t2.Lacute = 611;
                  t2.trademark = 1e3;
                  t2.edotaccent = 556;
                  t2.Igrave = 278;
                  t2.Imacron = 278;
                  t2.Lcaron = 611;
                  t2.onehalf = 834;
                  t2.lessequal = 549;
                  t2.ocircumflex = 611;
                  t2.ntilde = 611;
                  t2.Uhungarumlaut = 722;
                  t2.Eacute = 667;
                  t2.emacron = 556;
                  t2.gbreve = 611;
                  t2.onequarter = 834;
                  t2.Scaron = 667;
                  t2.Scommaaccent = 667;
                  t2.Ohungarumlaut = 778;
                  t2.degree = 400;
                  t2.ograve = 611;
                  t2.Ccaron = 722;
                  t2.ugrave = 611;
                  t2.radical = 549;
                  t2.Dcaron = 722;
                  t2.rcommaaccent = 389;
                  t2.Ntilde = 722;
                  t2.otilde = 611;
                  t2.Rcommaaccent = 722;
                  t2.Lcommaaccent = 611;
                  t2.Atilde = 722;
                  t2.Aogonek = 722;
                  t2.Aring = 722;
                  t2.Otilde = 778;
                  t2.zdotaccent = 500;
                  t2.Ecaron = 667;
                  t2.Iogonek = 278;
                  t2.kcommaaccent = 556;
                  t2.minus = 584;
                  t2.Icircumflex = 278;
                  t2.ncaron = 611;
                  t2.tcommaaccent = 333;
                  t2.logicalnot = 584;
                  t2.odieresis = 611;
                  t2.udieresis = 611;
                  t2.notequal = 549;
                  t2.gcommaaccent = 611;
                  t2.eth = 611;
                  t2.zcaron = 500;
                  t2.ncommaaccent = 611;
                  t2.onesuperior = 333;
                  t2.imacron = 278;
                  t2.Euro = 556;
                });
                t["Helvetica-BoldOblique"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 278;
                  t2.exclam = 333;
                  t2.quotedbl = 474;
                  t2.numbersign = 556;
                  t2.dollar = 556;
                  t2.percent = 889;
                  t2.ampersand = 722;
                  t2.quoteright = 278;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asterisk = 389;
                  t2.plus = 584;
                  t2.comma = 278;
                  t2.hyphen = 333;
                  t2.period = 278;
                  t2.slash = 278;
                  t2.zero = 556;
                  t2.one = 556;
                  t2.two = 556;
                  t2.three = 556;
                  t2.four = 556;
                  t2.five = 556;
                  t2.six = 556;
                  t2.seven = 556;
                  t2.eight = 556;
                  t2.nine = 556;
                  t2.colon = 333;
                  t2.semicolon = 333;
                  t2.less = 584;
                  t2.equal = 584;
                  t2.greater = 584;
                  t2.question = 611;
                  t2.at = 975;
                  t2.A = 722;
                  t2.B = 722;
                  t2.C = 722;
                  t2.D = 722;
                  t2.E = 667;
                  t2.F = 611;
                  t2.G = 778;
                  t2.H = 722;
                  t2.I = 278;
                  t2.J = 556;
                  t2.K = 722;
                  t2.L = 611;
                  t2.M = 833;
                  t2.N = 722;
                  t2.O = 778;
                  t2.P = 667;
                  t2.Q = 778;
                  t2.R = 722;
                  t2.S = 667;
                  t2.T = 611;
                  t2.U = 722;
                  t2.V = 667;
                  t2.W = 944;
                  t2.X = 667;
                  t2.Y = 667;
                  t2.Z = 611;
                  t2.bracketleft = 333;
                  t2.backslash = 278;
                  t2.bracketright = 333;
                  t2.asciicircum = 584;
                  t2.underscore = 556;
                  t2.quoteleft = 278;
                  t2.a = 556;
                  t2.b = 611;
                  t2.c = 556;
                  t2.d = 611;
                  t2.e = 556;
                  t2.f = 333;
                  t2.g = 611;
                  t2.h = 611;
                  t2.i = 278;
                  t2.j = 278;
                  t2.k = 556;
                  t2.l = 278;
                  t2.m = 889;
                  t2.n = 611;
                  t2.o = 611;
                  t2.p = 611;
                  t2.q = 611;
                  t2.r = 389;
                  t2.s = 556;
                  t2.t = 333;
                  t2.u = 611;
                  t2.v = 556;
                  t2.w = 778;
                  t2.x = 556;
                  t2.y = 556;
                  t2.z = 500;
                  t2.braceleft = 389;
                  t2.bar = 280;
                  t2.braceright = 389;
                  t2.asciitilde = 584;
                  t2.exclamdown = 333;
                  t2.cent = 556;
                  t2.sterling = 556;
                  t2.fraction = 167;
                  t2.yen = 556;
                  t2.florin = 556;
                  t2.section = 556;
                  t2.currency = 556;
                  t2.quotesingle = 238;
                  t2.quotedblleft = 500;
                  t2.guillemotleft = 556;
                  t2.guilsinglleft = 333;
                  t2.guilsinglright = 333;
                  t2.fi = 611;
                  t2.fl = 611;
                  t2.endash = 556;
                  t2.dagger = 556;
                  t2.daggerdbl = 556;
                  t2.periodcentered = 278;
                  t2.paragraph = 556;
                  t2.bullet = 350;
                  t2.quotesinglbase = 278;
                  t2.quotedblbase = 500;
                  t2.quotedblright = 500;
                  t2.guillemotright = 556;
                  t2.ellipsis = 1e3;
                  t2.perthousand = 1e3;
                  t2.questiondown = 611;
                  t2.grave = 333;
                  t2.acute = 333;
                  t2.circumflex = 333;
                  t2.tilde = 333;
                  t2.macron = 333;
                  t2.breve = 333;
                  t2.dotaccent = 333;
                  t2.dieresis = 333;
                  t2.ring = 333;
                  t2.cedilla = 333;
                  t2.hungarumlaut = 333;
                  t2.ogonek = 333;
                  t2.caron = 333;
                  t2.emdash = 1e3;
                  t2.AE = 1e3;
                  t2.ordfeminine = 370;
                  t2.Lslash = 611;
                  t2.Oslash = 778;
                  t2.OE = 1e3;
                  t2.ordmasculine = 365;
                  t2.ae = 889;
                  t2.dotlessi = 278;
                  t2.lslash = 278;
                  t2.oslash = 611;
                  t2.oe = 944;
                  t2.germandbls = 611;
                  t2.Idieresis = 278;
                  t2.eacute = 556;
                  t2.abreve = 556;
                  t2.uhungarumlaut = 611;
                  t2.ecaron = 556;
                  t2.Ydieresis = 667;
                  t2.divide = 584;
                  t2.Yacute = 667;
                  t2.Acircumflex = 722;
                  t2.aacute = 556;
                  t2.Ucircumflex = 722;
                  t2.yacute = 556;
                  t2.scommaaccent = 556;
                  t2.ecircumflex = 556;
                  t2.Uring = 722;
                  t2.Udieresis = 722;
                  t2.aogonek = 556;
                  t2.Uacute = 722;
                  t2.uogonek = 611;
                  t2.Edieresis = 667;
                  t2.Dcroat = 722;
                  t2.commaaccent = 250;
                  t2.copyright = 737;
                  t2.Emacron = 667;
                  t2.ccaron = 556;
                  t2.aring = 556;
                  t2.Ncommaaccent = 722;
                  t2.lacute = 278;
                  t2.agrave = 556;
                  t2.Tcommaaccent = 611;
                  t2.Cacute = 722;
                  t2.atilde = 556;
                  t2.Edotaccent = 667;
                  t2.scaron = 556;
                  t2.scedilla = 556;
                  t2.iacute = 278;
                  t2.lozenge = 494;
                  t2.Rcaron = 722;
                  t2.Gcommaaccent = 778;
                  t2.ucircumflex = 611;
                  t2.acircumflex = 556;
                  t2.Amacron = 722;
                  t2.rcaron = 389;
                  t2.ccedilla = 556;
                  t2.Zdotaccent = 611;
                  t2.Thorn = 667;
                  t2.Omacron = 778;
                  t2.Racute = 722;
                  t2.Sacute = 667;
                  t2.dcaron = 743;
                  t2.Umacron = 722;
                  t2.uring = 611;
                  t2.threesuperior = 333;
                  t2.Ograve = 778;
                  t2.Agrave = 722;
                  t2.Abreve = 722;
                  t2.multiply = 584;
                  t2.uacute = 611;
                  t2.Tcaron = 611;
                  t2.partialdiff = 494;
                  t2.ydieresis = 556;
                  t2.Nacute = 722;
                  t2.icircumflex = 278;
                  t2.Ecircumflex = 667;
                  t2.adieresis = 556;
                  t2.edieresis = 556;
                  t2.cacute = 556;
                  t2.nacute = 611;
                  t2.umacron = 611;
                  t2.Ncaron = 722;
                  t2.Iacute = 278;
                  t2.plusminus = 584;
                  t2.brokenbar = 280;
                  t2.registered = 737;
                  t2.Gbreve = 778;
                  t2.Idotaccent = 278;
                  t2.summation = 600;
                  t2.Egrave = 667;
                  t2.racute = 389;
                  t2.omacron = 611;
                  t2.Zacute = 611;
                  t2.Zcaron = 611;
                  t2.greaterequal = 549;
                  t2.Eth = 722;
                  t2.Ccedilla = 722;
                  t2.lcommaaccent = 278;
                  t2.tcaron = 389;
                  t2.eogonek = 556;
                  t2.Uogonek = 722;
                  t2.Aacute = 722;
                  t2.Adieresis = 722;
                  t2.egrave = 556;
                  t2.zacute = 500;
                  t2.iogonek = 278;
                  t2.Oacute = 778;
                  t2.oacute = 611;
                  t2.amacron = 556;
                  t2.sacute = 556;
                  t2.idieresis = 278;
                  t2.Ocircumflex = 778;
                  t2.Ugrave = 722;
                  t2.Delta = 612;
                  t2.thorn = 611;
                  t2.twosuperior = 333;
                  t2.Odieresis = 778;
                  t2.mu = 611;
                  t2.igrave = 278;
                  t2.ohungarumlaut = 611;
                  t2.Eogonek = 667;
                  t2.dcroat = 611;
                  t2.threequarters = 834;
                  t2.Scedilla = 667;
                  t2.lcaron = 400;
                  t2.Kcommaaccent = 722;
                  t2.Lacute = 611;
                  t2.trademark = 1e3;
                  t2.edotaccent = 556;
                  t2.Igrave = 278;
                  t2.Imacron = 278;
                  t2.Lcaron = 611;
                  t2.onehalf = 834;
                  t2.lessequal = 549;
                  t2.ocircumflex = 611;
                  t2.ntilde = 611;
                  t2.Uhungarumlaut = 722;
                  t2.Eacute = 667;
                  t2.emacron = 556;
                  t2.gbreve = 611;
                  t2.onequarter = 834;
                  t2.Scaron = 667;
                  t2.Scommaaccent = 667;
                  t2.Ohungarumlaut = 778;
                  t2.degree = 400;
                  t2.ograve = 611;
                  t2.Ccaron = 722;
                  t2.ugrave = 611;
                  t2.radical = 549;
                  t2.Dcaron = 722;
                  t2.rcommaaccent = 389;
                  t2.Ntilde = 722;
                  t2.otilde = 611;
                  t2.Rcommaaccent = 722;
                  t2.Lcommaaccent = 611;
                  t2.Atilde = 722;
                  t2.Aogonek = 722;
                  t2.Aring = 722;
                  t2.Otilde = 778;
                  t2.zdotaccent = 500;
                  t2.Ecaron = 667;
                  t2.Iogonek = 278;
                  t2.kcommaaccent = 556;
                  t2.minus = 584;
                  t2.Icircumflex = 278;
                  t2.ncaron = 611;
                  t2.tcommaaccent = 333;
                  t2.logicalnot = 584;
                  t2.odieresis = 611;
                  t2.udieresis = 611;
                  t2.notequal = 549;
                  t2.gcommaaccent = 611;
                  t2.eth = 611;
                  t2.zcaron = 500;
                  t2.ncommaaccent = 611;
                  t2.onesuperior = 333;
                  t2.imacron = 278;
                  t2.Euro = 556;
                });
                t["Helvetica-Oblique"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 278;
                  t2.exclam = 278;
                  t2.quotedbl = 355;
                  t2.numbersign = 556;
                  t2.dollar = 556;
                  t2.percent = 889;
                  t2.ampersand = 667;
                  t2.quoteright = 222;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asterisk = 389;
                  t2.plus = 584;
                  t2.comma = 278;
                  t2.hyphen = 333;
                  t2.period = 278;
                  t2.slash = 278;
                  t2.zero = 556;
                  t2.one = 556;
                  t2.two = 556;
                  t2.three = 556;
                  t2.four = 556;
                  t2.five = 556;
                  t2.six = 556;
                  t2.seven = 556;
                  t2.eight = 556;
                  t2.nine = 556;
                  t2.colon = 278;
                  t2.semicolon = 278;
                  t2.less = 584;
                  t2.equal = 584;
                  t2.greater = 584;
                  t2.question = 556;
                  t2.at = 1015;
                  t2.A = 667;
                  t2.B = 667;
                  t2.C = 722;
                  t2.D = 722;
                  t2.E = 667;
                  t2.F = 611;
                  t2.G = 778;
                  t2.H = 722;
                  t2.I = 278;
                  t2.J = 500;
                  t2.K = 667;
                  t2.L = 556;
                  t2.M = 833;
                  t2.N = 722;
                  t2.O = 778;
                  t2.P = 667;
                  t2.Q = 778;
                  t2.R = 722;
                  t2.S = 667;
                  t2.T = 611;
                  t2.U = 722;
                  t2.V = 667;
                  t2.W = 944;
                  t2.X = 667;
                  t2.Y = 667;
                  t2.Z = 611;
                  t2.bracketleft = 278;
                  t2.backslash = 278;
                  t2.bracketright = 278;
                  t2.asciicircum = 469;
                  t2.underscore = 556;
                  t2.quoteleft = 222;
                  t2.a = 556;
                  t2.b = 556;
                  t2.c = 500;
                  t2.d = 556;
                  t2.e = 556;
                  t2.f = 278;
                  t2.g = 556;
                  t2.h = 556;
                  t2.i = 222;
                  t2.j = 222;
                  t2.k = 500;
                  t2.l = 222;
                  t2.m = 833;
                  t2.n = 556;
                  t2.o = 556;
                  t2.p = 556;
                  t2.q = 556;
                  t2.r = 333;
                  t2.s = 500;
                  t2.t = 278;
                  t2.u = 556;
                  t2.v = 500;
                  t2.w = 722;
                  t2.x = 500;
                  t2.y = 500;
                  t2.z = 500;
                  t2.braceleft = 334;
                  t2.bar = 260;
                  t2.braceright = 334;
                  t2.asciitilde = 584;
                  t2.exclamdown = 333;
                  t2.cent = 556;
                  t2.sterling = 556;
                  t2.fraction = 167;
                  t2.yen = 556;
                  t2.florin = 556;
                  t2.section = 556;
                  t2.currency = 556;
                  t2.quotesingle = 191;
                  t2.quotedblleft = 333;
                  t2.guillemotleft = 556;
                  t2.guilsinglleft = 333;
                  t2.guilsinglright = 333;
                  t2.fi = 500;
                  t2.fl = 500;
                  t2.endash = 556;
                  t2.dagger = 556;
                  t2.daggerdbl = 556;
                  t2.periodcentered = 278;
                  t2.paragraph = 537;
                  t2.bullet = 350;
                  t2.quotesinglbase = 222;
                  t2.quotedblbase = 333;
                  t2.quotedblright = 333;
                  t2.guillemotright = 556;
                  t2.ellipsis = 1e3;
                  t2.perthousand = 1e3;
                  t2.questiondown = 611;
                  t2.grave = 333;
                  t2.acute = 333;
                  t2.circumflex = 333;
                  t2.tilde = 333;
                  t2.macron = 333;
                  t2.breve = 333;
                  t2.dotaccent = 333;
                  t2.dieresis = 333;
                  t2.ring = 333;
                  t2.cedilla = 333;
                  t2.hungarumlaut = 333;
                  t2.ogonek = 333;
                  t2.caron = 333;
                  t2.emdash = 1e3;
                  t2.AE = 1e3;
                  t2.ordfeminine = 370;
                  t2.Lslash = 556;
                  t2.Oslash = 778;
                  t2.OE = 1e3;
                  t2.ordmasculine = 365;
                  t2.ae = 889;
                  t2.dotlessi = 278;
                  t2.lslash = 222;
                  t2.oslash = 611;
                  t2.oe = 944;
                  t2.germandbls = 611;
                  t2.Idieresis = 278;
                  t2.eacute = 556;
                  t2.abreve = 556;
                  t2.uhungarumlaut = 556;
                  t2.ecaron = 556;
                  t2.Ydieresis = 667;
                  t2.divide = 584;
                  t2.Yacute = 667;
                  t2.Acircumflex = 667;
                  t2.aacute = 556;
                  t2.Ucircumflex = 722;
                  t2.yacute = 500;
                  t2.scommaaccent = 500;
                  t2.ecircumflex = 556;
                  t2.Uring = 722;
                  t2.Udieresis = 722;
                  t2.aogonek = 556;
                  t2.Uacute = 722;
                  t2.uogonek = 556;
                  t2.Edieresis = 667;
                  t2.Dcroat = 722;
                  t2.commaaccent = 250;
                  t2.copyright = 737;
                  t2.Emacron = 667;
                  t2.ccaron = 500;
                  t2.aring = 556;
                  t2.Ncommaaccent = 722;
                  t2.lacute = 222;
                  t2.agrave = 556;
                  t2.Tcommaaccent = 611;
                  t2.Cacute = 722;
                  t2.atilde = 556;
                  t2.Edotaccent = 667;
                  t2.scaron = 500;
                  t2.scedilla = 500;
                  t2.iacute = 278;
                  t2.lozenge = 471;
                  t2.Rcaron = 722;
                  t2.Gcommaaccent = 778;
                  t2.ucircumflex = 556;
                  t2.acircumflex = 556;
                  t2.Amacron = 667;
                  t2.rcaron = 333;
                  t2.ccedilla = 500;
                  t2.Zdotaccent = 611;
                  t2.Thorn = 667;
                  t2.Omacron = 778;
                  t2.Racute = 722;
                  t2.Sacute = 667;
                  t2.dcaron = 643;
                  t2.Umacron = 722;
                  t2.uring = 556;
                  t2.threesuperior = 333;
                  t2.Ograve = 778;
                  t2.Agrave = 667;
                  t2.Abreve = 667;
                  t2.multiply = 584;
                  t2.uacute = 556;
                  t2.Tcaron = 611;
                  t2.partialdiff = 476;
                  t2.ydieresis = 500;
                  t2.Nacute = 722;
                  t2.icircumflex = 278;
                  t2.Ecircumflex = 667;
                  t2.adieresis = 556;
                  t2.edieresis = 556;
                  t2.cacute = 500;
                  t2.nacute = 556;
                  t2.umacron = 556;
                  t2.Ncaron = 722;
                  t2.Iacute = 278;
                  t2.plusminus = 584;
                  t2.brokenbar = 260;
                  t2.registered = 737;
                  t2.Gbreve = 778;
                  t2.Idotaccent = 278;
                  t2.summation = 600;
                  t2.Egrave = 667;
                  t2.racute = 333;
                  t2.omacron = 556;
                  t2.Zacute = 611;
                  t2.Zcaron = 611;
                  t2.greaterequal = 549;
                  t2.Eth = 722;
                  t2.Ccedilla = 722;
                  t2.lcommaaccent = 222;
                  t2.tcaron = 317;
                  t2.eogonek = 556;
                  t2.Uogonek = 722;
                  t2.Aacute = 667;
                  t2.Adieresis = 667;
                  t2.egrave = 556;
                  t2.zacute = 500;
                  t2.iogonek = 222;
                  t2.Oacute = 778;
                  t2.oacute = 556;
                  t2.amacron = 556;
                  t2.sacute = 500;
                  t2.idieresis = 278;
                  t2.Ocircumflex = 778;
                  t2.Ugrave = 722;
                  t2.Delta = 612;
                  t2.thorn = 556;
                  t2.twosuperior = 333;
                  t2.Odieresis = 778;
                  t2.mu = 556;
                  t2.igrave = 278;
                  t2.ohungarumlaut = 556;
                  t2.Eogonek = 667;
                  t2.dcroat = 556;
                  t2.threequarters = 834;
                  t2.Scedilla = 667;
                  t2.lcaron = 299;
                  t2.Kcommaaccent = 667;
                  t2.Lacute = 556;
                  t2.trademark = 1e3;
                  t2.edotaccent = 556;
                  t2.Igrave = 278;
                  t2.Imacron = 278;
                  t2.Lcaron = 556;
                  t2.onehalf = 834;
                  t2.lessequal = 549;
                  t2.ocircumflex = 556;
                  t2.ntilde = 556;
                  t2.Uhungarumlaut = 722;
                  t2.Eacute = 667;
                  t2.emacron = 556;
                  t2.gbreve = 556;
                  t2.onequarter = 834;
                  t2.Scaron = 667;
                  t2.Scommaaccent = 667;
                  t2.Ohungarumlaut = 778;
                  t2.degree = 400;
                  t2.ograve = 556;
                  t2.Ccaron = 722;
                  t2.ugrave = 556;
                  t2.radical = 453;
                  t2.Dcaron = 722;
                  t2.rcommaaccent = 333;
                  t2.Ntilde = 722;
                  t2.otilde = 556;
                  t2.Rcommaaccent = 722;
                  t2.Lcommaaccent = 556;
                  t2.Atilde = 667;
                  t2.Aogonek = 667;
                  t2.Aring = 667;
                  t2.Otilde = 778;
                  t2.zdotaccent = 500;
                  t2.Ecaron = 667;
                  t2.Iogonek = 278;
                  t2.kcommaaccent = 500;
                  t2.minus = 584;
                  t2.Icircumflex = 278;
                  t2.ncaron = 556;
                  t2.tcommaaccent = 278;
                  t2.logicalnot = 584;
                  t2.odieresis = 556;
                  t2.udieresis = 556;
                  t2.notequal = 549;
                  t2.gcommaaccent = 556;
                  t2.eth = 556;
                  t2.zcaron = 500;
                  t2.ncommaaccent = 556;
                  t2.onesuperior = 333;
                  t2.imacron = 278;
                  t2.Euro = 556;
                });
                t.Symbol = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 250;
                  t2.exclam = 333;
                  t2.universal = 713;
                  t2.numbersign = 500;
                  t2.existential = 549;
                  t2.percent = 833;
                  t2.ampersand = 778;
                  t2.suchthat = 439;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asteriskmath = 500;
                  t2.plus = 549;
                  t2.comma = 250;
                  t2.minus = 549;
                  t2.period = 250;
                  t2.slash = 278;
                  t2.zero = 500;
                  t2.one = 500;
                  t2.two = 500;
                  t2.three = 500;
                  t2.four = 500;
                  t2.five = 500;
                  t2.six = 500;
                  t2.seven = 500;
                  t2.eight = 500;
                  t2.nine = 500;
                  t2.colon = 278;
                  t2.semicolon = 278;
                  t2.less = 549;
                  t2.equal = 549;
                  t2.greater = 549;
                  t2.question = 444;
                  t2.congruent = 549;
                  t2.Alpha = 722;
                  t2.Beta = 667;
                  t2.Chi = 722;
                  t2.Delta = 612;
                  t2.Epsilon = 611;
                  t2.Phi = 763;
                  t2.Gamma = 603;
                  t2.Eta = 722;
                  t2.Iota = 333;
                  t2.theta1 = 631;
                  t2.Kappa = 722;
                  t2.Lambda = 686;
                  t2.Mu = 889;
                  t2.Nu = 722;
                  t2.Omicron = 722;
                  t2.Pi = 768;
                  t2.Theta = 741;
                  t2.Rho = 556;
                  t2.Sigma = 592;
                  t2.Tau = 611;
                  t2.Upsilon = 690;
                  t2.sigma1 = 439;
                  t2.Omega = 768;
                  t2.Xi = 645;
                  t2.Psi = 795;
                  t2.Zeta = 611;
                  t2.bracketleft = 333;
                  t2.therefore = 863;
                  t2.bracketright = 333;
                  t2.perpendicular = 658;
                  t2.underscore = 500;
                  t2.radicalex = 500;
                  t2.alpha = 631;
                  t2.beta = 549;
                  t2.chi = 549;
                  t2.delta = 494;
                  t2.epsilon = 439;
                  t2.phi = 521;
                  t2.gamma = 411;
                  t2.eta = 603;
                  t2.iota = 329;
                  t2.phi1 = 603;
                  t2.kappa = 549;
                  t2.lambda = 549;
                  t2.mu = 576;
                  t2.nu = 521;
                  t2.omicron = 549;
                  t2.pi = 549;
                  t2.theta = 521;
                  t2.rho = 549;
                  t2.sigma = 603;
                  t2.tau = 439;
                  t2.upsilon = 576;
                  t2.omega1 = 713;
                  t2.omega = 686;
                  t2.xi = 493;
                  t2.psi = 686;
                  t2.zeta = 494;
                  t2.braceleft = 480;
                  t2.bar = 200;
                  t2.braceright = 480;
                  t2.similar = 549;
                  t2.Euro = 750;
                  t2.Upsilon1 = 620;
                  t2.minute = 247;
                  t2.lessequal = 549;
                  t2.fraction = 167;
                  t2.infinity = 713;
                  t2.florin = 500;
                  t2.club = 753;
                  t2.diamond = 753;
                  t2.heart = 753;
                  t2.spade = 753;
                  t2.arrowboth = 1042;
                  t2.arrowleft = 987;
                  t2.arrowup = 603;
                  t2.arrowright = 987;
                  t2.arrowdown = 603;
                  t2.degree = 400;
                  t2.plusminus = 549;
                  t2.second = 411;
                  t2.greaterequal = 549;
                  t2.multiply = 549;
                  t2.proportional = 713;
                  t2.partialdiff = 494;
                  t2.bullet = 460;
                  t2.divide = 549;
                  t2.notequal = 549;
                  t2.equivalence = 549;
                  t2.approxequal = 549;
                  t2.ellipsis = 1e3;
                  t2.arrowvertex = 603;
                  t2.arrowhorizex = 1e3;
                  t2.carriagereturn = 658;
                  t2.aleph = 823;
                  t2.Ifraktur = 686;
                  t2.Rfraktur = 795;
                  t2.weierstrass = 987;
                  t2.circlemultiply = 768;
                  t2.circleplus = 768;
                  t2.emptyset = 823;
                  t2.intersection = 768;
                  t2.union = 768;
                  t2.propersuperset = 713;
                  t2.reflexsuperset = 713;
                  t2.notsubset = 713;
                  t2.propersubset = 713;
                  t2.reflexsubset = 713;
                  t2.element = 713;
                  t2.notelement = 713;
                  t2.angle = 768;
                  t2.gradient = 713;
                  t2.registerserif = 790;
                  t2.copyrightserif = 790;
                  t2.trademarkserif = 890;
                  t2.product = 823;
                  t2.radical = 549;
                  t2.dotmath = 250;
                  t2.logicalnot = 713;
                  t2.logicaland = 603;
                  t2.logicalor = 603;
                  t2.arrowdblboth = 1042;
                  t2.arrowdblleft = 987;
                  t2.arrowdblup = 603;
                  t2.arrowdblright = 987;
                  t2.arrowdbldown = 603;
                  t2.lozenge = 494;
                  t2.angleleft = 329;
                  t2.registersans = 790;
                  t2.copyrightsans = 790;
                  t2.trademarksans = 786;
                  t2.summation = 713;
                  t2.parenlefttp = 384;
                  t2.parenleftex = 384;
                  t2.parenleftbt = 384;
                  t2.bracketlefttp = 384;
                  t2.bracketleftex = 384;
                  t2.bracketleftbt = 384;
                  t2.bracelefttp = 494;
                  t2.braceleftmid = 494;
                  t2.braceleftbt = 494;
                  t2.braceex = 494;
                  t2.angleright = 329;
                  t2.integral = 274;
                  t2.integraltp = 686;
                  t2.integralex = 686;
                  t2.integralbt = 686;
                  t2.parenrighttp = 384;
                  t2.parenrightex = 384;
                  t2.parenrightbt = 384;
                  t2.bracketrighttp = 384;
                  t2.bracketrightex = 384;
                  t2.bracketrightbt = 384;
                  t2.bracerighttp = 494;
                  t2.bracerightmid = 494;
                  t2.bracerightbt = 494;
                  t2.apple = 790;
                });
                t["Times-Roman"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 250;
                  t2.exclam = 333;
                  t2.quotedbl = 408;
                  t2.numbersign = 500;
                  t2.dollar = 500;
                  t2.percent = 833;
                  t2.ampersand = 778;
                  t2.quoteright = 333;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asterisk = 500;
                  t2.plus = 564;
                  t2.comma = 250;
                  t2.hyphen = 333;
                  t2.period = 250;
                  t2.slash = 278;
                  t2.zero = 500;
                  t2.one = 500;
                  t2.two = 500;
                  t2.three = 500;
                  t2.four = 500;
                  t2.five = 500;
                  t2.six = 500;
                  t2.seven = 500;
                  t2.eight = 500;
                  t2.nine = 500;
                  t2.colon = 278;
                  t2.semicolon = 278;
                  t2.less = 564;
                  t2.equal = 564;
                  t2.greater = 564;
                  t2.question = 444;
                  t2.at = 921;
                  t2.A = 722;
                  t2.B = 667;
                  t2.C = 667;
                  t2.D = 722;
                  t2.E = 611;
                  t2.F = 556;
                  t2.G = 722;
                  t2.H = 722;
                  t2.I = 333;
                  t2.J = 389;
                  t2.K = 722;
                  t2.L = 611;
                  t2.M = 889;
                  t2.N = 722;
                  t2.O = 722;
                  t2.P = 556;
                  t2.Q = 722;
                  t2.R = 667;
                  t2.S = 556;
                  t2.T = 611;
                  t2.U = 722;
                  t2.V = 722;
                  t2.W = 944;
                  t2.X = 722;
                  t2.Y = 722;
                  t2.Z = 611;
                  t2.bracketleft = 333;
                  t2.backslash = 278;
                  t2.bracketright = 333;
                  t2.asciicircum = 469;
                  t2.underscore = 500;
                  t2.quoteleft = 333;
                  t2.a = 444;
                  t2.b = 500;
                  t2.c = 444;
                  t2.d = 500;
                  t2.e = 444;
                  t2.f = 333;
                  t2.g = 500;
                  t2.h = 500;
                  t2.i = 278;
                  t2.j = 278;
                  t2.k = 500;
                  t2.l = 278;
                  t2.m = 778;
                  t2.n = 500;
                  t2.o = 500;
                  t2.p = 500;
                  t2.q = 500;
                  t2.r = 333;
                  t2.s = 389;
                  t2.t = 278;
                  t2.u = 500;
                  t2.v = 500;
                  t2.w = 722;
                  t2.x = 500;
                  t2.y = 500;
                  t2.z = 444;
                  t2.braceleft = 480;
                  t2.bar = 200;
                  t2.braceright = 480;
                  t2.asciitilde = 541;
                  t2.exclamdown = 333;
                  t2.cent = 500;
                  t2.sterling = 500;
                  t2.fraction = 167;
                  t2.yen = 500;
                  t2.florin = 500;
                  t2.section = 500;
                  t2.currency = 500;
                  t2.quotesingle = 180;
                  t2.quotedblleft = 444;
                  t2.guillemotleft = 500;
                  t2.guilsinglleft = 333;
                  t2.guilsinglright = 333;
                  t2.fi = 556;
                  t2.fl = 556;
                  t2.endash = 500;
                  t2.dagger = 500;
                  t2.daggerdbl = 500;
                  t2.periodcentered = 250;
                  t2.paragraph = 453;
                  t2.bullet = 350;
                  t2.quotesinglbase = 333;
                  t2.quotedblbase = 444;
                  t2.quotedblright = 444;
                  t2.guillemotright = 500;
                  t2.ellipsis = 1e3;
                  t2.perthousand = 1e3;
                  t2.questiondown = 444;
                  t2.grave = 333;
                  t2.acute = 333;
                  t2.circumflex = 333;
                  t2.tilde = 333;
                  t2.macron = 333;
                  t2.breve = 333;
                  t2.dotaccent = 333;
                  t2.dieresis = 333;
                  t2.ring = 333;
                  t2.cedilla = 333;
                  t2.hungarumlaut = 333;
                  t2.ogonek = 333;
                  t2.caron = 333;
                  t2.emdash = 1e3;
                  t2.AE = 889;
                  t2.ordfeminine = 276;
                  t2.Lslash = 611;
                  t2.Oslash = 722;
                  t2.OE = 889;
                  t2.ordmasculine = 310;
                  t2.ae = 667;
                  t2.dotlessi = 278;
                  t2.lslash = 278;
                  t2.oslash = 500;
                  t2.oe = 722;
                  t2.germandbls = 500;
                  t2.Idieresis = 333;
                  t2.eacute = 444;
                  t2.abreve = 444;
                  t2.uhungarumlaut = 500;
                  t2.ecaron = 444;
                  t2.Ydieresis = 722;
                  t2.divide = 564;
                  t2.Yacute = 722;
                  t2.Acircumflex = 722;
                  t2.aacute = 444;
                  t2.Ucircumflex = 722;
                  t2.yacute = 500;
                  t2.scommaaccent = 389;
                  t2.ecircumflex = 444;
                  t2.Uring = 722;
                  t2.Udieresis = 722;
                  t2.aogonek = 444;
                  t2.Uacute = 722;
                  t2.uogonek = 500;
                  t2.Edieresis = 611;
                  t2.Dcroat = 722;
                  t2.commaaccent = 250;
                  t2.copyright = 760;
                  t2.Emacron = 611;
                  t2.ccaron = 444;
                  t2.aring = 444;
                  t2.Ncommaaccent = 722;
                  t2.lacute = 278;
                  t2.agrave = 444;
                  t2.Tcommaaccent = 611;
                  t2.Cacute = 667;
                  t2.atilde = 444;
                  t2.Edotaccent = 611;
                  t2.scaron = 389;
                  t2.scedilla = 389;
                  t2.iacute = 278;
                  t2.lozenge = 471;
                  t2.Rcaron = 667;
                  t2.Gcommaaccent = 722;
                  t2.ucircumflex = 500;
                  t2.acircumflex = 444;
                  t2.Amacron = 722;
                  t2.rcaron = 333;
                  t2.ccedilla = 444;
                  t2.Zdotaccent = 611;
                  t2.Thorn = 556;
                  t2.Omacron = 722;
                  t2.Racute = 667;
                  t2.Sacute = 556;
                  t2.dcaron = 588;
                  t2.Umacron = 722;
                  t2.uring = 500;
                  t2.threesuperior = 300;
                  t2.Ograve = 722;
                  t2.Agrave = 722;
                  t2.Abreve = 722;
                  t2.multiply = 564;
                  t2.uacute = 500;
                  t2.Tcaron = 611;
                  t2.partialdiff = 476;
                  t2.ydieresis = 500;
                  t2.Nacute = 722;
                  t2.icircumflex = 278;
                  t2.Ecircumflex = 611;
                  t2.adieresis = 444;
                  t2.edieresis = 444;
                  t2.cacute = 444;
                  t2.nacute = 500;
                  t2.umacron = 500;
                  t2.Ncaron = 722;
                  t2.Iacute = 333;
                  t2.plusminus = 564;
                  t2.brokenbar = 200;
                  t2.registered = 760;
                  t2.Gbreve = 722;
                  t2.Idotaccent = 333;
                  t2.summation = 600;
                  t2.Egrave = 611;
                  t2.racute = 333;
                  t2.omacron = 500;
                  t2.Zacute = 611;
                  t2.Zcaron = 611;
                  t2.greaterequal = 549;
                  t2.Eth = 722;
                  t2.Ccedilla = 667;
                  t2.lcommaaccent = 278;
                  t2.tcaron = 326;
                  t2.eogonek = 444;
                  t2.Uogonek = 722;
                  t2.Aacute = 722;
                  t2.Adieresis = 722;
                  t2.egrave = 444;
                  t2.zacute = 444;
                  t2.iogonek = 278;
                  t2.Oacute = 722;
                  t2.oacute = 500;
                  t2.amacron = 444;
                  t2.sacute = 389;
                  t2.idieresis = 278;
                  t2.Ocircumflex = 722;
                  t2.Ugrave = 722;
                  t2.Delta = 612;
                  t2.thorn = 500;
                  t2.twosuperior = 300;
                  t2.Odieresis = 722;
                  t2.mu = 500;
                  t2.igrave = 278;
                  t2.ohungarumlaut = 500;
                  t2.Eogonek = 611;
                  t2.dcroat = 500;
                  t2.threequarters = 750;
                  t2.Scedilla = 556;
                  t2.lcaron = 344;
                  t2.Kcommaaccent = 722;
                  t2.Lacute = 611;
                  t2.trademark = 980;
                  t2.edotaccent = 444;
                  t2.Igrave = 333;
                  t2.Imacron = 333;
                  t2.Lcaron = 611;
                  t2.onehalf = 750;
                  t2.lessequal = 549;
                  t2.ocircumflex = 500;
                  t2.ntilde = 500;
                  t2.Uhungarumlaut = 722;
                  t2.Eacute = 611;
                  t2.emacron = 444;
                  t2.gbreve = 500;
                  t2.onequarter = 750;
                  t2.Scaron = 556;
                  t2.Scommaaccent = 556;
                  t2.Ohungarumlaut = 722;
                  t2.degree = 400;
                  t2.ograve = 500;
                  t2.Ccaron = 667;
                  t2.ugrave = 500;
                  t2.radical = 453;
                  t2.Dcaron = 722;
                  t2.rcommaaccent = 333;
                  t2.Ntilde = 722;
                  t2.otilde = 500;
                  t2.Rcommaaccent = 667;
                  t2.Lcommaaccent = 611;
                  t2.Atilde = 722;
                  t2.Aogonek = 722;
                  t2.Aring = 722;
                  t2.Otilde = 722;
                  t2.zdotaccent = 444;
                  t2.Ecaron = 611;
                  t2.Iogonek = 333;
                  t2.kcommaaccent = 500;
                  t2.minus = 564;
                  t2.Icircumflex = 333;
                  t2.ncaron = 500;
                  t2.tcommaaccent = 278;
                  t2.logicalnot = 564;
                  t2.odieresis = 500;
                  t2.udieresis = 500;
                  t2.notequal = 549;
                  t2.gcommaaccent = 500;
                  t2.eth = 500;
                  t2.zcaron = 444;
                  t2.ncommaaccent = 500;
                  t2.onesuperior = 300;
                  t2.imacron = 278;
                  t2.Euro = 500;
                });
                t["Times-Bold"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 250;
                  t2.exclam = 333;
                  t2.quotedbl = 555;
                  t2.numbersign = 500;
                  t2.dollar = 500;
                  t2.percent = 1e3;
                  t2.ampersand = 833;
                  t2.quoteright = 333;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asterisk = 500;
                  t2.plus = 570;
                  t2.comma = 250;
                  t2.hyphen = 333;
                  t2.period = 250;
                  t2.slash = 278;
                  t2.zero = 500;
                  t2.one = 500;
                  t2.two = 500;
                  t2.three = 500;
                  t2.four = 500;
                  t2.five = 500;
                  t2.six = 500;
                  t2.seven = 500;
                  t2.eight = 500;
                  t2.nine = 500;
                  t2.colon = 333;
                  t2.semicolon = 333;
                  t2.less = 570;
                  t2.equal = 570;
                  t2.greater = 570;
                  t2.question = 500;
                  t2.at = 930;
                  t2.A = 722;
                  t2.B = 667;
                  t2.C = 722;
                  t2.D = 722;
                  t2.E = 667;
                  t2.F = 611;
                  t2.G = 778;
                  t2.H = 778;
                  t2.I = 389;
                  t2.J = 500;
                  t2.K = 778;
                  t2.L = 667;
                  t2.M = 944;
                  t2.N = 722;
                  t2.O = 778;
                  t2.P = 611;
                  t2.Q = 778;
                  t2.R = 722;
                  t2.S = 556;
                  t2.T = 667;
                  t2.U = 722;
                  t2.V = 722;
                  t2.W = 1e3;
                  t2.X = 722;
                  t2.Y = 722;
                  t2.Z = 667;
                  t2.bracketleft = 333;
                  t2.backslash = 278;
                  t2.bracketright = 333;
                  t2.asciicircum = 581;
                  t2.underscore = 500;
                  t2.quoteleft = 333;
                  t2.a = 500;
                  t2.b = 556;
                  t2.c = 444;
                  t2.d = 556;
                  t2.e = 444;
                  t2.f = 333;
                  t2.g = 500;
                  t2.h = 556;
                  t2.i = 278;
                  t2.j = 333;
                  t2.k = 556;
                  t2.l = 278;
                  t2.m = 833;
                  t2.n = 556;
                  t2.o = 500;
                  t2.p = 556;
                  t2.q = 556;
                  t2.r = 444;
                  t2.s = 389;
                  t2.t = 333;
                  t2.u = 556;
                  t2.v = 500;
                  t2.w = 722;
                  t2.x = 500;
                  t2.y = 500;
                  t2.z = 444;
                  t2.braceleft = 394;
                  t2.bar = 220;
                  t2.braceright = 394;
                  t2.asciitilde = 520;
                  t2.exclamdown = 333;
                  t2.cent = 500;
                  t2.sterling = 500;
                  t2.fraction = 167;
                  t2.yen = 500;
                  t2.florin = 500;
                  t2.section = 500;
                  t2.currency = 500;
                  t2.quotesingle = 278;
                  t2.quotedblleft = 500;
                  t2.guillemotleft = 500;
                  t2.guilsinglleft = 333;
                  t2.guilsinglright = 333;
                  t2.fi = 556;
                  t2.fl = 556;
                  t2.endash = 500;
                  t2.dagger = 500;
                  t2.daggerdbl = 500;
                  t2.periodcentered = 250;
                  t2.paragraph = 540;
                  t2.bullet = 350;
                  t2.quotesinglbase = 333;
                  t2.quotedblbase = 500;
                  t2.quotedblright = 500;
                  t2.guillemotright = 500;
                  t2.ellipsis = 1e3;
                  t2.perthousand = 1e3;
                  t2.questiondown = 500;
                  t2.grave = 333;
                  t2.acute = 333;
                  t2.circumflex = 333;
                  t2.tilde = 333;
                  t2.macron = 333;
                  t2.breve = 333;
                  t2.dotaccent = 333;
                  t2.dieresis = 333;
                  t2.ring = 333;
                  t2.cedilla = 333;
                  t2.hungarumlaut = 333;
                  t2.ogonek = 333;
                  t2.caron = 333;
                  t2.emdash = 1e3;
                  t2.AE = 1e3;
                  t2.ordfeminine = 300;
                  t2.Lslash = 667;
                  t2.Oslash = 778;
                  t2.OE = 1e3;
                  t2.ordmasculine = 330;
                  t2.ae = 722;
                  t2.dotlessi = 278;
                  t2.lslash = 278;
                  t2.oslash = 500;
                  t2.oe = 722;
                  t2.germandbls = 556;
                  t2.Idieresis = 389;
                  t2.eacute = 444;
                  t2.abreve = 500;
                  t2.uhungarumlaut = 556;
                  t2.ecaron = 444;
                  t2.Ydieresis = 722;
                  t2.divide = 570;
                  t2.Yacute = 722;
                  t2.Acircumflex = 722;
                  t2.aacute = 500;
                  t2.Ucircumflex = 722;
                  t2.yacute = 500;
                  t2.scommaaccent = 389;
                  t2.ecircumflex = 444;
                  t2.Uring = 722;
                  t2.Udieresis = 722;
                  t2.aogonek = 500;
                  t2.Uacute = 722;
                  t2.uogonek = 556;
                  t2.Edieresis = 667;
                  t2.Dcroat = 722;
                  t2.commaaccent = 250;
                  t2.copyright = 747;
                  t2.Emacron = 667;
                  t2.ccaron = 444;
                  t2.aring = 500;
                  t2.Ncommaaccent = 722;
                  t2.lacute = 278;
                  t2.agrave = 500;
                  t2.Tcommaaccent = 667;
                  t2.Cacute = 722;
                  t2.atilde = 500;
                  t2.Edotaccent = 667;
                  t2.scaron = 389;
                  t2.scedilla = 389;
                  t2.iacute = 278;
                  t2.lozenge = 494;
                  t2.Rcaron = 722;
                  t2.Gcommaaccent = 778;
                  t2.ucircumflex = 556;
                  t2.acircumflex = 500;
                  t2.Amacron = 722;
                  t2.rcaron = 444;
                  t2.ccedilla = 444;
                  t2.Zdotaccent = 667;
                  t2.Thorn = 611;
                  t2.Omacron = 778;
                  t2.Racute = 722;
                  t2.Sacute = 556;
                  t2.dcaron = 672;
                  t2.Umacron = 722;
                  t2.uring = 556;
                  t2.threesuperior = 300;
                  t2.Ograve = 778;
                  t2.Agrave = 722;
                  t2.Abreve = 722;
                  t2.multiply = 570;
                  t2.uacute = 556;
                  t2.Tcaron = 667;
                  t2.partialdiff = 494;
                  t2.ydieresis = 500;
                  t2.Nacute = 722;
                  t2.icircumflex = 278;
                  t2.Ecircumflex = 667;
                  t2.adieresis = 500;
                  t2.edieresis = 444;
                  t2.cacute = 444;
                  t2.nacute = 556;
                  t2.umacron = 556;
                  t2.Ncaron = 722;
                  t2.Iacute = 389;
                  t2.plusminus = 570;
                  t2.brokenbar = 220;
                  t2.registered = 747;
                  t2.Gbreve = 778;
                  t2.Idotaccent = 389;
                  t2.summation = 600;
                  t2.Egrave = 667;
                  t2.racute = 444;
                  t2.omacron = 500;
                  t2.Zacute = 667;
                  t2.Zcaron = 667;
                  t2.greaterequal = 549;
                  t2.Eth = 722;
                  t2.Ccedilla = 722;
                  t2.lcommaaccent = 278;
                  t2.tcaron = 416;
                  t2.eogonek = 444;
                  t2.Uogonek = 722;
                  t2.Aacute = 722;
                  t2.Adieresis = 722;
                  t2.egrave = 444;
                  t2.zacute = 444;
                  t2.iogonek = 278;
                  t2.Oacute = 778;
                  t2.oacute = 500;
                  t2.amacron = 500;
                  t2.sacute = 389;
                  t2.idieresis = 278;
                  t2.Ocircumflex = 778;
                  t2.Ugrave = 722;
                  t2.Delta = 612;
                  t2.thorn = 556;
                  t2.twosuperior = 300;
                  t2.Odieresis = 778;
                  t2.mu = 556;
                  t2.igrave = 278;
                  t2.ohungarumlaut = 500;
                  t2.Eogonek = 667;
                  t2.dcroat = 556;
                  t2.threequarters = 750;
                  t2.Scedilla = 556;
                  t2.lcaron = 394;
                  t2.Kcommaaccent = 778;
                  t2.Lacute = 667;
                  t2.trademark = 1e3;
                  t2.edotaccent = 444;
                  t2.Igrave = 389;
                  t2.Imacron = 389;
                  t2.Lcaron = 667;
                  t2.onehalf = 750;
                  t2.lessequal = 549;
                  t2.ocircumflex = 500;
                  t2.ntilde = 556;
                  t2.Uhungarumlaut = 722;
                  t2.Eacute = 667;
                  t2.emacron = 444;
                  t2.gbreve = 500;
                  t2.onequarter = 750;
                  t2.Scaron = 556;
                  t2.Scommaaccent = 556;
                  t2.Ohungarumlaut = 778;
                  t2.degree = 400;
                  t2.ograve = 500;
                  t2.Ccaron = 722;
                  t2.ugrave = 556;
                  t2.radical = 549;
                  t2.Dcaron = 722;
                  t2.rcommaaccent = 444;
                  t2.Ntilde = 722;
                  t2.otilde = 500;
                  t2.Rcommaaccent = 722;
                  t2.Lcommaaccent = 667;
                  t2.Atilde = 722;
                  t2.Aogonek = 722;
                  t2.Aring = 722;
                  t2.Otilde = 778;
                  t2.zdotaccent = 444;
                  t2.Ecaron = 667;
                  t2.Iogonek = 389;
                  t2.kcommaaccent = 556;
                  t2.minus = 570;
                  t2.Icircumflex = 389;
                  t2.ncaron = 556;
                  t2.tcommaaccent = 333;
                  t2.logicalnot = 570;
                  t2.odieresis = 500;
                  t2.udieresis = 556;
                  t2.notequal = 549;
                  t2.gcommaaccent = 500;
                  t2.eth = 500;
                  t2.zcaron = 444;
                  t2.ncommaaccent = 556;
                  t2.onesuperior = 300;
                  t2.imacron = 278;
                  t2.Euro = 500;
                });
                t["Times-BoldItalic"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 250;
                  t2.exclam = 389;
                  t2.quotedbl = 555;
                  t2.numbersign = 500;
                  t2.dollar = 500;
                  t2.percent = 833;
                  t2.ampersand = 778;
                  t2.quoteright = 333;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asterisk = 500;
                  t2.plus = 570;
                  t2.comma = 250;
                  t2.hyphen = 333;
                  t2.period = 250;
                  t2.slash = 278;
                  t2.zero = 500;
                  t2.one = 500;
                  t2.two = 500;
                  t2.three = 500;
                  t2.four = 500;
                  t2.five = 500;
                  t2.six = 500;
                  t2.seven = 500;
                  t2.eight = 500;
                  t2.nine = 500;
                  t2.colon = 333;
                  t2.semicolon = 333;
                  t2.less = 570;
                  t2.equal = 570;
                  t2.greater = 570;
                  t2.question = 500;
                  t2.at = 832;
                  t2.A = 667;
                  t2.B = 667;
                  t2.C = 667;
                  t2.D = 722;
                  t2.E = 667;
                  t2.F = 667;
                  t2.G = 722;
                  t2.H = 778;
                  t2.I = 389;
                  t2.J = 500;
                  t2.K = 667;
                  t2.L = 611;
                  t2.M = 889;
                  t2.N = 722;
                  t2.O = 722;
                  t2.P = 611;
                  t2.Q = 722;
                  t2.R = 667;
                  t2.S = 556;
                  t2.T = 611;
                  t2.U = 722;
                  t2.V = 667;
                  t2.W = 889;
                  t2.X = 667;
                  t2.Y = 611;
                  t2.Z = 611;
                  t2.bracketleft = 333;
                  t2.backslash = 278;
                  t2.bracketright = 333;
                  t2.asciicircum = 570;
                  t2.underscore = 500;
                  t2.quoteleft = 333;
                  t2.a = 500;
                  t2.b = 500;
                  t2.c = 444;
                  t2.d = 500;
                  t2.e = 444;
                  t2.f = 333;
                  t2.g = 500;
                  t2.h = 556;
                  t2.i = 278;
                  t2.j = 278;
                  t2.k = 500;
                  t2.l = 278;
                  t2.m = 778;
                  t2.n = 556;
                  t2.o = 500;
                  t2.p = 500;
                  t2.q = 500;
                  t2.r = 389;
                  t2.s = 389;
                  t2.t = 278;
                  t2.u = 556;
                  t2.v = 444;
                  t2.w = 667;
                  t2.x = 500;
                  t2.y = 444;
                  t2.z = 389;
                  t2.braceleft = 348;
                  t2.bar = 220;
                  t2.braceright = 348;
                  t2.asciitilde = 570;
                  t2.exclamdown = 389;
                  t2.cent = 500;
                  t2.sterling = 500;
                  t2.fraction = 167;
                  t2.yen = 500;
                  t2.florin = 500;
                  t2.section = 500;
                  t2.currency = 500;
                  t2.quotesingle = 278;
                  t2.quotedblleft = 500;
                  t2.guillemotleft = 500;
                  t2.guilsinglleft = 333;
                  t2.guilsinglright = 333;
                  t2.fi = 556;
                  t2.fl = 556;
                  t2.endash = 500;
                  t2.dagger = 500;
                  t2.daggerdbl = 500;
                  t2.periodcentered = 250;
                  t2.paragraph = 500;
                  t2.bullet = 350;
                  t2.quotesinglbase = 333;
                  t2.quotedblbase = 500;
                  t2.quotedblright = 500;
                  t2.guillemotright = 500;
                  t2.ellipsis = 1e3;
                  t2.perthousand = 1e3;
                  t2.questiondown = 500;
                  t2.grave = 333;
                  t2.acute = 333;
                  t2.circumflex = 333;
                  t2.tilde = 333;
                  t2.macron = 333;
                  t2.breve = 333;
                  t2.dotaccent = 333;
                  t2.dieresis = 333;
                  t2.ring = 333;
                  t2.cedilla = 333;
                  t2.hungarumlaut = 333;
                  t2.ogonek = 333;
                  t2.caron = 333;
                  t2.emdash = 1e3;
                  t2.AE = 944;
                  t2.ordfeminine = 266;
                  t2.Lslash = 611;
                  t2.Oslash = 722;
                  t2.OE = 944;
                  t2.ordmasculine = 300;
                  t2.ae = 722;
                  t2.dotlessi = 278;
                  t2.lslash = 278;
                  t2.oslash = 500;
                  t2.oe = 722;
                  t2.germandbls = 500;
                  t2.Idieresis = 389;
                  t2.eacute = 444;
                  t2.abreve = 500;
                  t2.uhungarumlaut = 556;
                  t2.ecaron = 444;
                  t2.Ydieresis = 611;
                  t2.divide = 570;
                  t2.Yacute = 611;
                  t2.Acircumflex = 667;
                  t2.aacute = 500;
                  t2.Ucircumflex = 722;
                  t2.yacute = 444;
                  t2.scommaaccent = 389;
                  t2.ecircumflex = 444;
                  t2.Uring = 722;
                  t2.Udieresis = 722;
                  t2.aogonek = 500;
                  t2.Uacute = 722;
                  t2.uogonek = 556;
                  t2.Edieresis = 667;
                  t2.Dcroat = 722;
                  t2.commaaccent = 250;
                  t2.copyright = 747;
                  t2.Emacron = 667;
                  t2.ccaron = 444;
                  t2.aring = 500;
                  t2.Ncommaaccent = 722;
                  t2.lacute = 278;
                  t2.agrave = 500;
                  t2.Tcommaaccent = 611;
                  t2.Cacute = 667;
                  t2.atilde = 500;
                  t2.Edotaccent = 667;
                  t2.scaron = 389;
                  t2.scedilla = 389;
                  t2.iacute = 278;
                  t2.lozenge = 494;
                  t2.Rcaron = 667;
                  t2.Gcommaaccent = 722;
                  t2.ucircumflex = 556;
                  t2.acircumflex = 500;
                  t2.Amacron = 667;
                  t2.rcaron = 389;
                  t2.ccedilla = 444;
                  t2.Zdotaccent = 611;
                  t2.Thorn = 611;
                  t2.Omacron = 722;
                  t2.Racute = 667;
                  t2.Sacute = 556;
                  t2.dcaron = 608;
                  t2.Umacron = 722;
                  t2.uring = 556;
                  t2.threesuperior = 300;
                  t2.Ograve = 722;
                  t2.Agrave = 667;
                  t2.Abreve = 667;
                  t2.multiply = 570;
                  t2.uacute = 556;
                  t2.Tcaron = 611;
                  t2.partialdiff = 494;
                  t2.ydieresis = 444;
                  t2.Nacute = 722;
                  t2.icircumflex = 278;
                  t2.Ecircumflex = 667;
                  t2.adieresis = 500;
                  t2.edieresis = 444;
                  t2.cacute = 444;
                  t2.nacute = 556;
                  t2.umacron = 556;
                  t2.Ncaron = 722;
                  t2.Iacute = 389;
                  t2.plusminus = 570;
                  t2.brokenbar = 220;
                  t2.registered = 747;
                  t2.Gbreve = 722;
                  t2.Idotaccent = 389;
                  t2.summation = 600;
                  t2.Egrave = 667;
                  t2.racute = 389;
                  t2.omacron = 500;
                  t2.Zacute = 611;
                  t2.Zcaron = 611;
                  t2.greaterequal = 549;
                  t2.Eth = 722;
                  t2.Ccedilla = 667;
                  t2.lcommaaccent = 278;
                  t2.tcaron = 366;
                  t2.eogonek = 444;
                  t2.Uogonek = 722;
                  t2.Aacute = 667;
                  t2.Adieresis = 667;
                  t2.egrave = 444;
                  t2.zacute = 389;
                  t2.iogonek = 278;
                  t2.Oacute = 722;
                  t2.oacute = 500;
                  t2.amacron = 500;
                  t2.sacute = 389;
                  t2.idieresis = 278;
                  t2.Ocircumflex = 722;
                  t2.Ugrave = 722;
                  t2.Delta = 612;
                  t2.thorn = 500;
                  t2.twosuperior = 300;
                  t2.Odieresis = 722;
                  t2.mu = 576;
                  t2.igrave = 278;
                  t2.ohungarumlaut = 500;
                  t2.Eogonek = 667;
                  t2.dcroat = 500;
                  t2.threequarters = 750;
                  t2.Scedilla = 556;
                  t2.lcaron = 382;
                  t2.Kcommaaccent = 667;
                  t2.Lacute = 611;
                  t2.trademark = 1e3;
                  t2.edotaccent = 444;
                  t2.Igrave = 389;
                  t2.Imacron = 389;
                  t2.Lcaron = 611;
                  t2.onehalf = 750;
                  t2.lessequal = 549;
                  t2.ocircumflex = 500;
                  t2.ntilde = 556;
                  t2.Uhungarumlaut = 722;
                  t2.Eacute = 667;
                  t2.emacron = 444;
                  t2.gbreve = 500;
                  t2.onequarter = 750;
                  t2.Scaron = 556;
                  t2.Scommaaccent = 556;
                  t2.Ohungarumlaut = 722;
                  t2.degree = 400;
                  t2.ograve = 500;
                  t2.Ccaron = 667;
                  t2.ugrave = 556;
                  t2.radical = 549;
                  t2.Dcaron = 722;
                  t2.rcommaaccent = 389;
                  t2.Ntilde = 722;
                  t2.otilde = 500;
                  t2.Rcommaaccent = 667;
                  t2.Lcommaaccent = 611;
                  t2.Atilde = 667;
                  t2.Aogonek = 667;
                  t2.Aring = 667;
                  t2.Otilde = 722;
                  t2.zdotaccent = 389;
                  t2.Ecaron = 667;
                  t2.Iogonek = 389;
                  t2.kcommaaccent = 500;
                  t2.minus = 606;
                  t2.Icircumflex = 389;
                  t2.ncaron = 556;
                  t2.tcommaaccent = 278;
                  t2.logicalnot = 606;
                  t2.odieresis = 500;
                  t2.udieresis = 556;
                  t2.notequal = 549;
                  t2.gcommaaccent = 500;
                  t2.eth = 500;
                  t2.zcaron = 389;
                  t2.ncommaaccent = 556;
                  t2.onesuperior = 300;
                  t2.imacron = 278;
                  t2.Euro = 500;
                });
                t["Times-Italic"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 250;
                  t2.exclam = 333;
                  t2.quotedbl = 420;
                  t2.numbersign = 500;
                  t2.dollar = 500;
                  t2.percent = 833;
                  t2.ampersand = 778;
                  t2.quoteright = 333;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asterisk = 500;
                  t2.plus = 675;
                  t2.comma = 250;
                  t2.hyphen = 333;
                  t2.period = 250;
                  t2.slash = 278;
                  t2.zero = 500;
                  t2.one = 500;
                  t2.two = 500;
                  t2.three = 500;
                  t2.four = 500;
                  t2.five = 500;
                  t2.six = 500;
                  t2.seven = 500;
                  t2.eight = 500;
                  t2.nine = 500;
                  t2.colon = 333;
                  t2.semicolon = 333;
                  t2.less = 675;
                  t2.equal = 675;
                  t2.greater = 675;
                  t2.question = 500;
                  t2.at = 920;
                  t2.A = 611;
                  t2.B = 611;
                  t2.C = 667;
                  t2.D = 722;
                  t2.E = 611;
                  t2.F = 611;
                  t2.G = 722;
                  t2.H = 722;
                  t2.I = 333;
                  t2.J = 444;
                  t2.K = 667;
                  t2.L = 556;
                  t2.M = 833;
                  t2.N = 667;
                  t2.O = 722;
                  t2.P = 611;
                  t2.Q = 722;
                  t2.R = 611;
                  t2.S = 500;
                  t2.T = 556;
                  t2.U = 722;
                  t2.V = 611;
                  t2.W = 833;
                  t2.X = 611;
                  t2.Y = 556;
                  t2.Z = 556;
                  t2.bracketleft = 389;
                  t2.backslash = 278;
                  t2.bracketright = 389;
                  t2.asciicircum = 422;
                  t2.underscore = 500;
                  t2.quoteleft = 333;
                  t2.a = 500;
                  t2.b = 500;
                  t2.c = 444;
                  t2.d = 500;
                  t2.e = 444;
                  t2.f = 278;
                  t2.g = 500;
                  t2.h = 500;
                  t2.i = 278;
                  t2.j = 278;
                  t2.k = 444;
                  t2.l = 278;
                  t2.m = 722;
                  t2.n = 500;
                  t2.o = 500;
                  t2.p = 500;
                  t2.q = 500;
                  t2.r = 389;
                  t2.s = 389;
                  t2.t = 278;
                  t2.u = 500;
                  t2.v = 444;
                  t2.w = 667;
                  t2.x = 444;
                  t2.y = 444;
                  t2.z = 389;
                  t2.braceleft = 400;
                  t2.bar = 275;
                  t2.braceright = 400;
                  t2.asciitilde = 541;
                  t2.exclamdown = 389;
                  t2.cent = 500;
                  t2.sterling = 500;
                  t2.fraction = 167;
                  t2.yen = 500;
                  t2.florin = 500;
                  t2.section = 500;
                  t2.currency = 500;
                  t2.quotesingle = 214;
                  t2.quotedblleft = 556;
                  t2.guillemotleft = 500;
                  t2.guilsinglleft = 333;
                  t2.guilsinglright = 333;
                  t2.fi = 500;
                  t2.fl = 500;
                  t2.endash = 500;
                  t2.dagger = 500;
                  t2.daggerdbl = 500;
                  t2.periodcentered = 250;
                  t2.paragraph = 523;
                  t2.bullet = 350;
                  t2.quotesinglbase = 333;
                  t2.quotedblbase = 556;
                  t2.quotedblright = 556;
                  t2.guillemotright = 500;
                  t2.ellipsis = 889;
                  t2.perthousand = 1e3;
                  t2.questiondown = 500;
                  t2.grave = 333;
                  t2.acute = 333;
                  t2.circumflex = 333;
                  t2.tilde = 333;
                  t2.macron = 333;
                  t2.breve = 333;
                  t2.dotaccent = 333;
                  t2.dieresis = 333;
                  t2.ring = 333;
                  t2.cedilla = 333;
                  t2.hungarumlaut = 333;
                  t2.ogonek = 333;
                  t2.caron = 333;
                  t2.emdash = 889;
                  t2.AE = 889;
                  t2.ordfeminine = 276;
                  t2.Lslash = 556;
                  t2.Oslash = 722;
                  t2.OE = 944;
                  t2.ordmasculine = 310;
                  t2.ae = 667;
                  t2.dotlessi = 278;
                  t2.lslash = 278;
                  t2.oslash = 500;
                  t2.oe = 667;
                  t2.germandbls = 500;
                  t2.Idieresis = 333;
                  t2.eacute = 444;
                  t2.abreve = 500;
                  t2.uhungarumlaut = 500;
                  t2.ecaron = 444;
                  t2.Ydieresis = 556;
                  t2.divide = 675;
                  t2.Yacute = 556;
                  t2.Acircumflex = 611;
                  t2.aacute = 500;
                  t2.Ucircumflex = 722;
                  t2.yacute = 444;
                  t2.scommaaccent = 389;
                  t2.ecircumflex = 444;
                  t2.Uring = 722;
                  t2.Udieresis = 722;
                  t2.aogonek = 500;
                  t2.Uacute = 722;
                  t2.uogonek = 500;
                  t2.Edieresis = 611;
                  t2.Dcroat = 722;
                  t2.commaaccent = 250;
                  t2.copyright = 760;
                  t2.Emacron = 611;
                  t2.ccaron = 444;
                  t2.aring = 500;
                  t2.Ncommaaccent = 667;
                  t2.lacute = 278;
                  t2.agrave = 500;
                  t2.Tcommaaccent = 556;
                  t2.Cacute = 667;
                  t2.atilde = 500;
                  t2.Edotaccent = 611;
                  t2.scaron = 389;
                  t2.scedilla = 389;
                  t2.iacute = 278;
                  t2.lozenge = 471;
                  t2.Rcaron = 611;
                  t2.Gcommaaccent = 722;
                  t2.ucircumflex = 500;
                  t2.acircumflex = 500;
                  t2.Amacron = 611;
                  t2.rcaron = 389;
                  t2.ccedilla = 444;
                  t2.Zdotaccent = 556;
                  t2.Thorn = 611;
                  t2.Omacron = 722;
                  t2.Racute = 611;
                  t2.Sacute = 500;
                  t2.dcaron = 544;
                  t2.Umacron = 722;
                  t2.uring = 500;
                  t2.threesuperior = 300;
                  t2.Ograve = 722;
                  t2.Agrave = 611;
                  t2.Abreve = 611;
                  t2.multiply = 675;
                  t2.uacute = 500;
                  t2.Tcaron = 556;
                  t2.partialdiff = 476;
                  t2.ydieresis = 444;
                  t2.Nacute = 667;
                  t2.icircumflex = 278;
                  t2.Ecircumflex = 611;
                  t2.adieresis = 500;
                  t2.edieresis = 444;
                  t2.cacute = 444;
                  t2.nacute = 500;
                  t2.umacron = 500;
                  t2.Ncaron = 667;
                  t2.Iacute = 333;
                  t2.plusminus = 675;
                  t2.brokenbar = 275;
                  t2.registered = 760;
                  t2.Gbreve = 722;
                  t2.Idotaccent = 333;
                  t2.summation = 600;
                  t2.Egrave = 611;
                  t2.racute = 389;
                  t2.omacron = 500;
                  t2.Zacute = 556;
                  t2.Zcaron = 556;
                  t2.greaterequal = 549;
                  t2.Eth = 722;
                  t2.Ccedilla = 667;
                  t2.lcommaaccent = 278;
                  t2.tcaron = 300;
                  t2.eogonek = 444;
                  t2.Uogonek = 722;
                  t2.Aacute = 611;
                  t2.Adieresis = 611;
                  t2.egrave = 444;
                  t2.zacute = 389;
                  t2.iogonek = 278;
                  t2.Oacute = 722;
                  t2.oacute = 500;
                  t2.amacron = 500;
                  t2.sacute = 389;
                  t2.idieresis = 278;
                  t2.Ocircumflex = 722;
                  t2.Ugrave = 722;
                  t2.Delta = 612;
                  t2.thorn = 500;
                  t2.twosuperior = 300;
                  t2.Odieresis = 722;
                  t2.mu = 500;
                  t2.igrave = 278;
                  t2.ohungarumlaut = 500;
                  t2.Eogonek = 611;
                  t2.dcroat = 500;
                  t2.threequarters = 750;
                  t2.Scedilla = 500;
                  t2.lcaron = 300;
                  t2.Kcommaaccent = 667;
                  t2.Lacute = 556;
                  t2.trademark = 980;
                  t2.edotaccent = 444;
                  t2.Igrave = 333;
                  t2.Imacron = 333;
                  t2.Lcaron = 611;
                  t2.onehalf = 750;
                  t2.lessequal = 549;
                  t2.ocircumflex = 500;
                  t2.ntilde = 500;
                  t2.Uhungarumlaut = 722;
                  t2.Eacute = 611;
                  t2.emacron = 444;
                  t2.gbreve = 500;
                  t2.onequarter = 750;
                  t2.Scaron = 500;
                  t2.Scommaaccent = 500;
                  t2.Ohungarumlaut = 722;
                  t2.degree = 400;
                  t2.ograve = 500;
                  t2.Ccaron = 667;
                  t2.ugrave = 500;
                  t2.radical = 453;
                  t2.Dcaron = 722;
                  t2.rcommaaccent = 389;
                  t2.Ntilde = 667;
                  t2.otilde = 500;
                  t2.Rcommaaccent = 611;
                  t2.Lcommaaccent = 556;
                  t2.Atilde = 611;
                  t2.Aogonek = 611;
                  t2.Aring = 611;
                  t2.Otilde = 722;
                  t2.zdotaccent = 389;
                  t2.Ecaron = 611;
                  t2.Iogonek = 333;
                  t2.kcommaaccent = 444;
                  t2.minus = 675;
                  t2.Icircumflex = 333;
                  t2.ncaron = 500;
                  t2.tcommaaccent = 278;
                  t2.logicalnot = 675;
                  t2.odieresis = 500;
                  t2.udieresis = 500;
                  t2.notequal = 549;
                  t2.gcommaaccent = 500;
                  t2.eth = 500;
                  t2.zcaron = 389;
                  t2.ncommaaccent = 500;
                  t2.onesuperior = 300;
                  t2.imacron = 278;
                  t2.Euro = 500;
                });
                t.ZapfDingbats = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 278;
                  t2.a1 = 974;
                  t2.a2 = 961;
                  t2.a202 = 974;
                  t2.a3 = 980;
                  t2.a4 = 719;
                  t2.a5 = 789;
                  t2.a119 = 790;
                  t2.a118 = 791;
                  t2.a117 = 690;
                  t2.a11 = 960;
                  t2.a12 = 939;
                  t2.a13 = 549;
                  t2.a14 = 855;
                  t2.a15 = 911;
                  t2.a16 = 933;
                  t2.a105 = 911;
                  t2.a17 = 945;
                  t2.a18 = 974;
                  t2.a19 = 755;
                  t2.a20 = 846;
                  t2.a21 = 762;
                  t2.a22 = 761;
                  t2.a23 = 571;
                  t2.a24 = 677;
                  t2.a25 = 763;
                  t2.a26 = 760;
                  t2.a27 = 759;
                  t2.a28 = 754;
                  t2.a6 = 494;
                  t2.a7 = 552;
                  t2.a8 = 537;
                  t2.a9 = 577;
                  t2.a10 = 692;
                  t2.a29 = 786;
                  t2.a30 = 788;
                  t2.a31 = 788;
                  t2.a32 = 790;
                  t2.a33 = 793;
                  t2.a34 = 794;
                  t2.a35 = 816;
                  t2.a36 = 823;
                  t2.a37 = 789;
                  t2.a38 = 841;
                  t2.a39 = 823;
                  t2.a40 = 833;
                  t2.a41 = 816;
                  t2.a42 = 831;
                  t2.a43 = 923;
                  t2.a44 = 744;
                  t2.a45 = 723;
                  t2.a46 = 749;
                  t2.a47 = 790;
                  t2.a48 = 792;
                  t2.a49 = 695;
                  t2.a50 = 776;
                  t2.a51 = 768;
                  t2.a52 = 792;
                  t2.a53 = 759;
                  t2.a54 = 707;
                  t2.a55 = 708;
                  t2.a56 = 682;
                  t2.a57 = 701;
                  t2.a58 = 826;
                  t2.a59 = 815;
                  t2.a60 = 789;
                  t2.a61 = 789;
                  t2.a62 = 707;
                  t2.a63 = 687;
                  t2.a64 = 696;
                  t2.a65 = 689;
                  t2.a66 = 786;
                  t2.a67 = 787;
                  t2.a68 = 713;
                  t2.a69 = 791;
                  t2.a70 = 785;
                  t2.a71 = 791;
                  t2.a72 = 873;
                  t2.a73 = 761;
                  t2.a74 = 762;
                  t2.a203 = 762;
                  t2.a75 = 759;
                  t2.a204 = 759;
                  t2.a76 = 892;
                  t2.a77 = 892;
                  t2.a78 = 788;
                  t2.a79 = 784;
                  t2.a81 = 438;
                  t2.a82 = 138;
                  t2.a83 = 277;
                  t2.a84 = 415;
                  t2.a97 = 392;
                  t2.a98 = 392;
                  t2.a99 = 668;
                  t2.a100 = 668;
                  t2.a89 = 390;
                  t2.a90 = 390;
                  t2.a93 = 317;
                  t2.a94 = 317;
                  t2.a91 = 276;
                  t2.a92 = 276;
                  t2.a205 = 509;
                  t2.a85 = 509;
                  t2.a206 = 410;
                  t2.a86 = 410;
                  t2.a87 = 234;
                  t2.a88 = 234;
                  t2.a95 = 334;
                  t2.a96 = 334;
                  t2.a101 = 732;
                  t2.a102 = 544;
                  t2.a103 = 544;
                  t2.a104 = 910;
                  t2.a106 = 667;
                  t2.a107 = 760;
                  t2.a108 = 760;
                  t2.a112 = 776;
                  t2.a111 = 595;
                  t2.a110 = 694;
                  t2.a109 = 626;
                  t2.a120 = 788;
                  t2.a121 = 788;
                  t2.a122 = 788;
                  t2.a123 = 788;
                  t2.a124 = 788;
                  t2.a125 = 788;
                  t2.a126 = 788;
                  t2.a127 = 788;
                  t2.a128 = 788;
                  t2.a129 = 788;
                  t2.a130 = 788;
                  t2.a131 = 788;
                  t2.a132 = 788;
                  t2.a133 = 788;
                  t2.a134 = 788;
                  t2.a135 = 788;
                  t2.a136 = 788;
                  t2.a137 = 788;
                  t2.a138 = 788;
                  t2.a139 = 788;
                  t2.a140 = 788;
                  t2.a141 = 788;
                  t2.a142 = 788;
                  t2.a143 = 788;
                  t2.a144 = 788;
                  t2.a145 = 788;
                  t2.a146 = 788;
                  t2.a147 = 788;
                  t2.a148 = 788;
                  t2.a149 = 788;
                  t2.a150 = 788;
                  t2.a151 = 788;
                  t2.a152 = 788;
                  t2.a153 = 788;
                  t2.a154 = 788;
                  t2.a155 = 788;
                  t2.a156 = 788;
                  t2.a157 = 788;
                  t2.a158 = 788;
                  t2.a159 = 788;
                  t2.a160 = 894;
                  t2.a161 = 838;
                  t2.a163 = 1016;
                  t2.a164 = 458;
                  t2.a196 = 748;
                  t2.a165 = 924;
                  t2.a192 = 748;
                  t2.a166 = 918;
                  t2.a167 = 927;
                  t2.a168 = 928;
                  t2.a169 = 928;
                  t2.a170 = 834;
                  t2.a171 = 873;
                  t2.a172 = 828;
                  t2.a173 = 924;
                  t2.a162 = 924;
                  t2.a174 = 917;
                  t2.a175 = 930;
                  t2.a176 = 931;
                  t2.a177 = 463;
                  t2.a178 = 883;
                  t2.a179 = 836;
                  t2.a193 = 836;
                  t2.a180 = 867;
                  t2.a199 = 867;
                  t2.a181 = 696;
                  t2.a200 = 696;
                  t2.a182 = 874;
                  t2.a201 = 874;
                  t2.a183 = 760;
                  t2.a184 = 946;
                  t2.a197 = 771;
                  t2.a185 = 865;
                  t2.a194 = 771;
                  t2.a198 = 888;
                  t2.a186 = 967;
                  t2.a195 = 888;
                  t2.a187 = 831;
                  t2.a188 = 873;
                  t2.a189 = 927;
                  t2.a190 = 970;
                  t2.a191 = 918;
                });
              });
              exports2.getMetrics = getMetrics;
              const getFontBasicMetrics = (0, _core_utils.getLookupTableFactory)(function(t) {
                t.Courier = {
                  ascent: 629,
                  descent: -157,
                  capHeight: 562,
                  xHeight: -426
                };
                t["Courier-Bold"] = {
                  ascent: 629,
                  descent: -157,
                  capHeight: 562,
                  xHeight: 439
                };
                t["Courier-Oblique"] = {
                  ascent: 629,
                  descent: -157,
                  capHeight: 562,
                  xHeight: 426
                };
                t["Courier-BoldOblique"] = {
                  ascent: 629,
                  descent: -157,
                  capHeight: 562,
                  xHeight: 426
                };
                t.Helvetica = {
                  ascent: 718,
                  descent: -207,
                  capHeight: 718,
                  xHeight: 523
                };
                t["Helvetica-Bold"] = {
                  ascent: 718,
                  descent: -207,
                  capHeight: 718,
                  xHeight: 532
                };
                t["Helvetica-Oblique"] = {
                  ascent: 718,
                  descent: -207,
                  capHeight: 718,
                  xHeight: 523
                };
                t["Helvetica-BoldOblique"] = {
                  ascent: 718,
                  descent: -207,
                  capHeight: 718,
                  xHeight: 532
                };
                t["Times-Roman"] = {
                  ascent: 683,
                  descent: -217,
                  capHeight: 662,
                  xHeight: 450
                };
                t["Times-Bold"] = {
                  ascent: 683,
                  descent: -217,
                  capHeight: 676,
                  xHeight: 461
                };
                t["Times-Italic"] = {
                  ascent: 683,
                  descent: -217,
                  capHeight: 653,
                  xHeight: 441
                };
                t["Times-BoldItalic"] = {
                  ascent: 683,
                  descent: -217,
                  capHeight: 669,
                  xHeight: 462
                };
                t.Symbol = {
                  ascent: Math.NaN,
                  descent: Math.NaN,
                  capHeight: Math.NaN,
                  xHeight: Math.NaN
                };
                t.ZapfDingbats = {
                  ascent: Math.NaN,
                  descent: Math.NaN,
                  capHeight: Math.NaN,
                  xHeight: Math.NaN
                };
              });
              exports2.getFontBasicMetrics = getFontBasicMetrics;
            },
            /* 46 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.GlyfTable = void 0;
              const ON_CURVE_POINT = 1 << 0;
              const X_SHORT_VECTOR = 1 << 1;
              const Y_SHORT_VECTOR = 1 << 2;
              const REPEAT_FLAG = 1 << 3;
              const X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR = 1 << 4;
              const Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR = 1 << 5;
              const OVERLAP_SIMPLE = 1 << 6;
              const ARG_1_AND_2_ARE_WORDS = 1 << 0;
              const ARGS_ARE_XY_VALUES = 1 << 1;
              const WE_HAVE_A_SCALE = 1 << 3;
              const MORE_COMPONENTS = 1 << 5;
              const WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
              const WE_HAVE_A_TWO_BY_TWO = 1 << 7;
              const WE_HAVE_INSTRUCTIONS = 1 << 8;
              class GlyfTable {
                constructor({
                  glyfTable,
                  isGlyphLocationsLong,
                  locaTable,
                  numGlyphs
                }) {
                  this.glyphs = [];
                  const loca = new DataView(locaTable.buffer, locaTable.byteOffset, locaTable.byteLength);
                  const glyf = new DataView(glyfTable.buffer, glyfTable.byteOffset, glyfTable.byteLength);
                  const offsetSize = isGlyphLocationsLong ? 4 : 2;
                  let prev = isGlyphLocationsLong ? loca.getUint32(0) : 2 * loca.getUint16(0);
                  let pos = 0;
                  for (let i = 0; i < numGlyphs; i++) {
                    pos += offsetSize;
                    const next = isGlyphLocationsLong ? loca.getUint32(pos) : 2 * loca.getUint16(pos);
                    if (next === prev) {
                      this.glyphs.push(new Glyph({}));
                      continue;
                    }
                    const glyph = Glyph.parse(prev, glyf);
                    this.glyphs.push(glyph);
                    prev = next;
                  }
                }
                getSize() {
                  return this.glyphs.reduce((a, g) => {
                    const size = g.getSize();
                    return a + (size + 3 & ~3);
                  }, 0);
                }
                write() {
                  const totalSize = this.getSize();
                  const glyfTable = new DataView(new ArrayBuffer(totalSize));
                  const isLocationLong = totalSize > 131070;
                  const offsetSize = isLocationLong ? 4 : 2;
                  const locaTable = new DataView(new ArrayBuffer((this.glyphs.length + 1) * offsetSize));
                  if (isLocationLong) {
                    locaTable.setUint32(0, 0);
                  } else {
                    locaTable.setUint16(0, 0);
                  }
                  let pos = 0;
                  let locaIndex = 0;
                  for (const glyph of this.glyphs) {
                    pos += glyph.write(pos, glyfTable);
                    pos = pos + 3 & ~3;
                    locaIndex += offsetSize;
                    if (isLocationLong) {
                      locaTable.setUint32(locaIndex, pos);
                    } else {
                      locaTable.setUint16(locaIndex, pos >> 1);
                    }
                  }
                  return {
                    isLocationLong,
                    loca: new Uint8Array(locaTable.buffer),
                    glyf: new Uint8Array(glyfTable.buffer)
                  };
                }
                scale(factors) {
                  for (let i = 0, ii = this.glyphs.length; i < ii; i++) {
                    this.glyphs[i].scale(factors[i]);
                  }
                }
              }
              exports2.GlyfTable = GlyfTable;
              class Glyph {
                constructor({
                  header = null,
                  simple = null,
                  composites = null
                }) {
                  this.header = header;
                  this.simple = simple;
                  this.composites = composites;
                }
                static parse(pos, glyf) {
                  const [read, header] = GlyphHeader.parse(pos, glyf);
                  pos += read;
                  if (header.numberOfContours < 0) {
                    const composites = [];
                    while (true) {
                      const [n, composite] = CompositeGlyph.parse(pos, glyf);
                      pos += n;
                      composites.push(composite);
                      if (!(composite.flags & MORE_COMPONENTS)) {
                        break;
                      }
                    }
                    return new Glyph({
                      header,
                      composites
                    });
                  }
                  const simple = SimpleGlyph.parse(pos, glyf, header.numberOfContours);
                  return new Glyph({
                    header,
                    simple
                  });
                }
                getSize() {
                  if (!this.header) {
                    return 0;
                  }
                  const size = this.simple ? this.simple.getSize() : this.composites.reduce((a, c) => a + c.getSize(), 0);
                  return this.header.getSize() + size;
                }
                write(pos, buf) {
                  if (!this.header) {
                    return 0;
                  }
                  const spos = pos;
                  pos += this.header.write(pos, buf);
                  if (this.simple) {
                    pos += this.simple.write(pos, buf);
                  } else {
                    for (const composite of this.composites) {
                      pos += composite.write(pos, buf);
                    }
                  }
                  return pos - spos;
                }
                scale(factor) {
                  if (!this.header) {
                    return;
                  }
                  const xMiddle = (this.header.xMin + this.header.xMax) / 2;
                  this.header.scale(xMiddle, factor);
                  if (this.simple) {
                    this.simple.scale(xMiddle, factor);
                  } else {
                    for (const composite of this.composites) {
                      composite.scale(xMiddle, factor);
                    }
                  }
                }
              }
              class GlyphHeader {
                constructor({
                  numberOfContours,
                  xMin,
                  yMin,
                  xMax,
                  yMax
                }) {
                  this.numberOfContours = numberOfContours;
                  this.xMin = xMin;
                  this.yMin = yMin;
                  this.xMax = xMax;
                  this.yMax = yMax;
                }
                static parse(pos, glyf) {
                  return [10, new GlyphHeader({
                    numberOfContours: glyf.getInt16(pos),
                    xMin: glyf.getInt16(pos + 2),
                    yMin: glyf.getInt16(pos + 4),
                    xMax: glyf.getInt16(pos + 6),
                    yMax: glyf.getInt16(pos + 8)
                  })];
                }
                getSize() {
                  return 10;
                }
                write(pos, buf) {
                  buf.setInt16(pos, this.numberOfContours);
                  buf.setInt16(pos + 2, this.xMin);
                  buf.setInt16(pos + 4, this.yMin);
                  buf.setInt16(pos + 6, this.xMax);
                  buf.setInt16(pos + 8, this.yMax);
                  return 10;
                }
                scale(x, factor) {
                  this.xMin = Math.round(x + (this.xMin - x) * factor);
                  this.xMax = Math.round(x + (this.xMax - x) * factor);
                }
              }
              class Contour {
                constructor({
                  flags,
                  xCoordinates,
                  yCoordinates
                }) {
                  this.xCoordinates = xCoordinates;
                  this.yCoordinates = yCoordinates;
                  this.flags = flags;
                }
              }
              class SimpleGlyph {
                constructor({
                  contours,
                  instructions
                }) {
                  this.contours = contours;
                  this.instructions = instructions;
                }
                static parse(pos, glyf, numberOfContours) {
                  const endPtsOfContours = [];
                  for (let i = 0; i < numberOfContours; i++) {
                    const endPt = glyf.getUint16(pos);
                    pos += 2;
                    endPtsOfContours.push(endPt);
                  }
                  const numberOfPt = endPtsOfContours[numberOfContours - 1] + 1;
                  const instructionLength = glyf.getUint16(pos);
                  pos += 2;
                  const instructions = new Uint8Array(glyf).slice(pos, pos + instructionLength);
                  pos += instructionLength;
                  const flags = [];
                  for (let i = 0; i < numberOfPt; pos++, i++) {
                    let flag = glyf.getUint8(pos);
                    flags.push(flag);
                    if (flag & REPEAT_FLAG) {
                      const count = glyf.getUint8(++pos);
                      flag ^= REPEAT_FLAG;
                      for (let m = 0; m < count; m++) {
                        flags.push(flag);
                      }
                      i += count;
                    }
                  }
                  const allXCoordinates = [];
                  let xCoordinates = [];
                  let yCoordinates = [];
                  let pointFlags = [];
                  const contours = [];
                  let endPtsOfContoursIndex = 0;
                  let lastCoordinate = 0;
                  for (let i = 0; i < numberOfPt; i++) {
                    const flag = flags[i];
                    if (flag & X_SHORT_VECTOR) {
                      const x = glyf.getUint8(pos++);
                      lastCoordinate += flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR ? x : -x;
                      xCoordinates.push(lastCoordinate);
                    } else if (flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR) {
                      xCoordinates.push(lastCoordinate);
                    } else {
                      lastCoordinate += glyf.getInt16(pos);
                      pos += 2;
                      xCoordinates.push(lastCoordinate);
                    }
                    if (endPtsOfContours[endPtsOfContoursIndex] === i) {
                      endPtsOfContoursIndex++;
                      allXCoordinates.push(xCoordinates);
                      xCoordinates = [];
                    }
                  }
                  lastCoordinate = 0;
                  endPtsOfContoursIndex = 0;
                  for (let i = 0; i < numberOfPt; i++) {
                    const flag = flags[i];
                    if (flag & Y_SHORT_VECTOR) {
                      const y = glyf.getUint8(pos++);
                      lastCoordinate += flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR ? y : -y;
                      yCoordinates.push(lastCoordinate);
                    } else if (flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR) {
                      yCoordinates.push(lastCoordinate);
                    } else {
                      lastCoordinate += glyf.getInt16(pos);
                      pos += 2;
                      yCoordinates.push(lastCoordinate);
                    }
                    pointFlags.push(flag & ON_CURVE_POINT | flag & OVERLAP_SIMPLE);
                    if (endPtsOfContours[endPtsOfContoursIndex] === i) {
                      xCoordinates = allXCoordinates[endPtsOfContoursIndex];
                      endPtsOfContoursIndex++;
                      contours.push(new Contour({
                        flags: pointFlags,
                        xCoordinates,
                        yCoordinates
                      }));
                      yCoordinates = [];
                      pointFlags = [];
                    }
                  }
                  return new SimpleGlyph({
                    contours,
                    instructions
                  });
                }
                getSize() {
                  let size = this.contours.length * 2 + 2 + this.instructions.length;
                  let lastX = 0;
                  let lastY = 0;
                  for (const contour of this.contours) {
                    size += contour.flags.length;
                    for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {
                      const x = contour.xCoordinates[i];
                      const y = contour.yCoordinates[i];
                      let abs = Math.abs(x - lastX);
                      if (abs > 255) {
                        size += 2;
                      } else if (abs > 0) {
                        size += 1;
                      }
                      lastX = x;
                      abs = Math.abs(y - lastY);
                      if (abs > 255) {
                        size += 2;
                      } else if (abs > 0) {
                        size += 1;
                      }
                      lastY = y;
                    }
                  }
                  return size;
                }
                write(pos, buf) {
                  const spos = pos;
                  const xCoordinates = [];
                  const yCoordinates = [];
                  const flags = [];
                  let lastX = 0;
                  let lastY = 0;
                  for (const contour of this.contours) {
                    for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {
                      let flag = contour.flags[i];
                      const x = contour.xCoordinates[i];
                      let delta = x - lastX;
                      if (delta === 0) {
                        flag |= X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR;
                        xCoordinates.push(0);
                      } else {
                        const abs = Math.abs(delta);
                        if (abs <= 255) {
                          flag |= delta >= 0 ? X_SHORT_VECTOR | X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR : X_SHORT_VECTOR;
                          xCoordinates.push(abs);
                        } else {
                          xCoordinates.push(delta);
                        }
                      }
                      lastX = x;
                      const y = contour.yCoordinates[i];
                      delta = y - lastY;
                      if (delta === 0) {
                        flag |= Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR;
                        yCoordinates.push(0);
                      } else {
                        const abs = Math.abs(delta);
                        if (abs <= 255) {
                          flag |= delta >= 0 ? Y_SHORT_VECTOR | Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR : Y_SHORT_VECTOR;
                          yCoordinates.push(abs);
                        } else {
                          yCoordinates.push(delta);
                        }
                      }
                      lastY = y;
                      flags.push(flag);
                    }
                    buf.setUint16(pos, xCoordinates.length - 1);
                    pos += 2;
                  }
                  buf.setUint16(pos, this.instructions.length);
                  pos += 2;
                  if (this.instructions.length) {
                    new Uint8Array(buf.buffer, 0, buf.buffer.byteLength).set(this.instructions, pos);
                    pos += this.instructions.length;
                  }
                  for (const flag of flags) {
                    buf.setUint8(pos++, flag);
                  }
                  for (let i = 0, ii = xCoordinates.length; i < ii; i++) {
                    const x = xCoordinates[i];
                    const flag = flags[i];
                    if (flag & X_SHORT_VECTOR) {
                      buf.setUint8(pos++, x);
                    } else if (!(flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR)) {
                      buf.setInt16(pos, x);
                      pos += 2;
                    }
                  }
                  for (let i = 0, ii = yCoordinates.length; i < ii; i++) {
                    const y = yCoordinates[i];
                    const flag = flags[i];
                    if (flag & Y_SHORT_VECTOR) {
                      buf.setUint8(pos++, y);
                    } else if (!(flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR)) {
                      buf.setInt16(pos, y);
                      pos += 2;
                    }
                  }
                  return pos - spos;
                }
                scale(x, factor) {
                  for (const contour of this.contours) {
                    if (contour.xCoordinates.length === 0) {
                      continue;
                    }
                    for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {
                      contour.xCoordinates[i] = Math.round(x + (contour.xCoordinates[i] - x) * factor);
                    }
                  }
                }
              }
              class CompositeGlyph {
                constructor({
                  flags,
                  glyphIndex,
                  argument1,
                  argument2,
                  transf,
                  instructions
                }) {
                  this.flags = flags;
                  this.glyphIndex = glyphIndex;
                  this.argument1 = argument1;
                  this.argument2 = argument2;
                  this.transf = transf;
                  this.instructions = instructions;
                }
                static parse(pos, glyf) {
                  const spos = pos;
                  const transf = [];
                  let flags = glyf.getUint16(pos);
                  const glyphIndex = glyf.getUint16(pos + 2);
                  pos += 4;
                  let argument1, argument2;
                  if (flags & ARG_1_AND_2_ARE_WORDS) {
                    if (flags & ARGS_ARE_XY_VALUES) {
                      argument1 = glyf.getInt16(pos);
                      argument2 = glyf.getInt16(pos + 2);
                    } else {
                      argument1 = glyf.getUint16(pos);
                      argument2 = glyf.getUint16(pos + 2);
                    }
                    pos += 4;
                    flags ^= ARG_1_AND_2_ARE_WORDS;
                  } else {
                    if (flags & ARGS_ARE_XY_VALUES) {
                      argument1 = glyf.getInt8(pos);
                      argument2 = glyf.getInt8(pos + 1);
                    } else {
                      argument1 = glyf.getUint8(pos);
                      argument2 = glyf.getUint8(pos + 1);
                    }
                    pos += 2;
                  }
                  if (flags & WE_HAVE_A_SCALE) {
                    transf.push(glyf.getUint16(pos));
                    pos += 2;
                  } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
                    transf.push(glyf.getUint16(pos), glyf.getUint16(pos + 2));
                    pos += 4;
                  } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
                    transf.push(glyf.getUint16(pos), glyf.getUint16(pos + 2), glyf.getUint16(pos + 4), glyf.getUint16(pos + 6));
                    pos += 8;
                  }
                  let instructions = null;
                  if (flags & WE_HAVE_INSTRUCTIONS) {
                    const instructionLength = glyf.getUint16(pos);
                    pos += 2;
                    instructions = new Uint8Array(glyf).slice(pos, pos + instructionLength);
                    pos += instructionLength;
                  }
                  return [pos - spos, new CompositeGlyph({
                    flags,
                    glyphIndex,
                    argument1,
                    argument2,
                    transf,
                    instructions
                  })];
                }
                getSize() {
                  let size = 2 + 2 + this.transf.length * 2;
                  if (this.flags & WE_HAVE_INSTRUCTIONS) {
                    size += 2 + this.instructions.length;
                  }
                  size += 2;
                  if (this.flags & 2) {
                    if (!(this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127)) {
                      size += 2;
                    }
                  } else if (!(this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255)) {
                    size += 2;
                  }
                  return size;
                }
                write(pos, buf) {
                  const spos = pos;
                  if (this.flags & ARGS_ARE_XY_VALUES) {
                    if (!(this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127)) {
                      this.flags |= ARG_1_AND_2_ARE_WORDS;
                    }
                  } else if (!(this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255)) {
                    this.flags |= ARG_1_AND_2_ARE_WORDS;
                  }
                  buf.setUint16(pos, this.flags);
                  buf.setUint16(pos + 2, this.glyphIndex);
                  pos += 4;
                  if (this.flags & ARG_1_AND_2_ARE_WORDS) {
                    if (this.flags & ARGS_ARE_XY_VALUES) {
                      buf.setInt16(pos, this.argument1);
                      buf.setInt16(pos + 2, this.argument2);
                    } else {
                      buf.setUint16(pos, this.argument1);
                      buf.setUint16(pos + 2, this.argument2);
                    }
                    pos += 4;
                  } else {
                    buf.setUint8(pos, this.argument1);
                    buf.setUint8(pos + 1, this.argument2);
                    pos += 2;
                  }
                  if (this.flags & WE_HAVE_INSTRUCTIONS) {
                    buf.setUint16(pos, this.instructions.length);
                    pos += 2;
                    if (this.instructions.length) {
                      new Uint8Array(buf.buffer, 0, buf.buffer.byteLength).set(this.instructions, pos);
                      pos += this.instructions.length;
                    }
                  }
                  return pos - spos;
                }
                scale(x, factor) {
                }
              }
            },
            /* 47 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpenTypeFileBuilder = void 0;
              var _core_utils = __w_pdfjs_require__2(3);
              var _util = __w_pdfjs_require__2(2);
              function writeInt16(dest, offset, num) {
                dest[offset] = num >> 8 & 255;
                dest[offset + 1] = num & 255;
              }
              function writeInt32(dest, offset, num) {
                dest[offset] = num >> 24 & 255;
                dest[offset + 1] = num >> 16 & 255;
                dest[offset + 2] = num >> 8 & 255;
                dest[offset + 3] = num & 255;
              }
              function writeData(dest, offset, data) {
                if (data instanceof Uint8Array) {
                  dest.set(data, offset);
                } else if (typeof data === "string") {
                  for (let i = 0, ii = data.length; i < ii; i++) {
                    dest[offset++] = data.charCodeAt(i) & 255;
                  }
                } else {
                  for (const num of data) {
                    dest[offset++] = num & 255;
                  }
                }
              }
              const OTF_HEADER_SIZE = 12;
              const OTF_TABLE_ENTRY_SIZE = 16;
              class OpenTypeFileBuilder {
                constructor(sfnt) {
                  this.sfnt = sfnt;
                  this.tables = /* @__PURE__ */ Object.create(null);
                }
                static getSearchParams(entriesCount, entrySize) {
                  let maxPower2 = 1, log2 = 0;
                  while ((maxPower2 ^ entriesCount) > maxPower2) {
                    maxPower2 <<= 1;
                    log2++;
                  }
                  const searchRange = maxPower2 * entrySize;
                  return {
                    range: searchRange,
                    entry: log2,
                    rangeShift: entrySize * entriesCount - searchRange
                  };
                }
                toArray() {
                  let sfnt = this.sfnt;
                  const tables = this.tables;
                  const tablesNames = Object.keys(tables);
                  tablesNames.sort();
                  const numTables = tablesNames.length;
                  let i, j, jj, table, tableName;
                  let offset = OTF_HEADER_SIZE + numTables * OTF_TABLE_ENTRY_SIZE;
                  const tableOffsets = [offset];
                  for (i = 0; i < numTables; i++) {
                    table = tables[tablesNames[i]];
                    const paddedLength = (table.length + 3 & ~3) >>> 0;
                    offset += paddedLength;
                    tableOffsets.push(offset);
                  }
                  const file = new Uint8Array(offset);
                  for (i = 0; i < numTables; i++) {
                    table = tables[tablesNames[i]];
                    writeData(file, tableOffsets[i], table);
                  }
                  if (sfnt === "true") {
                    sfnt = (0, _util.string32)(65536);
                  }
                  file[0] = sfnt.charCodeAt(0) & 255;
                  file[1] = sfnt.charCodeAt(1) & 255;
                  file[2] = sfnt.charCodeAt(2) & 255;
                  file[3] = sfnt.charCodeAt(3) & 255;
                  writeInt16(file, 4, numTables);
                  const searchParams = OpenTypeFileBuilder.getSearchParams(numTables, 16);
                  writeInt16(file, 6, searchParams.range);
                  writeInt16(file, 8, searchParams.entry);
                  writeInt16(file, 10, searchParams.rangeShift);
                  offset = OTF_HEADER_SIZE;
                  for (i = 0; i < numTables; i++) {
                    tableName = tablesNames[i];
                    file[offset] = tableName.charCodeAt(0) & 255;
                    file[offset + 1] = tableName.charCodeAt(1) & 255;
                    file[offset + 2] = tableName.charCodeAt(2) & 255;
                    file[offset + 3] = tableName.charCodeAt(3) & 255;
                    let checksum = 0;
                    for (j = tableOffsets[i], jj = tableOffsets[i + 1]; j < jj; j += 4) {
                      const quad = (0, _core_utils.readUint32)(file, j);
                      checksum = checksum + quad >>> 0;
                    }
                    writeInt32(file, offset + 4, checksum);
                    writeInt32(file, offset + 8, tableOffsets[i]);
                    writeInt32(file, offset + 12, tables[tableName].length);
                    offset += OTF_TABLE_ENTRY_SIZE;
                  }
                  return file;
                }
                addTable(tag, data) {
                  if (tag in this.tables) {
                    throw new Error("Table " + tag + " already exists");
                  }
                  this.tables[tag] = data;
                }
              }
              exports2.OpenTypeFileBuilder = OpenTypeFileBuilder;
            },
            /* 48 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Type1Font = void 0;
              var _cff_parser = __w_pdfjs_require__2(35);
              var _util = __w_pdfjs_require__2(2);
              var _fonts_utils = __w_pdfjs_require__2(38);
              var _core_utils = __w_pdfjs_require__2(3);
              var _stream = __w_pdfjs_require__2(8);
              var _type1_parser = __w_pdfjs_require__2(49);
              function findBlock(streamBytes, signature, startIndex) {
                const streamBytesLength = streamBytes.length;
                const signatureLength = signature.length;
                const scanLength = streamBytesLength - signatureLength;
                let i = startIndex, found = false;
                while (i < scanLength) {
                  let j = 0;
                  while (j < signatureLength && streamBytes[i + j] === signature[j]) {
                    j++;
                  }
                  if (j >= signatureLength) {
                    i += j;
                    while (i < streamBytesLength && (0, _core_utils.isWhiteSpace)(streamBytes[i])) {
                      i++;
                    }
                    found = true;
                    break;
                  }
                  i++;
                }
                return {
                  found,
                  length: i
                };
              }
              function getHeaderBlock(stream, suggestedLength) {
                const EEXEC_SIGNATURE = [101, 101, 120, 101, 99];
                const streamStartPos = stream.pos;
                let headerBytes, headerBytesLength, block;
                try {
                  headerBytes = stream.getBytes(suggestedLength);
                  headerBytesLength = headerBytes.length;
                } catch {
                }
                if (headerBytesLength === suggestedLength) {
                  block = findBlock(headerBytes, EEXEC_SIGNATURE, suggestedLength - 2 * EEXEC_SIGNATURE.length);
                  if (block.found && block.length === suggestedLength) {
                    return {
                      stream: new _stream.Stream(headerBytes),
                      length: suggestedLength
                    };
                  }
                }
                (0, _util.warn)('Invalid "Length1" property in Type1 font -- trying to recover.');
                stream.pos = streamStartPos;
                const SCAN_BLOCK_LENGTH = 2048;
                let actualLength;
                while (true) {
                  const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
                  block = findBlock(scanBytes, EEXEC_SIGNATURE, 0);
                  if (block.length === 0) {
                    break;
                  }
                  stream.pos += block.length;
                  if (block.found) {
                    actualLength = stream.pos - streamStartPos;
                    break;
                  }
                }
                stream.pos = streamStartPos;
                if (actualLength) {
                  return {
                    stream: new _stream.Stream(stream.getBytes(actualLength)),
                    length: actualLength
                  };
                }
                (0, _util.warn)('Unable to recover "Length1" property in Type1 font -- using as is.');
                return {
                  stream: new _stream.Stream(stream.getBytes(suggestedLength)),
                  length: suggestedLength
                };
              }
              function getEexecBlock(stream, suggestedLength) {
                const eexecBytes = stream.getBytes();
                if (eexecBytes.length === 0) {
                  throw new _util.FormatError("getEexecBlock - no font program found.");
                }
                return {
                  stream: new _stream.Stream(eexecBytes),
                  length: eexecBytes.length
                };
              }
              class Type1Font {
                constructor(name, file, properties) {
                  const PFB_HEADER_SIZE = 6;
                  let headerBlockLength = properties.length1;
                  let eexecBlockLength = properties.length2;
                  let pfbHeader = file.peekBytes(PFB_HEADER_SIZE);
                  const pfbHeaderPresent = pfbHeader[0] === 128 && pfbHeader[1] === 1;
                  if (pfbHeaderPresent) {
                    file.skip(PFB_HEADER_SIZE);
                    headerBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
                  }
                  const headerBlock = getHeaderBlock(file, headerBlockLength);
                  const headerBlockParser = new _type1_parser.Type1Parser(headerBlock.stream, false, _fonts_utils.SEAC_ANALYSIS_ENABLED);
                  headerBlockParser.extractFontHeader(properties);
                  if (pfbHeaderPresent) {
                    pfbHeader = file.getBytes(PFB_HEADER_SIZE);
                    eexecBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
                  }
                  const eexecBlock = getEexecBlock(file, eexecBlockLength);
                  const eexecBlockParser = new _type1_parser.Type1Parser(eexecBlock.stream, true, _fonts_utils.SEAC_ANALYSIS_ENABLED);
                  const data = eexecBlockParser.extractFontProgram(properties);
                  for (const key in data.properties) {
                    properties[key] = data.properties[key];
                  }
                  const charstrings = data.charstrings;
                  const type2Charstrings = this.getType2Charstrings(charstrings);
                  const subrs = this.getType2Subrs(data.subrs);
                  this.charstrings = charstrings;
                  this.data = this.wrap(name, type2Charstrings, this.charstrings, subrs, properties);
                  this.seacs = this.getSeacs(data.charstrings);
                }
                get numGlyphs() {
                  return this.charstrings.length + 1;
                }
                getCharset() {
                  const charset = [".notdef"];
                  for (const {
                    glyphName
                  } of this.charstrings) {
                    charset.push(glyphName);
                  }
                  return charset;
                }
                getGlyphMapping(properties) {
                  const charstrings = this.charstrings;
                  if (properties.composite) {
                    const charCodeToGlyphId = /* @__PURE__ */ Object.create(null);
                    for (let glyphId2 = 0, charstringsLen = charstrings.length; glyphId2 < charstringsLen; glyphId2++) {
                      const charCode = properties.cMap.charCodeOf(glyphId2);
                      charCodeToGlyphId[charCode] = glyphId2 + 1;
                    }
                    return charCodeToGlyphId;
                  }
                  const glyphNames = [".notdef"];
                  let builtInEncoding, glyphId;
                  for (glyphId = 0; glyphId < charstrings.length; glyphId++) {
                    glyphNames.push(charstrings[glyphId].glyphName);
                  }
                  const encoding = properties.builtInEncoding;
                  if (encoding) {
                    builtInEncoding = /* @__PURE__ */ Object.create(null);
                    for (const charCode in encoding) {
                      glyphId = glyphNames.indexOf(encoding[charCode]);
                      if (glyphId >= 0) {
                        builtInEncoding[charCode] = glyphId;
                      }
                    }
                  }
                  return (0, _fonts_utils.type1FontGlyphMapping)(properties, builtInEncoding, glyphNames);
                }
                hasGlyphId(id) {
                  if (id < 0 || id >= this.numGlyphs) {
                    return false;
                  }
                  if (id === 0) {
                    return true;
                  }
                  const glyph = this.charstrings[id - 1];
                  return glyph.charstring.length > 0;
                }
                getSeacs(charstrings) {
                  const seacMap = [];
                  for (let i = 0, ii = charstrings.length; i < ii; i++) {
                    const charstring = charstrings[i];
                    if (charstring.seac) {
                      seacMap[i + 1] = charstring.seac;
                    }
                  }
                  return seacMap;
                }
                getType2Charstrings(type1Charstrings) {
                  const type2Charstrings = [];
                  for (const type1Charstring of type1Charstrings) {
                    type2Charstrings.push(type1Charstring.charstring);
                  }
                  return type2Charstrings;
                }
                getType2Subrs(type1Subrs) {
                  let bias = 0;
                  const count = type1Subrs.length;
                  if (count < 1133) {
                    bias = 107;
                  } else if (count < 33769) {
                    bias = 1131;
                  } else {
                    bias = 32768;
                  }
                  const type2Subrs = [];
                  let i;
                  for (i = 0; i < bias; i++) {
                    type2Subrs.push([11]);
                  }
                  for (i = 0; i < count; i++) {
                    type2Subrs.push(type1Subrs[i]);
                  }
                  return type2Subrs;
                }
                wrap(name, glyphs, charstrings, subrs, properties) {
                  const cff = new _cff_parser.CFF();
                  cff.header = new _cff_parser.CFFHeader(1, 0, 4, 4);
                  cff.names = [name];
                  const topDict = new _cff_parser.CFFTopDict();
                  topDict.setByName("version", 391);
                  topDict.setByName("Notice", 392);
                  topDict.setByName("FullName", 393);
                  topDict.setByName("FamilyName", 394);
                  topDict.setByName("Weight", 395);
                  topDict.setByName("Encoding", null);
                  topDict.setByName("FontMatrix", properties.fontMatrix);
                  topDict.setByName("FontBBox", properties.bbox);
                  topDict.setByName("charset", null);
                  topDict.setByName("CharStrings", null);
                  topDict.setByName("Private", null);
                  cff.topDict = topDict;
                  const strings = new _cff_parser.CFFStrings();
                  strings.add("Version 0.11");
                  strings.add("See original notice");
                  strings.add(name);
                  strings.add(name);
                  strings.add("Medium");
                  cff.strings = strings;
                  cff.globalSubrIndex = new _cff_parser.CFFIndex();
                  const count = glyphs.length;
                  const charsetArray = [".notdef"];
                  let i, ii;
                  for (i = 0; i < count; i++) {
                    const glyphName = charstrings[i].glyphName;
                    const index = _cff_parser.CFFStandardStrings.indexOf(glyphName);
                    if (index === -1) {
                      strings.add(glyphName);
                    }
                    charsetArray.push(glyphName);
                  }
                  cff.charset = new _cff_parser.CFFCharset(false, 0, charsetArray);
                  const charStringsIndex = new _cff_parser.CFFIndex();
                  charStringsIndex.add([139, 14]);
                  for (i = 0; i < count; i++) {
                    charStringsIndex.add(glyphs[i]);
                  }
                  cff.charStrings = charStringsIndex;
                  const privateDict = new _cff_parser.CFFPrivateDict();
                  privateDict.setByName("Subrs", null);
                  const fields = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
                  for (i = 0, ii = fields.length; i < ii; i++) {
                    const field = fields[i];
                    if (!(field in properties.privateData)) {
                      continue;
                    }
                    const value = properties.privateData[field];
                    if (Array.isArray(value)) {
                      for (let j = value.length - 1; j > 0; j--) {
                        value[j] -= value[j - 1];
                      }
                    }
                    privateDict.setByName(field, value);
                  }
                  cff.topDict.privateDict = privateDict;
                  const subrIndex = new _cff_parser.CFFIndex();
                  for (i = 0, ii = subrs.length; i < ii; i++) {
                    subrIndex.add(subrs[i]);
                  }
                  privateDict.subrsIndex = subrIndex;
                  const compiler = new _cff_parser.CFFCompiler(cff);
                  return compiler.compile();
                }
              }
              exports2.Type1Font = Type1Font;
            },
            /* 49 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Type1Parser = void 0;
              var _encodings = __w_pdfjs_require__2(37);
              var _core_utils = __w_pdfjs_require__2(3);
              var _stream = __w_pdfjs_require__2(8);
              var _util = __w_pdfjs_require__2(2);
              const HINTING_ENABLED = false;
              const COMMAND_MAP = {
                hstem: [1],
                vstem: [3],
                vmoveto: [4],
                rlineto: [5],
                hlineto: [6],
                vlineto: [7],
                rrcurveto: [8],
                callsubr: [10],
                flex: [12, 35],
                drop: [12, 18],
                endchar: [14],
                rmoveto: [21],
                hmoveto: [22],
                vhcurveto: [30],
                hvcurveto: [31]
              };
              class Type1CharString {
                constructor() {
                  this.width = 0;
                  this.lsb = 0;
                  this.flexing = false;
                  this.output = [];
                  this.stack = [];
                }
                convert(encoded, subrs, seacAnalysisEnabled) {
                  const count = encoded.length;
                  let error = false;
                  let wx, sbx, subrNumber;
                  for (let i = 0; i < count; i++) {
                    let value = encoded[i];
                    if (value < 32) {
                      if (value === 12) {
                        value = (value << 8) + encoded[++i];
                      }
                      switch (value) {
                        case 1:
                          if (!HINTING_ENABLED) {
                            this.stack = [];
                            break;
                          }
                          error = this.executeCommand(2, COMMAND_MAP.hstem);
                          break;
                        case 3:
                          if (!HINTING_ENABLED) {
                            this.stack = [];
                            break;
                          }
                          error = this.executeCommand(2, COMMAND_MAP.vstem);
                          break;
                        case 4:
                          if (this.flexing) {
                            if (this.stack.length < 1) {
                              error = true;
                              break;
                            }
                            const dy = this.stack.pop();
                            this.stack.push(0, dy);
                            break;
                          }
                          error = this.executeCommand(1, COMMAND_MAP.vmoveto);
                          break;
                        case 5:
                          error = this.executeCommand(2, COMMAND_MAP.rlineto);
                          break;
                        case 6:
                          error = this.executeCommand(1, COMMAND_MAP.hlineto);
                          break;
                        case 7:
                          error = this.executeCommand(1, COMMAND_MAP.vlineto);
                          break;
                        case 8:
                          error = this.executeCommand(6, COMMAND_MAP.rrcurveto);
                          break;
                        case 9:
                          this.stack = [];
                          break;
                        case 10:
                          if (this.stack.length < 1) {
                            error = true;
                            break;
                          }
                          subrNumber = this.stack.pop();
                          if (!subrs[subrNumber]) {
                            error = true;
                            break;
                          }
                          error = this.convert(subrs[subrNumber], subrs, seacAnalysisEnabled);
                          break;
                        case 11:
                          return error;
                        case 13:
                          if (this.stack.length < 2) {
                            error = true;
                            break;
                          }
                          wx = this.stack.pop();
                          sbx = this.stack.pop();
                          this.lsb = sbx;
                          this.width = wx;
                          this.stack.push(wx, sbx);
                          error = this.executeCommand(2, COMMAND_MAP.hmoveto);
                          break;
                        case 14:
                          this.output.push(COMMAND_MAP.endchar[0]);
                          break;
                        case 21:
                          if (this.flexing) {
                            break;
                          }
                          error = this.executeCommand(2, COMMAND_MAP.rmoveto);
                          break;
                        case 22:
                          if (this.flexing) {
                            this.stack.push(0);
                            break;
                          }
                          error = this.executeCommand(1, COMMAND_MAP.hmoveto);
                          break;
                        case 30:
                          error = this.executeCommand(4, COMMAND_MAP.vhcurveto);
                          break;
                        case 31:
                          error = this.executeCommand(4, COMMAND_MAP.hvcurveto);
                          break;
                        case (12 << 8) + 0:
                          this.stack = [];
                          break;
                        case (12 << 8) + 1:
                          if (!HINTING_ENABLED) {
                            this.stack = [];
                            break;
                          }
                          error = this.executeCommand(2, COMMAND_MAP.vstem);
                          break;
                        case (12 << 8) + 2:
                          if (!HINTING_ENABLED) {
                            this.stack = [];
                            break;
                          }
                          error = this.executeCommand(2, COMMAND_MAP.hstem);
                          break;
                        case (12 << 8) + 6:
                          if (seacAnalysisEnabled) {
                            const asb = this.stack.at(-5);
                            this.seac = this.stack.splice(-4, 4);
                            this.seac[0] += this.lsb - asb;
                            error = this.executeCommand(0, COMMAND_MAP.endchar);
                          } else {
                            error = this.executeCommand(4, COMMAND_MAP.endchar);
                          }
                          break;
                        case (12 << 8) + 7:
                          if (this.stack.length < 4) {
                            error = true;
                            break;
                          }
                          this.stack.pop();
                          wx = this.stack.pop();
                          const sby = this.stack.pop();
                          sbx = this.stack.pop();
                          this.lsb = sbx;
                          this.width = wx;
                          this.stack.push(wx, sbx, sby);
                          error = this.executeCommand(3, COMMAND_MAP.rmoveto);
                          break;
                        case (12 << 8) + 12:
                          if (this.stack.length < 2) {
                            error = true;
                            break;
                          }
                          const num2 = this.stack.pop();
                          const num1 = this.stack.pop();
                          this.stack.push(num1 / num2);
                          break;
                        case (12 << 8) + 16:
                          if (this.stack.length < 2) {
                            error = true;
                            break;
                          }
                          subrNumber = this.stack.pop();
                          const numArgs = this.stack.pop();
                          if (subrNumber === 0 && numArgs === 3) {
                            const flexArgs = this.stack.splice(-17, 17);
                            this.stack.push(flexArgs[2] + flexArgs[0], flexArgs[3] + flexArgs[1], flexArgs[4], flexArgs[5], flexArgs[6], flexArgs[7], flexArgs[8], flexArgs[9], flexArgs[10], flexArgs[11], flexArgs[12], flexArgs[13], flexArgs[14]);
                            error = this.executeCommand(13, COMMAND_MAP.flex, true);
                            this.flexing = false;
                            this.stack.push(flexArgs[15], flexArgs[16]);
                          } else if (subrNumber === 1 && numArgs === 0) {
                            this.flexing = true;
                          }
                          break;
                        case (12 << 8) + 17:
                          break;
                        case (12 << 8) + 33:
                          this.stack = [];
                          break;
                        default:
                          (0, _util.warn)('Unknown type 1 charstring command of "' + value + '"');
                          break;
                      }
                      if (error) {
                        break;
                      }
                      continue;
                    } else if (value <= 246) {
                      value -= 139;
                    } else if (value <= 250) {
                      value = (value - 247) * 256 + encoded[++i] + 108;
                    } else if (value <= 254) {
                      value = -((value - 251) * 256) - encoded[++i] - 108;
                    } else {
                      value = (encoded[++i] & 255) << 24 | (encoded[++i] & 255) << 16 | (encoded[++i] & 255) << 8 | (encoded[++i] & 255) << 0;
                    }
                    this.stack.push(value);
                  }
                  return error;
                }
                executeCommand(howManyArgs, command, keepStack) {
                  const stackLength = this.stack.length;
                  if (howManyArgs > stackLength) {
                    return true;
                  }
                  const start = stackLength - howManyArgs;
                  for (let i = start; i < stackLength; i++) {
                    let value = this.stack[i];
                    if (Number.isInteger(value)) {
                      this.output.push(28, value >> 8 & 255, value & 255);
                    } else {
                      value = 65536 * value | 0;
                      this.output.push(255, value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
                    }
                  }
                  this.output.push(...command);
                  if (keepStack) {
                    this.stack.splice(start, howManyArgs);
                  } else {
                    this.stack.length = 0;
                  }
                  return false;
                }
              }
              const EEXEC_ENCRYPT_KEY = 55665;
              const CHAR_STRS_ENCRYPT_KEY = 4330;
              function isHexDigit(code) {
                return code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102;
              }
              function decrypt(data, key, discardNumber) {
                if (discardNumber >= data.length) {
                  return new Uint8Array(0);
                }
                const c1 = 52845, c2 = 22719;
                let r = key | 0, i, j;
                for (i = 0; i < discardNumber; i++) {
                  r = (data[i] + r) * c1 + c2 & (1 << 16) - 1;
                }
                const count = data.length - discardNumber;
                const decrypted = new Uint8Array(count);
                for (i = discardNumber, j = 0; j < count; i++, j++) {
                  const value = data[i];
                  decrypted[j] = value ^ r >> 8;
                  r = (value + r) * c1 + c2 & (1 << 16) - 1;
                }
                return decrypted;
              }
              function decryptAscii(data, key, discardNumber) {
                const c1 = 52845, c2 = 22719;
                let r = key | 0;
                const count = data.length, maybeLength = count >>> 1;
                const decrypted = new Uint8Array(maybeLength);
                let i, j;
                for (i = 0, j = 0; i < count; i++) {
                  const digit1 = data[i];
                  if (!isHexDigit(digit1)) {
                    continue;
                  }
                  i++;
                  let digit2;
                  while (i < count && !isHexDigit(digit2 = data[i])) {
                    i++;
                  }
                  if (i < count) {
                    const value = parseInt(String.fromCharCode(digit1, digit2), 16);
                    decrypted[j++] = value ^ r >> 8;
                    r = (value + r) * c1 + c2 & (1 << 16) - 1;
                  }
                }
                return decrypted.slice(discardNumber, j);
              }
              function isSpecial(c) {
                return c === 47 || c === 91 || c === 93 || c === 123 || c === 125 || c === 40 || c === 41;
              }
              class Type1Parser {
                constructor(stream, encrypted, seacAnalysisEnabled) {
                  if (encrypted) {
                    const data = stream.getBytes();
                    const isBinary = !((isHexDigit(data[0]) || (0, _core_utils.isWhiteSpace)(data[0])) && isHexDigit(data[1]) && isHexDigit(data[2]) && isHexDigit(data[3]) && isHexDigit(data[4]) && isHexDigit(data[5]) && isHexDigit(data[6]) && isHexDigit(data[7]));
                    stream = new _stream.Stream(isBinary ? decrypt(data, EEXEC_ENCRYPT_KEY, 4) : decryptAscii(data, EEXEC_ENCRYPT_KEY, 4));
                  }
                  this.seacAnalysisEnabled = !!seacAnalysisEnabled;
                  this.stream = stream;
                  this.nextChar();
                }
                readNumberArray() {
                  this.getToken();
                  const array = [];
                  while (true) {
                    const token = this.getToken();
                    if (token === null || token === "]" || token === "}") {
                      break;
                    }
                    array.push(parseFloat(token || 0));
                  }
                  return array;
                }
                readNumber() {
                  const token = this.getToken();
                  return parseFloat(token || 0);
                }
                readInt() {
                  const token = this.getToken();
                  return parseInt(token || 0, 10) | 0;
                }
                readBoolean() {
                  const token = this.getToken();
                  return token === "true" ? 1 : 0;
                }
                nextChar() {
                  return this.currentChar = this.stream.getByte();
                }
                prevChar() {
                  this.stream.skip(-2);
                  return this.currentChar = this.stream.getByte();
                }
                getToken() {
                  let comment = false;
                  let ch = this.currentChar;
                  while (true) {
                    if (ch === -1) {
                      return null;
                    }
                    if (comment) {
                      if (ch === 10 || ch === 13) {
                        comment = false;
                      }
                    } else if (ch === 37) {
                      comment = true;
                    } else if (!(0, _core_utils.isWhiteSpace)(ch)) {
                      break;
                    }
                    ch = this.nextChar();
                  }
                  if (isSpecial(ch)) {
                    this.nextChar();
                    return String.fromCharCode(ch);
                  }
                  let token = "";
                  do {
                    token += String.fromCharCode(ch);
                    ch = this.nextChar();
                  } while (ch >= 0 && !(0, _core_utils.isWhiteSpace)(ch) && !isSpecial(ch));
                  return token;
                }
                readCharStrings(bytes, lenIV) {
                  if (lenIV === -1) {
                    return bytes;
                  }
                  return decrypt(bytes, CHAR_STRS_ENCRYPT_KEY, lenIV);
                }
                extractFontProgram(properties) {
                  const stream = this.stream;
                  const subrs = [], charstrings = [];
                  const privateData = /* @__PURE__ */ Object.create(null);
                  privateData.lenIV = 4;
                  const program = {
                    subrs: [],
                    charstrings: [],
                    properties: {
                      privateData
                    }
                  };
                  let token, length, data, lenIV;
                  while ((token = this.getToken()) !== null) {
                    if (token !== "/") {
                      continue;
                    }
                    token = this.getToken();
                    switch (token) {
                      case "CharStrings":
                        this.getToken();
                        this.getToken();
                        this.getToken();
                        this.getToken();
                        while (true) {
                          token = this.getToken();
                          if (token === null || token === "end") {
                            break;
                          }
                          if (token !== "/") {
                            continue;
                          }
                          const glyph = this.getToken();
                          length = this.readInt();
                          this.getToken();
                          data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
                          lenIV = program.properties.privateData.lenIV;
                          const encoded = this.readCharStrings(data, lenIV);
                          this.nextChar();
                          token = this.getToken();
                          if (token === "noaccess") {
                            this.getToken();
                          } else if (token === "/") {
                            this.prevChar();
                          }
                          charstrings.push({
                            glyph,
                            encoded
                          });
                        }
                        break;
                      case "Subrs":
                        this.readInt();
                        this.getToken();
                        while (this.getToken() === "dup") {
                          const index = this.readInt();
                          length = this.readInt();
                          this.getToken();
                          data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
                          lenIV = program.properties.privateData.lenIV;
                          const encoded = this.readCharStrings(data, lenIV);
                          this.nextChar();
                          token = this.getToken();
                          if (token === "noaccess") {
                            this.getToken();
                          }
                          subrs[index] = encoded;
                        }
                        break;
                      case "BlueValues":
                      case "OtherBlues":
                      case "FamilyBlues":
                      case "FamilyOtherBlues":
                        const blueArray = this.readNumberArray();
                        if (blueArray.length > 0 && blueArray.length % 2 === 0 && HINTING_ENABLED) {
                          program.properties.privateData[token] = blueArray;
                        }
                        break;
                      case "StemSnapH":
                      case "StemSnapV":
                        program.properties.privateData[token] = this.readNumberArray();
                        break;
                      case "StdHW":
                      case "StdVW":
                        program.properties.privateData[token] = this.readNumberArray()[0];
                        break;
                      case "BlueShift":
                      case "lenIV":
                      case "BlueFuzz":
                      case "BlueScale":
                      case "LanguageGroup":
                        program.properties.privateData[token] = this.readNumber();
                        break;
                      case "ExpansionFactor":
                        program.properties.privateData[token] = this.readNumber() || 0.06;
                        break;
                      case "ForceBold":
                        program.properties.privateData[token] = this.readBoolean();
                        break;
                    }
                  }
                  for (const {
                    encoded,
                    glyph
                  } of charstrings) {
                    const charString = new Type1CharString();
                    const error = charString.convert(encoded, subrs, this.seacAnalysisEnabled);
                    let output = charString.output;
                    if (error) {
                      output = [14];
                    }
                    const charStringObject = {
                      glyphName: glyph,
                      charstring: output,
                      width: charString.width,
                      lsb: charString.lsb,
                      seac: charString.seac
                    };
                    if (glyph === ".notdef") {
                      program.charstrings.unshift(charStringObject);
                    } else {
                      program.charstrings.push(charStringObject);
                    }
                    if (properties.builtInEncoding) {
                      const index = properties.builtInEncoding.indexOf(glyph);
                      if (index > -1 && properties.widths[index] === void 0 && index >= properties.firstChar && index <= properties.lastChar) {
                        properties.widths[index] = charString.width;
                      }
                    }
                  }
                  return program;
                }
                extractFontHeader(properties) {
                  let token;
                  while ((token = this.getToken()) !== null) {
                    if (token !== "/") {
                      continue;
                    }
                    token = this.getToken();
                    switch (token) {
                      case "FontMatrix":
                        const matrix = this.readNumberArray();
                        properties.fontMatrix = matrix;
                        break;
                      case "Encoding":
                        const encodingArg = this.getToken();
                        let encoding;
                        if (!/^\d+$/.test(encodingArg)) {
                          encoding = (0, _encodings.getEncoding)(encodingArg);
                        } else {
                          encoding = [];
                          const size = parseInt(encodingArg, 10) | 0;
                          this.getToken();
                          for (let j = 0; j < size; j++) {
                            token = this.getToken();
                            while (token !== "dup" && token !== "def") {
                              token = this.getToken();
                              if (token === null) {
                                return;
                              }
                            }
                            if (token === "def") {
                              break;
                            }
                            const index = this.readInt();
                            this.getToken();
                            const glyph = this.getToken();
                            encoding[index] = glyph;
                            this.getToken();
                          }
                        }
                        properties.builtInEncoding = encoding;
                        break;
                      case "FontBBox":
                        const fontBBox = this.readNumberArray();
                        properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
                        properties.descent = Math.min(fontBBox[1], fontBBox[3]);
                        properties.ascentScaled = true;
                        break;
                    }
                  }
                }
              }
              exports2.Type1Parser = Type1Parser;
            },
            /* 50 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Pattern = void 0;
              exports2.clearPatternCaches = clearPatternCaches;
              exports2.getTilingPatternIR = getTilingPatternIR;
              var _util = __w_pdfjs_require__2(2);
              var _base_stream = __w_pdfjs_require__2(5);
              var _colorspace = __w_pdfjs_require__2(12);
              var _core_utils = __w_pdfjs_require__2(3);
              const ShadingType = {
                FUNCTION_BASED: 1,
                AXIAL: 2,
                RADIAL: 3,
                FREE_FORM_MESH: 4,
                LATTICE_FORM_MESH: 5,
                COONS_PATCH_MESH: 6,
                TENSOR_PATCH_MESH: 7
              };
              class Pattern {
                constructor() {
                  (0, _util.unreachable)("Cannot initialize Pattern.");
                }
                static parseShading(shading, xref, res, pdfFunctionFactory, localColorSpaceCache) {
                  const dict = shading instanceof _base_stream.BaseStream ? shading.dict : shading;
                  const type = dict.get("ShadingType");
                  try {
                    switch (type) {
                      case ShadingType.AXIAL:
                      case ShadingType.RADIAL:
                        return new RadialAxialShading(dict, xref, res, pdfFunctionFactory, localColorSpaceCache);
                      case ShadingType.FREE_FORM_MESH:
                      case ShadingType.LATTICE_FORM_MESH:
                      case ShadingType.COONS_PATCH_MESH:
                      case ShadingType.TENSOR_PATCH_MESH:
                        return new MeshShading(shading, xref, res, pdfFunctionFactory, localColorSpaceCache);
                      default:
                        throw new _util.FormatError("Unsupported ShadingType: " + type);
                    }
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)(ex);
                    return new DummyShading();
                  }
                }
              }
              exports2.Pattern = Pattern;
              const _BaseShading = class _BaseShading {
                constructor() {
                  if (this.constructor === _BaseShading) {
                    (0, _util.unreachable)("Cannot initialize BaseShading.");
                  }
                }
                getIR() {
                  (0, _util.unreachable)("Abstract method `getIR` called.");
                }
              };
              __publicField(_BaseShading, "SMALL_NUMBER", 1e-6);
              let BaseShading = _BaseShading;
              class RadialAxialShading extends BaseShading {
                constructor(dict, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
                  super();
                  this.coordsArr = dict.getArray("Coords");
                  this.shadingType = dict.get("ShadingType");
                  const cs = _colorspace.ColorSpace.parse({
                    cs: dict.getRaw("CS") || dict.getRaw("ColorSpace"),
                    xref,
                    resources,
                    pdfFunctionFactory,
                    localColorSpaceCache
                  });
                  const bbox = dict.getArray("BBox");
                  this.bbox = Array.isArray(bbox) && bbox.length === 4 ? _util.Util.normalizeRect(bbox) : null;
                  let t0 = 0, t1 = 1;
                  if (dict.has("Domain")) {
                    const domainArr = dict.getArray("Domain");
                    t0 = domainArr[0];
                    t1 = domainArr[1];
                  }
                  let extendStart = false, extendEnd = false;
                  if (dict.has("Extend")) {
                    const extendArr = dict.getArray("Extend");
                    extendStart = extendArr[0];
                    extendEnd = extendArr[1];
                  }
                  if (this.shadingType === ShadingType.RADIAL && (!extendStart || !extendEnd)) {
                    const [x1, y1, r1, x2, y2, r2] = this.coordsArr;
                    const distance = Math.hypot(x1 - x2, y1 - y2);
                    if (r1 <= r2 + distance && r2 <= r1 + distance) {
                      (0, _util.warn)("Unsupported radial gradient.");
                    }
                  }
                  this.extendStart = extendStart;
                  this.extendEnd = extendEnd;
                  const fnObj = dict.getRaw("Function");
                  const fn = pdfFunctionFactory.createFromArray(fnObj);
                  const NUMBER_OF_SAMPLES = 840;
                  const step = (t1 - t0) / NUMBER_OF_SAMPLES;
                  const colorStops = this.colorStops = [];
                  if (t0 >= t1 || step <= 0) {
                    (0, _util.info)("Bad shading domain.");
                    return;
                  }
                  const color = new Float32Array(cs.numComps), ratio = new Float32Array(1);
                  let rgbColor;
                  let iBase = 0;
                  ratio[0] = t0;
                  fn(ratio, 0, color, 0);
                  let rgbBase = cs.getRgb(color, 0);
                  const cssColorBase = _util.Util.makeHexColor(rgbBase[0], rgbBase[1], rgbBase[2]);
                  colorStops.push([0, cssColorBase]);
                  let iPrev = 1;
                  ratio[0] = t0 + step;
                  fn(ratio, 0, color, 0);
                  let rgbPrev = cs.getRgb(color, 0);
                  let maxSlopeR = rgbPrev[0] - rgbBase[0] + 1;
                  let maxSlopeG = rgbPrev[1] - rgbBase[1] + 1;
                  let maxSlopeB = rgbPrev[2] - rgbBase[2] + 1;
                  let minSlopeR = rgbPrev[0] - rgbBase[0] - 1;
                  let minSlopeG = rgbPrev[1] - rgbBase[1] - 1;
                  let minSlopeB = rgbPrev[2] - rgbBase[2] - 1;
                  for (let i = 2; i < NUMBER_OF_SAMPLES; i++) {
                    ratio[0] = t0 + i * step;
                    fn(ratio, 0, color, 0);
                    rgbColor = cs.getRgb(color, 0);
                    const run = i - iBase;
                    maxSlopeR = Math.min(maxSlopeR, (rgbColor[0] - rgbBase[0] + 1) / run);
                    maxSlopeG = Math.min(maxSlopeG, (rgbColor[1] - rgbBase[1] + 1) / run);
                    maxSlopeB = Math.min(maxSlopeB, (rgbColor[2] - rgbBase[2] + 1) / run);
                    minSlopeR = Math.max(minSlopeR, (rgbColor[0] - rgbBase[0] - 1) / run);
                    minSlopeG = Math.max(minSlopeG, (rgbColor[1] - rgbBase[1] - 1) / run);
                    minSlopeB = Math.max(minSlopeB, (rgbColor[2] - rgbBase[2] - 1) / run);
                    const slopesExist = minSlopeR <= maxSlopeR && minSlopeG <= maxSlopeG && minSlopeB <= maxSlopeB;
                    if (!slopesExist) {
                      const cssColor2 = _util.Util.makeHexColor(rgbPrev[0], rgbPrev[1], rgbPrev[2]);
                      colorStops.push([iPrev / NUMBER_OF_SAMPLES, cssColor2]);
                      maxSlopeR = rgbColor[0] - rgbPrev[0] + 1;
                      maxSlopeG = rgbColor[1] - rgbPrev[1] + 1;
                      maxSlopeB = rgbColor[2] - rgbPrev[2] + 1;
                      minSlopeR = rgbColor[0] - rgbPrev[0] - 1;
                      minSlopeG = rgbColor[1] - rgbPrev[1] - 1;
                      minSlopeB = rgbColor[2] - rgbPrev[2] - 1;
                      iBase = iPrev;
                      rgbBase = rgbPrev;
                    }
                    iPrev = i;
                    rgbPrev = rgbColor;
                  }
                  const cssColor = _util.Util.makeHexColor(rgbPrev[0], rgbPrev[1], rgbPrev[2]);
                  colorStops.push([1, cssColor]);
                  let background = "transparent";
                  if (dict.has("Background")) {
                    rgbColor = cs.getRgb(dict.get("Background"), 0);
                    background = _util.Util.makeHexColor(rgbColor[0], rgbColor[1], rgbColor[2]);
                  }
                  if (!extendStart) {
                    colorStops.unshift([0, background]);
                    colorStops[1][0] += BaseShading.SMALL_NUMBER;
                  }
                  if (!extendEnd) {
                    colorStops.at(-1)[0] -= BaseShading.SMALL_NUMBER;
                    colorStops.push([1, background]);
                  }
                  this.colorStops = colorStops;
                }
                getIR() {
                  const coordsArr = this.coordsArr;
                  const shadingType = this.shadingType;
                  let type, p0, p1, r0, r1;
                  if (shadingType === ShadingType.AXIAL) {
                    p0 = [coordsArr[0], coordsArr[1]];
                    p1 = [coordsArr[2], coordsArr[3]];
                    r0 = null;
                    r1 = null;
                    type = "axial";
                  } else if (shadingType === ShadingType.RADIAL) {
                    p0 = [coordsArr[0], coordsArr[1]];
                    p1 = [coordsArr[3], coordsArr[4]];
                    r0 = coordsArr[2];
                    r1 = coordsArr[5];
                    type = "radial";
                  } else {
                    (0, _util.unreachable)(`getPattern type unknown: ${shadingType}`);
                  }
                  return ["RadialAxial", type, this.bbox, this.colorStops, p0, p1, r0, r1];
                }
              }
              class MeshStreamReader {
                constructor(stream, context) {
                  this.stream = stream;
                  this.context = context;
                  this.buffer = 0;
                  this.bufferLength = 0;
                  const numComps = context.numComps;
                  this.tmpCompsBuf = new Float32Array(numComps);
                  const csNumComps = context.colorSpace.numComps;
                  this.tmpCsCompsBuf = context.colorFn ? new Float32Array(csNumComps) : this.tmpCompsBuf;
                }
                get hasData() {
                  if (this.stream.end) {
                    return this.stream.pos < this.stream.end;
                  }
                  if (this.bufferLength > 0) {
                    return true;
                  }
                  const nextByte = this.stream.getByte();
                  if (nextByte < 0) {
                    return false;
                  }
                  this.buffer = nextByte;
                  this.bufferLength = 8;
                  return true;
                }
                readBits(n) {
                  let buffer = this.buffer;
                  let bufferLength = this.bufferLength;
                  if (n === 32) {
                    if (bufferLength === 0) {
                      return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
                    }
                    buffer = buffer << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
                    const nextByte = this.stream.getByte();
                    this.buffer = nextByte & (1 << bufferLength) - 1;
                    return (buffer << 8 - bufferLength | (nextByte & 255) >> bufferLength) >>> 0;
                  }
                  if (n === 8 && bufferLength === 0) {
                    return this.stream.getByte();
                  }
                  while (bufferLength < n) {
                    buffer = buffer << 8 | this.stream.getByte();
                    bufferLength += 8;
                  }
                  bufferLength -= n;
                  this.bufferLength = bufferLength;
                  this.buffer = buffer & (1 << bufferLength) - 1;
                  return buffer >> bufferLength;
                }
                align() {
                  this.buffer = 0;
                  this.bufferLength = 0;
                }
                readFlag() {
                  return this.readBits(this.context.bitsPerFlag);
                }
                readCoordinate() {
                  const bitsPerCoordinate = this.context.bitsPerCoordinate;
                  const xi = this.readBits(bitsPerCoordinate);
                  const yi = this.readBits(bitsPerCoordinate);
                  const decode = this.context.decode;
                  const scale = bitsPerCoordinate < 32 ? 1 / ((1 << bitsPerCoordinate) - 1) : 23283064365386963e-26;
                  return [xi * scale * (decode[1] - decode[0]) + decode[0], yi * scale * (decode[3] - decode[2]) + decode[2]];
                }
                readComponents() {
                  const numComps = this.context.numComps;
                  const bitsPerComponent = this.context.bitsPerComponent;
                  const scale = bitsPerComponent < 32 ? 1 / ((1 << bitsPerComponent) - 1) : 23283064365386963e-26;
                  const decode = this.context.decode;
                  const components = this.tmpCompsBuf;
                  for (let i = 0, j = 4; i < numComps; i++, j += 2) {
                    const ci = this.readBits(bitsPerComponent);
                    components[i] = ci * scale * (decode[j + 1] - decode[j]) + decode[j];
                  }
                  const color = this.tmpCsCompsBuf;
                  if (this.context.colorFn) {
                    this.context.colorFn(components, 0, color, 0);
                  }
                  return this.context.colorSpace.getRgb(color, 0);
                }
              }
              let bCache = /* @__PURE__ */ Object.create(null);
              function buildB(count) {
                const lut = [];
                for (let i = 0; i <= count; i++) {
                  const t = i / count, t_ = 1 - t;
                  lut.push(new Float32Array([t_ ** 3, 3 * t * t_ ** 2, 3 * t ** 2 * t_, t ** 3]));
                }
                return lut;
              }
              function getB(count) {
                return bCache[count] || (bCache[count] = buildB(count));
              }
              function clearPatternCaches() {
                bCache = /* @__PURE__ */ Object.create(null);
              }
              const _MeshShading = class _MeshShading extends BaseShading {
                constructor(stream, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
                  super();
                  if (!(stream instanceof _base_stream.BaseStream)) {
                    throw new _util.FormatError("Mesh data is not a stream");
                  }
                  const dict = stream.dict;
                  this.shadingType = dict.get("ShadingType");
                  const bbox = dict.getArray("BBox");
                  this.bbox = Array.isArray(bbox) && bbox.length === 4 ? _util.Util.normalizeRect(bbox) : null;
                  const cs = _colorspace.ColorSpace.parse({
                    cs: dict.getRaw("CS") || dict.getRaw("ColorSpace"),
                    xref,
                    resources,
                    pdfFunctionFactory,
                    localColorSpaceCache
                  });
                  this.background = dict.has("Background") ? cs.getRgb(dict.get("Background"), 0) : null;
                  const fnObj = dict.getRaw("Function");
                  const fn = fnObj ? pdfFunctionFactory.createFromArray(fnObj) : null;
                  this.coords = [];
                  this.colors = [];
                  this.figures = [];
                  const decodeContext = {
                    bitsPerCoordinate: dict.get("BitsPerCoordinate"),
                    bitsPerComponent: dict.get("BitsPerComponent"),
                    bitsPerFlag: dict.get("BitsPerFlag"),
                    decode: dict.getArray("Decode"),
                    colorFn: fn,
                    colorSpace: cs,
                    numComps: fn ? 1 : cs.numComps
                  };
                  const reader = new MeshStreamReader(stream, decodeContext);
                  let patchMesh = false;
                  switch (this.shadingType) {
                    case ShadingType.FREE_FORM_MESH:
                      this._decodeType4Shading(reader);
                      break;
                    case ShadingType.LATTICE_FORM_MESH:
                      const verticesPerRow = dict.get("VerticesPerRow") | 0;
                      if (verticesPerRow < 2) {
                        throw new _util.FormatError("Invalid VerticesPerRow");
                      }
                      this._decodeType5Shading(reader, verticesPerRow);
                      break;
                    case ShadingType.COONS_PATCH_MESH:
                      this._decodeType6Shading(reader);
                      patchMesh = true;
                      break;
                    case ShadingType.TENSOR_PATCH_MESH:
                      this._decodeType7Shading(reader);
                      patchMesh = true;
                      break;
                    default:
                      (0, _util.unreachable)("Unsupported mesh type.");
                      break;
                  }
                  if (patchMesh) {
                    this._updateBounds();
                    for (let i = 0, ii = this.figures.length; i < ii; i++) {
                      this._buildFigureFromPatch(i);
                    }
                  }
                  this._updateBounds();
                  this._packData();
                }
                _decodeType4Shading(reader) {
                  const coords = this.coords;
                  const colors = this.colors;
                  const operators = [];
                  const ps = [];
                  let verticesLeft = 0;
                  while (reader.hasData) {
                    const f = reader.readFlag();
                    const coord = reader.readCoordinate();
                    const color = reader.readComponents();
                    if (verticesLeft === 0) {
                      if (!(0 <= f && f <= 2)) {
                        throw new _util.FormatError("Unknown type4 flag");
                      }
                      switch (f) {
                        case 0:
                          verticesLeft = 3;
                          break;
                        case 1:
                          ps.push(ps.at(-2), ps.at(-1));
                          verticesLeft = 1;
                          break;
                        case 2:
                          ps.push(ps.at(-3), ps.at(-1));
                          verticesLeft = 1;
                          break;
                      }
                      operators.push(f);
                    }
                    ps.push(coords.length);
                    coords.push(coord);
                    colors.push(color);
                    verticesLeft--;
                    reader.align();
                  }
                  this.figures.push({
                    type: "triangles",
                    coords: new Int32Array(ps),
                    colors: new Int32Array(ps)
                  });
                }
                _decodeType5Shading(reader, verticesPerRow) {
                  const coords = this.coords;
                  const colors = this.colors;
                  const ps = [];
                  while (reader.hasData) {
                    const coord = reader.readCoordinate();
                    const color = reader.readComponents();
                    ps.push(coords.length);
                    coords.push(coord);
                    colors.push(color);
                  }
                  this.figures.push({
                    type: "lattice",
                    coords: new Int32Array(ps),
                    colors: new Int32Array(ps),
                    verticesPerRow
                  });
                }
                _decodeType6Shading(reader) {
                  const coords = this.coords;
                  const colors = this.colors;
                  const ps = new Int32Array(16);
                  const cs = new Int32Array(4);
                  while (reader.hasData) {
                    const f = reader.readFlag();
                    if (!(0 <= f && f <= 3)) {
                      throw new _util.FormatError("Unknown type6 flag");
                    }
                    const pi = coords.length;
                    for (let i = 0, ii = f !== 0 ? 8 : 12; i < ii; i++) {
                      coords.push(reader.readCoordinate());
                    }
                    const ci = colors.length;
                    for (let i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
                      colors.push(reader.readComponents());
                    }
                    let tmp1, tmp2, tmp3, tmp4;
                    switch (f) {
                      case 0:
                        ps[12] = pi + 3;
                        ps[13] = pi + 4;
                        ps[14] = pi + 5;
                        ps[15] = pi + 6;
                        ps[8] = pi + 2;
                        ps[11] = pi + 7;
                        ps[4] = pi + 1;
                        ps[7] = pi + 8;
                        ps[0] = pi;
                        ps[1] = pi + 11;
                        ps[2] = pi + 10;
                        ps[3] = pi + 9;
                        cs[2] = ci + 1;
                        cs[3] = ci + 2;
                        cs[0] = ci;
                        cs[1] = ci + 3;
                        break;
                      case 1:
                        tmp1 = ps[12];
                        tmp2 = ps[13];
                        tmp3 = ps[14];
                        tmp4 = ps[15];
                        ps[12] = tmp4;
                        ps[13] = pi + 0;
                        ps[14] = pi + 1;
                        ps[15] = pi + 2;
                        ps[8] = tmp3;
                        ps[11] = pi + 3;
                        ps[4] = tmp2;
                        ps[7] = pi + 4;
                        ps[0] = tmp1;
                        ps[1] = pi + 7;
                        ps[2] = pi + 6;
                        ps[3] = pi + 5;
                        tmp1 = cs[2];
                        tmp2 = cs[3];
                        cs[2] = tmp2;
                        cs[3] = ci;
                        cs[0] = tmp1;
                        cs[1] = ci + 1;
                        break;
                      case 2:
                        tmp1 = ps[15];
                        tmp2 = ps[11];
                        ps[12] = ps[3];
                        ps[13] = pi + 0;
                        ps[14] = pi + 1;
                        ps[15] = pi + 2;
                        ps[8] = ps[7];
                        ps[11] = pi + 3;
                        ps[4] = tmp2;
                        ps[7] = pi + 4;
                        ps[0] = tmp1;
                        ps[1] = pi + 7;
                        ps[2] = pi + 6;
                        ps[3] = pi + 5;
                        tmp1 = cs[3];
                        cs[2] = cs[1];
                        cs[3] = ci;
                        cs[0] = tmp1;
                        cs[1] = ci + 1;
                        break;
                      case 3:
                        ps[12] = ps[0];
                        ps[13] = pi + 0;
                        ps[14] = pi + 1;
                        ps[15] = pi + 2;
                        ps[8] = ps[1];
                        ps[11] = pi + 3;
                        ps[4] = ps[2];
                        ps[7] = pi + 4;
                        ps[0] = ps[3];
                        ps[1] = pi + 7;
                        ps[2] = pi + 6;
                        ps[3] = pi + 5;
                        cs[2] = cs[0];
                        cs[3] = ci;
                        cs[0] = cs[1];
                        cs[1] = ci + 1;
                        break;
                    }
                    ps[5] = coords.length;
                    coords.push([(-4 * coords[ps[0]][0] - coords[ps[15]][0] + 6 * (coords[ps[4]][0] + coords[ps[1]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[13]][0] + coords[ps[7]][0])) / 9, (-4 * coords[ps[0]][1] - coords[ps[15]][1] + 6 * (coords[ps[4]][1] + coords[ps[1]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[13]][1] + coords[ps[7]][1])) / 9]);
                    ps[6] = coords.length;
                    coords.push([(-4 * coords[ps[3]][0] - coords[ps[12]][0] + 6 * (coords[ps[2]][0] + coords[ps[7]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[4]][0] + coords[ps[14]][0])) / 9, (-4 * coords[ps[3]][1] - coords[ps[12]][1] + 6 * (coords[ps[2]][1] + coords[ps[7]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[4]][1] + coords[ps[14]][1])) / 9]);
                    ps[9] = coords.length;
                    coords.push([(-4 * coords[ps[12]][0] - coords[ps[3]][0] + 6 * (coords[ps[8]][0] + coords[ps[13]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[11]][0] + coords[ps[1]][0])) / 9, (-4 * coords[ps[12]][1] - coords[ps[3]][1] + 6 * (coords[ps[8]][1] + coords[ps[13]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[11]][1] + coords[ps[1]][1])) / 9]);
                    ps[10] = coords.length;
                    coords.push([(-4 * coords[ps[15]][0] - coords[ps[0]][0] + 6 * (coords[ps[11]][0] + coords[ps[14]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[2]][0] + coords[ps[8]][0])) / 9, (-4 * coords[ps[15]][1] - coords[ps[0]][1] + 6 * (coords[ps[11]][1] + coords[ps[14]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[2]][1] + coords[ps[8]][1])) / 9]);
                    this.figures.push({
                      type: "patch",
                      coords: new Int32Array(ps),
                      colors: new Int32Array(cs)
                    });
                  }
                }
                _decodeType7Shading(reader) {
                  const coords = this.coords;
                  const colors = this.colors;
                  const ps = new Int32Array(16);
                  const cs = new Int32Array(4);
                  while (reader.hasData) {
                    const f = reader.readFlag();
                    if (!(0 <= f && f <= 3)) {
                      throw new _util.FormatError("Unknown type7 flag");
                    }
                    const pi = coords.length;
                    for (let i = 0, ii = f !== 0 ? 12 : 16; i < ii; i++) {
                      coords.push(reader.readCoordinate());
                    }
                    const ci = colors.length;
                    for (let i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
                      colors.push(reader.readComponents());
                    }
                    let tmp1, tmp2, tmp3, tmp4;
                    switch (f) {
                      case 0:
                        ps[12] = pi + 3;
                        ps[13] = pi + 4;
                        ps[14] = pi + 5;
                        ps[15] = pi + 6;
                        ps[8] = pi + 2;
                        ps[9] = pi + 13;
                        ps[10] = pi + 14;
                        ps[11] = pi + 7;
                        ps[4] = pi + 1;
                        ps[5] = pi + 12;
                        ps[6] = pi + 15;
                        ps[7] = pi + 8;
                        ps[0] = pi;
                        ps[1] = pi + 11;
                        ps[2] = pi + 10;
                        ps[3] = pi + 9;
                        cs[2] = ci + 1;
                        cs[3] = ci + 2;
                        cs[0] = ci;
                        cs[1] = ci + 3;
                        break;
                      case 1:
                        tmp1 = ps[12];
                        tmp2 = ps[13];
                        tmp3 = ps[14];
                        tmp4 = ps[15];
                        ps[12] = tmp4;
                        ps[13] = pi + 0;
                        ps[14] = pi + 1;
                        ps[15] = pi + 2;
                        ps[8] = tmp3;
                        ps[9] = pi + 9;
                        ps[10] = pi + 10;
                        ps[11] = pi + 3;
                        ps[4] = tmp2;
                        ps[5] = pi + 8;
                        ps[6] = pi + 11;
                        ps[7] = pi + 4;
                        ps[0] = tmp1;
                        ps[1] = pi + 7;
                        ps[2] = pi + 6;
                        ps[3] = pi + 5;
                        tmp1 = cs[2];
                        tmp2 = cs[3];
                        cs[2] = tmp2;
                        cs[3] = ci;
                        cs[0] = tmp1;
                        cs[1] = ci + 1;
                        break;
                      case 2:
                        tmp1 = ps[15];
                        tmp2 = ps[11];
                        ps[12] = ps[3];
                        ps[13] = pi + 0;
                        ps[14] = pi + 1;
                        ps[15] = pi + 2;
                        ps[8] = ps[7];
                        ps[9] = pi + 9;
                        ps[10] = pi + 10;
                        ps[11] = pi + 3;
                        ps[4] = tmp2;
                        ps[5] = pi + 8;
                        ps[6] = pi + 11;
                        ps[7] = pi + 4;
                        ps[0] = tmp1;
                        ps[1] = pi + 7;
                        ps[2] = pi + 6;
                        ps[3] = pi + 5;
                        tmp1 = cs[3];
                        cs[2] = cs[1];
                        cs[3] = ci;
                        cs[0] = tmp1;
                        cs[1] = ci + 1;
                        break;
                      case 3:
                        ps[12] = ps[0];
                        ps[13] = pi + 0;
                        ps[14] = pi + 1;
                        ps[15] = pi + 2;
                        ps[8] = ps[1];
                        ps[9] = pi + 9;
                        ps[10] = pi + 10;
                        ps[11] = pi + 3;
                        ps[4] = ps[2];
                        ps[5] = pi + 8;
                        ps[6] = pi + 11;
                        ps[7] = pi + 4;
                        ps[0] = ps[3];
                        ps[1] = pi + 7;
                        ps[2] = pi + 6;
                        ps[3] = pi + 5;
                        cs[2] = cs[0];
                        cs[3] = ci;
                        cs[0] = cs[1];
                        cs[1] = ci + 1;
                        break;
                    }
                    this.figures.push({
                      type: "patch",
                      coords: new Int32Array(ps),
                      colors: new Int32Array(cs)
                    });
                  }
                }
                _buildFigureFromPatch(index) {
                  const figure = this.figures[index];
                  (0, _util.assert)(figure.type === "patch", "Unexpected patch mesh figure");
                  const coords = this.coords, colors = this.colors;
                  const pi = figure.coords;
                  const ci = figure.colors;
                  const figureMinX = Math.min(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
                  const figureMinY = Math.min(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
                  const figureMaxX = Math.max(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
                  const figureMaxY = Math.max(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
                  let splitXBy = Math.ceil((figureMaxX - figureMinX) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
                  splitXBy = Math.max(_MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(_MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitXBy));
                  let splitYBy = Math.ceil((figureMaxY - figureMinY) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
                  splitYBy = Math.max(_MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(_MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitYBy));
                  const verticesPerRow = splitXBy + 1;
                  const figureCoords = new Int32Array((splitYBy + 1) * verticesPerRow);
                  const figureColors = new Int32Array((splitYBy + 1) * verticesPerRow);
                  let k = 0;
                  const cl = new Uint8Array(3), cr = new Uint8Array(3);
                  const c0 = colors[ci[0]], c1 = colors[ci[1]], c2 = colors[ci[2]], c3 = colors[ci[3]];
                  const bRow = getB(splitYBy), bCol = getB(splitXBy);
                  for (let row = 0; row <= splitYBy; row++) {
                    cl[0] = (c0[0] * (splitYBy - row) + c2[0] * row) / splitYBy | 0;
                    cl[1] = (c0[1] * (splitYBy - row) + c2[1] * row) / splitYBy | 0;
                    cl[2] = (c0[2] * (splitYBy - row) + c2[2] * row) / splitYBy | 0;
                    cr[0] = (c1[0] * (splitYBy - row) + c3[0] * row) / splitYBy | 0;
                    cr[1] = (c1[1] * (splitYBy - row) + c3[1] * row) / splitYBy | 0;
                    cr[2] = (c1[2] * (splitYBy - row) + c3[2] * row) / splitYBy | 0;
                    for (let col = 0; col <= splitXBy; col++, k++) {
                      if ((row === 0 || row === splitYBy) && (col === 0 || col === splitXBy)) {
                        continue;
                      }
                      let x = 0, y = 0;
                      let q = 0;
                      for (let i = 0; i <= 3; i++) {
                        for (let j = 0; j <= 3; j++, q++) {
                          const m = bRow[row][i] * bCol[col][j];
                          x += coords[pi[q]][0] * m;
                          y += coords[pi[q]][1] * m;
                        }
                      }
                      figureCoords[k] = coords.length;
                      coords.push([x, y]);
                      figureColors[k] = colors.length;
                      const newColor = new Uint8Array(3);
                      newColor[0] = (cl[0] * (splitXBy - col) + cr[0] * col) / splitXBy | 0;
                      newColor[1] = (cl[1] * (splitXBy - col) + cr[1] * col) / splitXBy | 0;
                      newColor[2] = (cl[2] * (splitXBy - col) + cr[2] * col) / splitXBy | 0;
                      colors.push(newColor);
                    }
                  }
                  figureCoords[0] = pi[0];
                  figureColors[0] = ci[0];
                  figureCoords[splitXBy] = pi[3];
                  figureColors[splitXBy] = ci[1];
                  figureCoords[verticesPerRow * splitYBy] = pi[12];
                  figureColors[verticesPerRow * splitYBy] = ci[2];
                  figureCoords[verticesPerRow * splitYBy + splitXBy] = pi[15];
                  figureColors[verticesPerRow * splitYBy + splitXBy] = ci[3];
                  this.figures[index] = {
                    type: "lattice",
                    coords: figureCoords,
                    colors: figureColors,
                    verticesPerRow
                  };
                }
                _updateBounds() {
                  let minX = this.coords[0][0], minY = this.coords[0][1], maxX = minX, maxY = minY;
                  for (let i = 1, ii = this.coords.length; i < ii; i++) {
                    const x = this.coords[i][0], y = this.coords[i][1];
                    minX = minX > x ? x : minX;
                    minY = minY > y ? y : minY;
                    maxX = maxX < x ? x : maxX;
                    maxY = maxY < y ? y : maxY;
                  }
                  this.bounds = [minX, minY, maxX, maxY];
                }
                _packData() {
                  let i, ii, j, jj;
                  const coords = this.coords;
                  const coordsPacked = new Float32Array(coords.length * 2);
                  for (i = 0, j = 0, ii = coords.length; i < ii; i++) {
                    const xy = coords[i];
                    coordsPacked[j++] = xy[0];
                    coordsPacked[j++] = xy[1];
                  }
                  this.coords = coordsPacked;
                  const colors = this.colors;
                  const colorsPacked = new Uint8Array(colors.length * 3);
                  for (i = 0, j = 0, ii = colors.length; i < ii; i++) {
                    const c = colors[i];
                    colorsPacked[j++] = c[0];
                    colorsPacked[j++] = c[1];
                    colorsPacked[j++] = c[2];
                  }
                  this.colors = colorsPacked;
                  const figures = this.figures;
                  for (i = 0, ii = figures.length; i < ii; i++) {
                    const figure = figures[i], ps = figure.coords, cs = figure.colors;
                    for (j = 0, jj = ps.length; j < jj; j++) {
                      ps[j] *= 2;
                      cs[j] *= 3;
                    }
                  }
                }
                getIR() {
                  return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.bbox, this.background];
                }
              };
              __publicField(_MeshShading, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3);
              __publicField(_MeshShading, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20);
              __publicField(_MeshShading, "TRIANGLE_DENSITY", 20);
              let MeshShading = _MeshShading;
              class DummyShading extends BaseShading {
                getIR() {
                  return ["Dummy"];
                }
              }
              function getTilingPatternIR(operatorList, dict, color) {
                const matrix = dict.getArray("Matrix");
                const bbox = _util.Util.normalizeRect(dict.getArray("BBox"));
                const xstep = dict.get("XStep");
                const ystep = dict.get("YStep");
                const paintType = dict.get("PaintType");
                const tilingType = dict.get("TilingType");
                if (bbox[2] - bbox[0] === 0 || bbox[3] - bbox[1] === 0) {
                  throw new _util.FormatError(`Invalid getTilingPatternIR /BBox array: [${bbox}].`);
                }
                return ["TilingPattern", color, operatorList, matrix, bbox, xstep, ystep, paintType, tilingType];
              }
            },
            /* 51 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.getXfaFontDict = getXfaFontDict;
              exports2.getXfaFontName = getXfaFontName;
              var _calibri_factors = __w_pdfjs_require__2(52);
              var _primitives = __w_pdfjs_require__2(4);
              var _helvetica_factors = __w_pdfjs_require__2(53);
              var _liberationsans_widths = __w_pdfjs_require__2(54);
              var _myriadpro_factors = __w_pdfjs_require__2(55);
              var _segoeui_factors = __w_pdfjs_require__2(56);
              var _core_utils = __w_pdfjs_require__2(3);
              var _fonts_utils = __w_pdfjs_require__2(38);
              const getXFAFontMap = (0, _core_utils.getLookupTableFactory)(function(t) {
                t["MyriadPro-Regular"] = t["PdfJS-Fallback-Regular"] = {
                  name: "LiberationSans-Regular",
                  factors: _myriadpro_factors.MyriadProRegularFactors,
                  baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
                  baseMapping: _liberationsans_widths.LiberationSansRegularMapping,
                  metrics: _myriadpro_factors.MyriadProRegularMetrics
                };
                t["MyriadPro-Bold"] = t["PdfJS-Fallback-Bold"] = {
                  name: "LiberationSans-Bold",
                  factors: _myriadpro_factors.MyriadProBoldFactors,
                  baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldMapping,
                  metrics: _myriadpro_factors.MyriadProBoldMetrics
                };
                t["MyriadPro-It"] = t["MyriadPro-Italic"] = t["PdfJS-Fallback-Italic"] = {
                  name: "LiberationSans-Italic",
                  factors: _myriadpro_factors.MyriadProItalicFactors,
                  baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansItalicMapping,
                  metrics: _myriadpro_factors.MyriadProItalicMetrics
                };
                t["MyriadPro-BoldIt"] = t["MyriadPro-BoldItalic"] = t["PdfJS-Fallback-BoldItalic"] = {
                  name: "LiberationSans-BoldItalic",
                  factors: _myriadpro_factors.MyriadProBoldItalicFactors,
                  baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping,
                  metrics: _myriadpro_factors.MyriadProBoldItalicMetrics
                };
                t.ArialMT = t.Arial = t["Arial-Regular"] = {
                  name: "LiberationSans-Regular",
                  baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
                  baseMapping: _liberationsans_widths.LiberationSansRegularMapping
                };
                t["Arial-BoldMT"] = t["Arial-Bold"] = {
                  name: "LiberationSans-Bold",
                  baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldMapping
                };
                t["Arial-ItalicMT"] = t["Arial-Italic"] = {
                  name: "LiberationSans-Italic",
                  baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansItalicMapping
                };
                t["Arial-BoldItalicMT"] = t["Arial-BoldItalic"] = {
                  name: "LiberationSans-BoldItalic",
                  baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping
                };
                t["Calibri-Regular"] = {
                  name: "LiberationSans-Regular",
                  factors: _calibri_factors.CalibriRegularFactors,
                  baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
                  baseMapping: _liberationsans_widths.LiberationSansRegularMapping,
                  metrics: _calibri_factors.CalibriRegularMetrics
                };
                t["Calibri-Bold"] = {
                  name: "LiberationSans-Bold",
                  factors: _calibri_factors.CalibriBoldFactors,
                  baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldMapping,
                  metrics: _calibri_factors.CalibriBoldMetrics
                };
                t["Calibri-Italic"] = {
                  name: "LiberationSans-Italic",
                  factors: _calibri_factors.CalibriItalicFactors,
                  baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansItalicMapping,
                  metrics: _calibri_factors.CalibriItalicMetrics
                };
                t["Calibri-BoldItalic"] = {
                  name: "LiberationSans-BoldItalic",
                  factors: _calibri_factors.CalibriBoldItalicFactors,
                  baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping,
                  metrics: _calibri_factors.CalibriBoldItalicMetrics
                };
                t["Segoeui-Regular"] = {
                  name: "LiberationSans-Regular",
                  factors: _segoeui_factors.SegoeuiRegularFactors,
                  baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
                  baseMapping: _liberationsans_widths.LiberationSansRegularMapping,
                  metrics: _segoeui_factors.SegoeuiRegularMetrics
                };
                t["Segoeui-Bold"] = {
                  name: "LiberationSans-Bold",
                  factors: _segoeui_factors.SegoeuiBoldFactors,
                  baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldMapping,
                  metrics: _segoeui_factors.SegoeuiBoldMetrics
                };
                t["Segoeui-Italic"] = {
                  name: "LiberationSans-Italic",
                  factors: _segoeui_factors.SegoeuiItalicFactors,
                  baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansItalicMapping,
                  metrics: _segoeui_factors.SegoeuiItalicMetrics
                };
                t["Segoeui-BoldItalic"] = {
                  name: "LiberationSans-BoldItalic",
                  factors: _segoeui_factors.SegoeuiBoldItalicFactors,
                  baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping,
                  metrics: _segoeui_factors.SegoeuiBoldItalicMetrics
                };
                t["Helvetica-Regular"] = t.Helvetica = {
                  name: "LiberationSans-Regular",
                  factors: _helvetica_factors.HelveticaRegularFactors,
                  baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
                  baseMapping: _liberationsans_widths.LiberationSansRegularMapping,
                  metrics: _helvetica_factors.HelveticaRegularMetrics
                };
                t["Helvetica-Bold"] = {
                  name: "LiberationSans-Bold",
                  factors: _helvetica_factors.HelveticaBoldFactors,
                  baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldMapping,
                  metrics: _helvetica_factors.HelveticaBoldMetrics
                };
                t["Helvetica-Italic"] = {
                  name: "LiberationSans-Italic",
                  factors: _helvetica_factors.HelveticaItalicFactors,
                  baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansItalicMapping,
                  metrics: _helvetica_factors.HelveticaItalicMetrics
                };
                t["Helvetica-BoldItalic"] = {
                  name: "LiberationSans-BoldItalic",
                  factors: _helvetica_factors.HelveticaBoldItalicFactors,
                  baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping,
                  metrics: _helvetica_factors.HelveticaBoldItalicMetrics
                };
              });
              function getXfaFontName(name) {
                const fontName = (0, _fonts_utils.normalizeFontName)(name);
                const fontMap = getXFAFontMap();
                return fontMap[fontName];
              }
              function getXfaFontWidths(name) {
                const info = getXfaFontName(name);
                if (!info) {
                  return null;
                }
                const {
                  baseWidths,
                  baseMapping,
                  factors
                } = info;
                const rescaledBaseWidths = !factors ? baseWidths : baseWidths.map((w, i) => w * factors[i]);
                let currentCode = -2;
                let currentArray;
                const newWidths = [];
                for (const [unicode, glyphIndex] of baseMapping.map((charUnicode, index) => [charUnicode, index]).sort(([unicode1], [unicode2]) => unicode1 - unicode2)) {
                  if (unicode === -1) {
                    continue;
                  }
                  if (unicode === currentCode + 1) {
                    currentArray.push(rescaledBaseWidths[glyphIndex]);
                    currentCode += 1;
                  } else {
                    currentCode = unicode;
                    currentArray = [rescaledBaseWidths[glyphIndex]];
                    newWidths.push(unicode, currentArray);
                  }
                }
                return newWidths;
              }
              function getXfaFontDict(name) {
                const widths = getXfaFontWidths(name);
                const dict = new _primitives.Dict(null);
                dict.set("BaseFont", _primitives.Name.get(name));
                dict.set("Type", _primitives.Name.get("Font"));
                dict.set("Subtype", _primitives.Name.get("CIDFontType2"));
                dict.set("Encoding", _primitives.Name.get("Identity-H"));
                dict.set("CIDToGIDMap", _primitives.Name.get("Identity"));
                dict.set("W", widths);
                dict.set("FirstChar", widths[0]);
                dict.set("LastChar", widths.at(-2) + widths.at(-1).length - 1);
                const descriptor = new _primitives.Dict(null);
                dict.set("FontDescriptor", descriptor);
                const systemInfo = new _primitives.Dict(null);
                systemInfo.set("Ordering", "Identity");
                systemInfo.set("Registry", "Adobe");
                systemInfo.set("Supplement", 0);
                dict.set("CIDSystemInfo", systemInfo);
                return dict;
              }
            },
            /* 52 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CalibriRegularMetrics = exports2.CalibriRegularFactors = exports2.CalibriItalicMetrics = exports2.CalibriItalicFactors = exports2.CalibriBoldMetrics = exports2.CalibriBoldItalicMetrics = exports2.CalibriBoldItalicFactors = exports2.CalibriBoldFactors = void 0;
              const CalibriBoldFactors = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.CalibriBoldFactors = CalibriBoldFactors;
              const CalibriBoldMetrics = {
                lineHeight: 1.2207,
                lineGap: 0.2207
              };
              exports2.CalibriBoldMetrics = CalibriBoldMetrics;
              const CalibriBoldItalicFactors = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.CalibriBoldItalicFactors = CalibriBoldItalicFactors;
              const CalibriBoldItalicMetrics = {
                lineHeight: 1.2207,
                lineGap: 0.2207
              };
              exports2.CalibriBoldItalicMetrics = CalibriBoldItalicMetrics;
              const CalibriItalicFactors = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.CalibriItalicFactors = CalibriItalicFactors;
              const CalibriItalicMetrics = {
                lineHeight: 1.2207,
                lineGap: 0.2207
              };
              exports2.CalibriItalicMetrics = CalibriItalicMetrics;
              const CalibriRegularFactors = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.CalibriRegularFactors = CalibriRegularFactors;
              const CalibriRegularMetrics = {
                lineHeight: 1.2207,
                lineGap: 0.2207
              };
              exports2.CalibriRegularMetrics = CalibriRegularMetrics;
            },
            /* 53 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.HelveticaRegularMetrics = exports2.HelveticaRegularFactors = exports2.HelveticaItalicMetrics = exports2.HelveticaItalicFactors = exports2.HelveticaBoldMetrics = exports2.HelveticaBoldItalicMetrics = exports2.HelveticaBoldItalicFactors = exports2.HelveticaBoldFactors = void 0;
              const HelveticaBoldFactors = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.HelveticaBoldFactors = HelveticaBoldFactors;
              const HelveticaBoldMetrics = {
                lineHeight: 1.2,
                lineGap: 0.2
              };
              exports2.HelveticaBoldMetrics = HelveticaBoldMetrics;
              const HelveticaBoldItalicFactors = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.HelveticaBoldItalicFactors = HelveticaBoldItalicFactors;
              const HelveticaBoldItalicMetrics = {
                lineHeight: 1.35,
                lineGap: 0.2
              };
              exports2.HelveticaBoldItalicMetrics = HelveticaBoldItalicMetrics;
              const HelveticaItalicFactors = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.HelveticaItalicFactors = HelveticaItalicFactors;
              const HelveticaItalicMetrics = {
                lineHeight: 1.35,
                lineGap: 0.2
              };
              exports2.HelveticaItalicMetrics = HelveticaItalicMetrics;
              const HelveticaRegularFactors = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.HelveticaRegularFactors = HelveticaRegularFactors;
              const HelveticaRegularMetrics = {
                lineHeight: 1.2,
                lineGap: 0.2
              };
              exports2.HelveticaRegularMetrics = HelveticaRegularMetrics;
            },
            /* 54 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.LiberationSansRegularWidths = exports2.LiberationSansRegularMapping = exports2.LiberationSansItalicWidths = exports2.LiberationSansItalicMapping = exports2.LiberationSansBoldWidths = exports2.LiberationSansBoldMapping = exports2.LiberationSansBoldItalicWidths = exports2.LiberationSansBoldItalicMapping = void 0;
              const LiberationSansBoldWidths = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
              exports2.LiberationSansBoldWidths = LiberationSansBoldWidths;
              const LiberationSansBoldMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
              exports2.LiberationSansBoldMapping = LiberationSansBoldMapping;
              const LiberationSansBoldItalicWidths = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
              exports2.LiberationSansBoldItalicWidths = LiberationSansBoldItalicWidths;
              const LiberationSansBoldItalicMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
              exports2.LiberationSansBoldItalicMapping = LiberationSansBoldItalicMapping;
              const LiberationSansItalicWidths = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
              exports2.LiberationSansItalicWidths = LiberationSansItalicWidths;
              const LiberationSansItalicMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
              exports2.LiberationSansItalicMapping = LiberationSansItalicMapping;
              const LiberationSansRegularWidths = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
              exports2.LiberationSansRegularWidths = LiberationSansRegularWidths;
              const LiberationSansRegularMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
              exports2.LiberationSansRegularMapping = LiberationSansRegularMapping;
            },
            /* 55 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MyriadProRegularMetrics = exports2.MyriadProRegularFactors = exports2.MyriadProItalicMetrics = exports2.MyriadProItalicFactors = exports2.MyriadProBoldMetrics = exports2.MyriadProBoldItalicMetrics = exports2.MyriadProBoldItalicFactors = exports2.MyriadProBoldFactors = void 0;
              const MyriadProBoldFactors = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.MyriadProBoldFactors = MyriadProBoldFactors;
              const MyriadProBoldMetrics = {
                lineHeight: 1.2,
                lineGap: 0.2
              };
              exports2.MyriadProBoldMetrics = MyriadProBoldMetrics;
              const MyriadProBoldItalicFactors = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.MyriadProBoldItalicFactors = MyriadProBoldItalicFactors;
              const MyriadProBoldItalicMetrics = {
                lineHeight: 1.2,
                lineGap: 0.2
              };
              exports2.MyriadProBoldItalicMetrics = MyriadProBoldItalicMetrics;
              const MyriadProItalicFactors = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.MyriadProItalicFactors = MyriadProItalicFactors;
              const MyriadProItalicMetrics = {
                lineHeight: 1.2,
                lineGap: 0.2
              };
              exports2.MyriadProItalicMetrics = MyriadProItalicMetrics;
              const MyriadProRegularFactors = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.MyriadProRegularFactors = MyriadProRegularFactors;
              const MyriadProRegularMetrics = {
                lineHeight: 1.2,
                lineGap: 0.2
              };
              exports2.MyriadProRegularMetrics = MyriadProRegularMetrics;
            },
            /* 56 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SegoeuiRegularMetrics = exports2.SegoeuiRegularFactors = exports2.SegoeuiItalicMetrics = exports2.SegoeuiItalicFactors = exports2.SegoeuiBoldMetrics = exports2.SegoeuiBoldItalicMetrics = exports2.SegoeuiBoldItalicFactors = exports2.SegoeuiBoldFactors = void 0;
              const SegoeuiBoldFactors = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.SegoeuiBoldFactors = SegoeuiBoldFactors;
              const SegoeuiBoldMetrics = {
                lineHeight: 1.33008,
                lineGap: 0
              };
              exports2.SegoeuiBoldMetrics = SegoeuiBoldMetrics;
              const SegoeuiBoldItalicFactors = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.SegoeuiBoldItalicFactors = SegoeuiBoldItalicFactors;
              const SegoeuiBoldItalicMetrics = {
                lineHeight: 1.33008,
                lineGap: 0
              };
              exports2.SegoeuiBoldItalicMetrics = SegoeuiBoldItalicMetrics;
              const SegoeuiItalicFactors = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.SegoeuiItalicFactors = SegoeuiItalicFactors;
              const SegoeuiItalicMetrics = {
                lineHeight: 1.33008,
                lineGap: 0
              };
              exports2.SegoeuiItalicMetrics = SegoeuiItalicMetrics;
              const SegoeuiRegularFactors = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.SegoeuiRegularFactors = SegoeuiRegularFactors;
              const SegoeuiRegularMetrics = {
                lineHeight: 1.33008,
                lineGap: 0
              };
              exports2.SegoeuiRegularMetrics = SegoeuiRegularMetrics;
            },
            /* 57 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PostScriptEvaluator = exports2.PostScriptCompiler = exports2.PDFFunctionFactory = void 0;
              exports2.isPDFFunction = isPDFFunction;
              var _primitives = __w_pdfjs_require__2(4);
              var _util = __w_pdfjs_require__2(2);
              var _ps_parser = __w_pdfjs_require__2(58);
              var _base_stream = __w_pdfjs_require__2(5);
              var _image_utils = __w_pdfjs_require__2(59);
              class PDFFunctionFactory {
                constructor({
                  xref,
                  isEvalSupported = true
                }) {
                  this.xref = xref;
                  this.isEvalSupported = isEvalSupported !== false;
                }
                create(fn) {
                  const cachedFunction = this.getCached(fn);
                  if (cachedFunction) {
                    return cachedFunction;
                  }
                  const parsedFunction = PDFFunction.parse({
                    xref: this.xref,
                    isEvalSupported: this.isEvalSupported,
                    fn: fn instanceof _primitives.Ref ? this.xref.fetch(fn) : fn
                  });
                  this._cache(fn, parsedFunction);
                  return parsedFunction;
                }
                createFromArray(fnObj) {
                  const cachedFunction = this.getCached(fnObj);
                  if (cachedFunction) {
                    return cachedFunction;
                  }
                  const parsedFunction = PDFFunction.parseArray({
                    xref: this.xref,
                    isEvalSupported: this.isEvalSupported,
                    fnObj: fnObj instanceof _primitives.Ref ? this.xref.fetch(fnObj) : fnObj
                  });
                  this._cache(fnObj, parsedFunction);
                  return parsedFunction;
                }
                getCached(cacheKey) {
                  var _a;
                  let fnRef;
                  if (cacheKey instanceof _primitives.Ref) {
                    fnRef = cacheKey;
                  } else if (cacheKey instanceof _primitives.Dict) {
                    fnRef = cacheKey.objId;
                  } else if (cacheKey instanceof _base_stream.BaseStream) {
                    fnRef = (_a = cacheKey.dict) == null ? void 0 : _a.objId;
                  }
                  if (fnRef) {
                    const localFunction = this._localFunctionCache.getByRef(fnRef);
                    if (localFunction) {
                      return localFunction;
                    }
                  }
                  return null;
                }
                _cache(cacheKey, parsedFunction) {
                  var _a;
                  if (!parsedFunction) {
                    throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
                  }
                  let fnRef;
                  if (cacheKey instanceof _primitives.Ref) {
                    fnRef = cacheKey;
                  } else if (cacheKey instanceof _primitives.Dict) {
                    fnRef = cacheKey.objId;
                  } else if (cacheKey instanceof _base_stream.BaseStream) {
                    fnRef = (_a = cacheKey.dict) == null ? void 0 : _a.objId;
                  }
                  if (fnRef) {
                    this._localFunctionCache.set(null, fnRef, parsedFunction);
                  }
                }
                get _localFunctionCache() {
                  return (0, _util.shadow)(this, "_localFunctionCache", new _image_utils.LocalFunctionCache());
                }
              }
              exports2.PDFFunctionFactory = PDFFunctionFactory;
              function toNumberArray(arr) {
                if (!Array.isArray(arr)) {
                  return null;
                }
                const length = arr.length;
                for (let i = 0; i < length; i++) {
                  if (typeof arr[i] !== "number") {
                    const result = new Array(length);
                    for (let j = 0; j < length; j++) {
                      result[j] = +arr[j];
                    }
                    return result;
                  }
                }
                return arr;
              }
              class PDFFunction {
                static getSampleArray(size, outputSize, bps, stream) {
                  let i, ii;
                  let length = 1;
                  for (i = 0, ii = size.length; i < ii; i++) {
                    length *= size[i];
                  }
                  length *= outputSize;
                  const array = new Array(length);
                  let codeSize = 0;
                  let codeBuf = 0;
                  const sampleMul = 1 / (2 ** bps - 1);
                  const strBytes = stream.getBytes((length * bps + 7) / 8);
                  let strIdx = 0;
                  for (i = 0; i < length; i++) {
                    while (codeSize < bps) {
                      codeBuf <<= 8;
                      codeBuf |= strBytes[strIdx++];
                      codeSize += 8;
                    }
                    codeSize -= bps;
                    array[i] = (codeBuf >> codeSize) * sampleMul;
                    codeBuf &= (1 << codeSize) - 1;
                  }
                  return array;
                }
                static parse({
                  xref,
                  isEvalSupported,
                  fn
                }) {
                  const dict = fn.dict || fn;
                  const typeNum = dict.get("FunctionType");
                  switch (typeNum) {
                    case 0:
                      return this.constructSampled({
                        xref,
                        isEvalSupported,
                        fn,
                        dict
                      });
                    case 1:
                      break;
                    case 2:
                      return this.constructInterpolated({
                        xref,
                        isEvalSupported,
                        dict
                      });
                    case 3:
                      return this.constructStiched({
                        xref,
                        isEvalSupported,
                        dict
                      });
                    case 4:
                      return this.constructPostScript({
                        xref,
                        isEvalSupported,
                        fn,
                        dict
                      });
                  }
                  throw new _util.FormatError("Unknown type of function");
                }
                static parseArray({
                  xref,
                  isEvalSupported,
                  fnObj
                }) {
                  if (!Array.isArray(fnObj)) {
                    return this.parse({
                      xref,
                      isEvalSupported,
                      fn: fnObj
                    });
                  }
                  const fnArray = [];
                  for (const fn of fnObj) {
                    fnArray.push(this.parse({
                      xref,
                      isEvalSupported,
                      fn: xref.fetchIfRef(fn)
                    }));
                  }
                  return function(src, srcOffset, dest, destOffset) {
                    for (let i = 0, ii = fnArray.length; i < ii; i++) {
                      fnArray[i](src, srcOffset, dest, destOffset + i);
                    }
                  };
                }
                static constructSampled({
                  xref,
                  isEvalSupported,
                  fn,
                  dict
                }) {
                  function toMultiArray(arr) {
                    const inputLength = arr.length;
                    const out = [];
                    let index = 0;
                    for (let i = 0; i < inputLength; i += 2) {
                      out[index++] = [arr[i], arr[i + 1]];
                    }
                    return out;
                  }
                  function interpolate(x, xmin, xmax, ymin, ymax) {
                    return ymin + (x - xmin) * ((ymax - ymin) / (xmax - xmin));
                  }
                  let domain = toNumberArray(dict.getArray("Domain"));
                  let range = toNumberArray(dict.getArray("Range"));
                  if (!domain || !range) {
                    throw new _util.FormatError("No domain or range");
                  }
                  const inputSize = domain.length / 2;
                  const outputSize = range.length / 2;
                  domain = toMultiArray(domain);
                  range = toMultiArray(range);
                  const size = toNumberArray(dict.getArray("Size"));
                  const bps = dict.get("BitsPerSample");
                  const order = dict.get("Order") || 1;
                  if (order !== 1) {
                    (0, _util.info)("No support for cubic spline interpolation: " + order);
                  }
                  let encode = toNumberArray(dict.getArray("Encode"));
                  if (!encode) {
                    encode = [];
                    for (let i = 0; i < inputSize; ++i) {
                      encode.push([0, size[i] - 1]);
                    }
                  } else {
                    encode = toMultiArray(encode);
                  }
                  let decode = toNumberArray(dict.getArray("Decode"));
                  decode = !decode ? range : toMultiArray(decode);
                  const samples = this.getSampleArray(size, outputSize, bps, fn);
                  return function constructSampledFn(src, srcOffset, dest, destOffset) {
                    const cubeVertices = 1 << inputSize;
                    const cubeN = new Float64Array(cubeVertices);
                    const cubeVertex = new Uint32Array(cubeVertices);
                    let i, j;
                    for (j = 0; j < cubeVertices; j++) {
                      cubeN[j] = 1;
                    }
                    let k = outputSize, pos = 1;
                    for (i = 0; i < inputSize; ++i) {
                      const domain_2i = domain[i][0];
                      const domain_2i_1 = domain[i][1];
                      const xi = Math.min(Math.max(src[srcOffset + i], domain_2i), domain_2i_1);
                      let e = interpolate(xi, domain_2i, domain_2i_1, encode[i][0], encode[i][1]);
                      const size_i = size[i];
                      e = Math.min(Math.max(e, 0), size_i - 1);
                      const e0 = e < size_i - 1 ? Math.floor(e) : e - 1;
                      const n0 = e0 + 1 - e;
                      const n1 = e - e0;
                      const offset0 = e0 * k;
                      const offset1 = offset0 + k;
                      for (j = 0; j < cubeVertices; j++) {
                        if (j & pos) {
                          cubeN[j] *= n1;
                          cubeVertex[j] += offset1;
                        } else {
                          cubeN[j] *= n0;
                          cubeVertex[j] += offset0;
                        }
                      }
                      k *= size_i;
                      pos <<= 1;
                    }
                    for (j = 0; j < outputSize; ++j) {
                      let rj = 0;
                      for (i = 0; i < cubeVertices; i++) {
                        rj += samples[cubeVertex[i] + j] * cubeN[i];
                      }
                      rj = interpolate(rj, 0, 1, decode[j][0], decode[j][1]);
                      dest[destOffset + j] = Math.min(Math.max(rj, range[j][0]), range[j][1]);
                    }
                  };
                }
                static constructInterpolated({
                  xref,
                  isEvalSupported,
                  dict
                }) {
                  const c0 = toNumberArray(dict.getArray("C0")) || [0];
                  const c1 = toNumberArray(dict.getArray("C1")) || [1];
                  const n = dict.get("N");
                  const diff = [];
                  for (let i = 0, ii = c0.length; i < ii; ++i) {
                    diff.push(c1[i] - c0[i]);
                  }
                  const length = diff.length;
                  return function constructInterpolatedFn(src, srcOffset, dest, destOffset) {
                    const x = n === 1 ? src[srcOffset] : src[srcOffset] ** n;
                    for (let j = 0; j < length; ++j) {
                      dest[destOffset + j] = c0[j] + x * diff[j];
                    }
                  };
                }
                static constructStiched({
                  xref,
                  isEvalSupported,
                  dict
                }) {
                  const domain = toNumberArray(dict.getArray("Domain"));
                  if (!domain) {
                    throw new _util.FormatError("No domain");
                  }
                  const inputSize = domain.length / 2;
                  if (inputSize !== 1) {
                    throw new _util.FormatError("Bad domain for stiched function");
                  }
                  const fns = [];
                  for (const fn of dict.get("Functions")) {
                    fns.push(this.parse({
                      xref,
                      isEvalSupported,
                      fn: xref.fetchIfRef(fn)
                    }));
                  }
                  const bounds = toNumberArray(dict.getArray("Bounds"));
                  const encode = toNumberArray(dict.getArray("Encode"));
                  const tmpBuf = new Float32Array(1);
                  return function constructStichedFn(src, srcOffset, dest, destOffset) {
                    const clip = function constructStichedFromIRClip(v2, min, max) {
                      if (v2 > max) {
                        v2 = max;
                      } else if (v2 < min) {
                        v2 = min;
                      }
                      return v2;
                    };
                    const v = clip(src[srcOffset], domain[0], domain[1]);
                    const length = bounds.length;
                    let i;
                    for (i = 0; i < length; ++i) {
                      if (v < bounds[i]) {
                        break;
                      }
                    }
                    let dmin = domain[0];
                    if (i > 0) {
                      dmin = bounds[i - 1];
                    }
                    let dmax = domain[1];
                    if (i < bounds.length) {
                      dmax = bounds[i];
                    }
                    const rmin = encode[2 * i];
                    const rmax = encode[2 * i + 1];
                    tmpBuf[0] = dmin === dmax ? rmin : rmin + (v - dmin) * (rmax - rmin) / (dmax - dmin);
                    fns[i](tmpBuf, 0, dest, destOffset);
                  };
                }
                static constructPostScript({
                  xref,
                  isEvalSupported,
                  fn,
                  dict
                }) {
                  const domain = toNumberArray(dict.getArray("Domain"));
                  const range = toNumberArray(dict.getArray("Range"));
                  if (!domain) {
                    throw new _util.FormatError("No domain.");
                  }
                  if (!range) {
                    throw new _util.FormatError("No range.");
                  }
                  const lexer = new _ps_parser.PostScriptLexer(fn);
                  const parser = new _ps_parser.PostScriptParser(lexer);
                  const code = parser.parse();
                  if (isEvalSupported && _util.FeatureTest.isEvalSupported) {
                    const compiled = new PostScriptCompiler().compile(code, domain, range);
                    if (compiled) {
                      return new Function("src", "srcOffset", "dest", "destOffset", compiled);
                    }
                  }
                  (0, _util.info)("Unable to compile PS function");
                  const numOutputs = range.length >> 1;
                  const numInputs = domain.length >> 1;
                  const evaluator = new PostScriptEvaluator(code);
                  const cache = /* @__PURE__ */ Object.create(null);
                  const MAX_CACHE_SIZE = 2048 * 4;
                  let cache_available = MAX_CACHE_SIZE;
                  const tmpBuf = new Float32Array(numInputs);
                  return function constructPostScriptFn(src, srcOffset, dest, destOffset) {
                    let i, value;
                    let key = "";
                    const input = tmpBuf;
                    for (i = 0; i < numInputs; i++) {
                      value = src[srcOffset + i];
                      input[i] = value;
                      key += value + "_";
                    }
                    const cachedValue = cache[key];
                    if (cachedValue !== void 0) {
                      dest.set(cachedValue, destOffset);
                      return;
                    }
                    const output = new Float32Array(numOutputs);
                    const stack = evaluator.execute(input);
                    const stackIndex = stack.length - numOutputs;
                    for (i = 0; i < numOutputs; i++) {
                      value = stack[stackIndex + i];
                      let bound = range[i * 2];
                      if (value < bound) {
                        value = bound;
                      } else {
                        bound = range[i * 2 + 1];
                        if (value > bound) {
                          value = bound;
                        }
                      }
                      output[i] = value;
                    }
                    if (cache_available > 0) {
                      cache_available--;
                      cache[key] = output;
                    }
                    dest.set(output, destOffset);
                  };
                }
              }
              function isPDFFunction(v) {
                let fnDict;
                if (v instanceof _primitives.Dict) {
                  fnDict = v;
                } else if (v instanceof _base_stream.BaseStream) {
                  fnDict = v.dict;
                } else {
                  return false;
                }
                return fnDict.has("FunctionType");
              }
              const _PostScriptStack = class _PostScriptStack {
                constructor(initialStack) {
                  this.stack = initialStack ? Array.from(initialStack) : [];
                }
                push(value) {
                  if (this.stack.length >= _PostScriptStack.MAX_STACK_SIZE) {
                    throw new Error("PostScript function stack overflow.");
                  }
                  this.stack.push(value);
                }
                pop() {
                  if (this.stack.length <= 0) {
                    throw new Error("PostScript function stack underflow.");
                  }
                  return this.stack.pop();
                }
                copy(n) {
                  if (this.stack.length + n >= _PostScriptStack.MAX_STACK_SIZE) {
                    throw new Error("PostScript function stack overflow.");
                  }
                  const stack = this.stack;
                  for (let i = stack.length - n, j = n - 1; j >= 0; j--, i++) {
                    stack.push(stack[i]);
                  }
                }
                index(n) {
                  this.push(this.stack[this.stack.length - n - 1]);
                }
                roll(n, p) {
                  const stack = this.stack;
                  const l = stack.length - n;
                  const r = stack.length - 1;
                  const c = l + (p - Math.floor(p / n) * n);
                  for (let i = l, j = r; i < j; i++, j--) {
                    const t = stack[i];
                    stack[i] = stack[j];
                    stack[j] = t;
                  }
                  for (let i = l, j = c - 1; i < j; i++, j--) {
                    const t = stack[i];
                    stack[i] = stack[j];
                    stack[j] = t;
                  }
                  for (let i = c, j = r; i < j; i++, j--) {
                    const t = stack[i];
                    stack[i] = stack[j];
                    stack[j] = t;
                  }
                }
              };
              __publicField(_PostScriptStack, "MAX_STACK_SIZE", 100);
              let PostScriptStack = _PostScriptStack;
              class PostScriptEvaluator {
                constructor(operators) {
                  this.operators = operators;
                }
                execute(initialStack) {
                  const stack = new PostScriptStack(initialStack);
                  let counter = 0;
                  const operators = this.operators;
                  const length = operators.length;
                  let operator, a, b;
                  while (counter < length) {
                    operator = operators[counter++];
                    if (typeof operator === "number") {
                      stack.push(operator);
                      continue;
                    }
                    switch (operator) {
                      case "jz":
                        b = stack.pop();
                        a = stack.pop();
                        if (!a) {
                          counter = b;
                        }
                        break;
                      case "j":
                        a = stack.pop();
                        counter = a;
                        break;
                      case "abs":
                        a = stack.pop();
                        stack.push(Math.abs(a));
                        break;
                      case "add":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a + b);
                        break;
                      case "and":
                        b = stack.pop();
                        a = stack.pop();
                        if (typeof a === "boolean" && typeof b === "boolean") {
                          stack.push(a && b);
                        } else {
                          stack.push(a & b);
                        }
                        break;
                      case "atan":
                        b = stack.pop();
                        a = stack.pop();
                        a = Math.atan2(a, b) / Math.PI * 180;
                        if (a < 0) {
                          a += 360;
                        }
                        stack.push(a);
                        break;
                      case "bitshift":
                        b = stack.pop();
                        a = stack.pop();
                        if (a > 0) {
                          stack.push(a << b);
                        } else {
                          stack.push(a >> b);
                        }
                        break;
                      case "ceiling":
                        a = stack.pop();
                        stack.push(Math.ceil(a));
                        break;
                      case "copy":
                        a = stack.pop();
                        stack.copy(a);
                        break;
                      case "cos":
                        a = stack.pop();
                        stack.push(Math.cos(a % 360 / 180 * Math.PI));
                        break;
                      case "cvi":
                        a = stack.pop() | 0;
                        stack.push(a);
                        break;
                      case "cvr":
                        break;
                      case "div":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a / b);
                        break;
                      case "dup":
                        stack.copy(1);
                        break;
                      case "eq":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a === b);
                        break;
                      case "exch":
                        stack.roll(2, 1);
                        break;
                      case "exp":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a ** b);
                        break;
                      case "false":
                        stack.push(false);
                        break;
                      case "floor":
                        a = stack.pop();
                        stack.push(Math.floor(a));
                        break;
                      case "ge":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a >= b);
                        break;
                      case "gt":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a > b);
                        break;
                      case "idiv":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a / b | 0);
                        break;
                      case "index":
                        a = stack.pop();
                        stack.index(a);
                        break;
                      case "le":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a <= b);
                        break;
                      case "ln":
                        a = stack.pop();
                        stack.push(Math.log(a));
                        break;
                      case "log":
                        a = stack.pop();
                        stack.push(Math.log10(a));
                        break;
                      case "lt":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a < b);
                        break;
                      case "mod":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a % b);
                        break;
                      case "mul":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a * b);
                        break;
                      case "ne":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a !== b);
                        break;
                      case "neg":
                        a = stack.pop();
                        stack.push(-a);
                        break;
                      case "not":
                        a = stack.pop();
                        if (typeof a === "boolean") {
                          stack.push(!a);
                        } else {
                          stack.push(~a);
                        }
                        break;
                      case "or":
                        b = stack.pop();
                        a = stack.pop();
                        if (typeof a === "boolean" && typeof b === "boolean") {
                          stack.push(a || b);
                        } else {
                          stack.push(a | b);
                        }
                        break;
                      case "pop":
                        stack.pop();
                        break;
                      case "roll":
                        b = stack.pop();
                        a = stack.pop();
                        stack.roll(a, b);
                        break;
                      case "round":
                        a = stack.pop();
                        stack.push(Math.round(a));
                        break;
                      case "sin":
                        a = stack.pop();
                        stack.push(Math.sin(a % 360 / 180 * Math.PI));
                        break;
                      case "sqrt":
                        a = stack.pop();
                        stack.push(Math.sqrt(a));
                        break;
                      case "sub":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a - b);
                        break;
                      case "true":
                        stack.push(true);
                        break;
                      case "truncate":
                        a = stack.pop();
                        a = a < 0 ? Math.ceil(a) : Math.floor(a);
                        stack.push(a);
                        break;
                      case "xor":
                        b = stack.pop();
                        a = stack.pop();
                        if (typeof a === "boolean" && typeof b === "boolean") {
                          stack.push(a !== b);
                        } else {
                          stack.push(a ^ b);
                        }
                        break;
                      default:
                        throw new _util.FormatError(`Unknown operator ${operator}`);
                    }
                  }
                  return stack.stack;
                }
              }
              exports2.PostScriptEvaluator = PostScriptEvaluator;
              class AstNode {
                constructor(type) {
                  this.type = type;
                }
                visit(visitor) {
                  (0, _util.unreachable)("abstract method");
                }
              }
              class AstArgument extends AstNode {
                constructor(index, min, max) {
                  super("args");
                  this.index = index;
                  this.min = min;
                  this.max = max;
                }
                visit(visitor) {
                  visitor.visitArgument(this);
                }
              }
              class AstLiteral extends AstNode {
                constructor(number) {
                  super("literal");
                  this.number = number;
                  this.min = number;
                  this.max = number;
                }
                visit(visitor) {
                  visitor.visitLiteral(this);
                }
              }
              class AstBinaryOperation extends AstNode {
                constructor(op, arg1, arg2, min, max) {
                  super("binary");
                  this.op = op;
                  this.arg1 = arg1;
                  this.arg2 = arg2;
                  this.min = min;
                  this.max = max;
                }
                visit(visitor) {
                  visitor.visitBinaryOperation(this);
                }
              }
              class AstMin extends AstNode {
                constructor(arg, max) {
                  super("max");
                  this.arg = arg;
                  this.min = arg.min;
                  this.max = max;
                }
                visit(visitor) {
                  visitor.visitMin(this);
                }
              }
              class AstVariable extends AstNode {
                constructor(index, min, max) {
                  super("var");
                  this.index = index;
                  this.min = min;
                  this.max = max;
                }
                visit(visitor) {
                  visitor.visitVariable(this);
                }
              }
              class AstVariableDefinition extends AstNode {
                constructor(variable, arg) {
                  super("definition");
                  this.variable = variable;
                  this.arg = arg;
                }
                visit(visitor) {
                  visitor.visitVariableDefinition(this);
                }
              }
              class ExpressionBuilderVisitor {
                constructor() {
                  this.parts = [];
                }
                visitArgument(arg) {
                  this.parts.push("Math.max(", arg.min, ", Math.min(", arg.max, ", src[srcOffset + ", arg.index, "]))");
                }
                visitVariable(variable) {
                  this.parts.push("v", variable.index);
                }
                visitLiteral(literal) {
                  this.parts.push(literal.number);
                }
                visitBinaryOperation(operation) {
                  this.parts.push("(");
                  operation.arg1.visit(this);
                  this.parts.push(" ", operation.op, " ");
                  operation.arg2.visit(this);
                  this.parts.push(")");
                }
                visitVariableDefinition(definition) {
                  this.parts.push("var ");
                  definition.variable.visit(this);
                  this.parts.push(" = ");
                  definition.arg.visit(this);
                  this.parts.push(";");
                }
                visitMin(max) {
                  this.parts.push("Math.min(");
                  max.arg.visit(this);
                  this.parts.push(", ", max.max, ")");
                }
                toString() {
                  return this.parts.join("");
                }
              }
              function buildAddOperation(num1, num2) {
                if (num2.type === "literal" && num2.number === 0) {
                  return num1;
                }
                if (num1.type === "literal" && num1.number === 0) {
                  return num2;
                }
                if (num2.type === "literal" && num1.type === "literal") {
                  return new AstLiteral(num1.number + num2.number);
                }
                return new AstBinaryOperation("+", num1, num2, num1.min + num2.min, num1.max + num2.max);
              }
              function buildMulOperation(num1, num2) {
                if (num2.type === "literal") {
                  if (num2.number === 0) {
                    return new AstLiteral(0);
                  } else if (num2.number === 1) {
                    return num1;
                  } else if (num1.type === "literal") {
                    return new AstLiteral(num1.number * num2.number);
                  }
                }
                if (num1.type === "literal") {
                  if (num1.number === 0) {
                    return new AstLiteral(0);
                  } else if (num1.number === 1) {
                    return num2;
                  }
                }
                const min = Math.min(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
                const max = Math.max(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
                return new AstBinaryOperation("*", num1, num2, min, max);
              }
              function buildSubOperation(num1, num2) {
                if (num2.type === "literal") {
                  if (num2.number === 0) {
                    return num1;
                  } else if (num1.type === "literal") {
                    return new AstLiteral(num1.number - num2.number);
                  }
                }
                if (num2.type === "binary" && num2.op === "-" && num1.type === "literal" && num1.number === 1 && num2.arg1.type === "literal" && num2.arg1.number === 1) {
                  return num2.arg2;
                }
                return new AstBinaryOperation("-", num1, num2, num1.min - num2.max, num1.max - num2.min);
              }
              function buildMinOperation(num1, max) {
                if (num1.min >= max) {
                  return new AstLiteral(max);
                } else if (num1.max <= max) {
                  return num1;
                }
                return new AstMin(num1, max);
              }
              class PostScriptCompiler {
                compile(code, domain, range) {
                  const stack = [];
                  const instructions = [];
                  const inputSize = domain.length >> 1, outputSize = range.length >> 1;
                  let lastRegister = 0;
                  let n, j;
                  let num1, num2, ast1, ast2, tmpVar, item;
                  for (let i = 0; i < inputSize; i++) {
                    stack.push(new AstArgument(i, domain[i * 2], domain[i * 2 + 1]));
                  }
                  for (let i = 0, ii = code.length; i < ii; i++) {
                    item = code[i];
                    if (typeof item === "number") {
                      stack.push(new AstLiteral(item));
                      continue;
                    }
                    switch (item) {
                      case "add":
                        if (stack.length < 2) {
                          return null;
                        }
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(buildAddOperation(num1, num2));
                        break;
                      case "cvr":
                        if (stack.length < 1) {
                          return null;
                        }
                        break;
                      case "mul":
                        if (stack.length < 2) {
                          return null;
                        }
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(buildMulOperation(num1, num2));
                        break;
                      case "sub":
                        if (stack.length < 2) {
                          return null;
                        }
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(buildSubOperation(num1, num2));
                        break;
                      case "exch":
                        if (stack.length < 2) {
                          return null;
                        }
                        ast1 = stack.pop();
                        ast2 = stack.pop();
                        stack.push(ast1, ast2);
                        break;
                      case "pop":
                        if (stack.length < 1) {
                          return null;
                        }
                        stack.pop();
                        break;
                      case "index":
                        if (stack.length < 1) {
                          return null;
                        }
                        num1 = stack.pop();
                        if (num1.type !== "literal") {
                          return null;
                        }
                        n = num1.number;
                        if (n < 0 || !Number.isInteger(n) || stack.length < n) {
                          return null;
                        }
                        ast1 = stack[stack.length - n - 1];
                        if (ast1.type === "literal" || ast1.type === "var") {
                          stack.push(ast1);
                          break;
                        }
                        tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
                        stack[stack.length - n - 1] = tmpVar;
                        stack.push(tmpVar);
                        instructions.push(new AstVariableDefinition(tmpVar, ast1));
                        break;
                      case "dup":
                        if (stack.length < 1) {
                          return null;
                        }
                        if (typeof code[i + 1] === "number" && code[i + 2] === "gt" && code[i + 3] === i + 7 && code[i + 4] === "jz" && code[i + 5] === "pop" && code[i + 6] === code[i + 1]) {
                          num1 = stack.pop();
                          stack.push(buildMinOperation(num1, code[i + 1]));
                          i += 6;
                          break;
                        }
                        ast1 = stack.at(-1);
                        if (ast1.type === "literal" || ast1.type === "var") {
                          stack.push(ast1);
                          break;
                        }
                        tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
                        stack[stack.length - 1] = tmpVar;
                        stack.push(tmpVar);
                        instructions.push(new AstVariableDefinition(tmpVar, ast1));
                        break;
                      case "roll":
                        if (stack.length < 2) {
                          return null;
                        }
                        num2 = stack.pop();
                        num1 = stack.pop();
                        if (num2.type !== "literal" || num1.type !== "literal") {
                          return null;
                        }
                        j = num2.number;
                        n = num1.number;
                        if (n <= 0 || !Number.isInteger(n) || !Number.isInteger(j) || stack.length < n) {
                          return null;
                        }
                        j = (j % n + n) % n;
                        if (j === 0) {
                          break;
                        }
                        stack.push(...stack.splice(stack.length - n, n - j));
                        break;
                      default:
                        return null;
                    }
                  }
                  if (stack.length !== outputSize) {
                    return null;
                  }
                  const result = [];
                  for (const instruction of instructions) {
                    const statementBuilder = new ExpressionBuilderVisitor();
                    instruction.visit(statementBuilder);
                    result.push(statementBuilder.toString());
                  }
                  for (let i = 0, ii = stack.length; i < ii; i++) {
                    const expr = stack[i], statementBuilder = new ExpressionBuilderVisitor();
                    expr.visit(statementBuilder);
                    const min = range[i * 2], max = range[i * 2 + 1];
                    const out = [statementBuilder.toString()];
                    if (min > expr.min) {
                      out.unshift("Math.max(", min, ", ");
                      out.push(")");
                    }
                    if (max < expr.max) {
                      out.unshift("Math.min(", max, ", ");
                      out.push(")");
                    }
                    out.unshift("dest[destOffset + ", i, "] = ");
                    out.push(";");
                    result.push(out.join(""));
                  }
                  return result.join("\n");
                }
              }
              exports2.PostScriptCompiler = PostScriptCompiler;
            },
            /* 58 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PostScriptParser = exports2.PostScriptLexer = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(4);
              var _core_utils = __w_pdfjs_require__2(3);
              class PostScriptParser {
                constructor(lexer) {
                  this.lexer = lexer;
                  this.operators = [];
                  this.token = null;
                  this.prev = null;
                }
                nextToken() {
                  this.prev = this.token;
                  this.token = this.lexer.getToken();
                }
                accept(type) {
                  if (this.token.type === type) {
                    this.nextToken();
                    return true;
                  }
                  return false;
                }
                expect(type) {
                  if (this.accept(type)) {
                    return true;
                  }
                  throw new _util.FormatError(`Unexpected symbol: found ${this.token.type} expected ${type}.`);
                }
                parse() {
                  this.nextToken();
                  this.expect(PostScriptTokenTypes.LBRACE);
                  this.parseBlock();
                  this.expect(PostScriptTokenTypes.RBRACE);
                  return this.operators;
                }
                parseBlock() {
                  while (true) {
                    if (this.accept(PostScriptTokenTypes.NUMBER)) {
                      this.operators.push(this.prev.value);
                    } else if (this.accept(PostScriptTokenTypes.OPERATOR)) {
                      this.operators.push(this.prev.value);
                    } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
                      this.parseCondition();
                    } else {
                      return;
                    }
                  }
                }
                parseCondition() {
                  const conditionLocation = this.operators.length;
                  this.operators.push(null, null);
                  this.parseBlock();
                  this.expect(PostScriptTokenTypes.RBRACE);
                  if (this.accept(PostScriptTokenTypes.IF)) {
                    this.operators[conditionLocation] = this.operators.length;
                    this.operators[conditionLocation + 1] = "jz";
                  } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
                    const jumpLocation = this.operators.length;
                    this.operators.push(null, null);
                    const endOfTrue = this.operators.length;
                    this.parseBlock();
                    this.expect(PostScriptTokenTypes.RBRACE);
                    this.expect(PostScriptTokenTypes.IFELSE);
                    this.operators[jumpLocation] = this.operators.length;
                    this.operators[jumpLocation + 1] = "j";
                    this.operators[conditionLocation] = endOfTrue;
                    this.operators[conditionLocation + 1] = "jz";
                  } else {
                    throw new _util.FormatError("PS Function: error parsing conditional.");
                  }
                }
              }
              exports2.PostScriptParser = PostScriptParser;
              const PostScriptTokenTypes = {
                LBRACE: 0,
                RBRACE: 1,
                NUMBER: 2,
                OPERATOR: 3,
                IF: 4,
                IFELSE: 5
              };
              class PostScriptToken {
                static get opCache() {
                  return (0, _util.shadow)(this, "opCache", /* @__PURE__ */ Object.create(null));
                }
                constructor(type, value) {
                  this.type = type;
                  this.value = value;
                }
                static getOperator(op) {
                  var _a;
                  return (_a = PostScriptToken.opCache)[op] || (_a[op] = new PostScriptToken(PostScriptTokenTypes.OPERATOR, op));
                }
                static get LBRACE() {
                  return (0, _util.shadow)(this, "LBRACE", new PostScriptToken(PostScriptTokenTypes.LBRACE, "{"));
                }
                static get RBRACE() {
                  return (0, _util.shadow)(this, "RBRACE", new PostScriptToken(PostScriptTokenTypes.RBRACE, "}"));
                }
                static get IF() {
                  return (0, _util.shadow)(this, "IF", new PostScriptToken(PostScriptTokenTypes.IF, "IF"));
                }
                static get IFELSE() {
                  return (0, _util.shadow)(this, "IFELSE", new PostScriptToken(PostScriptTokenTypes.IFELSE, "IFELSE"));
                }
              }
              class PostScriptLexer {
                constructor(stream) {
                  this.stream = stream;
                  this.nextChar();
                  this.strBuf = [];
                }
                nextChar() {
                  return this.currentChar = this.stream.getByte();
                }
                getToken() {
                  let comment = false;
                  let ch = this.currentChar;
                  while (true) {
                    if (ch < 0) {
                      return _primitives.EOF;
                    }
                    if (comment) {
                      if (ch === 10 || ch === 13) {
                        comment = false;
                      }
                    } else if (ch === 37) {
                      comment = true;
                    } else if (!(0, _core_utils.isWhiteSpace)(ch)) {
                      break;
                    }
                    ch = this.nextChar();
                  }
                  switch (ch | 0) {
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                    case 43:
                    case 45:
                    case 46:
                      return new PostScriptToken(PostScriptTokenTypes.NUMBER, this.getNumber());
                    case 123:
                      this.nextChar();
                      return PostScriptToken.LBRACE;
                    case 125:
                      this.nextChar();
                      return PostScriptToken.RBRACE;
                  }
                  const strBuf = this.strBuf;
                  strBuf.length = 0;
                  strBuf[0] = String.fromCharCode(ch);
                  while ((ch = this.nextChar()) >= 0 && (ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122)) {
                    strBuf.push(String.fromCharCode(ch));
                  }
                  const str = strBuf.join("");
                  switch (str.toLowerCase()) {
                    case "if":
                      return PostScriptToken.IF;
                    case "ifelse":
                      return PostScriptToken.IFELSE;
                    default:
                      return PostScriptToken.getOperator(str);
                  }
                }
                getNumber() {
                  let ch = this.currentChar;
                  const strBuf = this.strBuf;
                  strBuf.length = 0;
                  strBuf[0] = String.fromCharCode(ch);
                  while ((ch = this.nextChar()) >= 0) {
                    if (ch >= 48 && ch <= 57 || ch === 45 || ch === 46) {
                      strBuf.push(String.fromCharCode(ch));
                    } else {
                      break;
                    }
                  }
                  const value = parseFloat(strBuf.join(""));
                  if (isNaN(value)) {
                    throw new _util.FormatError(`Invalid floating point number: ${value}`);
                  }
                  return value;
                }
              }
              exports2.PostScriptLexer = PostScriptLexer;
            },
            /* 59 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.RegionalImageCache = exports2.LocalTilingPatternCache = exports2.LocalImageCache = exports2.LocalGStateCache = exports2.LocalFunctionCache = exports2.LocalColorSpaceCache = exports2.GlobalImageCache = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(4);
              class BaseLocalCache {
                constructor(options) {
                  if (this.constructor === BaseLocalCache) {
                    (0, _util.unreachable)("Cannot initialize BaseLocalCache.");
                  }
                  this._onlyRefs = (options == null ? void 0 : options.onlyRefs) === true;
                  if (!this._onlyRefs) {
                    this._nameRefMap = /* @__PURE__ */ new Map();
                    this._imageMap = /* @__PURE__ */ new Map();
                  }
                  this._imageCache = new _primitives.RefSetCache();
                }
                getByName(name) {
                  if (this._onlyRefs) {
                    (0, _util.unreachable)("Should not call `getByName` method.");
                  }
                  const ref = this._nameRefMap.get(name);
                  if (ref) {
                    return this.getByRef(ref);
                  }
                  return this._imageMap.get(name) || null;
                }
                getByRef(ref) {
                  return this._imageCache.get(ref) || null;
                }
                set(name, ref, data) {
                  (0, _util.unreachable)("Abstract method `set` called.");
                }
              }
              class LocalImageCache extends BaseLocalCache {
                set(name, ref = null, data) {
                  if (typeof name !== "string") {
                    throw new Error('LocalImageCache.set - expected "name" argument.');
                  }
                  if (ref) {
                    if (this._imageCache.has(ref)) {
                      return;
                    }
                    this._nameRefMap.set(name, ref);
                    this._imageCache.put(ref, data);
                    return;
                  }
                  if (this._imageMap.has(name)) {
                    return;
                  }
                  this._imageMap.set(name, data);
                }
              }
              exports2.LocalImageCache = LocalImageCache;
              class LocalColorSpaceCache extends BaseLocalCache {
                set(name = null, ref = null, data) {
                  if (typeof name !== "string" && !ref) {
                    throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
                  }
                  if (ref) {
                    if (this._imageCache.has(ref)) {
                      return;
                    }
                    if (name !== null) {
                      this._nameRefMap.set(name, ref);
                    }
                    this._imageCache.put(ref, data);
                    return;
                  }
                  if (this._imageMap.has(name)) {
                    return;
                  }
                  this._imageMap.set(name, data);
                }
              }
              exports2.LocalColorSpaceCache = LocalColorSpaceCache;
              class LocalFunctionCache extends BaseLocalCache {
                constructor(options) {
                  super({
                    onlyRefs: true
                  });
                }
                set(name = null, ref, data) {
                  if (!ref) {
                    throw new Error('LocalFunctionCache.set - expected "ref" argument.');
                  }
                  if (this._imageCache.has(ref)) {
                    return;
                  }
                  this._imageCache.put(ref, data);
                }
              }
              exports2.LocalFunctionCache = LocalFunctionCache;
              class LocalGStateCache extends BaseLocalCache {
                set(name, ref = null, data) {
                  if (typeof name !== "string") {
                    throw new Error('LocalGStateCache.set - expected "name" argument.');
                  }
                  if (ref) {
                    if (this._imageCache.has(ref)) {
                      return;
                    }
                    this._nameRefMap.set(name, ref);
                    this._imageCache.put(ref, data);
                    return;
                  }
                  if (this._imageMap.has(name)) {
                    return;
                  }
                  this._imageMap.set(name, data);
                }
              }
              exports2.LocalGStateCache = LocalGStateCache;
              class LocalTilingPatternCache extends BaseLocalCache {
                constructor(options) {
                  super({
                    onlyRefs: true
                  });
                }
                set(name = null, ref, data) {
                  if (!ref) {
                    throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
                  }
                  if (this._imageCache.has(ref)) {
                    return;
                  }
                  this._imageCache.put(ref, data);
                }
              }
              exports2.LocalTilingPatternCache = LocalTilingPatternCache;
              class RegionalImageCache extends BaseLocalCache {
                constructor(options) {
                  super({
                    onlyRefs: true
                  });
                }
                set(name = null, ref, data) {
                  if (!ref) {
                    throw new Error('RegionalImageCache.set - expected "ref" argument.');
                  }
                  if (this._imageCache.has(ref)) {
                    return;
                  }
                  this._imageCache.put(ref, data);
                }
              }
              exports2.RegionalImageCache = RegionalImageCache;
              const _GlobalImageCache = class _GlobalImageCache {
                constructor() {
                  this._refCache = new _primitives.RefSetCache();
                  this._imageCache = new _primitives.RefSetCache();
                }
                get _byteSize() {
                  let byteSize = 0;
                  for (const imageData of this._imageCache) {
                    byteSize += imageData.byteSize;
                  }
                  return byteSize;
                }
                get _cacheLimitReached() {
                  if (this._imageCache.size < _GlobalImageCache.MIN_IMAGES_TO_CACHE) {
                    return false;
                  }
                  if (this._byteSize < _GlobalImageCache.MAX_BYTE_SIZE) {
                    return false;
                  }
                  return true;
                }
                shouldCache(ref, pageIndex) {
                  let pageIndexSet = this._refCache.get(ref);
                  if (!pageIndexSet) {
                    pageIndexSet = /* @__PURE__ */ new Set();
                    this._refCache.put(ref, pageIndexSet);
                  }
                  pageIndexSet.add(pageIndex);
                  if (pageIndexSet.size < _GlobalImageCache.NUM_PAGES_THRESHOLD) {
                    return false;
                  }
                  if (!this._imageCache.has(ref) && this._cacheLimitReached) {
                    return false;
                  }
                  return true;
                }
                addByteSize(ref, byteSize) {
                  const imageData = this._imageCache.get(ref);
                  if (!imageData) {
                    return;
                  }
                  if (imageData.byteSize) {
                    return;
                  }
                  imageData.byteSize = byteSize;
                }
                getData(ref, pageIndex) {
                  const pageIndexSet = this._refCache.get(ref);
                  if (!pageIndexSet) {
                    return null;
                  }
                  if (pageIndexSet.size < _GlobalImageCache.NUM_PAGES_THRESHOLD) {
                    return null;
                  }
                  const imageData = this._imageCache.get(ref);
                  if (!imageData) {
                    return null;
                  }
                  pageIndexSet.add(pageIndex);
                  return imageData;
                }
                setData(ref, data) {
                  if (!this._refCache.has(ref)) {
                    throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
                  }
                  if (this._imageCache.has(ref)) {
                    return;
                  }
                  if (this._cacheLimitReached) {
                    (0, _util.warn)("GlobalImageCache.setData - cache limit reached.");
                    return;
                  }
                  this._imageCache.put(ref, data);
                }
                clear(onlyData = false) {
                  if (!onlyData) {
                    this._refCache.clear();
                  }
                  this._imageCache.clear();
                }
              };
              __publicField(_GlobalImageCache, "NUM_PAGES_THRESHOLD", 2);
              __publicField(_GlobalImageCache, "MIN_IMAGES_TO_CACHE", 10);
              __publicField(_GlobalImageCache, "MAX_BYTE_SIZE", 5 * _util.MAX_IMAGE_SIZE_TO_CACHE);
              let GlobalImageCache = _GlobalImageCache;
              exports2.GlobalImageCache = GlobalImageCache;
            },
            /* 60 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.bidi = bidi;
              var _util = __w_pdfjs_require__2(2);
              const baseTypes = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"];
              const arabicTypes = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
              function isOdd(i) {
                return (i & 1) !== 0;
              }
              function isEven(i) {
                return (i & 1) === 0;
              }
              function findUnequal(arr, start, value) {
                let j, jj;
                for (j = start, jj = arr.length; j < jj; ++j) {
                  if (arr[j] !== value) {
                    return j;
                  }
                }
                return j;
              }
              function setValues(arr, start, end, value) {
                for (let j = start; j < end; ++j) {
                  arr[j] = value;
                }
              }
              function reverseValues(arr, start, end) {
                for (let i = start, j = end - 1; i < j; ++i, --j) {
                  const temp = arr[i];
                  arr[i] = arr[j];
                  arr[j] = temp;
                }
              }
              function createBidiText(str, isLTR, vertical = false) {
                let dir = "ltr";
                if (vertical) {
                  dir = "ttb";
                } else if (!isLTR) {
                  dir = "rtl";
                }
                return {
                  str,
                  dir
                };
              }
              const chars = [];
              const types = [];
              function bidi(str, startLevel = -1, vertical = false) {
                let isLTR = true;
                const strLength = str.length;
                if (strLength === 0 || vertical) {
                  return createBidiText(str, isLTR, vertical);
                }
                chars.length = strLength;
                types.length = strLength;
                let numBidi = 0;
                let i, ii;
                for (i = 0; i < strLength; ++i) {
                  chars[i] = str.charAt(i);
                  const charCode = str.charCodeAt(i);
                  let charType = "L";
                  if (charCode <= 255) {
                    charType = baseTypes[charCode];
                  } else if (1424 <= charCode && charCode <= 1524) {
                    charType = "R";
                  } else if (1536 <= charCode && charCode <= 1791) {
                    charType = arabicTypes[charCode & 255];
                    if (!charType) {
                      (0, _util.warn)("Bidi: invalid Unicode character " + charCode.toString(16));
                    }
                  } else if (1792 <= charCode && charCode <= 2220 || 64336 <= charCode && charCode <= 65023 || 65136 <= charCode && charCode <= 65279) {
                    charType = "AL";
                  }
                  if (charType === "R" || charType === "AL" || charType === "AN") {
                    numBidi++;
                  }
                  types[i] = charType;
                }
                if (numBidi === 0) {
                  isLTR = true;
                  return createBidiText(str, isLTR);
                }
                if (startLevel === -1) {
                  if (numBidi / strLength < 0.3 && strLength > 4) {
                    isLTR = true;
                    startLevel = 0;
                  } else {
                    isLTR = false;
                    startLevel = 1;
                  }
                }
                const levels = [];
                for (i = 0; i < strLength; ++i) {
                  levels[i] = startLevel;
                }
                const e = isOdd(startLevel) ? "R" : "L";
                const sor = e;
                const eor = sor;
                let lastType = sor;
                for (i = 0; i < strLength; ++i) {
                  if (types[i] === "NSM") {
                    types[i] = lastType;
                  } else {
                    lastType = types[i];
                  }
                }
                lastType = sor;
                let t;
                for (i = 0; i < strLength; ++i) {
                  t = types[i];
                  if (t === "EN") {
                    types[i] = lastType === "AL" ? "AN" : "EN";
                  } else if (t === "R" || t === "L" || t === "AL") {
                    lastType = t;
                  }
                }
                for (i = 0; i < strLength; ++i) {
                  t = types[i];
                  if (t === "AL") {
                    types[i] = "R";
                  }
                }
                for (i = 1; i < strLength - 1; ++i) {
                  if (types[i] === "ES" && types[i - 1] === "EN" && types[i + 1] === "EN") {
                    types[i] = "EN";
                  }
                  if (types[i] === "CS" && (types[i - 1] === "EN" || types[i - 1] === "AN") && types[i + 1] === types[i - 1]) {
                    types[i] = types[i - 1];
                  }
                }
                for (i = 0; i < strLength; ++i) {
                  if (types[i] === "EN") {
                    for (let j = i - 1; j >= 0; --j) {
                      if (types[j] !== "ET") {
                        break;
                      }
                      types[j] = "EN";
                    }
                    for (let j = i + 1; j < strLength; ++j) {
                      if (types[j] !== "ET") {
                        break;
                      }
                      types[j] = "EN";
                    }
                  }
                }
                for (i = 0; i < strLength; ++i) {
                  t = types[i];
                  if (t === "WS" || t === "ES" || t === "ET" || t === "CS") {
                    types[i] = "ON";
                  }
                }
                lastType = sor;
                for (i = 0; i < strLength; ++i) {
                  t = types[i];
                  if (t === "EN") {
                    types[i] = lastType === "L" ? "L" : "EN";
                  } else if (t === "R" || t === "L") {
                    lastType = t;
                  }
                }
                for (i = 0; i < strLength; ++i) {
                  if (types[i] === "ON") {
                    const end = findUnequal(types, i + 1, "ON");
                    let before = sor;
                    if (i > 0) {
                      before = types[i - 1];
                    }
                    let after = eor;
                    if (end + 1 < strLength) {
                      after = types[end + 1];
                    }
                    if (before !== "L") {
                      before = "R";
                    }
                    if (after !== "L") {
                      after = "R";
                    }
                    if (before === after) {
                      setValues(types, i, end, before);
                    }
                    i = end - 1;
                  }
                }
                for (i = 0; i < strLength; ++i) {
                  if (types[i] === "ON") {
                    types[i] = e;
                  }
                }
                for (i = 0; i < strLength; ++i) {
                  t = types[i];
                  if (isEven(levels[i])) {
                    if (t === "R") {
                      levels[i] += 1;
                    } else if (t === "AN" || t === "EN") {
                      levels[i] += 2;
                    }
                  } else if (t === "L" || t === "AN" || t === "EN") {
                    levels[i] += 1;
                  }
                }
                let highestLevel = -1;
                let lowestOddLevel = 99;
                let level;
                for (i = 0, ii = levels.length; i < ii; ++i) {
                  level = levels[i];
                  if (highestLevel < level) {
                    highestLevel = level;
                  }
                  if (lowestOddLevel > level && isOdd(level)) {
                    lowestOddLevel = level;
                  }
                }
                for (level = highestLevel; level >= lowestOddLevel; --level) {
                  let start = -1;
                  for (i = 0, ii = levels.length; i < ii; ++i) {
                    if (levels[i] < level) {
                      if (start >= 0) {
                        reverseValues(chars, start, i);
                        start = -1;
                      }
                    } else if (start < 0) {
                      start = i;
                    }
                  }
                  if (start >= 0) {
                    reverseValues(chars, start, levels.length);
                  }
                }
                for (i = 0, ii = chars.length; i < ii; ++i) {
                  const ch = chars[i];
                  if (ch === "<" || ch === ">") {
                    chars[i] = "";
                  }
                }
                return createBidiText(chars.join(""), isLTR);
              }
            },
            /* 61 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.getFontSubstitution = getFontSubstitution;
              var _fonts_utils = __w_pdfjs_require__2(38);
              var _core_utils = __w_pdfjs_require__2(3);
              const NORMAL = {
                style: "normal",
                weight: "normal"
              };
              const BOLD = {
                style: "normal",
                weight: "bold"
              };
              const ITALIC = {
                style: "italic",
                weight: "normal"
              };
              const BOLDITALIC = {
                style: "italic",
                weight: "bold"
              };
              const substitutionMap = /* @__PURE__ */ new Map([["Times-Roman", {
                local: ["Times New Roman", "Times-Roman", "Times", "Liberation Serif", "Nimbus Roman", "Nimbus Roman L", "Tinos", "Thorndale", "TeX Gyre Termes", "FreeSerif", "DejaVu Serif", "Bitstream Vera Serif", "Ubuntu"],
                style: NORMAL,
                ultimate: "serif"
              }], ["Times-Bold", {
                alias: "Times-Roman",
                style: BOLD,
                ultimate: "serif"
              }], ["Times-Italic", {
                alias: "Times-Roman",
                style: ITALIC,
                ultimate: "serif"
              }], ["Times-BoldItalic", {
                alias: "Times-Roman",
                style: BOLDITALIC,
                ultimate: "serif"
              }], ["Helvetica", {
                local: ["Helvetica", "Helvetica Neue", "Arial", "Arial Nova", "Liberation Sans", "Arimo", "Nimbus Sans", "Nimbus Sans L", "A030", "TeX Gyre Heros", "FreeSans", "DejaVu Sans", "Albany", "Bitstream Vera Sans", "Arial Unicode MS", "Microsoft Sans Serif", "Apple Symbols", "Cantarell"],
                path: "LiberationSans-Regular.ttf",
                style: NORMAL,
                ultimate: "sans-serif"
              }], ["Helvetica-Bold", {
                alias: "Helvetica",
                path: "LiberationSans-Bold.ttf",
                style: BOLD,
                ultimate: "sans-serif"
              }], ["Helvetica-Oblique", {
                alias: "Helvetica",
                path: "LiberationSans-Italic.ttf",
                style: ITALIC,
                ultimate: "sans-serif"
              }], ["Helvetica-BoldOblique", {
                alias: "Helvetica",
                path: "LiberationSans-BoldItalic.ttf",
                style: BOLDITALIC,
                ultimate: "sans-serif"
              }], ["Courier", {
                local: ["Courier", "Courier New", "Liberation Mono", "Nimbus Mono", "Nimbus Mono L", "Cousine", "Cumberland", "TeX Gyre Cursor", "FreeMono"],
                style: NORMAL,
                ultimate: "monospace"
              }], ["Courier-Bold", {
                alias: "Courier",
                style: BOLD,
                ultimate: "monospace"
              }], ["Courier-Oblique", {
                alias: "Courier",
                style: ITALIC,
                ultimate: "monospace"
              }], ["Courier-BoldOblique", {
                alias: "Courier",
                style: BOLDITALIC,
                ultimate: "monospace"
              }], ["ArialBlack", {
                local: ["Arial Black"],
                style: {
                  style: "normal",
                  weight: "900"
                },
                fallback: "Helvetica-Bold"
              }], ["ArialBlack-Bold", {
                alias: "ArialBlack"
              }], ["ArialBlack-Italic", {
                alias: "ArialBlack",
                style: {
                  style: "italic",
                  weight: "900"
                },
                fallback: "Helvetica-BoldOblique"
              }], ["ArialBlack-BoldItalic", {
                alias: "ArialBlack-Italic"
              }], ["ArialNarrow", {
                local: ["Arial Narrow", "Liberation Sans Narrow", "Helvetica Condensed", "Nimbus Sans Narrow", "TeX Gyre Heros Cn"],
                style: NORMAL,
                fallback: "Helvetica"
              }], ["ArialNarrow-Bold", {
                alias: "ArialNarrow",
                style: BOLD,
                fallback: "Helvetica-Bold"
              }], ["ArialNarrow-Italic", {
                alias: "ArialNarrow",
                style: ITALIC,
                fallback: "Helvetica-Oblique"
              }], ["ArialNarrow-BoldItalic", {
                alias: "ArialNarrow",
                style: BOLDITALIC,
                fallback: "Helvetica-BoldOblique"
              }], ["Calibri", {
                local: ["Calibri", "Carlito"],
                style: NORMAL,
                fallback: "Helvetica"
              }], ["Calibri-Bold", {
                alias: "Calibri",
                style: BOLD,
                fallback: "Helvetica-Bold"
              }], ["Calibri-Italic", {
                alias: "Calibri",
                style: ITALIC,
                fallback: "Helvetica-Oblique"
              }], ["Calibri-BoldItalic", {
                alias: "Calibri",
                style: BOLDITALIC,
                fallback: "Helvetica-BoldOblique"
              }], ["Wingdings", {
                local: ["Wingdings", "URW Dingbats"],
                style: NORMAL
              }], ["Wingdings-Regular", {
                alias: "Wingdings"
              }], ["Wingdings-Bold", {
                alias: "Wingdings"
              }]]);
              const fontAliases = /* @__PURE__ */ new Map([["Arial-Black", "ArialBlack"]]);
              function getStyleToAppend(style) {
                switch (style) {
                  case BOLD:
                    return "Bold";
                  case ITALIC:
                    return "Italic";
                  case BOLDITALIC:
                    return "Bold Italic";
                  default:
                    if ((style == null ? void 0 : style.weight) === "bold") {
                      return "Bold";
                    }
                    if ((style == null ? void 0 : style.style) === "italic") {
                      return "Italic";
                    }
                }
                return "";
              }
              function generateFont({
                alias,
                local,
                path,
                fallback,
                style,
                ultimate
              }, src, localFontPath, useFallback = true, usePath = true, append = "") {
                const result = {
                  style: null,
                  ultimate: null
                };
                if (local) {
                  const extra = append ? ` ${append}` : "";
                  for (const name of local) {
                    src.push(`local(${name}${extra})`);
                  }
                }
                if (alias) {
                  const substitution = substitutionMap.get(alias);
                  const aliasAppend = append || getStyleToAppend(style);
                  Object.assign(result, generateFont(substitution, src, localFontPath, useFallback && !fallback, usePath && !path, aliasAppend));
                }
                if (style) {
                  result.style = style;
                }
                if (ultimate) {
                  result.ultimate = ultimate;
                }
                if (useFallback && fallback) {
                  const fallbackInfo = substitutionMap.get(fallback);
                  const {
                    ultimate: fallbackUltimate
                  } = generateFont(fallbackInfo, src, localFontPath, useFallback, usePath && !path, append);
                  result.ultimate || (result.ultimate = fallbackUltimate);
                }
                if (usePath && path && localFontPath) {
                  src.push(`url(${localFontPath}${path})`);
                }
                return result;
              }
              function getFontSubstitution(systemFontCache, idFactory, localFontPath, baseFontName, standardFontName) {
                baseFontName = (0, _fonts_utils.normalizeFontName)(baseFontName);
                const key = baseFontName;
                let substitutionInfo = systemFontCache.get(key);
                if (substitutionInfo) {
                  return substitutionInfo;
                }
                let substitution = substitutionMap.get(baseFontName);
                if (!substitution) {
                  for (const [alias, subst] of fontAliases) {
                    if (baseFontName.startsWith(alias)) {
                      baseFontName = `${subst}${baseFontName.substring(alias.length)}`;
                      substitution = substitutionMap.get(baseFontName);
                      break;
                    }
                  }
                }
                let mustAddBaseFont = false;
                if (!substitution) {
                  substitution = substitutionMap.get(standardFontName);
                  mustAddBaseFont = true;
                }
                const loadedName = `${idFactory.getDocId()}_s${idFactory.createFontId()}`;
                if (!substitution) {
                  if (!(0, _core_utils.validateFontName)(baseFontName)) {
                    systemFontCache.set(key, null);
                    return null;
                  }
                  const bold = /bold/gi.test(baseFontName);
                  const italic = /oblique|italic/gi.test(baseFontName);
                  const style2 = bold && italic && BOLDITALIC || bold && BOLD || italic && ITALIC || NORMAL;
                  substitutionInfo = {
                    css: loadedName,
                    guessFallback: true,
                    loadedName,
                    baseFontName,
                    src: `local(${baseFontName})`,
                    style: style2
                  };
                  systemFontCache.set(key, substitutionInfo);
                  return substitutionInfo;
                }
                const src = [];
                if (mustAddBaseFont && (0, _core_utils.validateFontName)(baseFontName)) {
                  src.push(`local(${baseFontName})`);
                }
                const {
                  style,
                  ultimate
                } = generateFont(substitution, src, localFontPath);
                const guessFallback = ultimate === null;
                const fallback = guessFallback ? "" : `,${ultimate}`;
                substitutionInfo = {
                  css: `${loadedName}${fallback}`,
                  guessFallback,
                  loadedName,
                  baseFontName,
                  src: src.join(","),
                  style
                };
                systemFontCache.set(key, substitutionInfo);
                return substitutionInfo;
              }
            },
            /* 62 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ImageResizer = void 0;
              var _util = __w_pdfjs_require__2(2);
              const MIN_IMAGE_DIM = 2048;
              const MAX_IMAGE_DIM = 65537;
              const MAX_ERROR = 128;
              class ImageResizer {
                constructor(imgData, isMask) {
                  this._imgData = imgData;
                  this._isMask = isMask;
                }
                static needsToBeResized(width, height) {
                  if (width <= this._goodSquareLength && height <= this._goodSquareLength) {
                    return false;
                  }
                  const {
                    MAX_DIM
                  } = this;
                  if (width > MAX_DIM || height > MAX_DIM) {
                    return true;
                  }
                  const area = width * height;
                  if (this._hasMaxArea) {
                    return area > this.MAX_AREA;
                  }
                  if (area < this._goodSquareLength ** 2) {
                    return false;
                  }
                  if (this._areGoodDims(width, height)) {
                    this._goodSquareLength = Math.max(this._goodSquareLength, Math.floor(Math.sqrt(width * height)));
                    return false;
                  }
                  this._goodSquareLength = this._guessMax(this._goodSquareLength, MAX_DIM, MAX_ERROR, 0);
                  const maxArea = this.MAX_AREA = this._goodSquareLength ** 2;
                  return area > maxArea;
                }
                static get MAX_DIM() {
                  return (0, _util.shadow)(this, "MAX_DIM", this._guessMax(MIN_IMAGE_DIM, MAX_IMAGE_DIM, 0, 1));
                }
                static get MAX_AREA() {
                  this._hasMaxArea = true;
                  return (0, _util.shadow)(this, "MAX_AREA", this._guessMax(ImageResizer._goodSquareLength, this.MAX_DIM, MAX_ERROR, 0) ** 2);
                }
                static set MAX_AREA(area) {
                  if (area >= 0) {
                    this._hasMaxArea = true;
                    (0, _util.shadow)(this, "MAX_AREA", area);
                  }
                }
                static setMaxArea(area) {
                  if (!this._hasMaxArea) {
                    this.MAX_AREA = area >> 2;
                  }
                }
                static _areGoodDims(width, height) {
                  try {
                    const canvas = new OffscreenCanvas(width, height);
                    const ctx = canvas.getContext("2d");
                    ctx.fillRect(0, 0, 1, 1);
                    const opacity = ctx.getImageData(0, 0, 1, 1).data[3];
                    canvas.width = canvas.height = 1;
                    return opacity !== 0;
                  } catch {
                    return false;
                  }
                }
                static _guessMax(start, end, tolerance, defaultHeight) {
                  while (start + tolerance + 1 < end) {
                    const middle = Math.floor((start + end) / 2);
                    const height = defaultHeight || middle;
                    if (this._areGoodDims(middle, height)) {
                      start = middle;
                    } else {
                      end = middle;
                    }
                  }
                  return start;
                }
                static async createImage(imgData, isMask = false) {
                  return new ImageResizer(imgData, isMask)._createImage();
                }
                async _createImage() {
                  const data = this._encodeBMP();
                  const blob = new Blob([data.buffer], {
                    type: "image/bmp"
                  });
                  const bitmapPromise = createImageBitmap(blob);
                  const {
                    MAX_AREA,
                    MAX_DIM
                  } = ImageResizer;
                  const {
                    _imgData: imgData
                  } = this;
                  const {
                    width,
                    height
                  } = imgData;
                  const minFactor = Math.max(width / MAX_DIM, height / MAX_DIM, Math.sqrt(width * height / MAX_AREA));
                  const firstFactor = Math.max(minFactor, 2);
                  const factor = Math.round(10 * (minFactor + 1.25)) / 10 / firstFactor;
                  const N = Math.floor(Math.log2(factor));
                  const steps = new Array(N + 2).fill(2);
                  steps[0] = firstFactor;
                  steps.splice(-1, 1, factor / (1 << N));
                  let newWidth = width;
                  let newHeight = height;
                  let bitmap = await bitmapPromise;
                  for (const step of steps) {
                    const prevWidth = newWidth;
                    const prevHeight = newHeight;
                    newWidth = Math.floor(newWidth / step) - 1;
                    newHeight = Math.floor(newHeight / step) - 1;
                    const canvas = new OffscreenCanvas(newWidth, newHeight);
                    const ctx = canvas.getContext("2d");
                    ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
                    bitmap = canvas.transferToImageBitmap();
                  }
                  imgData.data = null;
                  imgData.bitmap = bitmap;
                  imgData.width = newWidth;
                  imgData.height = newHeight;
                  return imgData;
                }
                _encodeBMP() {
                  const {
                    width,
                    height,
                    kind
                  } = this._imgData;
                  let data = this._imgData.data;
                  let bitPerPixel;
                  let colorTable = new Uint8Array(0);
                  let maskTable = colorTable;
                  let compression = 0;
                  switch (kind) {
                    case _util.ImageKind.GRAYSCALE_1BPP: {
                      bitPerPixel = 1;
                      colorTable = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);
                      const rowLen = width + 7 >> 3;
                      const rowSize = rowLen + 3 & -4;
                      if (rowLen !== rowSize) {
                        const newData = new Uint8Array(rowSize * height);
                        let k = 0;
                        for (let i2 = 0, ii = height * rowLen; i2 < ii; i2 += rowLen, k += rowSize) {
                          newData.set(data.subarray(i2, i2 + rowLen), k);
                        }
                        data = newData;
                      }
                      break;
                    }
                    case _util.ImageKind.RGB_24BPP: {
                      bitPerPixel = 24;
                      if (width & 3) {
                        const rowLen = 3 * width;
                        const rowSize = rowLen + 3 & -4;
                        const extraLen = rowSize - rowLen;
                        const newData = new Uint8Array(rowSize * height);
                        let k = 0;
                        for (let i2 = 0, ii = height * rowLen; i2 < ii; i2 += rowLen) {
                          const row = data.subarray(i2, i2 + rowLen);
                          for (let j = 0; j < rowLen; j += 3) {
                            newData[k++] = row[j + 2];
                            newData[k++] = row[j + 1];
                            newData[k++] = row[j];
                          }
                          k += extraLen;
                        }
                        data = newData;
                      } else {
                        for (let i2 = 0, ii = data.length; i2 < ii; i2 += 3) {
                          const tmp = data[i2];
                          data[i2] = data[i2 + 2];
                          data[i2 + 2] = tmp;
                        }
                      }
                      break;
                    }
                    case _util.ImageKind.RGBA_32BPP:
                      bitPerPixel = 32;
                      compression = 3;
                      maskTable = new Uint8Array(4 + 4 + 4 + 4 + 52);
                      const view2 = new DataView(maskTable.buffer);
                      if (_util.FeatureTest.isLittleEndian) {
                        view2.setUint32(0, 255, true);
                        view2.setUint32(4, 65280, true);
                        view2.setUint32(8, 16711680, true);
                        view2.setUint32(12, 4278190080, true);
                      } else {
                        view2.setUint32(0, 4278190080, true);
                        view2.setUint32(4, 16711680, true);
                        view2.setUint32(8, 65280, true);
                        view2.setUint32(12, 255, true);
                      }
                      break;
                    default:
                      throw new Error("invalid format");
                  }
                  let i = 0;
                  const headerLength = 40 + maskTable.length;
                  const fileLength = 14 + headerLength + colorTable.length + data.length;
                  const bmpData = new Uint8Array(fileLength);
                  const view = new DataView(bmpData.buffer);
                  view.setUint16(i, 19778, true);
                  i += 2;
                  view.setUint32(i, fileLength, true);
                  i += 4;
                  view.setUint32(i, 0, true);
                  i += 4;
                  view.setUint32(i, 14 + headerLength + colorTable.length, true);
                  i += 4;
                  view.setUint32(i, headerLength, true);
                  i += 4;
                  view.setInt32(i, width, true);
                  i += 4;
                  view.setInt32(i, -height, true);
                  i += 4;
                  view.setUint16(i, 1, true);
                  i += 2;
                  view.setUint16(i, bitPerPixel, true);
                  i += 2;
                  view.setUint32(i, compression, true);
                  i += 4;
                  view.setUint32(i, 0, true);
                  i += 4;
                  view.setInt32(i, 0, true);
                  i += 4;
                  view.setInt32(i, 0, true);
                  i += 4;
                  view.setUint32(i, colorTable.length / 4, true);
                  i += 4;
                  view.setUint32(i, 0, true);
                  i += 4;
                  bmpData.set(maskTable, i);
                  i += maskTable.length;
                  bmpData.set(colorTable, i);
                  i += colorTable.length;
                  bmpData.set(data, i);
                  return bmpData;
                }
              }
              exports2.ImageResizer = ImageResizer;
              ImageResizer._goodSquareLength = MIN_IMAGE_DIM;
            },
            /* 63 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MurmurHash3_64 = void 0;
              var _util = __w_pdfjs_require__2(2);
              const SEED = 3285377520;
              const MASK_HIGH = 4294901760;
              const MASK_LOW = 65535;
              class MurmurHash3_64 {
                constructor(seed) {
                  this.h1 = seed ? seed & 4294967295 : SEED;
                  this.h2 = seed ? seed & 4294967295 : SEED;
                }
                update(input) {
                  let data, length;
                  if (typeof input === "string") {
                    data = new Uint8Array(input.length * 2);
                    length = 0;
                    for (let i = 0, ii = input.length; i < ii; i++) {
                      const code = input.charCodeAt(i);
                      if (code <= 255) {
                        data[length++] = code;
                      } else {
                        data[length++] = code >>> 8;
                        data[length++] = code & 255;
                      }
                    }
                  } else if ((0, _util.isArrayBuffer)(input)) {
                    data = input.slice();
                    length = data.byteLength;
                  } else {
                    throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
                  }
                  const blockCounts = length >> 2;
                  const tailLength = length - blockCounts * 4;
                  const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
                  let k1 = 0, k2 = 0;
                  let h1 = this.h1, h2 = this.h2;
                  const C1 = 3432918353, C2 = 461845907;
                  const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
                  for (let i = 0; i < blockCounts; i++) {
                    if (i & 1) {
                      k1 = dataUint32[i];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      h1 ^= k1;
                      h1 = h1 << 13 | h1 >>> 19;
                      h1 = h1 * 5 + 3864292196;
                    } else {
                      k2 = dataUint32[i];
                      k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
                      k2 = k2 << 15 | k2 >>> 17;
                      k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
                      h2 ^= k2;
                      h2 = h2 << 13 | h2 >>> 19;
                      h2 = h2 * 5 + 3864292196;
                    }
                  }
                  k1 = 0;
                  switch (tailLength) {
                    case 3:
                      k1 ^= data[blockCounts * 4 + 2] << 16;
                    case 2:
                      k1 ^= data[blockCounts * 4 + 1] << 8;
                    case 1:
                      k1 ^= data[blockCounts * 4];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      if (blockCounts & 1) {
                        h1 ^= k1;
                      } else {
                        h2 ^= k1;
                      }
                  }
                  this.h1 = h1;
                  this.h2 = h2;
                }
                hexdigest() {
                  let h1 = this.h1, h2 = this.h2;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
                  h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
                  h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  return (h1 >>> 0).toString(16).padStart(8, "0") + (h2 >>> 0).toString(16).padStart(8, "0");
                }
              }
              exports2.MurmurHash3_64 = MurmurHash3_64;
            },
            /* 64 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OperatorList = void 0;
              var _util = __w_pdfjs_require__2(2);
              function addState(parentState, pattern, checkFn, iterateFn, processFn) {
                let state = parentState;
                for (let i = 0, ii = pattern.length - 1; i < ii; i++) {
                  const item = pattern[i];
                  state = state[item] || (state[item] = []);
                }
                state[pattern.at(-1)] = {
                  checkFn,
                  iterateFn,
                  processFn
                };
              }
              const InitialState = [];
              addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintInlineImageXObject, _util.OPS.restore], null, function iterateInlineImageGroup(context, i) {
                const fnArray = context.fnArray;
                const iFirstSave = context.iCurr - 3;
                const pos = (i - iFirstSave) % 4;
                switch (pos) {
                  case 0:
                    return fnArray[i] === _util.OPS.save;
                  case 1:
                    return fnArray[i] === _util.OPS.transform;
                  case 2:
                    return fnArray[i] === _util.OPS.paintInlineImageXObject;
                  case 3:
                    return fnArray[i] === _util.OPS.restore;
                }
                throw new Error(`iterateInlineImageGroup - invalid pos: ${pos}`);
              }, function foundInlineImageGroup(context, i) {
                const MIN_IMAGES_IN_INLINE_IMAGES_BLOCK = 10;
                const MAX_IMAGES_IN_INLINE_IMAGES_BLOCK = 200;
                const MAX_WIDTH = 1e3;
                const IMAGE_PADDING = 1;
                const fnArray = context.fnArray, argsArray = context.argsArray;
                const curr = context.iCurr;
                const iFirstSave = curr - 3;
                const iFirstTransform = curr - 2;
                const iFirstPIIXO = curr - 1;
                const count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_INLINE_IMAGES_BLOCK);
                if (count < MIN_IMAGES_IN_INLINE_IMAGES_BLOCK) {
                  return i - (i - iFirstSave) % 4;
                }
                let maxX = 0;
                const map = [];
                let maxLineHeight = 0;
                let currentX = IMAGE_PADDING, currentY = IMAGE_PADDING;
                for (let q = 0; q < count; q++) {
                  const transform = argsArray[iFirstTransform + (q << 2)];
                  const img2 = argsArray[iFirstPIIXO + (q << 2)][0];
                  if (currentX + img2.width > MAX_WIDTH) {
                    maxX = Math.max(maxX, currentX);
                    currentY += maxLineHeight + 2 * IMAGE_PADDING;
                    currentX = 0;
                    maxLineHeight = 0;
                  }
                  map.push({
                    transform,
                    x: currentX,
                    y: currentY,
                    w: img2.width,
                    h: img2.height
                  });
                  currentX += img2.width + 2 * IMAGE_PADDING;
                  maxLineHeight = Math.max(maxLineHeight, img2.height);
                }
                const imgWidth = Math.max(maxX, currentX) + IMAGE_PADDING;
                const imgHeight = currentY + maxLineHeight + IMAGE_PADDING;
                const imgData = new Uint8Array(imgWidth * imgHeight * 4);
                const imgRowSize = imgWidth << 2;
                for (let q = 0; q < count; q++) {
                  const data = argsArray[iFirstPIIXO + (q << 2)][0].data;
                  const rowSize = map[q].w << 2;
                  let dataOffset = 0;
                  let offset = map[q].x + map[q].y * imgWidth << 2;
                  imgData.set(data.subarray(0, rowSize), offset - imgRowSize);
                  for (let k = 0, kk = map[q].h; k < kk; k++) {
                    imgData.set(data.subarray(dataOffset, dataOffset + rowSize), offset);
                    dataOffset += rowSize;
                    offset += imgRowSize;
                  }
                  imgData.set(data.subarray(dataOffset - rowSize, dataOffset), offset);
                  while (offset >= 0) {
                    data[offset - 4] = data[offset];
                    data[offset - 3] = data[offset + 1];
                    data[offset - 2] = data[offset + 2];
                    data[offset - 1] = data[offset + 3];
                    data[offset + rowSize] = data[offset + rowSize - 4];
                    data[offset + rowSize + 1] = data[offset + rowSize - 3];
                    data[offset + rowSize + 2] = data[offset + rowSize - 2];
                    data[offset + rowSize + 3] = data[offset + rowSize - 1];
                    offset -= imgRowSize;
                  }
                }
                const img = {
                  width: imgWidth,
                  height: imgHeight
                };
                if (context.isOffscreenCanvasSupported) {
                  const canvas = new OffscreenCanvas(imgWidth, imgHeight);
                  const ctx = canvas.getContext("2d");
                  ctx.putImageData(new ImageData(new Uint8ClampedArray(imgData.buffer), imgWidth, imgHeight), 0, 0);
                  img.bitmap = canvas.transferToImageBitmap();
                  img.data = null;
                } else {
                  img.kind = _util.ImageKind.RGBA_32BPP;
                  img.data = imgData;
                }
                fnArray.splice(iFirstSave, count * 4, _util.OPS.paintInlineImageXObjectGroup);
                argsArray.splice(iFirstSave, count * 4, [img, map]);
                return iFirstSave + 1;
              });
              addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageMaskXObject, _util.OPS.restore], null, function iterateImageMaskGroup(context, i) {
                const fnArray = context.fnArray;
                const iFirstSave = context.iCurr - 3;
                const pos = (i - iFirstSave) % 4;
                switch (pos) {
                  case 0:
                    return fnArray[i] === _util.OPS.save;
                  case 1:
                    return fnArray[i] === _util.OPS.transform;
                  case 2:
                    return fnArray[i] === _util.OPS.paintImageMaskXObject;
                  case 3:
                    return fnArray[i] === _util.OPS.restore;
                }
                throw new Error(`iterateImageMaskGroup - invalid pos: ${pos}`);
              }, function foundImageMaskGroup(context, i) {
                const MIN_IMAGES_IN_MASKS_BLOCK = 10;
                const MAX_IMAGES_IN_MASKS_BLOCK = 100;
                const MAX_SAME_IMAGES_IN_MASKS_BLOCK = 1e3;
                const fnArray = context.fnArray, argsArray = context.argsArray;
                const curr = context.iCurr;
                const iFirstSave = curr - 3;
                const iFirstTransform = curr - 2;
                const iFirstPIMXO = curr - 1;
                let count = Math.floor((i - iFirstSave) / 4);
                if (count < MIN_IMAGES_IN_MASKS_BLOCK) {
                  return i - (i - iFirstSave) % 4;
                }
                let isSameImage = false;
                let iTransform, transformArgs;
                const firstPIMXOArg0 = argsArray[iFirstPIMXO][0];
                const firstTransformArg0 = argsArray[iFirstTransform][0], firstTransformArg1 = argsArray[iFirstTransform][1], firstTransformArg2 = argsArray[iFirstTransform][2], firstTransformArg3 = argsArray[iFirstTransform][3];
                if (firstTransformArg1 === firstTransformArg2) {
                  isSameImage = true;
                  iTransform = iFirstTransform + 4;
                  let iPIMXO = iFirstPIMXO + 4;
                  for (let q = 1; q < count; q++, iTransform += 4, iPIMXO += 4) {
                    transformArgs = argsArray[iTransform];
                    if (argsArray[iPIMXO][0] !== firstPIMXOArg0 || transformArgs[0] !== firstTransformArg0 || transformArgs[1] !== firstTransformArg1 || transformArgs[2] !== firstTransformArg2 || transformArgs[3] !== firstTransformArg3) {
                      if (q < MIN_IMAGES_IN_MASKS_BLOCK) {
                        isSameImage = false;
                      } else {
                        count = q;
                      }
                      break;
                    }
                  }
                }
                if (isSameImage) {
                  count = Math.min(count, MAX_SAME_IMAGES_IN_MASKS_BLOCK);
                  const positions = new Float32Array(count * 2);
                  iTransform = iFirstTransform;
                  for (let q = 0; q < count; q++, iTransform += 4) {
                    transformArgs = argsArray[iTransform];
                    positions[q << 1] = transformArgs[4];
                    positions[(q << 1) + 1] = transformArgs[5];
                  }
                  fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectRepeat);
                  argsArray.splice(iFirstSave, count * 4, [firstPIMXOArg0, firstTransformArg0, firstTransformArg1, firstTransformArg2, firstTransformArg3, positions]);
                } else {
                  count = Math.min(count, MAX_IMAGES_IN_MASKS_BLOCK);
                  const images = [];
                  for (let q = 0; q < count; q++) {
                    transformArgs = argsArray[iFirstTransform + (q << 2)];
                    const maskParams = argsArray[iFirstPIMXO + (q << 2)][0];
                    images.push({
                      data: maskParams.data,
                      width: maskParams.width,
                      height: maskParams.height,
                      interpolate: maskParams.interpolate,
                      count: maskParams.count,
                      transform: transformArgs
                    });
                  }
                  fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectGroup);
                  argsArray.splice(iFirstSave, count * 4, [images]);
                }
                return iFirstSave + 1;
              });
              addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageXObject, _util.OPS.restore], function(context) {
                const argsArray = context.argsArray;
                const iFirstTransform = context.iCurr - 2;
                return argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0;
              }, function iterateImageGroup(context, i) {
                const fnArray = context.fnArray, argsArray = context.argsArray;
                const iFirstSave = context.iCurr - 3;
                const pos = (i - iFirstSave) % 4;
                switch (pos) {
                  case 0:
                    return fnArray[i] === _util.OPS.save;
                  case 1:
                    if (fnArray[i] !== _util.OPS.transform) {
                      return false;
                    }
                    const iFirstTransform = context.iCurr - 2;
                    const firstTransformArg0 = argsArray[iFirstTransform][0];
                    const firstTransformArg3 = argsArray[iFirstTransform][3];
                    if (argsArray[i][0] !== firstTransformArg0 || argsArray[i][1] !== 0 || argsArray[i][2] !== 0 || argsArray[i][3] !== firstTransformArg3) {
                      return false;
                    }
                    return true;
                  case 2:
                    if (fnArray[i] !== _util.OPS.paintImageXObject) {
                      return false;
                    }
                    const iFirstPIXO = context.iCurr - 1;
                    const firstPIXOArg0 = argsArray[iFirstPIXO][0];
                    if (argsArray[i][0] !== firstPIXOArg0) {
                      return false;
                    }
                    return true;
                  case 3:
                    return fnArray[i] === _util.OPS.restore;
                }
                throw new Error(`iterateImageGroup - invalid pos: ${pos}`);
              }, function(context, i) {
                const MIN_IMAGES_IN_BLOCK = 3;
                const MAX_IMAGES_IN_BLOCK = 1e3;
                const fnArray = context.fnArray, argsArray = context.argsArray;
                const curr = context.iCurr;
                const iFirstSave = curr - 3;
                const iFirstTransform = curr - 2;
                const iFirstPIXO = curr - 1;
                const firstPIXOArg0 = argsArray[iFirstPIXO][0];
                const firstTransformArg0 = argsArray[iFirstTransform][0];
                const firstTransformArg3 = argsArray[iFirstTransform][3];
                const count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_BLOCK);
                if (count < MIN_IMAGES_IN_BLOCK) {
                  return i - (i - iFirstSave) % 4;
                }
                const positions = new Float32Array(count * 2);
                let iTransform = iFirstTransform;
                for (let q = 0; q < count; q++, iTransform += 4) {
                  const transformArgs = argsArray[iTransform];
                  positions[q << 1] = transformArgs[4];
                  positions[(q << 1) + 1] = transformArgs[5];
                }
                const args = [firstPIXOArg0, firstTransformArg0, firstTransformArg3, positions];
                fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageXObjectRepeat);
                argsArray.splice(iFirstSave, count * 4, args);
                return iFirstSave + 1;
              });
              addState(InitialState, [_util.OPS.beginText, _util.OPS.setFont, _util.OPS.setTextMatrix, _util.OPS.showText, _util.OPS.endText], null, function iterateShowTextGroup(context, i) {
                const fnArray = context.fnArray, argsArray = context.argsArray;
                const iFirstSave = context.iCurr - 4;
                const pos = (i - iFirstSave) % 5;
                switch (pos) {
                  case 0:
                    return fnArray[i] === _util.OPS.beginText;
                  case 1:
                    return fnArray[i] === _util.OPS.setFont;
                  case 2:
                    return fnArray[i] === _util.OPS.setTextMatrix;
                  case 3:
                    if (fnArray[i] !== _util.OPS.showText) {
                      return false;
                    }
                    const iFirstSetFont = context.iCurr - 3;
                    const firstSetFontArg0 = argsArray[iFirstSetFont][0];
                    const firstSetFontArg1 = argsArray[iFirstSetFont][1];
                    if (argsArray[i][0] !== firstSetFontArg0 || argsArray[i][1] !== firstSetFontArg1) {
                      return false;
                    }
                    return true;
                  case 4:
                    return fnArray[i] === _util.OPS.endText;
                }
                throw new Error(`iterateShowTextGroup - invalid pos: ${pos}`);
              }, function(context, i) {
                const MIN_CHARS_IN_BLOCK = 3;
                const MAX_CHARS_IN_BLOCK = 1e3;
                const fnArray = context.fnArray, argsArray = context.argsArray;
                const curr = context.iCurr;
                const iFirstBeginText = curr - 4;
                const iFirstSetFont = curr - 3;
                const iFirstSetTextMatrix = curr - 2;
                const iFirstShowText = curr - 1;
                const iFirstEndText = curr;
                const firstSetFontArg0 = argsArray[iFirstSetFont][0];
                const firstSetFontArg1 = argsArray[iFirstSetFont][1];
                let count = Math.min(Math.floor((i - iFirstBeginText) / 5), MAX_CHARS_IN_BLOCK);
                if (count < MIN_CHARS_IN_BLOCK) {
                  return i - (i - iFirstBeginText) % 5;
                }
                let iFirst = iFirstBeginText;
                if (iFirstBeginText >= 4 && fnArray[iFirstBeginText - 4] === fnArray[iFirstSetFont] && fnArray[iFirstBeginText - 3] === fnArray[iFirstSetTextMatrix] && fnArray[iFirstBeginText - 2] === fnArray[iFirstShowText] && fnArray[iFirstBeginText - 1] === fnArray[iFirstEndText] && argsArray[iFirstBeginText - 4][0] === firstSetFontArg0 && argsArray[iFirstBeginText - 4][1] === firstSetFontArg1) {
                  count++;
                  iFirst -= 5;
                }
                let iEndText = iFirst + 4;
                for (let q = 1; q < count; q++) {
                  fnArray.splice(iEndText, 3);
                  argsArray.splice(iEndText, 3);
                  iEndText += 2;
                }
                return iEndText + 1;
              });
              class NullOptimizer {
                constructor(queue) {
                  this.queue = queue;
                }
                _optimize() {
                }
                push(fn, args) {
                  this.queue.fnArray.push(fn);
                  this.queue.argsArray.push(args);
                  this._optimize();
                }
                flush() {
                }
                reset() {
                }
              }
              class QueueOptimizer extends NullOptimizer {
                constructor(queue) {
                  super(queue);
                  this.state = null;
                  this.context = {
                    iCurr: 0,
                    fnArray: queue.fnArray,
                    argsArray: queue.argsArray,
                    isOffscreenCanvasSupported: false
                  };
                  this.match = null;
                  this.lastProcessed = 0;
                }
                set isOffscreenCanvasSupported(value) {
                  this.context.isOffscreenCanvasSupported = value;
                }
                _optimize() {
                  const fnArray = this.queue.fnArray;
                  let i = this.lastProcessed, ii = fnArray.length;
                  let state = this.state;
                  let match = this.match;
                  if (!state && !match && i + 1 === ii && !InitialState[fnArray[i]]) {
                    this.lastProcessed = ii;
                    return;
                  }
                  const context = this.context;
                  while (i < ii) {
                    if (match) {
                      const iterate = (0, match.iterateFn)(context, i);
                      if (iterate) {
                        i++;
                        continue;
                      }
                      i = (0, match.processFn)(context, i + 1);
                      ii = fnArray.length;
                      match = null;
                      state = null;
                      if (i >= ii) {
                        break;
                      }
                    }
                    state = (state || InitialState)[fnArray[i]];
                    if (!state || Array.isArray(state)) {
                      i++;
                      continue;
                    }
                    context.iCurr = i;
                    i++;
                    if (state.checkFn && !(0, state.checkFn)(context)) {
                      state = null;
                      continue;
                    }
                    match = state;
                    state = null;
                  }
                  this.state = state;
                  this.match = match;
                  this.lastProcessed = i;
                }
                flush() {
                  while (this.match) {
                    const length = this.queue.fnArray.length;
                    this.lastProcessed = (0, this.match.processFn)(this.context, length);
                    this.match = null;
                    this.state = null;
                    this._optimize();
                  }
                }
                reset() {
                  this.state = null;
                  this.match = null;
                  this.lastProcessed = 0;
                }
              }
              const _OperatorList = class _OperatorList {
                constructor(intent = 0, streamSink) {
                  this._streamSink = streamSink;
                  this.fnArray = [];
                  this.argsArray = [];
                  this.optimizer = streamSink && !(intent & _util.RenderingIntentFlag.OPLIST) ? new QueueOptimizer(this) : new NullOptimizer(this);
                  this.dependencies = /* @__PURE__ */ new Set();
                  this._totalLength = 0;
                  this.weight = 0;
                  this._resolved = streamSink ? null : Promise.resolve();
                }
                set isOffscreenCanvasSupported(value) {
                  this.optimizer.isOffscreenCanvasSupported = value;
                }
                get length() {
                  return this.argsArray.length;
                }
                get ready() {
                  return this._resolved || this._streamSink.ready;
                }
                get totalLength() {
                  return this._totalLength + this.length;
                }
                addOp(fn, args) {
                  this.optimizer.push(fn, args);
                  this.weight++;
                  if (this._streamSink) {
                    if (this.weight >= _OperatorList.CHUNK_SIZE) {
                      this.flush();
                    } else if (this.weight >= _OperatorList.CHUNK_SIZE_ABOUT && (fn === _util.OPS.restore || fn === _util.OPS.endText)) {
                      this.flush();
                    }
                  }
                }
                addImageOps(fn, args, optionalContent) {
                  if (optionalContent !== void 0) {
                    this.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);
                  }
                  this.addOp(fn, args);
                  if (optionalContent !== void 0) {
                    this.addOp(_util.OPS.endMarkedContent, []);
                  }
                }
                addDependency(dependency) {
                  if (this.dependencies.has(dependency)) {
                    return;
                  }
                  this.dependencies.add(dependency);
                  this.addOp(_util.OPS.dependency, [dependency]);
                }
                addDependencies(dependencies) {
                  for (const dependency of dependencies) {
                    this.addDependency(dependency);
                  }
                }
                addOpList(opList) {
                  if (!(opList instanceof _OperatorList)) {
                    (0, _util.warn)('addOpList - ignoring invalid "opList" parameter.');
                    return;
                  }
                  for (const dependency of opList.dependencies) {
                    this.dependencies.add(dependency);
                  }
                  for (let i = 0, ii = opList.length; i < ii; i++) {
                    this.addOp(opList.fnArray[i], opList.argsArray[i]);
                  }
                }
                getIR() {
                  return {
                    fnArray: this.fnArray,
                    argsArray: this.argsArray,
                    length: this.length
                  };
                }
                get _transfers() {
                  var _a;
                  const transfers = [];
                  const {
                    fnArray,
                    argsArray,
                    length
                  } = this;
                  for (let i = 0; i < length; i++) {
                    switch (fnArray[i]) {
                      case _util.OPS.paintInlineImageXObject:
                      case _util.OPS.paintInlineImageXObjectGroup:
                      case _util.OPS.paintImageMaskXObject:
                        const arg = argsArray[i][0];
                        if (!arg.cached && ((_a = arg.data) == null ? void 0 : _a.buffer) instanceof ArrayBuffer) {
                          transfers.push(arg.data.buffer);
                        }
                        break;
                    }
                  }
                  return transfers;
                }
                flush(lastChunk = false, separateAnnots = null) {
                  this.optimizer.flush();
                  const length = this.length;
                  this._totalLength += length;
                  this._streamSink.enqueue({
                    fnArray: this.fnArray,
                    argsArray: this.argsArray,
                    lastChunk,
                    separateAnnots,
                    length
                  }, 1, this._transfers);
                  this.dependencies.clear();
                  this.fnArray.length = 0;
                  this.argsArray.length = 0;
                  this.weight = 0;
                  this.optimizer.reset();
                }
              };
              __publicField(_OperatorList, "CHUNK_SIZE", 1e3);
              __publicField(_OperatorList, "CHUNK_SIZE_ABOUT", _OperatorList.CHUNK_SIZE - 5);
              let OperatorList = _OperatorList;
              exports2.OperatorList = OperatorList;
            },
            /* 65 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFImage = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _image_utils = __w_pdfjs_require__2(28);
              var _base_stream = __w_pdfjs_require__2(5);
              var _colorspace = __w_pdfjs_require__2(12);
              var _decode_stream = __w_pdfjs_require__2(18);
              var _image_resizer = __w_pdfjs_require__2(62);
              var _jpeg_stream = __w_pdfjs_require__2(26);
              var _jpx = __w_pdfjs_require__2(30);
              var _primitives = __w_pdfjs_require__2(4);
              function decodeAndClamp(value, addend, coefficient, max) {
                value = addend + value * coefficient;
                if (value < 0) {
                  value = 0;
                } else if (value > max) {
                  value = max;
                }
                return value;
              }
              function resizeImageMask(src, bpc, w1, h1, w2, h2) {
                const length = w2 * h2;
                let dest;
                if (bpc <= 8) {
                  dest = new Uint8Array(length);
                } else if (bpc <= 16) {
                  dest = new Uint16Array(length);
                } else {
                  dest = new Uint32Array(length);
                }
                const xRatio = w1 / w2;
                const yRatio = h1 / h2;
                let i, j, py, newIndex = 0, oldIndex;
                const xScaled = new Uint16Array(w2);
                const w1Scanline = w1;
                for (i = 0; i < w2; i++) {
                  xScaled[i] = Math.floor(i * xRatio);
                }
                for (i = 0; i < h2; i++) {
                  py = Math.floor(i * yRatio) * w1Scanline;
                  for (j = 0; j < w2; j++) {
                    oldIndex = py + xScaled[j];
                    dest[newIndex++] = src[oldIndex];
                  }
                }
                return dest;
              }
              class PDFImage {
                constructor({
                  xref,
                  res,
                  image,
                  isInline = false,
                  smask = null,
                  mask = null,
                  isMask = false,
                  pdfFunctionFactory,
                  localColorSpaceCache
                }) {
                  var _a;
                  this.image = image;
                  const dict = image.dict;
                  const filter = dict.get("F", "Filter");
                  let filterName;
                  if (filter instanceof _primitives.Name) {
                    filterName = filter.name;
                  } else if (Array.isArray(filter)) {
                    const filterZero = xref.fetchIfRef(filter[0]);
                    if (filterZero instanceof _primitives.Name) {
                      filterName = filterZero.name;
                    }
                  }
                  switch (filterName) {
                    case "JPXDecode":
                      const jpxImage = new _jpx.JpxImage();
                      jpxImage.parseImageProperties(image.stream);
                      image.stream.reset();
                      image.width = jpxImage.width;
                      image.height = jpxImage.height;
                      image.bitsPerComponent = jpxImage.bitsPerComponent;
                      image.numComps = jpxImage.componentsCount;
                      break;
                    case "JBIG2Decode":
                      image.bitsPerComponent = 1;
                      image.numComps = 1;
                      break;
                  }
                  let width = dict.get("W", "Width");
                  let height = dict.get("H", "Height");
                  if (Number.isInteger(image.width) && image.width > 0 && Number.isInteger(image.height) && image.height > 0 && (image.width !== width || image.height !== height)) {
                    (0, _util.warn)("PDFImage - using the Width/Height of the image data, rather than the image dictionary.");
                    width = image.width;
                    height = image.height;
                  }
                  if (width < 1 || height < 1) {
                    throw new _util.FormatError(`Invalid image width: ${width} or height: ${height}`);
                  }
                  this.width = width;
                  this.height = height;
                  this.interpolate = dict.get("I", "Interpolate");
                  this.imageMask = dict.get("IM", "ImageMask") || false;
                  this.matte = dict.get("Matte") || false;
                  let bitsPerComponent = image.bitsPerComponent;
                  if (!bitsPerComponent) {
                    bitsPerComponent = dict.get("BPC", "BitsPerComponent");
                    if (!bitsPerComponent) {
                      if (this.imageMask) {
                        bitsPerComponent = 1;
                      } else {
                        throw new _util.FormatError(`Bits per component missing in image: ${this.imageMask}`);
                      }
                    }
                  }
                  this.bpc = bitsPerComponent;
                  if (!this.imageMask) {
                    let colorSpace = dict.getRaw("CS") || dict.getRaw("ColorSpace");
                    if (!colorSpace) {
                      (0, _util.info)("JPX images (which do not require color spaces)");
                      switch (image.numComps) {
                        case 1:
                          colorSpace = _primitives.Name.get("DeviceGray");
                          break;
                        case 3:
                          colorSpace = _primitives.Name.get("DeviceRGB");
                          break;
                        case 4:
                          colorSpace = _primitives.Name.get("DeviceCMYK");
                          break;
                        default:
                          throw new Error(`JPX images with ${image.numComps} color components not supported.`);
                      }
                    }
                    this.colorSpace = _colorspace.ColorSpace.parse({
                      cs: colorSpace,
                      xref,
                      resources: isInline ? res : null,
                      pdfFunctionFactory,
                      localColorSpaceCache
                    });
                    this.numComps = this.colorSpace.numComps;
                  }
                  this.decode = dict.getArray("D", "Decode");
                  this.needsDecode = false;
                  if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, bitsPerComponent) || isMask && !_colorspace.ColorSpace.isDefaultDecode(this.decode, 1))) {
                    this.needsDecode = true;
                    const max = (1 << bitsPerComponent) - 1;
                    this.decodeCoefficients = [];
                    this.decodeAddends = [];
                    const isIndexed = ((_a = this.colorSpace) == null ? void 0 : _a.name) === "Indexed";
                    for (let i = 0, j = 0; i < this.decode.length; i += 2, ++j) {
                      const dmin = this.decode[i];
                      const dmax = this.decode[i + 1];
                      this.decodeCoefficients[j] = isIndexed ? (dmax - dmin) / max : dmax - dmin;
                      this.decodeAddends[j] = isIndexed ? dmin : max * dmin;
                    }
                  }
                  if (smask) {
                    this.smask = new PDFImage({
                      xref,
                      res,
                      image: smask,
                      isInline,
                      pdfFunctionFactory,
                      localColorSpaceCache
                    });
                  } else if (mask) {
                    if (mask instanceof _base_stream.BaseStream) {
                      const maskDict = mask.dict, imageMask = maskDict.get("IM", "ImageMask");
                      if (!imageMask) {
                        (0, _util.warn)("Ignoring /Mask in image without /ImageMask.");
                      } else {
                        this.mask = new PDFImage({
                          xref,
                          res,
                          image: mask,
                          isInline,
                          isMask: true,
                          pdfFunctionFactory,
                          localColorSpaceCache
                        });
                      }
                    } else {
                      this.mask = mask;
                    }
                  }
                }
                static async buildImage({
                  xref,
                  res,
                  image,
                  isInline = false,
                  pdfFunctionFactory,
                  localColorSpaceCache
                }) {
                  const imageData = image;
                  let smaskData = null;
                  let maskData = null;
                  const smask = image.dict.get("SMask");
                  const mask = image.dict.get("Mask");
                  if (smask) {
                    if (smask instanceof _base_stream.BaseStream) {
                      smaskData = smask;
                    } else {
                      (0, _util.warn)("Unsupported /SMask format.");
                    }
                  } else if (mask) {
                    if (mask instanceof _base_stream.BaseStream || Array.isArray(mask)) {
                      maskData = mask;
                    } else {
                      (0, _util.warn)("Unsupported /Mask format.");
                    }
                  }
                  return new PDFImage({
                    xref,
                    res,
                    image: imageData,
                    isInline,
                    smask: smaskData,
                    mask: maskData,
                    pdfFunctionFactory,
                    localColorSpaceCache
                  });
                }
                static createRawMask({
                  imgArray,
                  width,
                  height,
                  imageIsFromDecodeStream,
                  inverseDecode,
                  interpolate
                }) {
                  const computedLength = (width + 7 >> 3) * height;
                  const actualLength = imgArray.byteLength;
                  const haveFullData = computedLength === actualLength;
                  let data, i;
                  if (imageIsFromDecodeStream && (!inverseDecode || haveFullData)) {
                    data = imgArray;
                  } else if (!inverseDecode) {
                    data = new Uint8Array(imgArray);
                  } else {
                    data = new Uint8Array(computedLength);
                    data.set(imgArray);
                    data.fill(255, actualLength);
                  }
                  if (inverseDecode) {
                    for (i = 0; i < actualLength; i++) {
                      data[i] ^= 255;
                    }
                  }
                  return {
                    data,
                    width,
                    height,
                    interpolate
                  };
                }
                static async createMask({
                  imgArray,
                  width,
                  height,
                  imageIsFromDecodeStream,
                  inverseDecode,
                  interpolate,
                  isOffscreenCanvasSupported = false
                }) {
                  const isSingleOpaquePixel = width === 1 && height === 1 && inverseDecode === (imgArray.length === 0 || !!(imgArray[0] & 128));
                  if (isSingleOpaquePixel) {
                    return {
                      isSingleOpaquePixel
                    };
                  }
                  if (isOffscreenCanvasSupported) {
                    if (_image_resizer.ImageResizer.needsToBeResized(width, height)) {
                      const data = new Uint8ClampedArray(width * height * 4);
                      (0, _image_utils.convertBlackAndWhiteToRGBA)({
                        src: imgArray,
                        dest: data,
                        width,
                        height,
                        nonBlackColor: 0,
                        inverseDecode
                      });
                      return _image_resizer.ImageResizer.createImage({
                        kind: _util.ImageKind.RGBA_32BPP,
                        data,
                        width,
                        height,
                        interpolate
                      });
                    }
                    const canvas = new OffscreenCanvas(width, height);
                    const ctx = canvas.getContext("2d");
                    const imgData = ctx.createImageData(width, height);
                    (0, _image_utils.convertBlackAndWhiteToRGBA)({
                      src: imgArray,
                      dest: imgData.data,
                      width,
                      height,
                      nonBlackColor: 0,
                      inverseDecode
                    });
                    ctx.putImageData(imgData, 0, 0);
                    const bitmap = canvas.transferToImageBitmap();
                    return {
                      data: null,
                      width,
                      height,
                      interpolate,
                      bitmap
                    };
                  }
                  return this.createRawMask({
                    imgArray,
                    width,
                    height,
                    inverseDecode,
                    imageIsFromDecodeStream,
                    interpolate
                  });
                }
                get drawWidth() {
                  var _a, _b;
                  return Math.max(this.width, ((_a = this.smask) == null ? void 0 : _a.width) || 0, ((_b = this.mask) == null ? void 0 : _b.width) || 0);
                }
                get drawHeight() {
                  var _a, _b;
                  return Math.max(this.height, ((_a = this.smask) == null ? void 0 : _a.height) || 0, ((_b = this.mask) == null ? void 0 : _b.height) || 0);
                }
                decodeBuffer(buffer) {
                  const bpc = this.bpc;
                  const numComps = this.numComps;
                  const decodeAddends = this.decodeAddends;
                  const decodeCoefficients = this.decodeCoefficients;
                  const max = (1 << bpc) - 1;
                  let i, ii;
                  if (bpc === 1) {
                    for (i = 0, ii = buffer.length; i < ii; i++) {
                      buffer[i] = +!buffer[i];
                    }
                    return;
                  }
                  let index = 0;
                  for (i = 0, ii = this.width * this.height; i < ii; i++) {
                    for (let j = 0; j < numComps; j++) {
                      buffer[index] = decodeAndClamp(buffer[index], decodeAddends[j], decodeCoefficients[j], max);
                      index++;
                    }
                  }
                }
                getComponents(buffer) {
                  const bpc = this.bpc;
                  if (bpc === 8) {
                    return buffer;
                  }
                  const width = this.width;
                  const height = this.height;
                  const numComps = this.numComps;
                  const length = width * height * numComps;
                  let bufferPos = 0;
                  let output;
                  if (bpc <= 8) {
                    output = new Uint8Array(length);
                  } else if (bpc <= 16) {
                    output = new Uint16Array(length);
                  } else {
                    output = new Uint32Array(length);
                  }
                  const rowComps = width * numComps;
                  const max = (1 << bpc) - 1;
                  let i = 0, ii, buf;
                  if (bpc === 1) {
                    let mask, loop1End, loop2End;
                    for (let j = 0; j < height; j++) {
                      loop1End = i + (rowComps & ~7);
                      loop2End = i + rowComps;
                      while (i < loop1End) {
                        buf = buffer[bufferPos++];
                        output[i] = buf >> 7 & 1;
                        output[i + 1] = buf >> 6 & 1;
                        output[i + 2] = buf >> 5 & 1;
                        output[i + 3] = buf >> 4 & 1;
                        output[i + 4] = buf >> 3 & 1;
                        output[i + 5] = buf >> 2 & 1;
                        output[i + 6] = buf >> 1 & 1;
                        output[i + 7] = buf & 1;
                        i += 8;
                      }
                      if (i < loop2End) {
                        buf = buffer[bufferPos++];
                        mask = 128;
                        while (i < loop2End) {
                          output[i++] = +!!(buf & mask);
                          mask >>= 1;
                        }
                      }
                    }
                  } else {
                    let bits = 0;
                    buf = 0;
                    for (i = 0, ii = length; i < ii; ++i) {
                      if (i % rowComps === 0) {
                        buf = 0;
                        bits = 0;
                      }
                      while (bits < bpc) {
                        buf = buf << 8 | buffer[bufferPos++];
                        bits += 8;
                      }
                      const remainingBits = bits - bpc;
                      let value = buf >> remainingBits;
                      if (value < 0) {
                        value = 0;
                      } else if (value > max) {
                        value = max;
                      }
                      output[i] = value;
                      buf &= (1 << remainingBits) - 1;
                      bits = remainingBits;
                    }
                  }
                  return output;
                }
                fillOpacity(rgbaBuf, width, height, actualHeight, image) {
                  const smask = this.smask;
                  const mask = this.mask;
                  let alphaBuf, sw, sh, i, ii, j;
                  if (smask) {
                    sw = smask.width;
                    sh = smask.height;
                    alphaBuf = new Uint8ClampedArray(sw * sh);
                    smask.fillGrayBuffer(alphaBuf);
                    if (sw !== width || sh !== height) {
                      alphaBuf = resizeImageMask(alphaBuf, smask.bpc, sw, sh, width, height);
                    }
                  } else if (mask) {
                    if (mask instanceof PDFImage) {
                      sw = mask.width;
                      sh = mask.height;
                      alphaBuf = new Uint8ClampedArray(sw * sh);
                      mask.numComps = 1;
                      mask.fillGrayBuffer(alphaBuf);
                      for (i = 0, ii = sw * sh; i < ii; ++i) {
                        alphaBuf[i] = 255 - alphaBuf[i];
                      }
                      if (sw !== width || sh !== height) {
                        alphaBuf = resizeImageMask(alphaBuf, mask.bpc, sw, sh, width, height);
                      }
                    } else if (Array.isArray(mask)) {
                      alphaBuf = new Uint8ClampedArray(width * height);
                      const numComps = this.numComps;
                      for (i = 0, ii = width * height; i < ii; ++i) {
                        let opacity = 0;
                        const imageOffset = i * numComps;
                        for (j = 0; j < numComps; ++j) {
                          const color = image[imageOffset + j];
                          const maskOffset = j * 2;
                          if (color < mask[maskOffset] || color > mask[maskOffset + 1]) {
                            opacity = 255;
                            break;
                          }
                        }
                        alphaBuf[i] = opacity;
                      }
                    } else {
                      throw new _util.FormatError("Unknown mask format.");
                    }
                  }
                  if (alphaBuf) {
                    for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
                      rgbaBuf[j] = alphaBuf[i];
                    }
                  } else {
                    for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
                      rgbaBuf[j] = 255;
                    }
                  }
                }
                undoPreblend(buffer, width, height) {
                  var _a;
                  const matte = (_a = this.smask) == null ? void 0 : _a.matte;
                  if (!matte) {
                    return;
                  }
                  const matteRgb = this.colorSpace.getRgb(matte, 0);
                  const matteR = matteRgb[0];
                  const matteG = matteRgb[1];
                  const matteB = matteRgb[2];
                  const length = width * height * 4;
                  for (let i = 0; i < length; i += 4) {
                    const alpha = buffer[i + 3];
                    if (alpha === 0) {
                      buffer[i] = 255;
                      buffer[i + 1] = 255;
                      buffer[i + 2] = 255;
                      continue;
                    }
                    const k = 255 / alpha;
                    buffer[i] = (buffer[i] - matteR) * k + matteR;
                    buffer[i + 1] = (buffer[i + 1] - matteG) * k + matteG;
                    buffer[i + 2] = (buffer[i + 2] - matteB) * k + matteB;
                  }
                }
                async createImageData(forceRGBA = false, isOffscreenCanvasSupported = false) {
                  const drawWidth = this.drawWidth;
                  const drawHeight = this.drawHeight;
                  const imgData = {
                    width: drawWidth,
                    height: drawHeight,
                    interpolate: this.interpolate,
                    kind: 0,
                    data: null
                  };
                  const numComps = this.numComps;
                  const originalWidth = this.width;
                  const originalHeight = this.height;
                  const bpc = this.bpc;
                  const rowBytes = originalWidth * numComps * bpc + 7 >> 3;
                  const mustBeResized = isOffscreenCanvasSupported && _image_resizer.ImageResizer.needsToBeResized(drawWidth, drawHeight);
                  if (!forceRGBA) {
                    let kind;
                    if (this.colorSpace.name === "DeviceGray" && bpc === 1) {
                      kind = _util.ImageKind.GRAYSCALE_1BPP;
                    } else if (this.colorSpace.name === "DeviceRGB" && bpc === 8 && !this.needsDecode) {
                      kind = _util.ImageKind.RGB_24BPP;
                    }
                    if (kind && !this.smask && !this.mask && drawWidth === originalWidth && drawHeight === originalHeight) {
                      const data2 = this.getImageBytes(originalHeight * rowBytes, {});
                      if (isOffscreenCanvasSupported) {
                        if (mustBeResized) {
                          return _image_resizer.ImageResizer.createImage({
                            data: data2,
                            kind,
                            width: drawWidth,
                            height: drawHeight,
                            interpolate: this.interpolate
                          }, this.needsDecode);
                        }
                        return this.createBitmap(kind, originalWidth, originalHeight, data2);
                      }
                      imgData.kind = kind;
                      imgData.data = data2;
                      if (this.needsDecode) {
                        (0, _util.assert)(kind === _util.ImageKind.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
                        const buffer = imgData.data;
                        for (let i = 0, ii = buffer.length; i < ii; i++) {
                          buffer[i] ^= 255;
                        }
                      }
                      return imgData;
                    }
                    if (this.image instanceof _jpeg_stream.JpegStream && !this.smask && !this.mask && !this.needsDecode) {
                      let imageLength = originalHeight * rowBytes;
                      if (isOffscreenCanvasSupported && !mustBeResized) {
                        let isHandled = false;
                        switch (this.colorSpace.name) {
                          case "DeviceGray":
                            imageLength *= 4;
                            isHandled = true;
                            break;
                          case "DeviceRGB":
                            imageLength = imageLength / 3 * 4;
                            isHandled = true;
                            break;
                          case "DeviceCMYK":
                            isHandled = true;
                            break;
                        }
                        if (isHandled) {
                          const rgba = this.getImageBytes(imageLength, {
                            drawWidth,
                            drawHeight,
                            forceRGBA: true
                          });
                          return this.createBitmap(_util.ImageKind.RGBA_32BPP, drawWidth, drawHeight, rgba);
                        }
                      } else {
                        switch (this.colorSpace.name) {
                          case "DeviceGray":
                            imageLength *= 3;
                          case "DeviceRGB":
                          case "DeviceCMYK":
                            imgData.kind = _util.ImageKind.RGB_24BPP;
                            imgData.data = this.getImageBytes(imageLength, {
                              drawWidth,
                              drawHeight,
                              forceRGB: true
                            });
                            if (mustBeResized) {
                              return _image_resizer.ImageResizer.createImage(imgData);
                            }
                            return imgData;
                        }
                      }
                    }
                  }
                  const imgArray = this.getImageBytes(originalHeight * rowBytes, {
                    internal: true
                  });
                  const actualHeight = 0 | imgArray.length / rowBytes * drawHeight / originalHeight;
                  const comps = this.getComponents(imgArray);
                  let alpha01, maybeUndoPreblend;
                  let canvas, ctx, canvasImgData, data;
                  if (isOffscreenCanvasSupported && !mustBeResized) {
                    canvas = new OffscreenCanvas(drawWidth, drawHeight);
                    ctx = canvas.getContext("2d");
                    canvasImgData = ctx.createImageData(drawWidth, drawHeight);
                    data = canvasImgData.data;
                  }
                  imgData.kind = _util.ImageKind.RGBA_32BPP;
                  if (!forceRGBA && !this.smask && !this.mask) {
                    if (!isOffscreenCanvasSupported || mustBeResized) {
                      imgData.kind = _util.ImageKind.RGB_24BPP;
                      data = new Uint8ClampedArray(drawWidth * drawHeight * 3);
                      alpha01 = 0;
                    } else {
                      const arr = new Uint32Array(data.buffer);
                      arr.fill(_util.FeatureTest.isLittleEndian ? 4278190080 : 255);
                      alpha01 = 1;
                    }
                    maybeUndoPreblend = false;
                  } else {
                    if (!isOffscreenCanvasSupported || mustBeResized) {
                      data = new Uint8ClampedArray(drawWidth * drawHeight * 4);
                    }
                    alpha01 = 1;
                    maybeUndoPreblend = true;
                    this.fillOpacity(data, drawWidth, drawHeight, actualHeight, comps);
                  }
                  if (this.needsDecode) {
                    this.decodeBuffer(comps);
                  }
                  this.colorSpace.fillRgb(data, originalWidth, originalHeight, drawWidth, drawHeight, actualHeight, bpc, comps, alpha01);
                  if (maybeUndoPreblend) {
                    this.undoPreblend(data, drawWidth, actualHeight);
                  }
                  if (isOffscreenCanvasSupported && !mustBeResized) {
                    ctx.putImageData(canvasImgData, 0, 0);
                    const bitmap = canvas.transferToImageBitmap();
                    return {
                      data: null,
                      width: drawWidth,
                      height: drawHeight,
                      bitmap,
                      interpolate: this.interpolate
                    };
                  }
                  imgData.data = data;
                  if (mustBeResized) {
                    return _image_resizer.ImageResizer.createImage(imgData);
                  }
                  return imgData;
                }
                fillGrayBuffer(buffer) {
                  const numComps = this.numComps;
                  if (numComps !== 1) {
                    throw new _util.FormatError(`Reading gray scale from a color image: ${numComps}`);
                  }
                  const width = this.width;
                  const height = this.height;
                  const bpc = this.bpc;
                  const rowBytes = width * numComps * bpc + 7 >> 3;
                  const imgArray = this.getImageBytes(height * rowBytes, {
                    internal: true
                  });
                  const comps = this.getComponents(imgArray);
                  let i, length;
                  if (bpc === 1) {
                    length = width * height;
                    if (this.needsDecode) {
                      for (i = 0; i < length; ++i) {
                        buffer[i] = comps[i] - 1 & 255;
                      }
                    } else {
                      for (i = 0; i < length; ++i) {
                        buffer[i] = -comps[i] & 255;
                      }
                    }
                    return;
                  }
                  if (this.needsDecode) {
                    this.decodeBuffer(comps);
                  }
                  length = width * height;
                  const scale = 255 / ((1 << bpc) - 1);
                  for (i = 0; i < length; ++i) {
                    buffer[i] = scale * comps[i];
                  }
                }
                createBitmap(kind, width, height, src) {
                  const canvas = new OffscreenCanvas(width, height);
                  const ctx = canvas.getContext("2d");
                  let imgData;
                  if (kind === _util.ImageKind.RGBA_32BPP) {
                    imgData = new ImageData(src, width, height);
                  } else {
                    imgData = ctx.createImageData(width, height);
                    (0, _image_utils.convertToRGBA)({
                      kind,
                      src,
                      dest: new Uint32Array(imgData.data.buffer),
                      width,
                      height,
                      inverseDecode: this.needsDecode
                    });
                  }
                  ctx.putImageData(imgData, 0, 0);
                  const bitmap = canvas.transferToImageBitmap();
                  return {
                    data: null,
                    width,
                    height,
                    bitmap,
                    interpolate: this.interpolate
                  };
                }
                getImageBytes(length, {
                  drawWidth,
                  drawHeight,
                  forceRGBA = false,
                  forceRGB = false,
                  internal = false
                }) {
                  this.image.reset();
                  this.image.drawWidth = drawWidth || this.width;
                  this.image.drawHeight = drawHeight || this.height;
                  this.image.forceRGBA = !!forceRGBA;
                  this.image.forceRGB = !!forceRGB;
                  const imageBytes = this.image.getBytes(length);
                  if (internal || this.image instanceof _decode_stream.DecodeStream) {
                    return imageBytes;
                  }
                  (0, _util.assert)(imageBytes instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.');
                  return new Uint8Array(imageBytes);
                }
              }
              exports2.PDFImage = PDFImage;
            },
            /* 66 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Catalog = void 0;
              var _core_utils = __w_pdfjs_require__2(3);
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(4);
              var _name_number_tree = __w_pdfjs_require__2(67);
              var _base_stream = __w_pdfjs_require__2(5);
              var _cleanup_helper = __w_pdfjs_require__2(68);
              var _colorspace = __w_pdfjs_require__2(12);
              var _file_spec = __w_pdfjs_require__2(69);
              var _image_utils = __w_pdfjs_require__2(59);
              var _metadata_parser = __w_pdfjs_require__2(70);
              var _struct_tree = __w_pdfjs_require__2(72);
              function fetchDestination(dest) {
                if (dest instanceof _primitives.Dict) {
                  dest = dest.get("D");
                }
                return Array.isArray(dest) ? dest : null;
              }
              class Catalog {
                constructor(pdfManager, xref) {
                  this.pdfManager = pdfManager;
                  this.xref = xref;
                  this._catDict = xref.getCatalogObj();
                  if (!(this._catDict instanceof _primitives.Dict)) {
                    throw new _util.FormatError("Catalog object is not a dictionary.");
                  }
                  this.toplevelPagesDict;
                  this._actualNumPages = null;
                  this.fontCache = new _primitives.RefSetCache();
                  this.builtInCMapCache = /* @__PURE__ */ new Map();
                  this.standardFontDataCache = /* @__PURE__ */ new Map();
                  this.globalImageCache = new _image_utils.GlobalImageCache();
                  this.pageKidsCountCache = new _primitives.RefSetCache();
                  this.pageIndexCache = new _primitives.RefSetCache();
                  this.nonBlendModesSet = new _primitives.RefSet();
                  this.systemFontCache = /* @__PURE__ */ new Map();
                }
                cloneDict() {
                  return this._catDict.clone();
                }
                get version() {
                  const version = this._catDict.get("Version");
                  if (version instanceof _primitives.Name) {
                    if (_core_utils.PDF_VERSION_REGEXP.test(version.name)) {
                      return (0, _util.shadow)(this, "version", version.name);
                    }
                    (0, _util.warn)(`Invalid PDF catalog version: ${version.name}`);
                  }
                  return (0, _util.shadow)(this, "version", null);
                }
                get lang() {
                  const lang = this._catDict.get("Lang");
                  return (0, _util.shadow)(this, "lang", typeof lang === "string" ? (0, _util.stringToPDFString)(lang) : null);
                }
                get needsRendering() {
                  const needsRendering = this._catDict.get("NeedsRendering");
                  return (0, _util.shadow)(this, "needsRendering", typeof needsRendering === "boolean" ? needsRendering : false);
                }
                get collection() {
                  let collection = null;
                  try {
                    const obj = this._catDict.get("Collection");
                    if (obj instanceof _primitives.Dict && obj.size > 0) {
                      collection = obj;
                    }
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.info)("Cannot fetch Collection entry; assuming no collection is present.");
                  }
                  return (0, _util.shadow)(this, "collection", collection);
                }
                get acroForm() {
                  let acroForm = null;
                  try {
                    const obj = this._catDict.get("AcroForm");
                    if (obj instanceof _primitives.Dict && obj.size > 0) {
                      acroForm = obj;
                    }
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.info)("Cannot fetch AcroForm entry; assuming no forms are present.");
                  }
                  return (0, _util.shadow)(this, "acroForm", acroForm);
                }
                get acroFormRef() {
                  const value = this._catDict.getRaw("AcroForm");
                  return (0, _util.shadow)(this, "acroFormRef", value instanceof _primitives.Ref ? value : null);
                }
                get metadata() {
                  var _a;
                  const streamRef = this._catDict.getRaw("Metadata");
                  if (!(streamRef instanceof _primitives.Ref)) {
                    return (0, _util.shadow)(this, "metadata", null);
                  }
                  let metadata = null;
                  try {
                    const stream = this.xref.fetch(streamRef, !((_a = this.xref.encrypt) == null ? void 0 : _a.encryptMetadata));
                    if (stream instanceof _base_stream.BaseStream && stream.dict instanceof _primitives.Dict) {
                      const type = stream.dict.get("Type");
                      const subtype = stream.dict.get("Subtype");
                      if ((0, _primitives.isName)(type, "Metadata") && (0, _primitives.isName)(subtype, "XML")) {
                        const data = (0, _util.stringToUTF8String)(stream.getString());
                        if (data) {
                          metadata = new _metadata_parser.MetadataParser(data).serializable;
                        }
                      }
                    }
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.info)(`Skipping invalid Metadata: "${ex}".`);
                  }
                  return (0, _util.shadow)(this, "metadata", metadata);
                }
                get markInfo() {
                  let markInfo = null;
                  try {
                    markInfo = this._readMarkInfo();
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)("Unable to read mark info.");
                  }
                  return (0, _util.shadow)(this, "markInfo", markInfo);
                }
                _readMarkInfo() {
                  const obj = this._catDict.get("MarkInfo");
                  if (!(obj instanceof _primitives.Dict)) {
                    return null;
                  }
                  const markInfo = {
                    Marked: false,
                    UserProperties: false,
                    Suspects: false
                  };
                  for (const key in markInfo) {
                    const value = obj.get(key);
                    if (typeof value === "boolean") {
                      markInfo[key] = value;
                    }
                  }
                  return markInfo;
                }
                get structTreeRoot() {
                  let structTree = null;
                  try {
                    structTree = this._readStructTreeRoot();
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)("Unable read to structTreeRoot info.");
                  }
                  return (0, _util.shadow)(this, "structTreeRoot", structTree);
                }
                _readStructTreeRoot() {
                  const rawObj = this._catDict.getRaw("StructTreeRoot");
                  const obj = this.xref.fetchIfRef(rawObj);
                  if (!(obj instanceof _primitives.Dict)) {
                    return null;
                  }
                  const root = new _struct_tree.StructTreeRoot(obj, rawObj);
                  root.init();
                  return root;
                }
                get toplevelPagesDict() {
                  const pagesObj = this._catDict.get("Pages");
                  if (!(pagesObj instanceof _primitives.Dict)) {
                    throw new _util.FormatError("Invalid top-level pages dictionary.");
                  }
                  return (0, _util.shadow)(this, "toplevelPagesDict", pagesObj);
                }
                get documentOutline() {
                  let obj = null;
                  try {
                    obj = this._readDocumentOutline();
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)("Unable to read document outline.");
                  }
                  return (0, _util.shadow)(this, "documentOutline", obj);
                }
                _readDocumentOutline() {
                  let obj = this._catDict.get("Outlines");
                  if (!(obj instanceof _primitives.Dict)) {
                    return null;
                  }
                  obj = obj.getRaw("First");
                  if (!(obj instanceof _primitives.Ref)) {
                    return null;
                  }
                  const root = {
                    items: []
                  };
                  const queue = [{
                    obj,
                    parent: root
                  }];
                  const processed = new _primitives.RefSet();
                  processed.put(obj);
                  const xref = this.xref, blackColor = new Uint8ClampedArray(3);
                  while (queue.length > 0) {
                    const i = queue.shift();
                    const outlineDict = xref.fetchIfRef(i.obj);
                    if (outlineDict === null) {
                      continue;
                    }
                    if (!outlineDict.has("Title")) {
                      throw new _util.FormatError("Invalid outline item encountered.");
                    }
                    const data = {
                      url: null,
                      dest: null,
                      action: null
                    };
                    Catalog.parseDestDictionary({
                      destDict: outlineDict,
                      resultObj: data,
                      docBaseUrl: this.baseUrl,
                      docAttachments: this.attachments
                    });
                    const title = outlineDict.get("Title");
                    const flags = outlineDict.get("F") || 0;
                    const color = outlineDict.getArray("C");
                    const count = outlineDict.get("Count");
                    let rgbColor = blackColor;
                    if (Array.isArray(color) && color.length === 3 && (color[0] !== 0 || color[1] !== 0 || color[2] !== 0)) {
                      rgbColor = _colorspace.ColorSpace.singletons.rgb.getRgb(color, 0);
                    }
                    const outlineItem = {
                      action: data.action,
                      attachment: data.attachment,
                      dest: data.dest,
                      url: data.url,
                      unsafeUrl: data.unsafeUrl,
                      newWindow: data.newWindow,
                      setOCGState: data.setOCGState,
                      title: (0, _util.stringToPDFString)(title),
                      color: rgbColor,
                      count: Number.isInteger(count) ? count : void 0,
                      bold: !!(flags & 2),
                      italic: !!(flags & 1),
                      items: []
                    };
                    i.parent.items.push(outlineItem);
                    obj = outlineDict.getRaw("First");
                    if (obj instanceof _primitives.Ref && !processed.has(obj)) {
                      queue.push({
                        obj,
                        parent: outlineItem
                      });
                      processed.put(obj);
                    }
                    obj = outlineDict.getRaw("Next");
                    if (obj instanceof _primitives.Ref && !processed.has(obj)) {
                      queue.push({
                        obj,
                        parent: i.parent
                      });
                      processed.put(obj);
                    }
                  }
                  return root.items.length > 0 ? root.items : null;
                }
                get permissions() {
                  let permissions = null;
                  try {
                    permissions = this._readPermissions();
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)("Unable to read permissions.");
                  }
                  return (0, _util.shadow)(this, "permissions", permissions);
                }
                _readPermissions() {
                  const encrypt = this.xref.trailer.get("Encrypt");
                  if (!(encrypt instanceof _primitives.Dict)) {
                    return null;
                  }
                  let flags = encrypt.get("P");
                  if (typeof flags !== "number") {
                    return null;
                  }
                  flags += 2 ** 32;
                  const permissions = [];
                  for (const key in _util.PermissionFlag) {
                    const value = _util.PermissionFlag[key];
                    if (flags & value) {
                      permissions.push(value);
                    }
                  }
                  return permissions;
                }
                get optionalContentConfig() {
                  let config = null;
                  try {
                    const properties = this._catDict.get("OCProperties");
                    if (!properties) {
                      return (0, _util.shadow)(this, "optionalContentConfig", null);
                    }
                    const defaultConfig = properties.get("D");
                    if (!defaultConfig) {
                      return (0, _util.shadow)(this, "optionalContentConfig", null);
                    }
                    const groupsData = properties.get("OCGs");
                    if (!Array.isArray(groupsData)) {
                      return (0, _util.shadow)(this, "optionalContentConfig", null);
                    }
                    const groups = [];
                    const groupRefs = [];
                    for (const groupRef of groupsData) {
                      if (!(groupRef instanceof _primitives.Ref)) {
                        continue;
                      }
                      groupRefs.push(groupRef);
                      const group = this.xref.fetchIfRef(groupRef);
                      groups.push({
                        id: groupRef.toString(),
                        name: typeof group.get("Name") === "string" ? (0, _util.stringToPDFString)(group.get("Name")) : null,
                        intent: typeof group.get("Intent") === "string" ? (0, _util.stringToPDFString)(group.get("Intent")) : null
                      });
                    }
                    config = this._readOptionalContentConfig(defaultConfig, groupRefs);
                    config.groups = groups;
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)(`Unable to read optional content config: ${ex}`);
                  }
                  return (0, _util.shadow)(this, "optionalContentConfig", config);
                }
                _readOptionalContentConfig(config, contentGroupRefs) {
                  function parseOnOff(refs) {
                    const onParsed = [];
                    if (Array.isArray(refs)) {
                      for (const value of refs) {
                        if (!(value instanceof _primitives.Ref)) {
                          continue;
                        }
                        if (contentGroupRefs.includes(value)) {
                          onParsed.push(value.toString());
                        }
                      }
                    }
                    return onParsed;
                  }
                  function parseOrder(refs, nestedLevels = 0) {
                    if (!Array.isArray(refs)) {
                      return null;
                    }
                    const order = [];
                    for (const value of refs) {
                      if (value instanceof _primitives.Ref && contentGroupRefs.includes(value)) {
                        parsedOrderRefs.put(value);
                        order.push(value.toString());
                        continue;
                      }
                      const nestedOrder = parseNestedOrder(value, nestedLevels);
                      if (nestedOrder) {
                        order.push(nestedOrder);
                      }
                    }
                    if (nestedLevels > 0) {
                      return order;
                    }
                    const hiddenGroups = [];
                    for (const groupRef of contentGroupRefs) {
                      if (parsedOrderRefs.has(groupRef)) {
                        continue;
                      }
                      hiddenGroups.push(groupRef.toString());
                    }
                    if (hiddenGroups.length) {
                      order.push({
                        name: null,
                        order: hiddenGroups
                      });
                    }
                    return order;
                  }
                  function parseNestedOrder(ref, nestedLevels) {
                    if (++nestedLevels > MAX_NESTED_LEVELS) {
                      (0, _util.warn)("parseNestedOrder - reached MAX_NESTED_LEVELS.");
                      return null;
                    }
                    const value = xref.fetchIfRef(ref);
                    if (!Array.isArray(value)) {
                      return null;
                    }
                    const nestedName = xref.fetchIfRef(value[0]);
                    if (typeof nestedName !== "string") {
                      return null;
                    }
                    const nestedOrder = parseOrder(value.slice(1), nestedLevels);
                    if (!nestedOrder || !nestedOrder.length) {
                      return null;
                    }
                    return {
                      name: (0, _util.stringToPDFString)(nestedName),
                      order: nestedOrder
                    };
                  }
                  const xref = this.xref, parsedOrderRefs = new _primitives.RefSet(), MAX_NESTED_LEVELS = 10;
                  return {
                    name: typeof config.get("Name") === "string" ? (0, _util.stringToPDFString)(config.get("Name")) : null,
                    creator: typeof config.get("Creator") === "string" ? (0, _util.stringToPDFString)(config.get("Creator")) : null,
                    baseState: config.get("BaseState") instanceof _primitives.Name ? config.get("BaseState").name : null,
                    on: parseOnOff(config.get("ON")),
                    off: parseOnOff(config.get("OFF")),
                    order: parseOrder(config.get("Order")),
                    groups: null
                  };
                }
                setActualNumPages(num = null) {
                  this._actualNumPages = num;
                }
                get hasActualNumPages() {
                  return this._actualNumPages !== null;
                }
                get _pagesCount() {
                  const obj = this.toplevelPagesDict.get("Count");
                  if (!Number.isInteger(obj)) {
                    throw new _util.FormatError("Page count in top-level pages dictionary is not an integer.");
                  }
                  return (0, _util.shadow)(this, "_pagesCount", obj);
                }
                get numPages() {
                  return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
                }
                get destinations() {
                  const obj = this._readDests(), dests = /* @__PURE__ */ Object.create(null);
                  if (obj instanceof _name_number_tree.NameTree) {
                    for (const [key, value] of obj.getAll()) {
                      const dest = fetchDestination(value);
                      if (dest) {
                        dests[(0, _util.stringToPDFString)(key)] = dest;
                      }
                    }
                  } else if (obj instanceof _primitives.Dict) {
                    obj.forEach(function(key, value) {
                      const dest = fetchDestination(value);
                      if (dest) {
                        dests[key] = dest;
                      }
                    });
                  }
                  return (0, _util.shadow)(this, "destinations", dests);
                }
                getDestination(id) {
                  const obj = this._readDests();
                  if (obj instanceof _name_number_tree.NameTree) {
                    const dest = fetchDestination(obj.get(id));
                    if (dest) {
                      return dest;
                    }
                    const allDest = this.destinations[id];
                    if (allDest) {
                      (0, _util.warn)(`Found "${id}" at an incorrect position in the NameTree.`);
                      return allDest;
                    }
                  } else if (obj instanceof _primitives.Dict) {
                    const dest = fetchDestination(obj.get(id));
                    if (dest) {
                      return dest;
                    }
                  }
                  return null;
                }
                _readDests() {
                  const obj = this._catDict.get("Names");
                  if (obj == null ? void 0 : obj.has("Dests")) {
                    return new _name_number_tree.NameTree(obj.getRaw("Dests"), this.xref);
                  } else if (this._catDict.has("Dests")) {
                    return this._catDict.get("Dests");
                  }
                  return void 0;
                }
                get pageLabels() {
                  let obj = null;
                  try {
                    obj = this._readPageLabels();
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)("Unable to read page labels.");
                  }
                  return (0, _util.shadow)(this, "pageLabels", obj);
                }
                _readPageLabels() {
                  const obj = this._catDict.getRaw("PageLabels");
                  if (!obj) {
                    return null;
                  }
                  const pageLabels = new Array(this.numPages);
                  let style = null, prefix = "";
                  const numberTree = new _name_number_tree.NumberTree(obj, this.xref);
                  const nums = numberTree.getAll();
                  let currentLabel = "", currentIndex = 1;
                  for (let i = 0, ii = this.numPages; i < ii; i++) {
                    const labelDict = nums.get(i);
                    if (labelDict !== void 0) {
                      if (!(labelDict instanceof _primitives.Dict)) {
                        throw new _util.FormatError("PageLabel is not a dictionary.");
                      }
                      if (labelDict.has("Type") && !(0, _primitives.isName)(labelDict.get("Type"), "PageLabel")) {
                        throw new _util.FormatError("Invalid type in PageLabel dictionary.");
                      }
                      if (labelDict.has("S")) {
                        const s = labelDict.get("S");
                        if (!(s instanceof _primitives.Name)) {
                          throw new _util.FormatError("Invalid style in PageLabel dictionary.");
                        }
                        style = s.name;
                      } else {
                        style = null;
                      }
                      if (labelDict.has("P")) {
                        const p = labelDict.get("P");
                        if (typeof p !== "string") {
                          throw new _util.FormatError("Invalid prefix in PageLabel dictionary.");
                        }
                        prefix = (0, _util.stringToPDFString)(p);
                      } else {
                        prefix = "";
                      }
                      if (labelDict.has("St")) {
                        const st = labelDict.get("St");
                        if (!(Number.isInteger(st) && st >= 1)) {
                          throw new _util.FormatError("Invalid start in PageLabel dictionary.");
                        }
                        currentIndex = st;
                      } else {
                        currentIndex = 1;
                      }
                    }
                    switch (style) {
                      case "D":
                        currentLabel = currentIndex;
                        break;
                      case "R":
                      case "r":
                        currentLabel = (0, _core_utils.toRomanNumerals)(currentIndex, style === "r");
                        break;
                      case "A":
                      case "a":
                        const LIMIT = 26;
                        const A_UPPER_CASE = 65, A_LOWER_CASE = 97;
                        const baseCharCode = style === "a" ? A_LOWER_CASE : A_UPPER_CASE;
                        const letterIndex = currentIndex - 1;
                        const character = String.fromCharCode(baseCharCode + letterIndex % LIMIT);
                        currentLabel = character.repeat(Math.floor(letterIndex / LIMIT) + 1);
                        break;
                      default:
                        if (style) {
                          throw new _util.FormatError(`Invalid style "${style}" in PageLabel dictionary.`);
                        }
                        currentLabel = "";
                    }
                    pageLabels[i] = prefix + currentLabel;
                    currentIndex++;
                  }
                  return pageLabels;
                }
                get pageLayout() {
                  const obj = this._catDict.get("PageLayout");
                  let pageLayout = "";
                  if (obj instanceof _primitives.Name) {
                    switch (obj.name) {
                      case "SinglePage":
                      case "OneColumn":
                      case "TwoColumnLeft":
                      case "TwoColumnRight":
                      case "TwoPageLeft":
                      case "TwoPageRight":
                        pageLayout = obj.name;
                    }
                  }
                  return (0, _util.shadow)(this, "pageLayout", pageLayout);
                }
                get pageMode() {
                  const obj = this._catDict.get("PageMode");
                  let pageMode = "UseNone";
                  if (obj instanceof _primitives.Name) {
                    switch (obj.name) {
                      case "UseNone":
                      case "UseOutlines":
                      case "UseThumbs":
                      case "FullScreen":
                      case "UseOC":
                      case "UseAttachments":
                        pageMode = obj.name;
                    }
                  }
                  return (0, _util.shadow)(this, "pageMode", pageMode);
                }
                get viewerPreferences() {
                  const obj = this._catDict.get("ViewerPreferences");
                  if (!(obj instanceof _primitives.Dict)) {
                    return (0, _util.shadow)(this, "viewerPreferences", null);
                  }
                  let prefs = null;
                  for (const key of obj.getKeys()) {
                    const value = obj.get(key);
                    let prefValue;
                    switch (key) {
                      case "HideToolbar":
                      case "HideMenubar":
                      case "HideWindowUI":
                      case "FitWindow":
                      case "CenterWindow":
                      case "DisplayDocTitle":
                      case "PickTrayByPDFSize":
                        if (typeof value === "boolean") {
                          prefValue = value;
                        }
                        break;
                      case "NonFullScreenPageMode":
                        if (value instanceof _primitives.Name) {
                          switch (value.name) {
                            case "UseNone":
                            case "UseOutlines":
                            case "UseThumbs":
                            case "UseOC":
                              prefValue = value.name;
                              break;
                            default:
                              prefValue = "UseNone";
                          }
                        }
                        break;
                      case "Direction":
                        if (value instanceof _primitives.Name) {
                          switch (value.name) {
                            case "L2R":
                            case "R2L":
                              prefValue = value.name;
                              break;
                            default:
                              prefValue = "L2R";
                          }
                        }
                        break;
                      case "ViewArea":
                      case "ViewClip":
                      case "PrintArea":
                      case "PrintClip":
                        if (value instanceof _primitives.Name) {
                          switch (value.name) {
                            case "MediaBox":
                            case "CropBox":
                            case "BleedBox":
                            case "TrimBox":
                            case "ArtBox":
                              prefValue = value.name;
                              break;
                            default:
                              prefValue = "CropBox";
                          }
                        }
                        break;
                      case "PrintScaling":
                        if (value instanceof _primitives.Name) {
                          switch (value.name) {
                            case "None":
                            case "AppDefault":
                              prefValue = value.name;
                              break;
                            default:
                              prefValue = "AppDefault";
                          }
                        }
                        break;
                      case "Duplex":
                        if (value instanceof _primitives.Name) {
                          switch (value.name) {
                            case "Simplex":
                            case "DuplexFlipShortEdge":
                            case "DuplexFlipLongEdge":
                              prefValue = value.name;
                              break;
                            default:
                              prefValue = "None";
                          }
                        }
                        break;
                      case "PrintPageRange":
                        if (Array.isArray(value) && value.length % 2 === 0) {
                          const isValid = value.every((page, i, arr) => {
                            return Number.isInteger(page) && page > 0 && (i === 0 || page >= arr[i - 1]) && page <= this.numPages;
                          });
                          if (isValid) {
                            prefValue = value;
                          }
                        }
                        break;
                      case "NumCopies":
                        if (Number.isInteger(value) && value > 0) {
                          prefValue = value;
                        }
                        break;
                      default:
                        (0, _util.warn)(`Ignoring non-standard key in ViewerPreferences: ${key}.`);
                        continue;
                    }
                    if (prefValue === void 0) {
                      (0, _util.warn)(`Bad value, for key "${key}", in ViewerPreferences: ${value}.`);
                      continue;
                    }
                    if (!prefs) {
                      prefs = /* @__PURE__ */ Object.create(null);
                    }
                    prefs[key] = prefValue;
                  }
                  return (0, _util.shadow)(this, "viewerPreferences", prefs);
                }
                get openAction() {
                  const obj = this._catDict.get("OpenAction");
                  const openAction = /* @__PURE__ */ Object.create(null);
                  if (obj instanceof _primitives.Dict) {
                    const destDict = new _primitives.Dict(this.xref);
                    destDict.set("A", obj);
                    const resultObj = {
                      url: null,
                      dest: null,
                      action: null
                    };
                    Catalog.parseDestDictionary({
                      destDict,
                      resultObj
                    });
                    if (Array.isArray(resultObj.dest)) {
                      openAction.dest = resultObj.dest;
                    } else if (resultObj.action) {
                      openAction.action = resultObj.action;
                    }
                  } else if (Array.isArray(obj)) {
                    openAction.dest = obj;
                  }
                  return (0, _util.shadow)(this, "openAction", (0, _util.objectSize)(openAction) > 0 ? openAction : null);
                }
                get attachments() {
                  const obj = this._catDict.get("Names");
                  let attachments = null;
                  if (obj instanceof _primitives.Dict && obj.has("EmbeddedFiles")) {
                    const nameTree = new _name_number_tree.NameTree(obj.getRaw("EmbeddedFiles"), this.xref);
                    for (const [key, value] of nameTree.getAll()) {
                      const fs = new _file_spec.FileSpec(value, this.xref);
                      if (!attachments) {
                        attachments = /* @__PURE__ */ Object.create(null);
                      }
                      attachments[(0, _util.stringToPDFString)(key)] = fs.serializable;
                    }
                  }
                  return (0, _util.shadow)(this, "attachments", attachments);
                }
                get xfaImages() {
                  const obj = this._catDict.get("Names");
                  let xfaImages = null;
                  if (obj instanceof _primitives.Dict && obj.has("XFAImages")) {
                    const nameTree = new _name_number_tree.NameTree(obj.getRaw("XFAImages"), this.xref);
                    for (const [key, value] of nameTree.getAll()) {
                      if (!xfaImages) {
                        xfaImages = new _primitives.Dict(this.xref);
                      }
                      xfaImages.set((0, _util.stringToPDFString)(key), value);
                    }
                  }
                  return (0, _util.shadow)(this, "xfaImages", xfaImages);
                }
                _collectJavaScript() {
                  const obj = this._catDict.get("Names");
                  let javaScript = null;
                  function appendIfJavaScriptDict(name, jsDict) {
                    if (!(jsDict instanceof _primitives.Dict)) {
                      return;
                    }
                    if (!(0, _primitives.isName)(jsDict.get("S"), "JavaScript")) {
                      return;
                    }
                    let js = jsDict.get("JS");
                    if (js instanceof _base_stream.BaseStream) {
                      js = js.getString();
                    } else if (typeof js !== "string") {
                      return;
                    }
                    js = (0, _util.stringToPDFString)(js).replaceAll("\0", "");
                    if (js) {
                      (javaScript || (javaScript = /* @__PURE__ */ new Map())).set(name, js);
                    }
                  }
                  if (obj instanceof _primitives.Dict && obj.has("JavaScript")) {
                    const nameTree = new _name_number_tree.NameTree(obj.getRaw("JavaScript"), this.xref);
                    for (const [key, value] of nameTree.getAll()) {
                      appendIfJavaScriptDict((0, _util.stringToPDFString)(key), value);
                    }
                  }
                  const openAction = this._catDict.get("OpenAction");
                  if (openAction) {
                    appendIfJavaScriptDict("OpenAction", openAction);
                  }
                  return javaScript;
                }
                get jsActions() {
                  const javaScript = this._collectJavaScript();
                  let actions = (0, _core_utils.collectActions)(this.xref, this._catDict, _util.DocumentActionEventType);
                  if (javaScript) {
                    actions || (actions = /* @__PURE__ */ Object.create(null));
                    for (const [key, val] of javaScript) {
                      if (key in actions) {
                        actions[key].push(val);
                      } else {
                        actions[key] = [val];
                      }
                    }
                  }
                  return (0, _util.shadow)(this, "jsActions", actions);
                }
                async fontFallback(id, handler) {
                  const translatedFonts = await Promise.all(this.fontCache);
                  for (const translatedFont of translatedFonts) {
                    if (translatedFont.loadedName === id) {
                      translatedFont.fallback(handler);
                      return;
                    }
                  }
                }
                async cleanup(manuallyTriggered = false) {
                  (0, _cleanup_helper.clearGlobalCaches)();
                  this.globalImageCache.clear(manuallyTriggered);
                  this.pageKidsCountCache.clear();
                  this.pageIndexCache.clear();
                  this.nonBlendModesSet.clear();
                  const translatedFonts = await Promise.all(this.fontCache);
                  for (const {
                    dict
                  } of translatedFonts) {
                    delete dict.cacheKey;
                  }
                  this.fontCache.clear();
                  this.builtInCMapCache.clear();
                  this.standardFontDataCache.clear();
                  this.systemFontCache.clear();
                }
                async getPageDict(pageIndex) {
                  const nodesToVisit = [this.toplevelPagesDict];
                  const visitedNodes = new _primitives.RefSet();
                  const pagesRef = this._catDict.getRaw("Pages");
                  if (pagesRef instanceof _primitives.Ref) {
                    visitedNodes.put(pagesRef);
                  }
                  const xref = this.xref, pageKidsCountCache = this.pageKidsCountCache, pageIndexCache = this.pageIndexCache;
                  let currentPageIndex = 0;
                  while (nodesToVisit.length) {
                    const currentNode = nodesToVisit.pop();
                    if (currentNode instanceof _primitives.Ref) {
                      const count2 = pageKidsCountCache.get(currentNode);
                      if (count2 >= 0 && currentPageIndex + count2 <= pageIndex) {
                        currentPageIndex += count2;
                        continue;
                      }
                      if (visitedNodes.has(currentNode)) {
                        throw new _util.FormatError("Pages tree contains circular reference.");
                      }
                      visitedNodes.put(currentNode);
                      const obj = await xref.fetchAsync(currentNode);
                      if (obj instanceof _primitives.Dict) {
                        let type = obj.getRaw("Type");
                        if (type instanceof _primitives.Ref) {
                          type = await xref.fetchAsync(type);
                        }
                        if ((0, _primitives.isName)(type, "Page") || !obj.has("Kids")) {
                          if (!pageKidsCountCache.has(currentNode)) {
                            pageKidsCountCache.put(currentNode, 1);
                          }
                          if (!pageIndexCache.has(currentNode)) {
                            pageIndexCache.put(currentNode, currentPageIndex);
                          }
                          if (currentPageIndex === pageIndex) {
                            return [obj, currentNode];
                          }
                          currentPageIndex++;
                          continue;
                        }
                      }
                      nodesToVisit.push(obj);
                      continue;
                    }
                    if (!(currentNode instanceof _primitives.Dict)) {
                      throw new _util.FormatError("Page dictionary kid reference points to wrong type of object.");
                    }
                    const {
                      objId
                    } = currentNode;
                    let count = currentNode.getRaw("Count");
                    if (count instanceof _primitives.Ref) {
                      count = await xref.fetchAsync(count);
                    }
                    if (Number.isInteger(count) && count >= 0) {
                      if (objId && !pageKidsCountCache.has(objId)) {
                        pageKidsCountCache.put(objId, count);
                      }
                      if (currentPageIndex + count <= pageIndex) {
                        currentPageIndex += count;
                        continue;
                      }
                    }
                    let kids = currentNode.getRaw("Kids");
                    if (kids instanceof _primitives.Ref) {
                      kids = await xref.fetchAsync(kids);
                    }
                    if (!Array.isArray(kids)) {
                      let type = currentNode.getRaw("Type");
                      if (type instanceof _primitives.Ref) {
                        type = await xref.fetchAsync(type);
                      }
                      if ((0, _primitives.isName)(type, "Page") || !currentNode.has("Kids")) {
                        if (currentPageIndex === pageIndex) {
                          return [currentNode, null];
                        }
                        currentPageIndex++;
                        continue;
                      }
                      throw new _util.FormatError("Page dictionary kids object is not an array.");
                    }
                    for (let last = kids.length - 1; last >= 0; last--) {
                      nodesToVisit.push(kids[last]);
                    }
                  }
                  throw new Error(`Page index ${pageIndex} not found.`);
                }
                async getAllPageDicts(recoveryMode = false) {
                  const {
                    ignoreErrors
                  } = this.pdfManager.evaluatorOptions;
                  const queue = [{
                    currentNode: this.toplevelPagesDict,
                    posInKids: 0
                  }];
                  const visitedNodes = new _primitives.RefSet();
                  const pagesRef = this._catDict.getRaw("Pages");
                  if (pagesRef instanceof _primitives.Ref) {
                    visitedNodes.put(pagesRef);
                  }
                  const map = /* @__PURE__ */ new Map(), xref = this.xref, pageIndexCache = this.pageIndexCache;
                  let pageIndex = 0;
                  function addPageDict(pageDict, pageRef) {
                    if (pageRef && !pageIndexCache.has(pageRef)) {
                      pageIndexCache.put(pageRef, pageIndex);
                    }
                    map.set(pageIndex++, [pageDict, pageRef]);
                  }
                  function addPageError(error) {
                    if (error instanceof _core_utils.XRefEntryException && !recoveryMode) {
                      throw error;
                    }
                    if (recoveryMode && ignoreErrors && pageIndex === 0) {
                      (0, _util.warn)(`getAllPageDicts - Skipping invalid first page: "${error}".`);
                      error = _primitives.Dict.empty;
                    }
                    map.set(pageIndex++, [error, null]);
                  }
                  while (queue.length > 0) {
                    const queueItem = queue.at(-1);
                    const {
                      currentNode,
                      posInKids
                    } = queueItem;
                    let kids = currentNode.getRaw("Kids");
                    if (kids instanceof _primitives.Ref) {
                      try {
                        kids = await xref.fetchAsync(kids);
                      } catch (ex) {
                        addPageError(ex);
                        break;
                      }
                    }
                    if (!Array.isArray(kids)) {
                      addPageError(new _util.FormatError("Page dictionary kids object is not an array."));
                      break;
                    }
                    if (posInKids >= kids.length) {
                      queue.pop();
                      continue;
                    }
                    const kidObj = kids[posInKids];
                    let obj;
                    if (kidObj instanceof _primitives.Ref) {
                      if (visitedNodes.has(kidObj)) {
                        addPageError(new _util.FormatError("Pages tree contains circular reference."));
                        break;
                      }
                      visitedNodes.put(kidObj);
                      try {
                        obj = await xref.fetchAsync(kidObj);
                      } catch (ex) {
                        addPageError(ex);
                        break;
                      }
                    } else {
                      obj = kidObj;
                    }
                    if (!(obj instanceof _primitives.Dict)) {
                      addPageError(new _util.FormatError("Page dictionary kid reference points to wrong type of object."));
                      break;
                    }
                    let type = obj.getRaw("Type");
                    if (type instanceof _primitives.Ref) {
                      try {
                        type = await xref.fetchAsync(type);
                      } catch (ex) {
                        addPageError(ex);
                        break;
                      }
                    }
                    if ((0, _primitives.isName)(type, "Page") || !obj.has("Kids")) {
                      addPageDict(obj, kidObj instanceof _primitives.Ref ? kidObj : null);
                    } else {
                      queue.push({
                        currentNode: obj,
                        posInKids: 0
                      });
                    }
                    queueItem.posInKids++;
                  }
                  return map;
                }
                getPageIndex(pageRef) {
                  const cachedPageIndex = this.pageIndexCache.get(pageRef);
                  if (cachedPageIndex !== void 0) {
                    return Promise.resolve(cachedPageIndex);
                  }
                  const xref = this.xref;
                  function pagesBeforeRef(kidRef) {
                    let total2 = 0, parentRef;
                    return xref.fetchAsync(kidRef).then(function(node) {
                      if ((0, _primitives.isRefsEqual)(kidRef, pageRef) && !(0, _primitives.isDict)(node, "Page") && !(node instanceof _primitives.Dict && !node.has("Type") && node.has("Contents"))) {
                        throw new _util.FormatError("The reference does not point to a /Page dictionary.");
                      }
                      if (!node) {
                        return null;
                      }
                      if (!(node instanceof _primitives.Dict)) {
                        throw new _util.FormatError("Node must be a dictionary.");
                      }
                      parentRef = node.getRaw("Parent");
                      return node.getAsync("Parent");
                    }).then(function(parent) {
                      if (!parent) {
                        return null;
                      }
                      if (!(parent instanceof _primitives.Dict)) {
                        throw new _util.FormatError("Parent must be a dictionary.");
                      }
                      return parent.getAsync("Kids");
                    }).then(function(kids) {
                      if (!kids) {
                        return null;
                      }
                      const kidPromises = [];
                      let found = false;
                      for (const kid of kids) {
                        if (!(kid instanceof _primitives.Ref)) {
                          throw new _util.FormatError("Kid must be a reference.");
                        }
                        if ((0, _primitives.isRefsEqual)(kid, kidRef)) {
                          found = true;
                          break;
                        }
                        kidPromises.push(xref.fetchAsync(kid).then(function(obj) {
                          if (!(obj instanceof _primitives.Dict)) {
                            throw new _util.FormatError("Kid node must be a dictionary.");
                          }
                          if (obj.has("Count")) {
                            total2 += obj.get("Count");
                          } else {
                            total2++;
                          }
                        }));
                      }
                      if (!found) {
                        throw new _util.FormatError("Kid reference not found in parent's kids.");
                      }
                      return Promise.all(kidPromises).then(function() {
                        return [total2, parentRef];
                      });
                    });
                  }
                  let total = 0;
                  const next = (ref) => pagesBeforeRef(ref).then((args) => {
                    if (!args) {
                      this.pageIndexCache.put(pageRef, total);
                      return total;
                    }
                    const [count, parentRef] = args;
                    total += count;
                    return next(parentRef);
                  });
                  return next(pageRef);
                }
                get baseUrl() {
                  const uri = this._catDict.get("URI");
                  if (uri instanceof _primitives.Dict) {
                    const base = uri.get("Base");
                    if (typeof base === "string") {
                      const absoluteUrl = (0, _util.createValidAbsoluteUrl)(base, null, {
                        tryConvertEncoding: true
                      });
                      if (absoluteUrl) {
                        return (0, _util.shadow)(this, "baseUrl", absoluteUrl.href);
                      }
                    }
                  }
                  return (0, _util.shadow)(this, "baseUrl", this.pdfManager.docBaseUrl);
                }
                static parseDestDictionary({
                  destDict,
                  resultObj,
                  docBaseUrl = null,
                  docAttachments = null
                }) {
                  if (!(destDict instanceof _primitives.Dict)) {
                    (0, _util.warn)("parseDestDictionary: `destDict` must be a dictionary.");
                    return;
                  }
                  let action = destDict.get("A"), url, dest;
                  if (!(action instanceof _primitives.Dict)) {
                    if (destDict.has("Dest")) {
                      action = destDict.get("Dest");
                    } else {
                      action = destDict.get("AA");
                      if (action instanceof _primitives.Dict) {
                        if (action.has("D")) {
                          action = action.get("D");
                        } else if (action.has("U")) {
                          action = action.get("U");
                        }
                      }
                    }
                  }
                  if (action instanceof _primitives.Dict) {
                    const actionType = action.get("S");
                    if (!(actionType instanceof _primitives.Name)) {
                      (0, _util.warn)("parseDestDictionary: Invalid type in Action dictionary.");
                      return;
                    }
                    const actionName = actionType.name;
                    switch (actionName) {
                      case "ResetForm":
                        const flags = action.get("Flags");
                        const include = ((typeof flags === "number" ? flags : 0) & 1) === 0;
                        const fields = [];
                        const refs = [];
                        for (const obj of action.get("Fields") || []) {
                          if (obj instanceof _primitives.Ref) {
                            refs.push(obj.toString());
                          } else if (typeof obj === "string") {
                            fields.push((0, _util.stringToPDFString)(obj));
                          }
                        }
                        resultObj.resetForm = {
                          fields,
                          refs,
                          include
                        };
                        break;
                      case "URI":
                        url = action.get("URI");
                        if (url instanceof _primitives.Name) {
                          url = "/" + url.name;
                        }
                        break;
                      case "GoTo":
                        dest = action.get("D");
                        break;
                      case "Launch":
                      case "GoToR":
                        const urlDict = action.get("F");
                        if (urlDict instanceof _primitives.Dict) {
                          url = urlDict.get("F") || null;
                        } else if (typeof urlDict === "string") {
                          url = urlDict;
                        }
                        let remoteDest = action.get("D");
                        if (remoteDest) {
                          if (remoteDest instanceof _primitives.Name) {
                            remoteDest = remoteDest.name;
                          }
                          if (typeof url === "string") {
                            const baseUrl = url.split("#")[0];
                            if (typeof remoteDest === "string") {
                              url = baseUrl + "#" + remoteDest;
                            } else if (Array.isArray(remoteDest)) {
                              url = baseUrl + "#" + JSON.stringify(remoteDest);
                            }
                          }
                        }
                        const newWindow = action.get("NewWindow");
                        if (typeof newWindow === "boolean") {
                          resultObj.newWindow = newWindow;
                        }
                        break;
                      case "GoToE":
                        const target = action.get("T");
                        let attachment;
                        if (docAttachments && target instanceof _primitives.Dict) {
                          const relationship = target.get("R");
                          const name = target.get("N");
                          if ((0, _primitives.isName)(relationship, "C") && typeof name === "string") {
                            attachment = docAttachments[(0, _util.stringToPDFString)(name)];
                          }
                        }
                        if (attachment) {
                          resultObj.attachment = attachment;
                        } else {
                          (0, _util.warn)(`parseDestDictionary - unimplemented "GoToE" action.`);
                        }
                        break;
                      case "Named":
                        const namedAction = action.get("N");
                        if (namedAction instanceof _primitives.Name) {
                          resultObj.action = namedAction.name;
                        }
                        break;
                      case "SetOCGState":
                        const state = action.get("State");
                        const preserveRB = action.get("PreserveRB");
                        if (!Array.isArray(state) || state.length === 0) {
                          break;
                        }
                        const stateArr = [];
                        for (const elem of state) {
                          if (elem instanceof _primitives.Name) {
                            switch (elem.name) {
                              case "ON":
                              case "OFF":
                              case "Toggle":
                                stateArr.push(elem.name);
                                break;
                            }
                          } else if (elem instanceof _primitives.Ref) {
                            stateArr.push(elem.toString());
                          }
                        }
                        if (stateArr.length !== state.length) {
                          break;
                        }
                        resultObj.setOCGState = {
                          state: stateArr,
                          preserveRB: typeof preserveRB === "boolean" ? preserveRB : true
                        };
                        break;
                      case "JavaScript":
                        const jsAction = action.get("JS");
                        let js;
                        if (jsAction instanceof _base_stream.BaseStream) {
                          js = jsAction.getString();
                        } else if (typeof jsAction === "string") {
                          js = jsAction;
                        }
                        const jsURL = js && (0, _core_utils.recoverJsURL)((0, _util.stringToPDFString)(js));
                        if (jsURL) {
                          url = jsURL.url;
                          resultObj.newWindow = jsURL.newWindow;
                          break;
                        }
                      default:
                        if (actionName === "JavaScript" || actionName === "SubmitForm") {
                          break;
                        }
                        (0, _util.warn)(`parseDestDictionary - unsupported action: "${actionName}".`);
                        break;
                    }
                  } else if (destDict.has("Dest")) {
                    dest = destDict.get("Dest");
                  }
                  if (typeof url === "string") {
                    const absoluteUrl = (0, _util.createValidAbsoluteUrl)(url, docBaseUrl, {
                      addDefaultProtocol: true,
                      tryConvertEncoding: true
                    });
                    if (absoluteUrl) {
                      resultObj.url = absoluteUrl.href;
                    }
                    resultObj.unsafeUrl = url;
                  }
                  if (dest) {
                    if (dest instanceof _primitives.Name) {
                      dest = dest.name;
                    }
                    if (typeof dest === "string") {
                      resultObj.dest = (0, _util.stringToPDFString)(dest);
                    } else if (Array.isArray(dest)) {
                      resultObj.dest = dest;
                    }
                  }
                }
              }
              exports2.Catalog = Catalog;
            },
            /* 67 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NumberTree = exports2.NameTree = void 0;
              var _primitives = __w_pdfjs_require__2(4);
              var _util = __w_pdfjs_require__2(2);
              class NameOrNumberTree {
                constructor(root, xref, type) {
                  if (this.constructor === NameOrNumberTree) {
                    (0, _util.unreachable)("Cannot initialize NameOrNumberTree.");
                  }
                  this.root = root;
                  this.xref = xref;
                  this._type = type;
                }
                getAll() {
                  const map = /* @__PURE__ */ new Map();
                  if (!this.root) {
                    return map;
                  }
                  const xref = this.xref;
                  const processed = new _primitives.RefSet();
                  processed.put(this.root);
                  const queue = [this.root];
                  while (queue.length > 0) {
                    const obj = xref.fetchIfRef(queue.shift());
                    if (!(obj instanceof _primitives.Dict)) {
                      continue;
                    }
                    if (obj.has("Kids")) {
                      const kids = obj.get("Kids");
                      if (!Array.isArray(kids)) {
                        continue;
                      }
                      for (const kid of kids) {
                        if (processed.has(kid)) {
                          throw new _util.FormatError(`Duplicate entry in "${this._type}" tree.`);
                        }
                        queue.push(kid);
                        processed.put(kid);
                      }
                      continue;
                    }
                    const entries = obj.get(this._type);
                    if (!Array.isArray(entries)) {
                      continue;
                    }
                    for (let i = 0, ii = entries.length; i < ii; i += 2) {
                      map.set(xref.fetchIfRef(entries[i]), xref.fetchIfRef(entries[i + 1]));
                    }
                  }
                  return map;
                }
                get(key) {
                  if (!this.root) {
                    return null;
                  }
                  const xref = this.xref;
                  let kidsOrEntries = xref.fetchIfRef(this.root);
                  let loopCount = 0;
                  const MAX_LEVELS = 10;
                  while (kidsOrEntries.has("Kids")) {
                    if (++loopCount > MAX_LEVELS) {
                      (0, _util.warn)(`Search depth limit reached for "${this._type}" tree.`);
                      return null;
                    }
                    const kids = kidsOrEntries.get("Kids");
                    if (!Array.isArray(kids)) {
                      return null;
                    }
                    let l = 0, r = kids.length - 1;
                    while (l <= r) {
                      const m = l + r >> 1;
                      const kid = xref.fetchIfRef(kids[m]);
                      const limits = kid.get("Limits");
                      if (key < xref.fetchIfRef(limits[0])) {
                        r = m - 1;
                      } else if (key > xref.fetchIfRef(limits[1])) {
                        l = m + 1;
                      } else {
                        kidsOrEntries = kid;
                        break;
                      }
                    }
                    if (l > r) {
                      return null;
                    }
                  }
                  const entries = kidsOrEntries.get(this._type);
                  if (Array.isArray(entries)) {
                    let l = 0, r = entries.length - 2;
                    while (l <= r) {
                      const tmp = l + r >> 1, m = tmp + (tmp & 1);
                      const currentKey = xref.fetchIfRef(entries[m]);
                      if (key < currentKey) {
                        r = m - 2;
                      } else if (key > currentKey) {
                        l = m + 2;
                      } else {
                        return xref.fetchIfRef(entries[m + 1]);
                      }
                    }
                  }
                  return null;
                }
              }
              class NameTree extends NameOrNumberTree {
                constructor(root, xref) {
                  super(root, xref, "Names");
                }
              }
              exports2.NameTree = NameTree;
              class NumberTree extends NameOrNumberTree {
                constructor(root, xref) {
                  super(root, xref, "Nums");
                }
              }
              exports2.NumberTree = NumberTree;
            },
            /* 68 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.clearGlobalCaches = clearGlobalCaches;
              var _pattern = __w_pdfjs_require__2(50);
              var _primitives = __w_pdfjs_require__2(4);
              var _unicode = __w_pdfjs_require__2(40);
              function clearGlobalCaches() {
                (0, _pattern.clearPatternCaches)();
                (0, _primitives.clearPrimitiveCaches)();
                (0, _unicode.clearUnicodeCaches)();
              }
            },
            /* 69 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FileSpec = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _base_stream = __w_pdfjs_require__2(5);
              var _primitives = __w_pdfjs_require__2(4);
              function pickPlatformItem(dict) {
                if (dict.has("UF")) {
                  return dict.get("UF");
                } else if (dict.has("F")) {
                  return dict.get("F");
                } else if (dict.has("Unix")) {
                  return dict.get("Unix");
                } else if (dict.has("Mac")) {
                  return dict.get("Mac");
                } else if (dict.has("DOS")) {
                  return dict.get("DOS");
                }
                return null;
              }
              class FileSpec {
                constructor(root, xref) {
                  if (!(root instanceof _primitives.Dict)) {
                    return;
                  }
                  this.xref = xref;
                  this.root = root;
                  if (root.has("FS")) {
                    this.fs = root.get("FS");
                  }
                  this.description = root.has("Desc") ? (0, _util.stringToPDFString)(root.get("Desc")) : "";
                  if (root.has("RF")) {
                    (0, _util.warn)("Related file specifications are not supported");
                  }
                  this.contentAvailable = true;
                  if (!root.has("EF")) {
                    this.contentAvailable = false;
                    (0, _util.warn)("Non-embedded file specifications are not supported");
                  }
                }
                get filename() {
                  if (!this._filename && this.root) {
                    const filename = pickPlatformItem(this.root) || "unnamed";
                    this._filename = (0, _util.stringToPDFString)(filename).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/");
                  }
                  return this._filename;
                }
                get content() {
                  if (!this.contentAvailable) {
                    return null;
                  }
                  if (!this.contentRef && this.root) {
                    this.contentRef = pickPlatformItem(this.root.get("EF"));
                  }
                  let content = null;
                  if (this.contentRef) {
                    const fileObj = this.xref.fetchIfRef(this.contentRef);
                    if (fileObj instanceof _base_stream.BaseStream) {
                      content = fileObj.getBytes();
                    } else {
                      (0, _util.warn)("Embedded file specification points to non-existing/invalid content");
                    }
                  } else {
                    (0, _util.warn)("Embedded file specification does not have a content");
                  }
                  return content;
                }
                get serializable() {
                  return {
                    filename: this.filename,
                    content: this.content
                  };
                }
              }
              exports2.FileSpec = FileSpec;
            },
            /* 70 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MetadataParser = void 0;
              var _xml_parser = __w_pdfjs_require__2(71);
              class MetadataParser {
                constructor(data) {
                  data = this._repair(data);
                  const parser = new _xml_parser.SimpleXMLParser({
                    lowerCaseName: true
                  });
                  const xmlDocument = parser.parseFromString(data);
                  this._metadataMap = /* @__PURE__ */ new Map();
                  this._data = data;
                  if (xmlDocument) {
                    this._parse(xmlDocument);
                  }
                }
                _repair(data) {
                  return data.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function(all, codes) {
                    const bytes = codes.replaceAll(/\\([0-3])([0-7])([0-7])/g, function(code, d1, d2, d3) {
                      return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);
                    }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function(str, name) {
                      switch (name) {
                        case "amp":
                          return "&";
                        case "apos":
                          return "'";
                        case "gt":
                          return ">";
                        case "lt":
                          return "<";
                        case "quot":
                          return '"';
                      }
                      throw new Error(`_repair: ${name} isn't defined.`);
                    });
                    const charBuf = [">"];
                    for (let i = 0, ii = bytes.length; i < ii; i += 2) {
                      const code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);
                      if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {
                        charBuf.push(String.fromCharCode(code));
                      } else {
                        charBuf.push("&#x" + (65536 + code).toString(16).substring(1) + ";");
                      }
                    }
                    return charBuf.join("");
                  });
                }
                _getSequence(entry) {
                  const name = entry.nodeName;
                  if (name !== "rdf:bag" && name !== "rdf:seq" && name !== "rdf:alt") {
                    return null;
                  }
                  return entry.childNodes.filter((node) => node.nodeName === "rdf:li");
                }
                _parseArray(entry) {
                  if (!entry.hasChildNodes()) {
                    return;
                  }
                  const [seqNode] = entry.childNodes;
                  const sequence = this._getSequence(seqNode) || [];
                  this._metadataMap.set(entry.nodeName, sequence.map((node) => node.textContent.trim()));
                }
                _parse(xmlDocument) {
                  let rdf = xmlDocument.documentElement;
                  if (rdf.nodeName !== "rdf:rdf") {
                    rdf = rdf.firstChild;
                    while (rdf && rdf.nodeName !== "rdf:rdf") {
                      rdf = rdf.nextSibling;
                    }
                  }
                  if (!rdf || rdf.nodeName !== "rdf:rdf" || !rdf.hasChildNodes()) {
                    return;
                  }
                  for (const desc of rdf.childNodes) {
                    if (desc.nodeName !== "rdf:description") {
                      continue;
                    }
                    for (const entry of desc.childNodes) {
                      const name = entry.nodeName;
                      switch (name) {
                        case "#text":
                          continue;
                        case "dc:creator":
                        case "dc:subject":
                          this._parseArray(entry);
                          continue;
                      }
                      this._metadataMap.set(name, entry.textContent.trim());
                    }
                  }
                }
                get serializable() {
                  return {
                    parsedData: this._metadataMap,
                    rawData: this._data
                  };
                }
              }
              exports2.MetadataParser = MetadataParser;
            },
            /* 71 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XMLParserErrorCode = exports2.XMLParserBase = exports2.SimpleXMLParser = exports2.SimpleDOMNode = void 0;
              var _core_utils = __w_pdfjs_require__2(3);
              const XMLParserErrorCode = {
                NoError: 0,
                EndOfDocument: -1,
                UnterminatedCdat: -2,
                UnterminatedXmlDeclaration: -3,
                UnterminatedDoctypeDeclaration: -4,
                UnterminatedComment: -5,
                MalformedElement: -6,
                OutOfMemory: -7,
                UnterminatedAttributeValue: -8,
                UnterminatedElement: -9,
                ElementNeverBegun: -10
              };
              exports2.XMLParserErrorCode = XMLParserErrorCode;
              function isWhitespace(s, index) {
                const ch = s[index];
                return ch === " " || ch === "\n" || ch === "\r" || ch === "	";
              }
              function isWhitespaceString(s) {
                for (let i = 0, ii = s.length; i < ii; i++) {
                  if (!isWhitespace(s, i)) {
                    return false;
                  }
                }
                return true;
              }
              class XMLParserBase {
                _resolveEntities(s) {
                  return s.replaceAll(/&([^;]+);/g, (all, entity) => {
                    if (entity.substring(0, 2) === "#x") {
                      return String.fromCodePoint(parseInt(entity.substring(2), 16));
                    } else if (entity.substring(0, 1) === "#") {
                      return String.fromCodePoint(parseInt(entity.substring(1), 10));
                    }
                    switch (entity) {
                      case "lt":
                        return "<";
                      case "gt":
                        return ">";
                      case "amp":
                        return "&";
                      case "quot":
                        return '"';
                      case "apos":
                        return "'";
                    }
                    return this.onResolveEntity(entity);
                  });
                }
                _parseContent(s, start) {
                  const attributes = [];
                  let pos = start;
                  function skipWs() {
                    while (pos < s.length && isWhitespace(s, pos)) {
                      ++pos;
                    }
                  }
                  while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
                    ++pos;
                  }
                  const name = s.substring(start, pos);
                  skipWs();
                  while (pos < s.length && s[pos] !== ">" && s[pos] !== "/" && s[pos] !== "?") {
                    skipWs();
                    let attrName = "", attrValue = "";
                    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== "=") {
                      attrName += s[pos];
                      ++pos;
                    }
                    skipWs();
                    if (s[pos] !== "=") {
                      return null;
                    }
                    ++pos;
                    skipWs();
                    const attrEndChar = s[pos];
                    if (attrEndChar !== '"' && attrEndChar !== "'") {
                      return null;
                    }
                    const attrEndIndex = s.indexOf(attrEndChar, ++pos);
                    if (attrEndIndex < 0) {
                      return null;
                    }
                    attrValue = s.substring(pos, attrEndIndex);
                    attributes.push({
                      name: attrName,
                      value: this._resolveEntities(attrValue)
                    });
                    pos = attrEndIndex + 1;
                    skipWs();
                  }
                  return {
                    name,
                    attributes,
                    parsed: pos - start
                  };
                }
                _parseProcessingInstruction(s, start) {
                  let pos = start;
                  function skipWs() {
                    while (pos < s.length && isWhitespace(s, pos)) {
                      ++pos;
                    }
                  }
                  while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "?" && s[pos] !== "/") {
                    ++pos;
                  }
                  const name = s.substring(start, pos);
                  skipWs();
                  const attrStart = pos;
                  while (pos < s.length && (s[pos] !== "?" || s[pos + 1] !== ">")) {
                    ++pos;
                  }
                  const value = s.substring(attrStart, pos);
                  return {
                    name,
                    value,
                    parsed: pos - start
                  };
                }
                parseXml(s) {
                  let i = 0;
                  while (i < s.length) {
                    const ch = s[i];
                    let j = i;
                    if (ch === "<") {
                      ++j;
                      const ch2 = s[j];
                      let q;
                      switch (ch2) {
                        case "/":
                          ++j;
                          q = s.indexOf(">", j);
                          if (q < 0) {
                            this.onError(XMLParserErrorCode.UnterminatedElement);
                            return;
                          }
                          this.onEndElement(s.substring(j, q));
                          j = q + 1;
                          break;
                        case "?":
                          ++j;
                          const pi = this._parseProcessingInstruction(s, j);
                          if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== "?>") {
                            this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);
                            return;
                          }
                          this.onPi(pi.name, pi.value);
                          j += pi.parsed + 2;
                          break;
                        case "!":
                          if (s.substring(j + 1, j + 3) === "--") {
                            q = s.indexOf("-->", j + 3);
                            if (q < 0) {
                              this.onError(XMLParserErrorCode.UnterminatedComment);
                              return;
                            }
                            this.onComment(s.substring(j + 3, q));
                            j = q + 3;
                          } else if (s.substring(j + 1, j + 8) === "[CDATA[") {
                            q = s.indexOf("]]>", j + 8);
                            if (q < 0) {
                              this.onError(XMLParserErrorCode.UnterminatedCdat);
                              return;
                            }
                            this.onCdata(s.substring(j + 8, q));
                            j = q + 3;
                          } else if (s.substring(j + 1, j + 8) === "DOCTYPE") {
                            const q2 = s.indexOf("[", j + 8);
                            let complexDoctype = false;
                            q = s.indexOf(">", j + 8);
                            if (q < 0) {
                              this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                              return;
                            }
                            if (q2 > 0 && q > q2) {
                              q = s.indexOf("]>", j + 8);
                              if (q < 0) {
                                this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                                return;
                              }
                              complexDoctype = true;
                            }
                            const doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));
                            this.onDoctype(doctypeContent);
                            j = q + (complexDoctype ? 2 : 1);
                          } else {
                            this.onError(XMLParserErrorCode.MalformedElement);
                            return;
                          }
                          break;
                        default:
                          const content = this._parseContent(s, j);
                          if (content === null) {
                            this.onError(XMLParserErrorCode.MalformedElement);
                            return;
                          }
                          let isClosed = false;
                          if (s.substring(j + content.parsed, j + content.parsed + 2) === "/>") {
                            isClosed = true;
                          } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== ">") {
                            this.onError(XMLParserErrorCode.UnterminatedElement);
                            return;
                          }
                          this.onBeginElement(content.name, content.attributes, isClosed);
                          j += content.parsed + (isClosed ? 2 : 1);
                          break;
                      }
                    } else {
                      while (j < s.length && s[j] !== "<") {
                        j++;
                      }
                      const text = s.substring(i, j);
                      this.onText(this._resolveEntities(text));
                    }
                    i = j;
                  }
                }
                onResolveEntity(name) {
                  return `&${name};`;
                }
                onPi(name, value) {
                }
                onComment(text) {
                }
                onCdata(text) {
                }
                onDoctype(doctypeContent) {
                }
                onText(text) {
                }
                onBeginElement(name, attributes, isEmpty) {
                }
                onEndElement(name) {
                }
                onError(code) {
                }
              }
              exports2.XMLParserBase = XMLParserBase;
              class SimpleDOMNode {
                constructor(nodeName, nodeValue) {
                  this.nodeName = nodeName;
                  this.nodeValue = nodeValue;
                  Object.defineProperty(this, "parentNode", {
                    value: null,
                    writable: true
                  });
                }
                get firstChild() {
                  var _a;
                  return (_a = this.childNodes) == null ? void 0 : _a[0];
                }
                get nextSibling() {
                  const childNodes = this.parentNode.childNodes;
                  if (!childNodes) {
                    return void 0;
                  }
                  const index = childNodes.indexOf(this);
                  if (index === -1) {
                    return void 0;
                  }
                  return childNodes[index + 1];
                }
                get textContent() {
                  if (!this.childNodes) {
                    return this.nodeValue || "";
                  }
                  return this.childNodes.map(function(child) {
                    return child.textContent;
                  }).join("");
                }
                get children() {
                  return this.childNodes || [];
                }
                hasChildNodes() {
                  var _a;
                  return ((_a = this.childNodes) == null ? void 0 : _a.length) > 0;
                }
                searchNode(paths, pos) {
                  var _a;
                  if (pos >= paths.length) {
                    return this;
                  }
                  const component = paths[pos];
                  if (component.name.startsWith("#") && pos < paths.length - 1) {
                    return this.searchNode(paths, pos + 1);
                  }
                  const stack = [];
                  let node = this;
                  while (true) {
                    if (component.name === node.nodeName) {
                      if (component.pos === 0) {
                        const res = node.searchNode(paths, pos + 1);
                        if (res !== null) {
                          return res;
                        }
                      } else if (stack.length === 0) {
                        return null;
                      } else {
                        const [parent] = stack.pop();
                        let siblingPos = 0;
                        for (const child of parent.childNodes) {
                          if (component.name === child.nodeName) {
                            if (siblingPos === component.pos) {
                              return child.searchNode(paths, pos + 1);
                            }
                            siblingPos++;
                          }
                        }
                        return node.searchNode(paths, pos + 1);
                      }
                    }
                    if (((_a = node.childNodes) == null ? void 0 : _a.length) > 0) {
                      stack.push([node, 0]);
                      node = node.childNodes[0];
                    } else if (stack.length === 0) {
                      return null;
                    } else {
                      while (stack.length !== 0) {
                        const [parent, currentPos] = stack.pop();
                        const newPos = currentPos + 1;
                        if (newPos < parent.childNodes.length) {
                          stack.push([parent, newPos]);
                          node = parent.childNodes[newPos];
                          break;
                        }
                      }
                      if (stack.length === 0) {
                        return null;
                      }
                    }
                  }
                }
                dump(buffer) {
                  if (this.nodeName === "#text") {
                    buffer.push((0, _core_utils.encodeToXmlString)(this.nodeValue));
                    return;
                  }
                  buffer.push(`<${this.nodeName}`);
                  if (this.attributes) {
                    for (const attribute of this.attributes) {
                      buffer.push(` ${attribute.name}="${(0, _core_utils.encodeToXmlString)(attribute.value)}"`);
                    }
                  }
                  if (this.hasChildNodes()) {
                    buffer.push(">");
                    for (const child of this.childNodes) {
                      child.dump(buffer);
                    }
                    buffer.push(`</${this.nodeName}>`);
                  } else if (this.nodeValue) {
                    buffer.push(`>${(0, _core_utils.encodeToXmlString)(this.nodeValue)}</${this.nodeName}>`);
                  } else {
                    buffer.push("/>");
                  }
                }
              }
              exports2.SimpleDOMNode = SimpleDOMNode;
              class SimpleXMLParser extends XMLParserBase {
                constructor({
                  hasAttributes = false,
                  lowerCaseName = false
                }) {
                  super();
                  this._currentFragment = null;
                  this._stack = null;
                  this._errorCode = XMLParserErrorCode.NoError;
                  this._hasAttributes = hasAttributes;
                  this._lowerCaseName = lowerCaseName;
                }
                parseFromString(data) {
                  this._currentFragment = [];
                  this._stack = [];
                  this._errorCode = XMLParserErrorCode.NoError;
                  this.parseXml(data);
                  if (this._errorCode !== XMLParserErrorCode.NoError) {
                    return void 0;
                  }
                  const [documentElement] = this._currentFragment;
                  if (!documentElement) {
                    return void 0;
                  }
                  return {
                    documentElement
                  };
                }
                onText(text) {
                  if (isWhitespaceString(text)) {
                    return;
                  }
                  const node = new SimpleDOMNode("#text", text);
                  this._currentFragment.push(node);
                }
                onCdata(text) {
                  const node = new SimpleDOMNode("#text", text);
                  this._currentFragment.push(node);
                }
                onBeginElement(name, attributes, isEmpty) {
                  if (this._lowerCaseName) {
                    name = name.toLowerCase();
                  }
                  const node = new SimpleDOMNode(name);
                  node.childNodes = [];
                  if (this._hasAttributes) {
                    node.attributes = attributes;
                  }
                  this._currentFragment.push(node);
                  if (isEmpty) {
                    return;
                  }
                  this._stack.push(this._currentFragment);
                  this._currentFragment = node.childNodes;
                }
                onEndElement(name) {
                  this._currentFragment = this._stack.pop() || [];
                  const lastElement = this._currentFragment.at(-1);
                  if (!lastElement) {
                    return null;
                  }
                  for (const childNode of lastElement.childNodes) {
                    childNode.parentNode = lastElement;
                  }
                  return lastElement;
                }
                onError(code) {
                  this._errorCode = code;
                }
              }
              exports2.SimpleXMLParser = SimpleXMLParser;
            },
            /* 72 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var _addIdToPage, addIdToPage_fn, _writeKids, writeKids_fn, _collectParents, collectParents_fn, _updateParentTag, updateParentTag_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StructTreeRoot = exports2.StructTreePage = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(4);
              var _name_number_tree = __w_pdfjs_require__2(67);
              var _writer = __w_pdfjs_require__2(73);
              const MAX_DEPTH = 40;
              const StructElementType = {
                PAGE_CONTENT: 1,
                STREAM_CONTENT: 2,
                OBJECT: 3,
                ANNOTATION: 4,
                ELEMENT: 5
              };
              const _StructTreeRoot = class _StructTreeRoot {
                constructor(rootDict, rootRef) {
                  __privateAdd(this, _addIdToPage);
                  this.dict = rootDict;
                  this.ref = rootRef instanceof _primitives.Ref ? rootRef : null;
                  this.roleMap = /* @__PURE__ */ new Map();
                  this.structParentIds = null;
                }
                init() {
                  this.readRoleMap();
                }
                addAnnotationIdToPage(pageRef, id) {
                  __privateMethod(this, _addIdToPage, addIdToPage_fn).call(this, pageRef, id, StructElementType.ANNOTATION);
                }
                readRoleMap() {
                  const roleMapDict = this.dict.get("RoleMap");
                  if (!(roleMapDict instanceof _primitives.Dict)) {
                    return;
                  }
                  roleMapDict.forEach((key, value) => {
                    if (!(value instanceof _primitives.Name)) {
                      return;
                    }
                    this.roleMap.set(key, value.name);
                  });
                }
                static async canCreateStructureTree({
                  catalogRef,
                  pdfManager,
                  newAnnotationsByPage
                }) {
                  var _a;
                  if (!(catalogRef instanceof _primitives.Ref)) {
                    (0, _util.warn)("Cannot save the struct tree: no catalog reference.");
                    return false;
                  }
                  let nextKey = 0;
                  let hasNothingToUpdate = true;
                  for (const [pageIndex, elements] of newAnnotationsByPage) {
                    const {
                      ref: pageRef
                    } = await pdfManager.getPage(pageIndex);
                    if (!(pageRef instanceof _primitives.Ref)) {
                      (0, _util.warn)(`Cannot save the struct tree: page ${pageIndex} has no ref.`);
                      hasNothingToUpdate = true;
                      break;
                    }
                    for (const element of elements) {
                      if ((_a = element.accessibilityData) == null ? void 0 : _a.type) {
                        element.parentTreeId = nextKey++;
                        hasNothingToUpdate = false;
                      }
                    }
                  }
                  if (hasNothingToUpdate) {
                    for (const elements of newAnnotationsByPage.values()) {
                      for (const element of elements) {
                        delete element.parentTreeId;
                      }
                    }
                    return false;
                  }
                  return true;
                }
                static async createStructureTree({
                  newAnnotationsByPage,
                  xref,
                  catalogRef,
                  pdfManager,
                  newRefs
                }) {
                  const root = pdfManager.catalog.cloneDict();
                  const structTreeRootRef = xref.getNewTemporaryRef();
                  root.set("StructTreeRoot", structTreeRootRef);
                  const buffer = [];
                  await (0, _writer.writeObject)(catalogRef, root, buffer, xref);
                  newRefs.push({
                    ref: catalogRef,
                    data: buffer.join("")
                  });
                  const structTreeRoot = new _primitives.Dict(xref);
                  structTreeRoot.set("Type", _primitives.Name.get("StructTreeRoot"));
                  const parentTreeRef = xref.getNewTemporaryRef();
                  structTreeRoot.set("ParentTree", parentTreeRef);
                  const kids = [];
                  structTreeRoot.set("K", kids);
                  const parentTree = new _primitives.Dict(xref);
                  const nums = [];
                  parentTree.set("Nums", nums);
                  const nextKey = await __privateMethod(this, _writeKids, writeKids_fn).call(this, {
                    newAnnotationsByPage,
                    structTreeRootRef,
                    kids,
                    nums,
                    xref,
                    pdfManager,
                    newRefs,
                    buffer
                  });
                  structTreeRoot.set("ParentTreeNextKey", nextKey);
                  buffer.length = 0;
                  await (0, _writer.writeObject)(parentTreeRef, parentTree, buffer, xref);
                  newRefs.push({
                    ref: parentTreeRef,
                    data: buffer.join("")
                  });
                  buffer.length = 0;
                  await (0, _writer.writeObject)(structTreeRootRef, structTreeRoot, buffer, xref);
                  newRefs.push({
                    ref: structTreeRootRef,
                    data: buffer.join("")
                  });
                }
                async canUpdateStructTree({
                  pdfManager,
                  newAnnotationsByPage
                }) {
                  var _a, _b;
                  if (!this.ref) {
                    (0, _util.warn)("Cannot update the struct tree: no root reference.");
                    return false;
                  }
                  let nextKey = this.dict.get("ParentTreeNextKey");
                  if (!Number.isInteger(nextKey) || nextKey < 0) {
                    (0, _util.warn)("Cannot update the struct tree: invalid next key.");
                    return false;
                  }
                  const parentTree = this.dict.get("ParentTree");
                  if (!(parentTree instanceof _primitives.Dict)) {
                    (0, _util.warn)("Cannot update the struct tree: ParentTree isn't a dict.");
                    return false;
                  }
                  const nums = parentTree.get("Nums");
                  if (!Array.isArray(nums)) {
                    (0, _util.warn)("Cannot update the struct tree: nums isn't an array.");
                    return false;
                  }
                  const {
                    numPages
                  } = pdfManager.catalog;
                  for (const pageIndex of newAnnotationsByPage.keys()) {
                    const {
                      pageDict,
                      ref: pageRef
                    } = await pdfManager.getPage(pageIndex);
                    if (!(pageRef instanceof _primitives.Ref)) {
                      (0, _util.warn)(`Cannot save the struct tree: page ${pageIndex} has no ref.`);
                      return false;
                    }
                    const id = pageDict.get("StructParents");
                    if (!Number.isInteger(id) || id < 0 || id >= numPages) {
                      (0, _util.warn)(`Cannot save the struct tree: page ${pageIndex} has no id.`);
                      return false;
                    }
                  }
                  let hasNothingToUpdate = true;
                  for (const [pageIndex, elements] of newAnnotationsByPage) {
                    const {
                      pageDict
                    } = await pdfManager.getPage(pageIndex);
                    __privateMethod(_a = _StructTreeRoot, _collectParents, collectParents_fn).call(_a, {
                      elements,
                      xref: this.dict.xref,
                      pageDict,
                      parentTree
                    });
                    for (const element of elements) {
                      if ((_b = element.accessibilityData) == null ? void 0 : _b.type) {
                        element.parentTreeId = nextKey++;
                        hasNothingToUpdate = false;
                      }
                    }
                  }
                  if (hasNothingToUpdate) {
                    for (const elements of newAnnotationsByPage.values()) {
                      for (const element of elements) {
                        delete element.parentTreeId;
                        delete element.structTreeParent;
                      }
                    }
                    return false;
                  }
                  return true;
                }
                async updateStructureTree({
                  newAnnotationsByPage,
                  pdfManager,
                  newRefs
                }) {
                  var _a;
                  const xref = this.dict.xref;
                  const structTreeRoot = this.dict.clone();
                  const structTreeRootRef = this.ref;
                  let parentTreeRef = structTreeRoot.getRaw("ParentTree");
                  let parentTree;
                  if (parentTreeRef instanceof _primitives.Ref) {
                    parentTree = xref.fetch(parentTreeRef);
                  } else {
                    parentTree = parentTreeRef;
                    parentTreeRef = xref.getNewTemporaryRef();
                    structTreeRoot.set("ParentTree", parentTreeRef);
                  }
                  parentTree = parentTree.clone();
                  let nums = parentTree.getRaw("Nums");
                  let numsRef = null;
                  if (nums instanceof _primitives.Ref) {
                    numsRef = nums;
                    nums = xref.fetch(numsRef);
                  }
                  nums = nums.slice();
                  if (!numsRef) {
                    parentTree.set("Nums", nums);
                  }
                  let kids = structTreeRoot.getRaw("K");
                  let kidsRef = null;
                  if (kids instanceof _primitives.Ref) {
                    kidsRef = kids;
                    kids = xref.fetch(kidsRef);
                  } else {
                    kidsRef = xref.getNewTemporaryRef();
                    structTreeRoot.set("K", kidsRef);
                  }
                  kids = Array.isArray(kids) ? kids.slice() : [kids];
                  const buffer = [];
                  const newNextkey = await __privateMethod(_a = _StructTreeRoot, _writeKids, writeKids_fn).call(_a, {
                    newAnnotationsByPage,
                    structTreeRootRef,
                    kids,
                    nums,
                    xref,
                    pdfManager,
                    newRefs,
                    buffer
                  });
                  structTreeRoot.set("ParentTreeNextKey", newNextkey);
                  buffer.length = 0;
                  await (0, _writer.writeObject)(kidsRef, kids, buffer, xref);
                  newRefs.push({
                    ref: kidsRef,
                    data: buffer.join("")
                  });
                  if (numsRef) {
                    buffer.length = 0;
                    await (0, _writer.writeObject)(numsRef, nums, buffer, xref);
                    newRefs.push({
                      ref: numsRef,
                      data: buffer.join("")
                    });
                  }
                  buffer.length = 0;
                  await (0, _writer.writeObject)(parentTreeRef, parentTree, buffer, xref);
                  newRefs.push({
                    ref: parentTreeRef,
                    data: buffer.join("")
                  });
                  buffer.length = 0;
                  await (0, _writer.writeObject)(structTreeRootRef, structTreeRoot, buffer, xref);
                  newRefs.push({
                    ref: structTreeRootRef,
                    data: buffer.join("")
                  });
                }
              };
              _addIdToPage = new WeakSet();
              addIdToPage_fn = function(pageRef, id, type) {
                if (!(pageRef instanceof _primitives.Ref) || id < 0) {
                  return;
                }
                this.structParentIds || (this.structParentIds = new _primitives.RefSetCache());
                let ids = this.structParentIds.get(pageRef);
                if (!ids) {
                  ids = [];
                  this.structParentIds.put(pageRef, ids);
                }
                ids.push([id, type]);
              };
              _writeKids = new WeakSet();
              writeKids_fn = async function({
                newAnnotationsByPage,
                structTreeRootRef,
                kids,
                nums,
                xref,
                pdfManager,
                newRefs,
                buffer
              }) {
                const objr = _primitives.Name.get("OBJR");
                let nextKey = -Infinity;
                for (const [pageIndex, elements] of newAnnotationsByPage) {
                  const {
                    ref: pageRef
                  } = await pdfManager.getPage(pageIndex);
                  for (const {
                    accessibilityData: {
                      type,
                      title,
                      lang,
                      alt,
                      expanded,
                      actualText
                    },
                    ref,
                    parentTreeId,
                    structTreeParent
                  } of elements) {
                    nextKey = Math.max(nextKey, parentTreeId);
                    const tagRef = xref.getNewTemporaryRef();
                    const tagDict = new _primitives.Dict(xref);
                    tagDict.set("S", _primitives.Name.get(type));
                    if (title) {
                      tagDict.set("T", title);
                    }
                    if (lang) {
                      tagDict.set("Lang", lang);
                    }
                    if (alt) {
                      tagDict.set("Alt", alt);
                    }
                    if (expanded) {
                      tagDict.set("E", expanded);
                    }
                    if (actualText) {
                      tagDict.set("ActualText", actualText);
                    }
                    if (structTreeParent) {
                      await __privateMethod(this, _updateParentTag, updateParentTag_fn).call(this, {
                        structTreeParent,
                        tagDict,
                        newTagRef: tagRef,
                        fallbackRef: structTreeRootRef,
                        xref,
                        newRefs,
                        buffer
                      });
                    } else {
                      tagDict.set("P", structTreeRootRef);
                    }
                    const objDict = new _primitives.Dict(xref);
                    tagDict.set("K", objDict);
                    objDict.set("Type", objr);
                    objDict.set("Pg", pageRef);
                    objDict.set("Obj", ref);
                    buffer.length = 0;
                    await (0, _writer.writeObject)(tagRef, tagDict, buffer, xref);
                    newRefs.push({
                      ref: tagRef,
                      data: buffer.join("")
                    });
                    nums.push(parentTreeId, tagRef);
                    kids.push(tagRef);
                  }
                }
                return nextKey + 1;
              };
              _collectParents = new WeakSet();
              collectParents_fn = function({
                elements,
                xref,
                pageDict,
                parentTree
              }) {
                const idToElement = /* @__PURE__ */ new Map();
                for (const element of elements) {
                  if (element.structTreeParentId) {
                    const id2 = parseInt(element.structTreeParentId.split("_mc")[1], 10);
                    idToElement.set(id2, element);
                  }
                }
                const id = pageDict.get("StructParents");
                const numberTree = new _name_number_tree.NumberTree(parentTree, xref);
                const parentArray = numberTree.get(id);
                if (!Array.isArray(parentArray)) {
                  return;
                }
                const updateElement = (kid, pageKid, kidRef) => {
                  const element = idToElement.get(kid);
                  if (element) {
                    const parentRef = pageKid.getRaw("P");
                    const parentDict = xref.fetchIfRef(parentRef);
                    if (parentRef instanceof _primitives.Ref && parentDict instanceof _primitives.Dict) {
                      element.structTreeParent = {
                        ref: kidRef,
                        dict: pageKid
                      };
                    }
                    return true;
                  }
                  return false;
                };
                for (const kidRef of parentArray) {
                  if (!(kidRef instanceof _primitives.Ref)) {
                    continue;
                  }
                  const pageKid = xref.fetch(kidRef);
                  const k = pageKid.get("K");
                  if (Number.isInteger(k)) {
                    updateElement(k, pageKid, kidRef);
                    continue;
                  }
                  if (!Array.isArray(k)) {
                    continue;
                  }
                  for (let kid of k) {
                    kid = xref.fetchIfRef(kid);
                    if (Number.isInteger(kid) && updateElement(kid, pageKid, kidRef)) {
                      break;
                    }
                  }
                }
              };
              _updateParentTag = new WeakSet();
              updateParentTag_fn = async function({
                structTreeParent: {
                  ref,
                  dict
                },
                tagDict,
                newTagRef,
                fallbackRef,
                xref,
                newRefs,
                buffer
              }) {
                const parentRef = dict.getRaw("P");
                let parentDict = xref.fetchIfRef(parentRef);
                tagDict.set("P", parentRef);
                let saveParentDict = false;
                let parentKids;
                let parentKidsRef = parentDict.getRaw("K");
                if (!(parentKidsRef instanceof _primitives.Ref)) {
                  parentKids = parentKidsRef;
                  parentKidsRef = xref.getNewTemporaryRef();
                  parentDict = parentDict.clone();
                  parentDict.set("K", parentKidsRef);
                  saveParentDict = true;
                } else {
                  parentKids = xref.fetch(parentKidsRef);
                }
                if (Array.isArray(parentKids)) {
                  const index = parentKids.indexOf(ref);
                  if (index >= 0) {
                    parentKids = parentKids.slice();
                    parentKids.splice(index + 1, 0, newTagRef);
                  } else {
                    (0, _util.warn)("Cannot update the struct tree: parent kid not found.");
                    tagDict.set("P", fallbackRef);
                    return;
                  }
                } else if (parentKids instanceof _primitives.Dict) {
                  parentKids = [parentKidsRef, newTagRef];
                  parentKidsRef = xref.getNewTemporaryRef();
                  parentDict.set("K", parentKidsRef);
                  saveParentDict = true;
                }
                buffer.length = 0;
                await (0, _writer.writeObject)(parentKidsRef, parentKids, buffer, xref);
                newRefs.push({
                  ref: parentKidsRef,
                  data: buffer.join("")
                });
                if (!saveParentDict) {
                  return;
                }
                buffer.length = 0;
                await (0, _writer.writeObject)(parentRef, parentDict, buffer, xref);
                newRefs.push({
                  ref: parentRef,
                  data: buffer.join("")
                });
              };
              __privateAdd(_StructTreeRoot, _writeKids);
              __privateAdd(_StructTreeRoot, _collectParents);
              __privateAdd(_StructTreeRoot, _updateParentTag);
              let StructTreeRoot = _StructTreeRoot;
              exports2.StructTreeRoot = StructTreeRoot;
              class StructElementNode {
                constructor(tree, dict) {
                  this.tree = tree;
                  this.dict = dict;
                  this.kids = [];
                  this.parseKids();
                }
                get role() {
                  const nameObj = this.dict.get("S");
                  const name = nameObj instanceof _primitives.Name ? nameObj.name : "";
                  const {
                    root
                  } = this.tree;
                  if (root.roleMap.has(name)) {
                    return root.roleMap.get(name);
                  }
                  return name;
                }
                parseKids() {
                  let pageObjId = null;
                  const objRef = this.dict.getRaw("Pg");
                  if (objRef instanceof _primitives.Ref) {
                    pageObjId = objRef.toString();
                  }
                  const kids = this.dict.get("K");
                  if (Array.isArray(kids)) {
                    for (const kid of kids) {
                      const element = this.parseKid(pageObjId, kid);
                      if (element) {
                        this.kids.push(element);
                      }
                    }
                  } else {
                    const element = this.parseKid(pageObjId, kids);
                    if (element) {
                      this.kids.push(element);
                    }
                  }
                }
                parseKid(pageObjId, kid) {
                  if (Number.isInteger(kid)) {
                    if (this.tree.pageDict.objId !== pageObjId) {
                      return null;
                    }
                    return new StructElement({
                      type: StructElementType.PAGE_CONTENT,
                      mcid: kid,
                      pageObjId
                    });
                  }
                  let kidDict = null;
                  if (kid instanceof _primitives.Ref) {
                    kidDict = this.dict.xref.fetch(kid);
                  } else if (kid instanceof _primitives.Dict) {
                    kidDict = kid;
                  }
                  if (!kidDict) {
                    return null;
                  }
                  const pageRef = kidDict.getRaw("Pg");
                  if (pageRef instanceof _primitives.Ref) {
                    pageObjId = pageRef.toString();
                  }
                  const type = kidDict.get("Type") instanceof _primitives.Name ? kidDict.get("Type").name : null;
                  if (type === "MCR") {
                    if (this.tree.pageDict.objId !== pageObjId) {
                      return null;
                    }
                    const kidRef = kidDict.getRaw("Stm");
                    return new StructElement({
                      type: StructElementType.STREAM_CONTENT,
                      refObjId: kidRef instanceof _primitives.Ref ? kidRef.toString() : null,
                      pageObjId,
                      mcid: kidDict.get("MCID")
                    });
                  }
                  if (type === "OBJR") {
                    if (this.tree.pageDict.objId !== pageObjId) {
                      return null;
                    }
                    const kidRef = kidDict.getRaw("Obj");
                    return new StructElement({
                      type: StructElementType.OBJECT,
                      refObjId: kidRef instanceof _primitives.Ref ? kidRef.toString() : null,
                      pageObjId
                    });
                  }
                  return new StructElement({
                    type: StructElementType.ELEMENT,
                    dict: kidDict
                  });
                }
              }
              class StructElement {
                constructor({
                  type,
                  dict = null,
                  mcid = null,
                  pageObjId = null,
                  refObjId = null
                }) {
                  this.type = type;
                  this.dict = dict;
                  this.mcid = mcid;
                  this.pageObjId = pageObjId;
                  this.refObjId = refObjId;
                  this.parentNode = null;
                }
              }
              class StructTreePage {
                constructor(structTreeRoot, pageDict) {
                  this.root = structTreeRoot;
                  this.rootDict = structTreeRoot ? structTreeRoot.dict : null;
                  this.pageDict = pageDict;
                  this.nodes = [];
                }
                parse(pageRef) {
                  var _a, _b;
                  if (!this.root || !this.rootDict) {
                    return;
                  }
                  const parentTree = this.rootDict.get("ParentTree");
                  if (!parentTree) {
                    return;
                  }
                  const id = this.pageDict.get("StructParents");
                  const ids = pageRef instanceof _primitives.Ref && ((_a = this.root.structParentIds) == null ? void 0 : _a.get(pageRef));
                  if (!Number.isInteger(id) && !ids) {
                    return;
                  }
                  const map = /* @__PURE__ */ new Map();
                  const numberTree = new _name_number_tree.NumberTree(parentTree, this.rootDict.xref);
                  if (Number.isInteger(id)) {
                    const parentArray = numberTree.get(id);
                    if (Array.isArray(parentArray)) {
                      for (const ref of parentArray) {
                        if (ref instanceof _primitives.Ref) {
                          this.addNode(this.rootDict.xref.fetch(ref), map);
                        }
                      }
                    }
                  }
                  if (!ids) {
                    return;
                  }
                  for (const [elemId, type] of ids) {
                    const obj = numberTree.get(elemId);
                    if (obj) {
                      const elem = this.addNode(this.rootDict.xref.fetchIfRef(obj), map);
                      if (((_b = elem == null ? void 0 : elem.kids) == null ? void 0 : _b.length) === 1 && elem.kids[0].type === StructElementType.OBJECT) {
                        elem.kids[0].type = type;
                      }
                    }
                  }
                }
                addNode(dict, map, level = 0) {
                  if (level > MAX_DEPTH) {
                    (0, _util.warn)("StructTree MAX_DEPTH reached.");
                    return null;
                  }
                  if (map.has(dict)) {
                    return map.get(dict);
                  }
                  const element = new StructElementNode(this, dict);
                  map.set(dict, element);
                  const parent = dict.get("P");
                  if (!parent || (0, _primitives.isName)(parent.get("Type"), "StructTreeRoot")) {
                    if (!this.addTopLevelNode(dict, element)) {
                      map.delete(dict);
                    }
                    return element;
                  }
                  const parentNode = this.addNode(parent, map, level + 1);
                  if (!parentNode) {
                    return element;
                  }
                  let save = false;
                  for (const kid of parentNode.kids) {
                    if (kid.type === StructElementType.ELEMENT && kid.dict === dict) {
                      kid.parentNode = element;
                      save = true;
                    }
                  }
                  if (!save) {
                    map.delete(dict);
                  }
                  return element;
                }
                addTopLevelNode(dict, element) {
                  const obj = this.rootDict.get("K");
                  if (!obj) {
                    return false;
                  }
                  if (obj instanceof _primitives.Dict) {
                    if (obj.objId !== dict.objId) {
                      return false;
                    }
                    this.nodes[0] = element;
                    return true;
                  }
                  if (!Array.isArray(obj)) {
                    return true;
                  }
                  let save = false;
                  for (let i = 0; i < obj.length; i++) {
                    const kidRef = obj[i];
                    if ((kidRef == null ? void 0 : kidRef.toString()) === dict.objId) {
                      this.nodes[i] = element;
                      save = true;
                    }
                  }
                  return save;
                }
                get serializable() {
                  function nodeToSerializable(node, parent, level = 0) {
                    if (level > MAX_DEPTH) {
                      (0, _util.warn)("StructTree too deep to be fully serialized.");
                      return;
                    }
                    const obj = /* @__PURE__ */ Object.create(null);
                    obj.role = node.role;
                    obj.children = [];
                    parent.children.push(obj);
                    const alt = node.dict.get("Alt");
                    if (typeof alt === "string") {
                      obj.alt = (0, _util.stringToPDFString)(alt);
                    }
                    const lang = node.dict.get("Lang");
                    if (typeof lang === "string") {
                      obj.lang = (0, _util.stringToPDFString)(lang);
                    }
                    for (const kid of node.kids) {
                      const kidElement = kid.type === StructElementType.ELEMENT ? kid.parentNode : null;
                      if (kidElement) {
                        nodeToSerializable(kidElement, obj, level + 1);
                        continue;
                      } else if (kid.type === StructElementType.PAGE_CONTENT || kid.type === StructElementType.STREAM_CONTENT) {
                        obj.children.push({
                          type: "content",
                          id: `p${kid.pageObjId}_mc${kid.mcid}`
                        });
                      } else if (kid.type === StructElementType.OBJECT) {
                        obj.children.push({
                          type: "object",
                          id: kid.refObjId
                        });
                      } else if (kid.type === StructElementType.ANNOTATION) {
                        obj.children.push({
                          type: "annotation",
                          id: `${_util.AnnotationPrefix}${kid.refObjId}`
                        });
                      }
                    }
                  }
                  const root = /* @__PURE__ */ Object.create(null);
                  root.children = [];
                  root.role = "Root";
                  for (const child of this.nodes) {
                    if (!child) {
                      continue;
                    }
                    nodeToSerializable(child, root);
                  }
                  return root;
                }
              }
              exports2.StructTreePage = StructTreePage;
            },
            /* 73 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.incrementalUpdate = incrementalUpdate;
              exports2.writeDict = writeDict;
              exports2.writeObject = writeObject;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(4);
              var _core_utils = __w_pdfjs_require__2(3);
              var _xml_parser = __w_pdfjs_require__2(71);
              var _base_stream = __w_pdfjs_require__2(5);
              var _crypto = __w_pdfjs_require__2(74);
              async function writeObject(ref, obj, buffer, {
                encrypt = null
              }) {
                const transform = encrypt == null ? void 0 : encrypt.createCipherTransform(ref.num, ref.gen);
                buffer.push(`${ref.num} ${ref.gen} obj
`);
                if (obj instanceof _primitives.Dict) {
                  await writeDict(obj, buffer, transform);
                } else if (obj instanceof _base_stream.BaseStream) {
                  await writeStream(obj, buffer, transform);
                } else if (Array.isArray(obj)) {
                  await writeArray(obj, buffer, transform);
                }
                buffer.push("\nendobj\n");
              }
              async function writeDict(dict, buffer, transform) {
                buffer.push("<<");
                for (const key of dict.getKeys()) {
                  buffer.push(` /${(0, _core_utils.escapePDFName)(key)} `);
                  await writeValue(dict.getRaw(key), buffer, transform);
                }
                buffer.push(">>");
              }
              async function writeStream(stream, buffer, transform) {
                let string = stream.getString();
                const {
                  dict
                } = stream;
                const [filter, params] = await Promise.all([dict.getAsync("Filter"), dict.getAsync("DecodeParms")]);
                const filterZero = Array.isArray(filter) ? await dict.xref.fetchIfRefAsync(filter[0]) : filter;
                const isFilterZeroFlateDecode = (0, _primitives.isName)(filterZero, "FlateDecode");
                const MIN_LENGTH_FOR_COMPRESSING = 256;
                if (typeof CompressionStream !== "undefined" && (string.length >= MIN_LENGTH_FOR_COMPRESSING || isFilterZeroFlateDecode)) {
                  try {
                    const byteArray = (0, _util.stringToBytes)(string);
                    const cs = new CompressionStream("deflate");
                    const writer = cs.writable.getWriter();
                    writer.write(byteArray);
                    writer.close();
                    const buf = await new Response(cs.readable).arrayBuffer();
                    string = (0, _util.bytesToString)(new Uint8Array(buf));
                    let newFilter, newParams;
                    if (!filter) {
                      newFilter = _primitives.Name.get("FlateDecode");
                    } else if (!isFilterZeroFlateDecode) {
                      newFilter = Array.isArray(filter) ? [_primitives.Name.get("FlateDecode"), ...filter] : [_primitives.Name.get("FlateDecode"), filter];
                      if (params) {
                        newParams = Array.isArray(params) ? [null, ...params] : [null, params];
                      }
                    }
                    if (newFilter) {
                      dict.set("Filter", newFilter);
                    }
                    if (newParams) {
                      dict.set("DecodeParms", newParams);
                    }
                  } catch (ex) {
                    (0, _util.info)(`writeStream - cannot compress data: "${ex}".`);
                  }
                }
                if (transform) {
                  string = transform.encryptString(string);
                }
                dict.set("Length", string.length);
                await writeDict(dict, buffer, transform);
                buffer.push(" stream\n", string, "\nendstream");
              }
              async function writeArray(array, buffer, transform) {
                buffer.push("[");
                let first = true;
                for (const val of array) {
                  if (!first) {
                    buffer.push(" ");
                  } else {
                    first = false;
                  }
                  await writeValue(val, buffer, transform);
                }
                buffer.push("]");
              }
              async function writeValue(value, buffer, transform) {
                if (value instanceof _primitives.Name) {
                  buffer.push(`/${(0, _core_utils.escapePDFName)(value.name)}`);
                } else if (value instanceof _primitives.Ref) {
                  buffer.push(`${value.num} ${value.gen} R`);
                } else if (Array.isArray(value)) {
                  await writeArray(value, buffer, transform);
                } else if (typeof value === "string") {
                  if (transform) {
                    value = transform.encryptString(value);
                  }
                  buffer.push(`(${(0, _core_utils.escapeString)(value)})`);
                } else if (typeof value === "number") {
                  buffer.push((0, _core_utils.numberToString)(value));
                } else if (typeof value === "boolean") {
                  buffer.push(value.toString());
                } else if (value instanceof _primitives.Dict) {
                  await writeDict(value, buffer, transform);
                } else if (value instanceof _base_stream.BaseStream) {
                  await writeStream(value, buffer, transform);
                } else if (value === null) {
                  buffer.push("null");
                } else {
                  (0, _util.warn)(`Unhandled value in writer: ${typeof value}, please file a bug.`);
                }
              }
              function writeInt(number, size, offset, buffer) {
                for (let i = size + offset - 1; i > offset - 1; i--) {
                  buffer[i] = number & 255;
                  number >>= 8;
                }
                return offset + size;
              }
              function writeString(string, offset, buffer) {
                for (let i = 0, len = string.length; i < len; i++) {
                  buffer[offset + i] = string.charCodeAt(i) & 255;
                }
              }
              function computeMD5(filesize, xrefInfo) {
                const time = Math.floor(Date.now() / 1e3);
                const filename = xrefInfo.filename || "";
                const md5Buffer = [time.toString(), filename, filesize.toString()];
                let md5BufferLen = md5Buffer.reduce((a, str) => a + str.length, 0);
                for (const value of Object.values(xrefInfo.info)) {
                  md5Buffer.push(value);
                  md5BufferLen += value.length;
                }
                const array = new Uint8Array(md5BufferLen);
                let offset = 0;
                for (const str of md5Buffer) {
                  writeString(str, offset, array);
                  offset += str.length;
                }
                return (0, _util.bytesToString)((0, _crypto.calculateMD5)(array));
              }
              function writeXFADataForAcroform(str, newRefs) {
                const xml = new _xml_parser.SimpleXMLParser({
                  hasAttributes: true
                }).parseFromString(str);
                for (const {
                  xfa
                } of newRefs) {
                  if (!xfa) {
                    continue;
                  }
                  const {
                    path,
                    value
                  } = xfa;
                  if (!path) {
                    continue;
                  }
                  const nodePath = (0, _core_utils.parseXFAPath)(path);
                  let node = xml.documentElement.searchNode(nodePath, 0);
                  if (!node && nodePath.length > 1) {
                    node = xml.documentElement.searchNode([nodePath.at(-1)], 0);
                  }
                  if (node) {
                    node.childNodes = Array.isArray(value) ? value.map((val) => new _xml_parser.SimpleDOMNode("value", val)) : [new _xml_parser.SimpleDOMNode("#text", value)];
                  } else {
                    (0, _util.warn)(`Node not found for path: ${path}`);
                  }
                }
                const buffer = [];
                xml.documentElement.dump(buffer);
                return buffer.join("");
              }
              async function updateAcroform({
                xref,
                acroForm,
                acroFormRef,
                hasXfa,
                hasXfaDatasetsEntry,
                xfaDatasetsRef,
                needAppearances,
                newRefs
              }) {
                if (hasXfa && !hasXfaDatasetsEntry && !xfaDatasetsRef) {
                  (0, _util.warn)("XFA - Cannot save it");
                }
                if (!needAppearances && (!hasXfa || !xfaDatasetsRef || hasXfaDatasetsEntry)) {
                  return;
                }
                const dict = acroForm.clone();
                if (hasXfa && !hasXfaDatasetsEntry) {
                  const newXfa = acroForm.get("XFA").slice();
                  newXfa.splice(2, 0, "datasets");
                  newXfa.splice(3, 0, xfaDatasetsRef);
                  dict.set("XFA", newXfa);
                }
                if (needAppearances) {
                  dict.set("NeedAppearances", true);
                }
                const buffer = [];
                await writeObject(acroFormRef, dict, buffer, xref);
                newRefs.push({
                  ref: acroFormRef,
                  data: buffer.join("")
                });
              }
              function updateXFA({
                xfaData,
                xfaDatasetsRef,
                newRefs,
                xref
              }) {
                if (xfaData === null) {
                  const datasets = xref.fetchIfRef(xfaDatasetsRef);
                  xfaData = writeXFADataForAcroform(datasets.getString(), newRefs);
                }
                const encrypt = xref.encrypt;
                if (encrypt) {
                  const transform = encrypt.createCipherTransform(xfaDatasetsRef.num, xfaDatasetsRef.gen);
                  xfaData = transform.encryptString(xfaData);
                }
                const data = `${xfaDatasetsRef.num} ${xfaDatasetsRef.gen} obj
<< /Type /EmbeddedFile /Length ${xfaData.length}>>
stream
` + xfaData + "\nendstream\nendobj\n";
                newRefs.push({
                  ref: xfaDatasetsRef,
                  data
                });
              }
              async function incrementalUpdate({
                originalData,
                xrefInfo,
                newRefs,
                xref = null,
                hasXfa = false,
                xfaDatasetsRef = null,
                hasXfaDatasetsEntry = false,
                needAppearances,
                acroFormRef = null,
                acroForm = null,
                xfaData = null
              }) {
                await updateAcroform({
                  xref,
                  acroForm,
                  acroFormRef,
                  hasXfa,
                  hasXfaDatasetsEntry,
                  xfaDatasetsRef,
                  needAppearances,
                  newRefs
                });
                if (hasXfa) {
                  updateXFA({
                    xfaData,
                    xfaDatasetsRef,
                    newRefs,
                    xref
                  });
                }
                const newXref = new _primitives.Dict(null);
                const refForXrefTable = xrefInfo.newRef;
                let buffer, baseOffset;
                const lastByte = originalData.at(-1);
                if (lastByte === 10 || lastByte === 13) {
                  buffer = [];
                  baseOffset = originalData.length;
                } else {
                  buffer = ["\n"];
                  baseOffset = originalData.length + 1;
                }
                newXref.set("Size", refForXrefTable.num + 1);
                newXref.set("Prev", xrefInfo.startXRef);
                newXref.set("Type", _primitives.Name.get("XRef"));
                if (xrefInfo.rootRef !== null) {
                  newXref.set("Root", xrefInfo.rootRef);
                }
                if (xrefInfo.infoRef !== null) {
                  newXref.set("Info", xrefInfo.infoRef);
                }
                if (xrefInfo.encryptRef !== null) {
                  newXref.set("Encrypt", xrefInfo.encryptRef);
                }
                newRefs.push({
                  ref: refForXrefTable,
                  data: ""
                });
                newRefs = newRefs.sort((a, b) => {
                  return a.ref.num - b.ref.num;
                });
                const xrefTableData = [[0, 1, 65535]];
                const indexes = [0, 1];
                let maxOffset = 0;
                for (const {
                  ref,
                  data
                } of newRefs) {
                  maxOffset = Math.max(maxOffset, baseOffset);
                  xrefTableData.push([1, baseOffset, Math.min(ref.gen, 65535)]);
                  baseOffset += data.length;
                  indexes.push(ref.num, 1);
                  buffer.push(data);
                }
                newXref.set("Index", indexes);
                if (Array.isArray(xrefInfo.fileIds) && xrefInfo.fileIds.length > 0) {
                  const md5 = computeMD5(baseOffset, xrefInfo);
                  newXref.set("ID", [xrefInfo.fileIds[0], md5]);
                }
                const offsetSize = Math.ceil(Math.log2(maxOffset) / 8);
                const sizes = [1, offsetSize, 2];
                const structSize = sizes[0] + sizes[1] + sizes[2];
                const tableLength = structSize * xrefTableData.length;
                newXref.set("W", sizes);
                newXref.set("Length", tableLength);
                buffer.push(`${refForXrefTable.num} ${refForXrefTable.gen} obj
`);
                await writeDict(newXref, buffer, null);
                buffer.push(" stream\n");
                const bufferLen = buffer.reduce((a, str) => a + str.length, 0);
                const footer = `
endstream
endobj
startxref
${baseOffset}
%%EOF
`;
                const array = new Uint8Array(originalData.length + bufferLen + tableLength + footer.length);
                array.set(originalData);
                let offset = originalData.length;
                for (const str of buffer) {
                  writeString(str, offset, array);
                  offset += str.length;
                }
                for (const [type, objOffset, gen] of xrefTableData) {
                  offset = writeInt(type, sizes[0], offset, array);
                  offset = writeInt(objOffset, sizes[1], offset, array);
                  offset = writeInt(gen, sizes[2], offset, array);
                }
                writeString(footer, offset, array);
                return array;
              }
            },
            /* 74 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var _defaultPasswordBytes, _createEncryptionKey20, createEncryptionKey20_fn, _prepareKeyData, prepareKeyData_fn, _decodeUserPassword, decodeUserPassword_fn, _buildObjectKey, buildObjectKey_fn, _buildCipherConstructor, buildCipherConstructor_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.calculateSHA256 = exports2.calculateMD5 = exports2.PDF20 = exports2.PDF17 = exports2.CipherTransformFactory = exports2.ARCFourCipher = exports2.AES256Cipher = exports2.AES128Cipher = void 0;
              exports2.calculateSHA384 = calculateSHA384;
              exports2.calculateSHA512 = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(4);
              var _decrypt_stream = __w_pdfjs_require__2(75);
              class ARCFourCipher {
                constructor(key) {
                  this.a = 0;
                  this.b = 0;
                  const s = new Uint8Array(256);
                  const keyLength = key.length;
                  for (let i = 0; i < 256; ++i) {
                    s[i] = i;
                  }
                  for (let i = 0, j = 0; i < 256; ++i) {
                    const tmp = s[i];
                    j = j + tmp + key[i % keyLength] & 255;
                    s[i] = s[j];
                    s[j] = tmp;
                  }
                  this.s = s;
                }
                encryptBlock(data) {
                  let a = this.a, b = this.b;
                  const s = this.s;
                  const n = data.length;
                  const output = new Uint8Array(n);
                  for (let i = 0; i < n; ++i) {
                    a = a + 1 & 255;
                    const tmp = s[a];
                    b = b + tmp & 255;
                    const tmp2 = s[b];
                    s[a] = tmp2;
                    s[b] = tmp;
                    output[i] = data[i] ^ s[tmp + tmp2 & 255];
                  }
                  this.a = a;
                  this.b = b;
                  return output;
                }
                decryptBlock(data) {
                  return this.encryptBlock(data);
                }
                encrypt(data) {
                  return this.encryptBlock(data);
                }
              }
              exports2.ARCFourCipher = ARCFourCipher;
              const calculateMD5 = function calculateMD5Closure() {
                const r = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
                const k = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
                function hash(data, offset, length) {
                  let h0 = 1732584193, h1 = -271733879, h2 = -1732584194, h3 = 271733878;
                  const paddedLength = length + 72 & ~63;
                  const padded = new Uint8Array(paddedLength);
                  let i, j;
                  for (i = 0; i < length; ++i) {
                    padded[i] = data[offset++];
                  }
                  padded[i++] = 128;
                  const n = paddedLength - 8;
                  while (i < n) {
                    padded[i++] = 0;
                  }
                  padded[i++] = length << 3 & 255;
                  padded[i++] = length >> 5 & 255;
                  padded[i++] = length >> 13 & 255;
                  padded[i++] = length >> 21 & 255;
                  padded[i++] = length >>> 29 & 255;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  const w = new Int32Array(16);
                  for (i = 0; i < paddedLength; ) {
                    for (j = 0; j < 16; ++j, i += 4) {
                      w[j] = padded[i] | padded[i + 1] << 8 | padded[i + 2] << 16 | padded[i + 3] << 24;
                    }
                    let a = h0, b = h1, c = h2, d = h3, f, g;
                    for (j = 0; j < 64; ++j) {
                      if (j < 16) {
                        f = b & c | ~b & d;
                        g = j;
                      } else if (j < 32) {
                        f = d & b | ~d & c;
                        g = 5 * j + 1 & 15;
                      } else if (j < 48) {
                        f = b ^ c ^ d;
                        g = 3 * j + 5 & 15;
                      } else {
                        f = c ^ (b | ~d);
                        g = 7 * j & 15;
                      }
                      const tmp = d, rotateArg = a + f + k[j] + w[g] | 0, rotate = r[j];
                      d = c;
                      c = b;
                      b = b + (rotateArg << rotate | rotateArg >>> 32 - rotate) | 0;
                      a = tmp;
                    }
                    h0 = h0 + a | 0;
                    h1 = h1 + b | 0;
                    h2 = h2 + c | 0;
                    h3 = h3 + d | 0;
                  }
                  return new Uint8Array([h0 & 255, h0 >> 8 & 255, h0 >> 16 & 255, h0 >>> 24 & 255, h1 & 255, h1 >> 8 & 255, h1 >> 16 & 255, h1 >>> 24 & 255, h2 & 255, h2 >> 8 & 255, h2 >> 16 & 255, h2 >>> 24 & 255, h3 & 255, h3 >> 8 & 255, h3 >> 16 & 255, h3 >>> 24 & 255]);
                }
                return hash;
              }();
              exports2.calculateMD5 = calculateMD5;
              class Word64 {
                constructor(highInteger, lowInteger) {
                  this.high = highInteger | 0;
                  this.low = lowInteger | 0;
                }
                and(word) {
                  this.high &= word.high;
                  this.low &= word.low;
                }
                xor(word) {
                  this.high ^= word.high;
                  this.low ^= word.low;
                }
                or(word) {
                  this.high |= word.high;
                  this.low |= word.low;
                }
                shiftRight(places) {
                  if (places >= 32) {
                    this.low = this.high >>> places - 32 | 0;
                    this.high = 0;
                  } else {
                    this.low = this.low >>> places | this.high << 32 - places;
                    this.high = this.high >>> places | 0;
                  }
                }
                shiftLeft(places) {
                  if (places >= 32) {
                    this.high = this.low << places - 32;
                    this.low = 0;
                  } else {
                    this.high = this.high << places | this.low >>> 32 - places;
                    this.low <<= places;
                  }
                }
                rotateRight(places) {
                  let low, high;
                  if (places & 32) {
                    high = this.low;
                    low = this.high;
                  } else {
                    low = this.low;
                    high = this.high;
                  }
                  places &= 31;
                  this.low = low >>> places | high << 32 - places;
                  this.high = high >>> places | low << 32 - places;
                }
                not() {
                  this.high = ~this.high;
                  this.low = ~this.low;
                }
                add(word) {
                  const lowAdd = (this.low >>> 0) + (word.low >>> 0);
                  let highAdd = (this.high >>> 0) + (word.high >>> 0);
                  if (lowAdd > 4294967295) {
                    highAdd += 1;
                  }
                  this.low = lowAdd | 0;
                  this.high = highAdd | 0;
                }
                copyTo(bytes, offset) {
                  bytes[offset] = this.high >>> 24 & 255;
                  bytes[offset + 1] = this.high >> 16 & 255;
                  bytes[offset + 2] = this.high >> 8 & 255;
                  bytes[offset + 3] = this.high & 255;
                  bytes[offset + 4] = this.low >>> 24 & 255;
                  bytes[offset + 5] = this.low >> 16 & 255;
                  bytes[offset + 6] = this.low >> 8 & 255;
                  bytes[offset + 7] = this.low & 255;
                }
                assign(word) {
                  this.high = word.high;
                  this.low = word.low;
                }
              }
              const calculateSHA256 = function calculateSHA256Closure() {
                function rotr(x, n) {
                  return x >>> n | x << 32 - n;
                }
                function ch(x, y, z) {
                  return x & y ^ ~x & z;
                }
                function maj(x, y, z) {
                  return x & y ^ x & z ^ y & z;
                }
                function sigma(x) {
                  return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
                }
                function sigmaPrime(x) {
                  return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
                }
                function littleSigma(x) {
                  return rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
                }
                function littleSigmaPrime(x) {
                  return rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
                }
                const k = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
                function hash(data, offset, length) {
                  let h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762, h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
                  const paddedLength = Math.ceil((length + 9) / 64) * 64;
                  const padded = new Uint8Array(paddedLength);
                  let i, j;
                  for (i = 0; i < length; ++i) {
                    padded[i] = data[offset++];
                  }
                  padded[i++] = 128;
                  const n = paddedLength - 8;
                  while (i < n) {
                    padded[i++] = 0;
                  }
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = length >>> 29 & 255;
                  padded[i++] = length >> 21 & 255;
                  padded[i++] = length >> 13 & 255;
                  padded[i++] = length >> 5 & 255;
                  padded[i++] = length << 3 & 255;
                  const w = new Uint32Array(64);
                  for (i = 0; i < paddedLength; ) {
                    for (j = 0; j < 16; ++j) {
                      w[j] = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
                      i += 4;
                    }
                    for (j = 16; j < 64; ++j) {
                      w[j] = littleSigmaPrime(w[j - 2]) + w[j - 7] + littleSigma(w[j - 15]) + w[j - 16] | 0;
                    }
                    let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, t1, t2;
                    for (j = 0; j < 64; ++j) {
                      t1 = h + sigmaPrime(e) + ch(e, f, g) + k[j] + w[j];
                      t2 = sigma(a) + maj(a, b, c);
                      h = g;
                      g = f;
                      f = e;
                      e = d + t1 | 0;
                      d = c;
                      c = b;
                      b = a;
                      a = t1 + t2 | 0;
                    }
                    h0 = h0 + a | 0;
                    h1 = h1 + b | 0;
                    h2 = h2 + c | 0;
                    h3 = h3 + d | 0;
                    h4 = h4 + e | 0;
                    h5 = h5 + f | 0;
                    h6 = h6 + g | 0;
                    h7 = h7 + h | 0;
                  }
                  return new Uint8Array([h0 >> 24 & 255, h0 >> 16 & 255, h0 >> 8 & 255, h0 & 255, h1 >> 24 & 255, h1 >> 16 & 255, h1 >> 8 & 255, h1 & 255, h2 >> 24 & 255, h2 >> 16 & 255, h2 >> 8 & 255, h2 & 255, h3 >> 24 & 255, h3 >> 16 & 255, h3 >> 8 & 255, h3 & 255, h4 >> 24 & 255, h4 >> 16 & 255, h4 >> 8 & 255, h4 & 255, h5 >> 24 & 255, h5 >> 16 & 255, h5 >> 8 & 255, h5 & 255, h6 >> 24 & 255, h6 >> 16 & 255, h6 >> 8 & 255, h6 & 255, h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255]);
                }
                return hash;
              }();
              exports2.calculateSHA256 = calculateSHA256;
              const calculateSHA512 = function calculateSHA512Closure() {
                function ch(result, x, y, z, tmp) {
                  result.assign(x);
                  result.and(y);
                  tmp.assign(x);
                  tmp.not();
                  tmp.and(z);
                  result.xor(tmp);
                }
                function maj(result, x, y, z, tmp) {
                  result.assign(x);
                  result.and(y);
                  tmp.assign(x);
                  tmp.and(z);
                  result.xor(tmp);
                  tmp.assign(y);
                  tmp.and(z);
                  result.xor(tmp);
                }
                function sigma(result, x, tmp) {
                  result.assign(x);
                  result.rotateRight(28);
                  tmp.assign(x);
                  tmp.rotateRight(34);
                  result.xor(tmp);
                  tmp.assign(x);
                  tmp.rotateRight(39);
                  result.xor(tmp);
                }
                function sigmaPrime(result, x, tmp) {
                  result.assign(x);
                  result.rotateRight(14);
                  tmp.assign(x);
                  tmp.rotateRight(18);
                  result.xor(tmp);
                  tmp.assign(x);
                  tmp.rotateRight(41);
                  result.xor(tmp);
                }
                function littleSigma(result, x, tmp) {
                  result.assign(x);
                  result.rotateRight(1);
                  tmp.assign(x);
                  tmp.rotateRight(8);
                  result.xor(tmp);
                  tmp.assign(x);
                  tmp.shiftRight(7);
                  result.xor(tmp);
                }
                function littleSigmaPrime(result, x, tmp) {
                  result.assign(x);
                  result.rotateRight(19);
                  tmp.assign(x);
                  tmp.rotateRight(61);
                  result.xor(tmp);
                  tmp.assign(x);
                  tmp.shiftRight(6);
                  result.xor(tmp);
                }
                const k = [new Word64(1116352408, 3609767458), new Word64(1899447441, 602891725), new Word64(3049323471, 3964484399), new Word64(3921009573, 2173295548), new Word64(961987163, 4081628472), new Word64(1508970993, 3053834265), new Word64(2453635748, 2937671579), new Word64(2870763221, 3664609560), new Word64(3624381080, 2734883394), new Word64(310598401, 1164996542), new Word64(607225278, 1323610764), new Word64(1426881987, 3590304994), new Word64(1925078388, 4068182383), new Word64(2162078206, 991336113), new Word64(2614888103, 633803317), new Word64(3248222580, 3479774868), new Word64(3835390401, 2666613458), new Word64(4022224774, 944711139), new Word64(264347078, 2341262773), new Word64(604807628, 2007800933), new Word64(770255983, 1495990901), new Word64(1249150122, 1856431235), new Word64(1555081692, 3175218132), new Word64(1996064986, 2198950837), new Word64(2554220882, 3999719339), new Word64(2821834349, 766784016), new Word64(2952996808, 2566594879), new Word64(3210313671, 3203337956), new Word64(3336571891, 1034457026), new Word64(3584528711, 2466948901), new Word64(113926993, 3758326383), new Word64(338241895, 168717936), new Word64(666307205, 1188179964), new Word64(773529912, 1546045734), new Word64(1294757372, 1522805485), new Word64(1396182291, 2643833823), new Word64(1695183700, 2343527390), new Word64(1986661051, 1014477480), new Word64(2177026350, 1206759142), new Word64(2456956037, 344077627), new Word64(2730485921, 1290863460), new Word64(2820302411, 3158454273), new Word64(3259730800, 3505952657), new Word64(3345764771, 106217008), new Word64(3516065817, 3606008344), new Word64(3600352804, 1432725776), new Word64(4094571909, 1467031594), new Word64(275423344, 851169720), new Word64(430227734, 3100823752), new Word64(506948616, 1363258195), new Word64(659060556, 3750685593), new Word64(883997877, 3785050280), new Word64(958139571, 3318307427), new Word64(1322822218, 3812723403), new Word64(1537002063, 2003034995), new Word64(1747873779, 3602036899), new Word64(1955562222, 1575990012), new Word64(2024104815, 1125592928), new Word64(2227730452, 2716904306), new Word64(2361852424, 442776044), new Word64(2428436474, 593698344), new Word64(2756734187, 3733110249), new Word64(3204031479, 2999351573), new Word64(3329325298, 3815920427), new Word64(3391569614, 3928383900), new Word64(3515267271, 566280711), new Word64(3940187606, 3454069534), new Word64(4118630271, 4000239992), new Word64(116418474, 1914138554), new Word64(174292421, 2731055270), new Word64(289380356, 3203993006), new Word64(460393269, 320620315), new Word64(685471733, 587496836), new Word64(852142971, 1086792851), new Word64(1017036298, 365543100), new Word64(1126000580, 2618297676), new Word64(1288033470, 3409855158), new Word64(1501505948, 4234509866), new Word64(1607167915, 987167468), new Word64(1816402316, 1246189591)];
                function hash(data, offset, length, mode384 = false) {
                  let h0, h1, h2, h3, h4, h5, h6, h7;
                  if (!mode384) {
                    h0 = new Word64(1779033703, 4089235720);
                    h1 = new Word64(3144134277, 2227873595);
                    h2 = new Word64(1013904242, 4271175723);
                    h3 = new Word64(2773480762, 1595750129);
                    h4 = new Word64(1359893119, 2917565137);
                    h5 = new Word64(2600822924, 725511199);
                    h6 = new Word64(528734635, 4215389547);
                    h7 = new Word64(1541459225, 327033209);
                  } else {
                    h0 = new Word64(3418070365, 3238371032);
                    h1 = new Word64(1654270250, 914150663);
                    h2 = new Word64(2438529370, 812702999);
                    h3 = new Word64(355462360, 4144912697);
                    h4 = new Word64(1731405415, 4290775857);
                    h5 = new Word64(2394180231, 1750603025);
                    h6 = new Word64(3675008525, 1694076839);
                    h7 = new Word64(1203062813, 3204075428);
                  }
                  const paddedLength = Math.ceil((length + 17) / 128) * 128;
                  const padded = new Uint8Array(paddedLength);
                  let i, j;
                  for (i = 0; i < length; ++i) {
                    padded[i] = data[offset++];
                  }
                  padded[i++] = 128;
                  const n = paddedLength - 16;
                  while (i < n) {
                    padded[i++] = 0;
                  }
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = length >>> 29 & 255;
                  padded[i++] = length >> 21 & 255;
                  padded[i++] = length >> 13 & 255;
                  padded[i++] = length >> 5 & 255;
                  padded[i++] = length << 3 & 255;
                  const w = new Array(80);
                  for (i = 0; i < 80; i++) {
                    w[i] = new Word64(0, 0);
                  }
                  let a = new Word64(0, 0), b = new Word64(0, 0), c = new Word64(0, 0);
                  let d = new Word64(0, 0), e = new Word64(0, 0), f = new Word64(0, 0);
                  let g = new Word64(0, 0), h = new Word64(0, 0);
                  const t1 = new Word64(0, 0), t2 = new Word64(0, 0);
                  const tmp1 = new Word64(0, 0), tmp2 = new Word64(0, 0);
                  let tmp3;
                  for (i = 0; i < paddedLength; ) {
                    for (j = 0; j < 16; ++j) {
                      w[j].high = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
                      w[j].low = padded[i + 4] << 24 | padded[i + 5] << 16 | padded[i + 6] << 8 | padded[i + 7];
                      i += 8;
                    }
                    for (j = 16; j < 80; ++j) {
                      tmp3 = w[j];
                      littleSigmaPrime(tmp3, w[j - 2], tmp2);
                      tmp3.add(w[j - 7]);
                      littleSigma(tmp1, w[j - 15], tmp2);
                      tmp3.add(tmp1);
                      tmp3.add(w[j - 16]);
                    }
                    a.assign(h0);
                    b.assign(h1);
                    c.assign(h2);
                    d.assign(h3);
                    e.assign(h4);
                    f.assign(h5);
                    g.assign(h6);
                    h.assign(h7);
                    for (j = 0; j < 80; ++j) {
                      t1.assign(h);
                      sigmaPrime(tmp1, e, tmp2);
                      t1.add(tmp1);
                      ch(tmp1, e, f, g, tmp2);
                      t1.add(tmp1);
                      t1.add(k[j]);
                      t1.add(w[j]);
                      sigma(t2, a, tmp2);
                      maj(tmp1, a, b, c, tmp2);
                      t2.add(tmp1);
                      tmp3 = h;
                      h = g;
                      g = f;
                      f = e;
                      d.add(t1);
                      e = d;
                      d = c;
                      c = b;
                      b = a;
                      tmp3.assign(t1);
                      tmp3.add(t2);
                      a = tmp3;
                    }
                    h0.add(a);
                    h1.add(b);
                    h2.add(c);
                    h3.add(d);
                    h4.add(e);
                    h5.add(f);
                    h6.add(g);
                    h7.add(h);
                  }
                  let result;
                  if (!mode384) {
                    result = new Uint8Array(64);
                    h0.copyTo(result, 0);
                    h1.copyTo(result, 8);
                    h2.copyTo(result, 16);
                    h3.copyTo(result, 24);
                    h4.copyTo(result, 32);
                    h5.copyTo(result, 40);
                    h6.copyTo(result, 48);
                    h7.copyTo(result, 56);
                  } else {
                    result = new Uint8Array(48);
                    h0.copyTo(result, 0);
                    h1.copyTo(result, 8);
                    h2.copyTo(result, 16);
                    h3.copyTo(result, 24);
                    h4.copyTo(result, 32);
                    h5.copyTo(result, 40);
                  }
                  return result;
                }
                return hash;
              }();
              exports2.calculateSHA512 = calculateSHA512;
              function calculateSHA384(data, offset, length) {
                return calculateSHA512(data, offset, length, true);
              }
              class NullCipher {
                decryptBlock(data) {
                  return data;
                }
                encrypt(data) {
                  return data;
                }
              }
              class AESBaseCipher {
                constructor() {
                  if (this.constructor === AESBaseCipher) {
                    (0, _util.unreachable)("Cannot initialize AESBaseCipher.");
                  }
                  this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]);
                  this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);
                  this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]);
                  this._mixCol = new Uint8Array(256);
                  for (let i = 0; i < 256; i++) {
                    this._mixCol[i] = i < 128 ? i << 1 : i << 1 ^ 27;
                  }
                  this.buffer = new Uint8Array(16);
                  this.bufferPosition = 0;
                }
                _expandKey(cipherKey) {
                  (0, _util.unreachable)("Cannot call `_expandKey` on the base class");
                }
                _decrypt(input, key) {
                  let t, u, v;
                  const state = new Uint8Array(16);
                  state.set(input);
                  for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {
                    state[j] ^= key[k];
                  }
                  for (let i = this._cyclesOfRepetition - 1; i >= 1; --i) {
                    t = state[13];
                    state[13] = state[9];
                    state[9] = state[5];
                    state[5] = state[1];
                    state[1] = t;
                    t = state[14];
                    u = state[10];
                    state[14] = state[6];
                    state[10] = state[2];
                    state[6] = t;
                    state[2] = u;
                    t = state[15];
                    u = state[11];
                    v = state[7];
                    state[15] = state[3];
                    state[11] = t;
                    state[7] = u;
                    state[3] = v;
                    for (let j = 0; j < 16; ++j) {
                      state[j] = this._inv_s[state[j]];
                    }
                    for (let j = 0, k = i * 16; j < 16; ++j, ++k) {
                      state[j] ^= key[k];
                    }
                    for (let j = 0; j < 16; j += 4) {
                      const s0 = this._mix[state[j]];
                      const s1 = this._mix[state[j + 1]];
                      const s2 = this._mix[state[j + 2]];
                      const s3 = this._mix[state[j + 3]];
                      t = s0 ^ s1 >>> 8 ^ s1 << 24 ^ s2 >>> 16 ^ s2 << 16 ^ s3 >>> 24 ^ s3 << 8;
                      state[j] = t >>> 24 & 255;
                      state[j + 1] = t >> 16 & 255;
                      state[j + 2] = t >> 8 & 255;
                      state[j + 3] = t & 255;
                    }
                  }
                  t = state[13];
                  state[13] = state[9];
                  state[9] = state[5];
                  state[5] = state[1];
                  state[1] = t;
                  t = state[14];
                  u = state[10];
                  state[14] = state[6];
                  state[10] = state[2];
                  state[6] = t;
                  state[2] = u;
                  t = state[15];
                  u = state[11];
                  v = state[7];
                  state[15] = state[3];
                  state[11] = t;
                  state[7] = u;
                  state[3] = v;
                  for (let j = 0; j < 16; ++j) {
                    state[j] = this._inv_s[state[j]];
                    state[j] ^= key[j];
                  }
                  return state;
                }
                _encrypt(input, key) {
                  const s = this._s;
                  let t, u, v;
                  const state = new Uint8Array(16);
                  state.set(input);
                  for (let j = 0; j < 16; ++j) {
                    state[j] ^= key[j];
                  }
                  for (let i = 1; i < this._cyclesOfRepetition; i++) {
                    for (let j = 0; j < 16; ++j) {
                      state[j] = s[state[j]];
                    }
                    v = state[1];
                    state[1] = state[5];
                    state[5] = state[9];
                    state[9] = state[13];
                    state[13] = v;
                    v = state[2];
                    u = state[6];
                    state[2] = state[10];
                    state[6] = state[14];
                    state[10] = v;
                    state[14] = u;
                    v = state[3];
                    u = state[7];
                    t = state[11];
                    state[3] = state[15];
                    state[7] = v;
                    state[11] = u;
                    state[15] = t;
                    for (let j = 0; j < 16; j += 4) {
                      const s0 = state[j + 0];
                      const s1 = state[j + 1];
                      const s2 = state[j + 2];
                      const s3 = state[j + 3];
                      t = s0 ^ s1 ^ s2 ^ s3;
                      state[j + 0] ^= t ^ this._mixCol[s0 ^ s1];
                      state[j + 1] ^= t ^ this._mixCol[s1 ^ s2];
                      state[j + 2] ^= t ^ this._mixCol[s2 ^ s3];
                      state[j + 3] ^= t ^ this._mixCol[s3 ^ s0];
                    }
                    for (let j = 0, k = i * 16; j < 16; ++j, ++k) {
                      state[j] ^= key[k];
                    }
                  }
                  for (let j = 0; j < 16; ++j) {
                    state[j] = s[state[j]];
                  }
                  v = state[1];
                  state[1] = state[5];
                  state[5] = state[9];
                  state[9] = state[13];
                  state[13] = v;
                  v = state[2];
                  u = state[6];
                  state[2] = state[10];
                  state[6] = state[14];
                  state[10] = v;
                  state[14] = u;
                  v = state[3];
                  u = state[7];
                  t = state[11];
                  state[3] = state[15];
                  state[7] = v;
                  state[11] = u;
                  state[15] = t;
                  for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {
                    state[j] ^= key[k];
                  }
                  return state;
                }
                _decryptBlock2(data, finalize) {
                  const sourceLength = data.length;
                  let buffer = this.buffer, bufferLength = this.bufferPosition;
                  const result = [];
                  let iv = this.iv;
                  for (let i = 0; i < sourceLength; ++i) {
                    buffer[bufferLength] = data[i];
                    ++bufferLength;
                    if (bufferLength < 16) {
                      continue;
                    }
                    const plain = this._decrypt(buffer, this._key);
                    for (let j = 0; j < 16; ++j) {
                      plain[j] ^= iv[j];
                    }
                    iv = buffer;
                    result.push(plain);
                    buffer = new Uint8Array(16);
                    bufferLength = 0;
                  }
                  this.buffer = buffer;
                  this.bufferLength = bufferLength;
                  this.iv = iv;
                  if (result.length === 0) {
                    return new Uint8Array(0);
                  }
                  let outputLength = 16 * result.length;
                  if (finalize) {
                    const lastBlock = result.at(-1);
                    let psLen = lastBlock[15];
                    if (psLen <= 16) {
                      for (let i = 15, ii = 16 - psLen; i >= ii; --i) {
                        if (lastBlock[i] !== psLen) {
                          psLen = 0;
                          break;
                        }
                      }
                      outputLength -= psLen;
                      result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
                    }
                  }
                  const output = new Uint8Array(outputLength);
                  for (let i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
                    output.set(result[i], j);
                  }
                  return output;
                }
                decryptBlock(data, finalize, iv = null) {
                  const sourceLength = data.length;
                  const buffer = this.buffer;
                  let bufferLength = this.bufferPosition;
                  if (iv) {
                    this.iv = iv;
                  } else {
                    for (let i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
                      buffer[bufferLength] = data[i];
                    }
                    if (bufferLength < 16) {
                      this.bufferLength = bufferLength;
                      return new Uint8Array(0);
                    }
                    this.iv = buffer;
                    data = data.subarray(16);
                  }
                  this.buffer = new Uint8Array(16);
                  this.bufferLength = 0;
                  this.decryptBlock = this._decryptBlock2;
                  return this.decryptBlock(data, finalize);
                }
                encrypt(data, iv) {
                  const sourceLength = data.length;
                  let buffer = this.buffer, bufferLength = this.bufferPosition;
                  const result = [];
                  if (!iv) {
                    iv = new Uint8Array(16);
                  }
                  for (let i = 0; i < sourceLength; ++i) {
                    buffer[bufferLength] = data[i];
                    ++bufferLength;
                    if (bufferLength < 16) {
                      continue;
                    }
                    for (let j = 0; j < 16; ++j) {
                      buffer[j] ^= iv[j];
                    }
                    const cipher = this._encrypt(buffer, this._key);
                    iv = cipher;
                    result.push(cipher);
                    buffer = new Uint8Array(16);
                    bufferLength = 0;
                  }
                  this.buffer = buffer;
                  this.bufferLength = bufferLength;
                  this.iv = iv;
                  if (result.length === 0) {
                    return new Uint8Array(0);
                  }
                  const outputLength = 16 * result.length;
                  const output = new Uint8Array(outputLength);
                  for (let i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
                    output.set(result[i], j);
                  }
                  return output;
                }
              }
              class AES128Cipher extends AESBaseCipher {
                constructor(key) {
                  super();
                  this._cyclesOfRepetition = 10;
                  this._keySize = 160;
                  this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]);
                  this._key = this._expandKey(key);
                }
                _expandKey(cipherKey) {
                  const b = 176;
                  const s = this._s;
                  const rcon = this._rcon;
                  const result = new Uint8Array(b);
                  result.set(cipherKey);
                  for (let j = 16, i = 1; j < b; ++i) {
                    let t1 = result[j - 3];
                    let t2 = result[j - 2];
                    let t3 = result[j - 1];
                    let t4 = result[j - 4];
                    t1 = s[t1];
                    t2 = s[t2];
                    t3 = s[t3];
                    t4 = s[t4];
                    t1 ^= rcon[i];
                    for (let n = 0; n < 4; ++n) {
                      result[j] = t1 ^= result[j - 16];
                      j++;
                      result[j] = t2 ^= result[j - 16];
                      j++;
                      result[j] = t3 ^= result[j - 16];
                      j++;
                      result[j] = t4 ^= result[j - 16];
                      j++;
                    }
                  }
                  return result;
                }
              }
              exports2.AES128Cipher = AES128Cipher;
              class AES256Cipher extends AESBaseCipher {
                constructor(key) {
                  super();
                  this._cyclesOfRepetition = 14;
                  this._keySize = 224;
                  this._key = this._expandKey(key);
                }
                _expandKey(cipherKey) {
                  const b = 240;
                  const s = this._s;
                  const result = new Uint8Array(b);
                  result.set(cipherKey);
                  let r = 1;
                  let t1, t2, t3, t4;
                  for (let j = 32, i = 1; j < b; ++i) {
                    if (j % 32 === 16) {
                      t1 = s[t1];
                      t2 = s[t2];
                      t3 = s[t3];
                      t4 = s[t4];
                    } else if (j % 32 === 0) {
                      t1 = result[j - 3];
                      t2 = result[j - 2];
                      t3 = result[j - 1];
                      t4 = result[j - 4];
                      t1 = s[t1];
                      t2 = s[t2];
                      t3 = s[t3];
                      t4 = s[t4];
                      t1 ^= r;
                      if ((r <<= 1) >= 256) {
                        r = (r ^ 27) & 255;
                      }
                    }
                    for (let n = 0; n < 4; ++n) {
                      result[j] = t1 ^= result[j - 32];
                      j++;
                      result[j] = t2 ^= result[j - 32];
                      j++;
                      result[j] = t3 ^= result[j - 32];
                      j++;
                      result[j] = t4 ^= result[j - 32];
                      j++;
                    }
                  }
                  return result;
                }
              }
              exports2.AES256Cipher = AES256Cipher;
              class PDF17 {
                checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
                  const hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerValidationSalt, password.length);
                  hashData.set(userBytes, password.length + ownerValidationSalt.length);
                  const result = calculateSHA256(hashData, 0, hashData.length);
                  return (0, _util.isArrayEqual)(result, ownerPassword);
                }
                checkUserPassword(password, userValidationSalt, userPassword) {
                  const hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userValidationSalt, password.length);
                  const result = calculateSHA256(hashData, 0, hashData.length);
                  return (0, _util.isArrayEqual)(result, userPassword);
                }
                getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
                  const hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerKeySalt, password.length);
                  hashData.set(userBytes, password.length + ownerKeySalt.length);
                  const key = calculateSHA256(hashData, 0, hashData.length);
                  const cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
                }
                getUserKey(password, userKeySalt, userEncryption) {
                  const hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userKeySalt, password.length);
                  const key = calculateSHA256(hashData, 0, hashData.length);
                  const cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
                }
              }
              exports2.PDF17 = PDF17;
              class PDF20 {
                _hash(password, input, userBytes) {
                  let k = calculateSHA256(input, 0, input.length).subarray(0, 32);
                  let e = [0];
                  let i = 0;
                  while (i < 64 || e.at(-1) > i - 32) {
                    const combinedLength = password.length + k.length + userBytes.length, combinedArray = new Uint8Array(combinedLength);
                    let writeOffset = 0;
                    combinedArray.set(password, writeOffset);
                    writeOffset += password.length;
                    combinedArray.set(k, writeOffset);
                    writeOffset += k.length;
                    combinedArray.set(userBytes, writeOffset);
                    const k1 = new Uint8Array(combinedLength * 64);
                    for (let j = 0, pos = 0; j < 64; j++, pos += combinedLength) {
                      k1.set(combinedArray, pos);
                    }
                    const cipher = new AES128Cipher(k.subarray(0, 16));
                    e = cipher.encrypt(k1, k.subarray(16, 32));
                    const remainder = e.slice(0, 16).reduce((a, b) => a + b, 0) % 3;
                    if (remainder === 0) {
                      k = calculateSHA256(e, 0, e.length);
                    } else if (remainder === 1) {
                      k = calculateSHA384(e, 0, e.length);
                    } else if (remainder === 2) {
                      k = calculateSHA512(e, 0, e.length);
                    }
                    i++;
                  }
                  return k.subarray(0, 32);
                }
                checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
                  const hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerValidationSalt, password.length);
                  hashData.set(userBytes, password.length + ownerValidationSalt.length);
                  const result = this._hash(password, hashData, userBytes);
                  return (0, _util.isArrayEqual)(result, ownerPassword);
                }
                checkUserPassword(password, userValidationSalt, userPassword) {
                  const hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userValidationSalt, password.length);
                  const result = this._hash(password, hashData, []);
                  return (0, _util.isArrayEqual)(result, userPassword);
                }
                getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
                  const hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerKeySalt, password.length);
                  hashData.set(userBytes, password.length + ownerKeySalt.length);
                  const key = this._hash(password, hashData, userBytes);
                  const cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
                }
                getUserKey(password, userKeySalt, userEncryption) {
                  const hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userKeySalt, password.length);
                  const key = this._hash(password, hashData, []);
                  const cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
                }
              }
              exports2.PDF20 = PDF20;
              class CipherTransform {
                constructor(stringCipherConstructor, streamCipherConstructor) {
                  this.StringCipherConstructor = stringCipherConstructor;
                  this.StreamCipherConstructor = streamCipherConstructor;
                }
                createStream(stream, length) {
                  const cipher = new this.StreamCipherConstructor();
                  return new _decrypt_stream.DecryptStream(stream, length, function cipherTransformDecryptStream(data, finalize) {
                    return cipher.decryptBlock(data, finalize);
                  });
                }
                decryptString(s) {
                  const cipher = new this.StringCipherConstructor();
                  let data = (0, _util.stringToBytes)(s);
                  data = cipher.decryptBlock(data, true);
                  return (0, _util.bytesToString)(data);
                }
                encryptString(s) {
                  const cipher = new this.StringCipherConstructor();
                  if (cipher instanceof AESBaseCipher) {
                    const strLen = s.length;
                    const pad = 16 - strLen % 16;
                    s += String.fromCharCode(pad).repeat(pad);
                    const iv = new Uint8Array(16);
                    if (typeof crypto !== "undefined") {
                      crypto.getRandomValues(iv);
                    } else {
                      for (let i = 0; i < 16; i++) {
                        iv[i] = Math.floor(256 * Math.random());
                      }
                    }
                    let data2 = (0, _util.stringToBytes)(s);
                    data2 = cipher.encrypt(data2, iv);
                    const buf = new Uint8Array(16 + data2.length);
                    buf.set(iv);
                    buf.set(data2, 16);
                    return (0, _util.bytesToString)(buf);
                  }
                  let data = (0, _util.stringToBytes)(s);
                  data = cipher.encrypt(data);
                  return (0, _util.bytesToString)(data);
                }
              }
              const _CipherTransformFactory = class _CipherTransformFactory {
                constructor(dict, fileId, password) {
                  __privateAdd(this, _createEncryptionKey20);
                  __privateAdd(this, _prepareKeyData);
                  __privateAdd(this, _decodeUserPassword);
                  __privateAdd(this, _buildObjectKey);
                  __privateAdd(this, _buildCipherConstructor);
                  const filter = dict.get("Filter");
                  if (!(0, _primitives.isName)(filter, "Standard")) {
                    throw new _util.FormatError("unknown encryption method");
                  }
                  this.filterName = filter.name;
                  this.dict = dict;
                  const algorithm = dict.get("V");
                  if (!Number.isInteger(algorithm) || algorithm !== 1 && algorithm !== 2 && algorithm !== 4 && algorithm !== 5) {
                    throw new _util.FormatError("unsupported encryption algorithm");
                  }
                  this.algorithm = algorithm;
                  let keyLength = dict.get("Length");
                  if (!keyLength) {
                    if (algorithm <= 3) {
                      keyLength = 40;
                    } else {
                      const cfDict = dict.get("CF");
                      const streamCryptoName = dict.get("StmF");
                      if (cfDict instanceof _primitives.Dict && streamCryptoName instanceof _primitives.Name) {
                        cfDict.suppressEncryption = true;
                        const handlerDict = cfDict.get(streamCryptoName.name);
                        keyLength = (handlerDict == null ? void 0 : handlerDict.get("Length")) || 128;
                        if (keyLength < 40) {
                          keyLength <<= 3;
                        }
                      }
                    }
                  }
                  if (!Number.isInteger(keyLength) || keyLength < 40 || keyLength % 8 !== 0) {
                    throw new _util.FormatError("invalid key length");
                  }
                  const ownerBytes = (0, _util.stringToBytes)(dict.get("O")), userBytes = (0, _util.stringToBytes)(dict.get("U"));
                  const ownerPassword = ownerBytes.subarray(0, 32);
                  const userPassword = userBytes.subarray(0, 32);
                  const flags = dict.get("P");
                  const revision = dict.get("R");
                  const encryptMetadata = (algorithm === 4 || algorithm === 5) && dict.get("EncryptMetadata") !== false;
                  this.encryptMetadata = encryptMetadata;
                  const fileIdBytes = (0, _util.stringToBytes)(fileId);
                  let passwordBytes;
                  if (password) {
                    if (revision === 6) {
                      try {
                        password = (0, _util.utf8StringToString)(password);
                      } catch {
                        (0, _util.warn)("CipherTransformFactory: Unable to convert UTF8 encoded password.");
                      }
                    }
                    passwordBytes = (0, _util.stringToBytes)(password);
                  }
                  let encryptionKey;
                  if (algorithm !== 5) {
                    encryptionKey = __privateMethod(this, _prepareKeyData, prepareKeyData_fn).call(this, fileIdBytes, passwordBytes, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
                  } else {
                    const ownerValidationSalt = ownerBytes.subarray(32, 40);
                    const ownerKeySalt = ownerBytes.subarray(40, 48);
                    const uBytes = userBytes.subarray(0, 48);
                    const userValidationSalt = userBytes.subarray(32, 40);
                    const userKeySalt = userBytes.subarray(40, 48);
                    const ownerEncryption = (0, _util.stringToBytes)(dict.get("OE"));
                    const userEncryption = (0, _util.stringToBytes)(dict.get("UE"));
                    const perms = (0, _util.stringToBytes)(dict.get("Perms"));
                    encryptionKey = __privateMethod(this, _createEncryptionKey20, createEncryptionKey20_fn).call(this, revision, passwordBytes, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms);
                  }
                  if (!encryptionKey && !password) {
                    throw new _util.PasswordException("No password given", _util.PasswordResponses.NEED_PASSWORD);
                  } else if (!encryptionKey && password) {
                    const decodedPassword = __privateMethod(this, _decodeUserPassword, decodeUserPassword_fn).call(this, passwordBytes, ownerPassword, revision, keyLength);
                    encryptionKey = __privateMethod(this, _prepareKeyData, prepareKeyData_fn).call(this, fileIdBytes, decodedPassword, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
                  }
                  if (!encryptionKey) {
                    throw new _util.PasswordException("Incorrect Password", _util.PasswordResponses.INCORRECT_PASSWORD);
                  }
                  this.encryptionKey = encryptionKey;
                  if (algorithm >= 4) {
                    const cf = dict.get("CF");
                    if (cf instanceof _primitives.Dict) {
                      cf.suppressEncryption = true;
                    }
                    this.cf = cf;
                    this.stmf = dict.get("StmF") || _primitives.Name.get("Identity");
                    this.strf = dict.get("StrF") || _primitives.Name.get("Identity");
                    this.eff = dict.get("EFF") || this.stmf;
                  }
                }
                createCipherTransform(num, gen) {
                  if (this.algorithm === 4 || this.algorithm === 5) {
                    return new CipherTransform(__privateMethod(this, _buildCipherConstructor, buildCipherConstructor_fn).call(this, this.cf, this.strf, num, gen, this.encryptionKey), __privateMethod(this, _buildCipherConstructor, buildCipherConstructor_fn).call(this, this.cf, this.stmf, num, gen, this.encryptionKey));
                  }
                  const key = __privateMethod(this, _buildObjectKey, buildObjectKey_fn).call(this, num, gen, this.encryptionKey, false);
                  const cipherConstructor = function() {
                    return new ARCFourCipher(key);
                  };
                  return new CipherTransform(cipherConstructor, cipherConstructor);
                }
              };
              _defaultPasswordBytes = new WeakMap();
              _createEncryptionKey20 = new WeakSet();
              createEncryptionKey20_fn = function(revision, password, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms) {
                if (password) {
                  const passwordLength = Math.min(127, password.length);
                  password = password.subarray(0, passwordLength);
                } else {
                  password = [];
                }
                const pdfAlgorithm = revision === 6 ? new PDF20() : new PDF17();
                if (pdfAlgorithm.checkUserPassword(password, userValidationSalt, userPassword)) {
                  return pdfAlgorithm.getUserKey(password, userKeySalt, userEncryption);
                } else if (password.length && pdfAlgorithm.checkOwnerPassword(password, ownerValidationSalt, uBytes, ownerPassword)) {
                  return pdfAlgorithm.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);
                }
                return null;
              };
              _prepareKeyData = new WeakSet();
              prepareKeyData_fn = function(fileId, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata) {
                const hashDataSize = 40 + ownerPassword.length + fileId.length;
                const hashData = new Uint8Array(hashDataSize);
                let i = 0, j, n;
                if (password) {
                  n = Math.min(32, password.length);
                  for (; i < n; ++i) {
                    hashData[i] = password[i];
                  }
                }
                j = 0;
                while (i < 32) {
                  hashData[i++] = __privateGet(_CipherTransformFactory, _defaultPasswordBytes)[j++];
                }
                for (j = 0, n = ownerPassword.length; j < n; ++j) {
                  hashData[i++] = ownerPassword[j];
                }
                hashData[i++] = flags & 255;
                hashData[i++] = flags >> 8 & 255;
                hashData[i++] = flags >> 16 & 255;
                hashData[i++] = flags >>> 24 & 255;
                for (j = 0, n = fileId.length; j < n; ++j) {
                  hashData[i++] = fileId[j];
                }
                if (revision >= 4 && !encryptMetadata) {
                  hashData[i++] = 255;
                  hashData[i++] = 255;
                  hashData[i++] = 255;
                  hashData[i++] = 255;
                }
                let hash = calculateMD5(hashData, 0, i);
                const keyLengthInBytes = keyLength >> 3;
                if (revision >= 3) {
                  for (j = 0; j < 50; ++j) {
                    hash = calculateMD5(hash, 0, keyLengthInBytes);
                  }
                }
                const encryptionKey = hash.subarray(0, keyLengthInBytes);
                let cipher, checkData;
                if (revision >= 3) {
                  for (i = 0; i < 32; ++i) {
                    hashData[i] = __privateGet(_CipherTransformFactory, _defaultPasswordBytes)[i];
                  }
                  for (j = 0, n = fileId.length; j < n; ++j) {
                    hashData[i++] = fileId[j];
                  }
                  cipher = new ARCFourCipher(encryptionKey);
                  checkData = cipher.encryptBlock(calculateMD5(hashData, 0, i));
                  n = encryptionKey.length;
                  const derivedKey = new Uint8Array(n);
                  for (j = 1; j <= 19; ++j) {
                    for (let k = 0; k < n; ++k) {
                      derivedKey[k] = encryptionKey[k] ^ j;
                    }
                    cipher = new ARCFourCipher(derivedKey);
                    checkData = cipher.encryptBlock(checkData);
                  }
                  for (j = 0, n = checkData.length; j < n; ++j) {
                    if (userPassword[j] !== checkData[j]) {
                      return null;
                    }
                  }
                } else {
                  cipher = new ARCFourCipher(encryptionKey);
                  checkData = cipher.encryptBlock(__privateGet(_CipherTransformFactory, _defaultPasswordBytes));
                  for (j = 0, n = checkData.length; j < n; ++j) {
                    if (userPassword[j] !== checkData[j]) {
                      return null;
                    }
                  }
                }
                return encryptionKey;
              };
              _decodeUserPassword = new WeakSet();
              decodeUserPassword_fn = function(password, ownerPassword, revision, keyLength) {
                const hashData = new Uint8Array(32);
                let i = 0;
                const n = Math.min(32, password.length);
                for (; i < n; ++i) {
                  hashData[i] = password[i];
                }
                let j = 0;
                while (i < 32) {
                  hashData[i++] = __privateGet(_CipherTransformFactory, _defaultPasswordBytes)[j++];
                }
                let hash = calculateMD5(hashData, 0, i);
                const keyLengthInBytes = keyLength >> 3;
                if (revision >= 3) {
                  for (j = 0; j < 50; ++j) {
                    hash = calculateMD5(hash, 0, hash.length);
                  }
                }
                let cipher, userPassword;
                if (revision >= 3) {
                  userPassword = ownerPassword;
                  const derivedKey = new Uint8Array(keyLengthInBytes);
                  for (j = 19; j >= 0; j--) {
                    for (let k = 0; k < keyLengthInBytes; ++k) {
                      derivedKey[k] = hash[k] ^ j;
                    }
                    cipher = new ARCFourCipher(derivedKey);
                    userPassword = cipher.encryptBlock(userPassword);
                  }
                } else {
                  cipher = new ARCFourCipher(hash.subarray(0, keyLengthInBytes));
                  userPassword = cipher.encryptBlock(ownerPassword);
                }
                return userPassword;
              };
              _buildObjectKey = new WeakSet();
              buildObjectKey_fn = function(num, gen, encryptionKey, isAes = false) {
                const key = new Uint8Array(encryptionKey.length + 9);
                const n = encryptionKey.length;
                let i;
                for (i = 0; i < n; ++i) {
                  key[i] = encryptionKey[i];
                }
                key[i++] = num & 255;
                key[i++] = num >> 8 & 255;
                key[i++] = num >> 16 & 255;
                key[i++] = gen & 255;
                key[i++] = gen >> 8 & 255;
                if (isAes) {
                  key[i++] = 115;
                  key[i++] = 65;
                  key[i++] = 108;
                  key[i++] = 84;
                }
                const hash = calculateMD5(key, 0, i);
                return hash.subarray(0, Math.min(encryptionKey.length + 5, 16));
              };
              _buildCipherConstructor = new WeakSet();
              buildCipherConstructor_fn = function(cf, name, num, gen, key) {
                if (!(name instanceof _primitives.Name)) {
                  throw new _util.FormatError("Invalid crypt filter name.");
                }
                const self2 = this;
                const cryptFilter = cf.get(name.name);
                const cfm = cryptFilter == null ? void 0 : cryptFilter.get("CFM");
                if (!cfm || cfm.name === "None") {
                  return function() {
                    return new NullCipher();
                  };
                }
                if (cfm.name === "V2") {
                  return function() {
                    var _a;
                    return new ARCFourCipher(__privateMethod(_a = self2, _buildObjectKey, buildObjectKey_fn).call(_a, num, gen, key, false));
                  };
                }
                if (cfm.name === "AESV2") {
                  return function() {
                    var _a;
                    return new AES128Cipher(__privateMethod(_a = self2, _buildObjectKey, buildObjectKey_fn).call(_a, num, gen, key, true));
                  };
                }
                if (cfm.name === "AESV3") {
                  return function() {
                    return new AES256Cipher(key);
                  };
                }
                throw new _util.FormatError("Unknown crypto method");
              };
              __privateAdd(_CipherTransformFactory, _defaultPasswordBytes, new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]));
              let CipherTransformFactory = _CipherTransformFactory;
              exports2.CipherTransformFactory = CipherTransformFactory;
            },
            /* 75 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.DecryptStream = void 0;
              var _decode_stream = __w_pdfjs_require__2(18);
              const chunkSize = 512;
              class DecryptStream extends _decode_stream.DecodeStream {
                constructor(str, maybeLength, decrypt) {
                  super(maybeLength);
                  this.str = str;
                  this.dict = str.dict;
                  this.decrypt = decrypt;
                  this.nextChunk = null;
                  this.initialized = false;
                }
                readBlock() {
                  var _a;
                  let chunk;
                  if (this.initialized) {
                    chunk = this.nextChunk;
                  } else {
                    chunk = this.str.getBytes(chunkSize);
                    this.initialized = true;
                  }
                  if (!chunk || chunk.length === 0) {
                    this.eof = true;
                    return;
                  }
                  this.nextChunk = this.str.getBytes(chunkSize);
                  const hasMoreData = ((_a = this.nextChunk) == null ? void 0 : _a.length) > 0;
                  const decrypt = this.decrypt;
                  chunk = decrypt(chunk, !hasMoreData);
                  const bufferLength = this.bufferLength, newLength = bufferLength + chunk.length, buffer = this.ensureBuffer(newLength);
                  buffer.set(chunk, bufferLength);
                  this.bufferLength = newLength;
                }
              }
              exports2.DecryptStream = DecryptStream;
            },
            /* 76 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ObjectLoader = void 0;
              var _primitives = __w_pdfjs_require__2(4);
              var _base_stream = __w_pdfjs_require__2(5);
              var _core_utils = __w_pdfjs_require__2(3);
              var _util = __w_pdfjs_require__2(2);
              function mayHaveChildren(value) {
                return value instanceof _primitives.Ref || value instanceof _primitives.Dict || value instanceof _base_stream.BaseStream || Array.isArray(value);
              }
              function addChildren(node, nodesToVisit) {
                if (node instanceof _primitives.Dict) {
                  node = node.getRawValues();
                } else if (node instanceof _base_stream.BaseStream) {
                  node = node.dict.getRawValues();
                } else if (!Array.isArray(node)) {
                  return;
                }
                for (const rawValue of node) {
                  if (mayHaveChildren(rawValue)) {
                    nodesToVisit.push(rawValue);
                  }
                }
              }
              class ObjectLoader {
                constructor(dict, keys, xref) {
                  this.dict = dict;
                  this.keys = keys;
                  this.xref = xref;
                  this.refSet = null;
                }
                async load() {
                  if (this.xref.stream.isDataLoaded) {
                    return void 0;
                  }
                  const {
                    keys,
                    dict
                  } = this;
                  this.refSet = new _primitives.RefSet();
                  const nodesToVisit = [];
                  for (const key of keys) {
                    const rawValue = dict.getRaw(key);
                    if (rawValue !== void 0) {
                      nodesToVisit.push(rawValue);
                    }
                  }
                  return this._walk(nodesToVisit);
                }
                async _walk(nodesToVisit) {
                  const nodesToRevisit = [];
                  const pendingRequests = [];
                  while (nodesToVisit.length) {
                    let currentNode = nodesToVisit.pop();
                    if (currentNode instanceof _primitives.Ref) {
                      if (this.refSet.has(currentNode)) {
                        continue;
                      }
                      try {
                        this.refSet.put(currentNode);
                        currentNode = this.xref.fetch(currentNode);
                      } catch (ex) {
                        if (!(ex instanceof _core_utils.MissingDataException)) {
                          (0, _util.warn)(`ObjectLoader._walk - requesting all data: "${ex}".`);
                          this.refSet = null;
                          const {
                            manager
                          } = this.xref.stream;
                          return manager.requestAllChunks();
                        }
                        nodesToRevisit.push(currentNode);
                        pendingRequests.push({
                          begin: ex.begin,
                          end: ex.end
                        });
                      }
                    }
                    if (currentNode instanceof _base_stream.BaseStream) {
                      const baseStreams = currentNode.getBaseStreams();
                      if (baseStreams) {
                        let foundMissingData = false;
                        for (const stream of baseStreams) {
                          if (stream.isDataLoaded) {
                            continue;
                          }
                          foundMissingData = true;
                          pendingRequests.push({
                            begin: stream.start,
                            end: stream.end
                          });
                        }
                        if (foundMissingData) {
                          nodesToRevisit.push(currentNode);
                        }
                      }
                    }
                    addChildren(currentNode, nodesToVisit);
                  }
                  if (pendingRequests.length) {
                    await this.xref.stream.manager.requestRanges(pendingRequests);
                    for (const node of nodesToRevisit) {
                      if (node instanceof _primitives.Ref) {
                        this.refSet.remove(node);
                      }
                    }
                    return this._walk(nodesToRevisit);
                  }
                  this.refSet = null;
                  return void 0;
                }
              }
              exports2.ObjectLoader = ObjectLoader;
            },
            /* 77 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XFAFactory = void 0;
              var _symbol_utils = __w_pdfjs_require__2(78);
              var _bind = __w_pdfjs_require__2(79);
              var _data = __w_pdfjs_require__2(89);
              var _fonts = __w_pdfjs_require__2(85);
              var _utils = __w_pdfjs_require__2(84);
              var _util = __w_pdfjs_require__2(2);
              var _parser = __w_pdfjs_require__2(90);
              var _xhtml = __w_pdfjs_require__2(100);
              class XFAFactory {
                constructor(data) {
                  try {
                    this.root = new _parser.XFAParser().parse(XFAFactory._createDocument(data));
                    const binder = new _bind.Binder(this.root);
                    this.form = binder.bind();
                    this.dataHandler = new _data.DataHandler(this.root, binder.getData());
                    this.form[_symbol_utils.$globalData].template = this.form;
                  } catch (e) {
                    (0, _util.warn)(`XFA - an error occurred during parsing and binding: ${e}`);
                  }
                }
                isValid() {
                  return this.root && this.form;
                }
                _createPagesHelper() {
                  const iterator = this.form[_symbol_utils.$toPages]();
                  return new Promise((resolve, reject) => {
                    const nextIteration = () => {
                      try {
                        const value = iterator.next();
                        if (value.done) {
                          resolve(value.value);
                        } else {
                          setTimeout(nextIteration, 0);
                        }
                      } catch (e) {
                        reject(e);
                      }
                    };
                    setTimeout(nextIteration, 0);
                  });
                }
                async _createPages() {
                  try {
                    this.pages = await this._createPagesHelper();
                    this.dims = this.pages.children.map((c) => {
                      const {
                        width,
                        height
                      } = c.attributes.style;
                      return [0, 0, parseInt(width), parseInt(height)];
                    });
                  } catch (e) {
                    (0, _util.warn)(`XFA - an error occurred during layout: ${e}`);
                  }
                }
                getBoundingBox(pageIndex) {
                  return this.dims[pageIndex];
                }
                async getNumPages() {
                  if (!this.pages) {
                    await this._createPages();
                  }
                  return this.dims.length;
                }
                setImages(images) {
                  this.form[_symbol_utils.$globalData].images = images;
                }
                setFonts(fonts) {
                  this.form[_symbol_utils.$globalData].fontFinder = new _fonts.FontFinder(fonts);
                  const missingFonts = [];
                  for (let typeface of this.form[_symbol_utils.$globalData].usedTypefaces) {
                    typeface = (0, _utils.stripQuotes)(typeface);
                    const font = this.form[_symbol_utils.$globalData].fontFinder.find(typeface);
                    if (!font) {
                      missingFonts.push(typeface);
                    }
                  }
                  if (missingFonts.length > 0) {
                    return missingFonts;
                  }
                  return null;
                }
                appendFonts(fonts, reallyMissingFonts) {
                  this.form[_symbol_utils.$globalData].fontFinder.add(fonts, reallyMissingFonts);
                }
                async getPages() {
                  if (!this.pages) {
                    await this._createPages();
                  }
                  const pages = this.pages;
                  this.pages = null;
                  return pages;
                }
                serializeData(storage) {
                  return this.dataHandler.serialize(storage);
                }
                static _createDocument(data) {
                  if (!data["/xdp:xdp"]) {
                    return data["xdp:xdp"];
                  }
                  return Object.values(data).join("");
                }
                static getRichTextAsHtml(rc) {
                  if (!rc || typeof rc !== "string") {
                    return null;
                  }
                  try {
                    let root = new _parser.XFAParser(_xhtml.XhtmlNamespace, true).parse(rc);
                    if (!["body", "xhtml"].includes(root[_symbol_utils.$nodeName])) {
                      const newRoot = _xhtml.XhtmlNamespace.body({});
                      newRoot[_symbol_utils.$appendChild](root);
                      root = newRoot;
                    }
                    const result = root[_symbol_utils.$toHTML]();
                    if (!result.success) {
                      return null;
                    }
                    const {
                      html
                    } = result;
                    const {
                      attributes
                    } = html;
                    if (attributes) {
                      if (attributes.class) {
                        attributes.class = attributes.class.filter((attr) => !attr.startsWith("xfa"));
                      }
                      attributes.dir = "auto";
                    }
                    return {
                      html,
                      str: root[_symbol_utils.$text]()
                    };
                  } catch (e) {
                    (0, _util.warn)(`XFA - an error occurred during parsing of rich text: ${e}`);
                  }
                  return null;
                }
              }
              exports2.XFAFactory = XFAFactory;
            },
            /* 78 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.$uid = exports2.$toStyle = exports2.$toString = exports2.$toPages = exports2.$toHTML = exports2.$text = exports2.$tabIndex = exports2.$setValue = exports2.$setSetAttributes = exports2.$setId = exports2.$searchNode = exports2.$root = exports2.$resolvePrototypes = exports2.$removeChild = exports2.$pushPara = exports2.$pushGlyphs = exports2.$popPara = exports2.$onText = exports2.$onChildCheck = exports2.$onChild = exports2.$nsAttributes = exports2.$nodeName = exports2.$namespaceId = exports2.$lastAttribute = exports2.$isUsable = exports2.$isTransparent = exports2.$isThereMoreWidth = exports2.$isSplittable = exports2.$isNsAgnostic = exports2.$isDescendent = exports2.$isDataValue = exports2.$isCDATAXml = exports2.$isBindable = exports2.$insertAt = exports2.$indexOf = exports2.$ids = exports2.$hasSettableValue = exports2.$globalData = exports2.$getTemplateRoot = exports2.$getSubformParent = exports2.$getRealChildrenByNameIt = exports2.$getParent = exports2.$getNextPage = exports2.$getExtra = exports2.$getDataValue = exports2.$getContainedChildren = exports2.$getChildrenByNameIt = exports2.$getChildrenByName = exports2.$getChildrenByClass = exports2.$getChildren = exports2.$getAvailableSpace = exports2.$getAttributes = exports2.$getAttributeIt = exports2.$flushHTML = exports2.$finalize = exports2.$extra = exports2.$dump = exports2.$data = exports2.$content = exports2.$consumed = exports2.$clone = exports2.$cleanup = exports2.$cleanPage = exports2.$clean = exports2.$childrenToHTML = exports2.$appendChild = exports2.$addHTML = exports2.$acceptWhitespace = void 0;
              const $acceptWhitespace = Symbol();
              exports2.$acceptWhitespace = $acceptWhitespace;
              const $addHTML = Symbol();
              exports2.$addHTML = $addHTML;
              const $appendChild = Symbol();
              exports2.$appendChild = $appendChild;
              const $childrenToHTML = Symbol();
              exports2.$childrenToHTML = $childrenToHTML;
              const $clean = Symbol();
              exports2.$clean = $clean;
              const $cleanPage = Symbol();
              exports2.$cleanPage = $cleanPage;
              const $cleanup = Symbol();
              exports2.$cleanup = $cleanup;
              const $clone = Symbol();
              exports2.$clone = $clone;
              const $consumed = Symbol();
              exports2.$consumed = $consumed;
              const $content = Symbol("content");
              exports2.$content = $content;
              const $data = Symbol("data");
              exports2.$data = $data;
              const $dump = Symbol();
              exports2.$dump = $dump;
              const $extra = Symbol("extra");
              exports2.$extra = $extra;
              const $finalize = Symbol();
              exports2.$finalize = $finalize;
              const $flushHTML = Symbol();
              exports2.$flushHTML = $flushHTML;
              const $getAttributeIt = Symbol();
              exports2.$getAttributeIt = $getAttributeIt;
              const $getAttributes = Symbol();
              exports2.$getAttributes = $getAttributes;
              const $getAvailableSpace = Symbol();
              exports2.$getAvailableSpace = $getAvailableSpace;
              const $getChildrenByClass = Symbol();
              exports2.$getChildrenByClass = $getChildrenByClass;
              const $getChildrenByName = Symbol();
              exports2.$getChildrenByName = $getChildrenByName;
              const $getChildrenByNameIt = Symbol();
              exports2.$getChildrenByNameIt = $getChildrenByNameIt;
              const $getDataValue = Symbol();
              exports2.$getDataValue = $getDataValue;
              const $getExtra = Symbol();
              exports2.$getExtra = $getExtra;
              const $getRealChildrenByNameIt = Symbol();
              exports2.$getRealChildrenByNameIt = $getRealChildrenByNameIt;
              const $getChildren = Symbol();
              exports2.$getChildren = $getChildren;
              const $getContainedChildren = Symbol();
              exports2.$getContainedChildren = $getContainedChildren;
              const $getNextPage = Symbol();
              exports2.$getNextPage = $getNextPage;
              const $getSubformParent = Symbol();
              exports2.$getSubformParent = $getSubformParent;
              const $getParent = Symbol();
              exports2.$getParent = $getParent;
              const $getTemplateRoot = Symbol();
              exports2.$getTemplateRoot = $getTemplateRoot;
              const $globalData = Symbol();
              exports2.$globalData = $globalData;
              const $hasSettableValue = Symbol();
              exports2.$hasSettableValue = $hasSettableValue;
              const $ids = Symbol();
              exports2.$ids = $ids;
              const $indexOf = Symbol();
              exports2.$indexOf = $indexOf;
              const $insertAt = Symbol();
              exports2.$insertAt = $insertAt;
              const $isCDATAXml = Symbol();
              exports2.$isCDATAXml = $isCDATAXml;
              const $isBindable = Symbol();
              exports2.$isBindable = $isBindable;
              const $isDataValue = Symbol();
              exports2.$isDataValue = $isDataValue;
              const $isDescendent = Symbol();
              exports2.$isDescendent = $isDescendent;
              const $isNsAgnostic = Symbol();
              exports2.$isNsAgnostic = $isNsAgnostic;
              const $isSplittable = Symbol();
              exports2.$isSplittable = $isSplittable;
              const $isThereMoreWidth = Symbol();
              exports2.$isThereMoreWidth = $isThereMoreWidth;
              const $isTransparent = Symbol();
              exports2.$isTransparent = $isTransparent;
              const $isUsable = Symbol();
              exports2.$isUsable = $isUsable;
              const $lastAttribute = Symbol();
              exports2.$lastAttribute = $lastAttribute;
              const $namespaceId = Symbol("namespaceId");
              exports2.$namespaceId = $namespaceId;
              const $nodeName = Symbol("nodeName");
              exports2.$nodeName = $nodeName;
              const $nsAttributes = Symbol();
              exports2.$nsAttributes = $nsAttributes;
              const $onChild = Symbol();
              exports2.$onChild = $onChild;
              const $onChildCheck = Symbol();
              exports2.$onChildCheck = $onChildCheck;
              const $onText = Symbol();
              exports2.$onText = $onText;
              const $pushGlyphs = Symbol();
              exports2.$pushGlyphs = $pushGlyphs;
              const $popPara = Symbol();
              exports2.$popPara = $popPara;
              const $pushPara = Symbol();
              exports2.$pushPara = $pushPara;
              const $removeChild = Symbol();
              exports2.$removeChild = $removeChild;
              const $root = Symbol("root");
              exports2.$root = $root;
              const $resolvePrototypes = Symbol();
              exports2.$resolvePrototypes = $resolvePrototypes;
              const $searchNode = Symbol();
              exports2.$searchNode = $searchNode;
              const $setId = Symbol();
              exports2.$setId = $setId;
              const $setSetAttributes = Symbol();
              exports2.$setSetAttributes = $setSetAttributes;
              const $setValue = Symbol();
              exports2.$setValue = $setValue;
              const $tabIndex = Symbol();
              exports2.$tabIndex = $tabIndex;
              const $text = Symbol();
              exports2.$text = $text;
              const $toPages = Symbol();
              exports2.$toPages = $toPages;
              const $toHTML = Symbol();
              exports2.$toHTML = $toHTML;
              const $toString = Symbol();
              exports2.$toString = $toString;
              const $toStyle = Symbol();
              exports2.$toStyle = $toStyle;
              const $uid = Symbol("uid");
              exports2.$uid = $uid;
            },
            /* 79 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Binder = void 0;
              var _symbol_utils = __w_pdfjs_require__2(78);
              var _template = __w_pdfjs_require__2(80);
              var _som = __w_pdfjs_require__2(88);
              var _xfa_object = __w_pdfjs_require__2(87);
              var _namespaces = __w_pdfjs_require__2(81);
              var _util = __w_pdfjs_require__2(2);
              const NS_DATASETS = _namespaces.NamespaceIds.datasets.id;
              function createText(content) {
                const node = new _template.Text({});
                node[_symbol_utils.$content] = content;
                return node;
              }
              class Binder {
                constructor(root) {
                  var _a;
                  this.root = root;
                  this.datasets = root.datasets;
                  this.data = ((_a = root.datasets) == null ? void 0 : _a.data) || new _xfa_object.XmlObject(_namespaces.NamespaceIds.datasets.id, "data");
                  this.emptyMerge = this.data[_symbol_utils.$getChildren]().length === 0;
                  this.root.form = this.form = root.template[_symbol_utils.$clone]();
                }
                _isConsumeData() {
                  return !this.emptyMerge && this._mergeMode;
                }
                _isMatchTemplate() {
                  return !this._isConsumeData();
                }
                bind() {
                  this._bindElement(this.form, this.data);
                  return this.form;
                }
                getData() {
                  return this.data;
                }
                _bindValue(formNode, data, picture) {
                  var _a, _b;
                  formNode[_symbol_utils.$data] = data;
                  if (formNode[_symbol_utils.$hasSettableValue]()) {
                    if (data[_symbol_utils.$isDataValue]()) {
                      const value = data[_symbol_utils.$getDataValue]();
                      formNode[_symbol_utils.$setValue](createText(value));
                    } else if (formNode instanceof _template.Field && ((_b = (_a = formNode.ui) == null ? void 0 : _a.choiceList) == null ? void 0 : _b.open) === "multiSelect") {
                      const value = data[_symbol_utils.$getChildren]().map((child) => child[_symbol_utils.$content].trim()).join("\n");
                      formNode[_symbol_utils.$setValue](createText(value));
                    } else if (this._isConsumeData()) {
                      (0, _util.warn)(`XFA - Nodes haven't the same type.`);
                    }
                  } else if (!data[_symbol_utils.$isDataValue]() || this._isMatchTemplate()) {
                    this._bindElement(formNode, data);
                  } else {
                    (0, _util.warn)(`XFA - Nodes haven't the same type.`);
                  }
                }
                _findDataByNameToConsume(name, isValue, dataNode, global) {
                  if (!name) {
                    return null;
                  }
                  let generator, match;
                  for (let i = 0; i < 3; i++) {
                    generator = dataNode[_symbol_utils.$getRealChildrenByNameIt](name, false, true);
                    while (true) {
                      match = generator.next().value;
                      if (!match) {
                        break;
                      }
                      if (isValue === match[_symbol_utils.$isDataValue]()) {
                        return match;
                      }
                    }
                    if (dataNode[_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.datasets.id && dataNode[_symbol_utils.$nodeName] === "data") {
                      break;
                    }
                    dataNode = dataNode[_symbol_utils.$getParent]();
                  }
                  if (!global) {
                    return null;
                  }
                  generator = this.data[_symbol_utils.$getRealChildrenByNameIt](name, true, false);
                  match = generator.next().value;
                  if (match) {
                    return match;
                  }
                  generator = this.data[_symbol_utils.$getAttributeIt](name, true);
                  match = generator.next().value;
                  if (match == null ? void 0 : match[_symbol_utils.$isDataValue]()) {
                    return match;
                  }
                  return null;
                }
                _setProperties(formNode, dataNode) {
                  if (!formNode.hasOwnProperty("setProperty")) {
                    return;
                  }
                  for (const {
                    ref,
                    target,
                    connection
                  } of formNode.setProperty.children) {
                    if (connection) {
                      continue;
                    }
                    if (!ref) {
                      continue;
                    }
                    const nodes = (0, _som.searchNode)(this.root, dataNode, ref, false, false);
                    if (!nodes) {
                      (0, _util.warn)(`XFA - Invalid reference: ${ref}.`);
                      continue;
                    }
                    const [node] = nodes;
                    if (!node[_symbol_utils.$isDescendent](this.data)) {
                      (0, _util.warn)(`XFA - Invalid node: must be a data node.`);
                      continue;
                    }
                    const targetNodes = (0, _som.searchNode)(this.root, formNode, target, false, false);
                    if (!targetNodes) {
                      (0, _util.warn)(`XFA - Invalid target: ${target}.`);
                      continue;
                    }
                    const [targetNode] = targetNodes;
                    if (!targetNode[_symbol_utils.$isDescendent](formNode)) {
                      (0, _util.warn)(`XFA - Invalid target: must be a property or subproperty.`);
                      continue;
                    }
                    const targetParent = targetNode[_symbol_utils.$getParent]();
                    if (targetNode instanceof _template.SetProperty || targetParent instanceof _template.SetProperty) {
                      (0, _util.warn)(`XFA - Invalid target: cannot be a setProperty or one of its properties.`);
                      continue;
                    }
                    if (targetNode instanceof _template.BindItems || targetParent instanceof _template.BindItems) {
                      (0, _util.warn)(`XFA - Invalid target: cannot be a bindItems or one of its properties.`);
                      continue;
                    }
                    const content = node[_symbol_utils.$text]();
                    const name = targetNode[_symbol_utils.$nodeName];
                    if (targetNode instanceof _xfa_object.XFAAttribute) {
                      const attrs = /* @__PURE__ */ Object.create(null);
                      attrs[name] = content;
                      const obj = Reflect.construct(Object.getPrototypeOf(targetParent).constructor, [attrs]);
                      targetParent[name] = obj[name];
                      continue;
                    }
                    if (!targetNode.hasOwnProperty(_symbol_utils.$content)) {
                      (0, _util.warn)(`XFA - Invalid node to use in setProperty`);
                      continue;
                    }
                    targetNode[_symbol_utils.$data] = node;
                    targetNode[_symbol_utils.$content] = content;
                    targetNode[_symbol_utils.$finalize]();
                  }
                }
                _bindItems(formNode, dataNode) {
                  if (!formNode.hasOwnProperty("items") || !formNode.hasOwnProperty("bindItems") || formNode.bindItems.isEmpty()) {
                    return;
                  }
                  for (const item of formNode.items.children) {
                    formNode[_symbol_utils.$removeChild](item);
                  }
                  formNode.items.clear();
                  const labels = new _template.Items({});
                  const values = new _template.Items({});
                  formNode[_symbol_utils.$appendChild](labels);
                  formNode.items.push(labels);
                  formNode[_symbol_utils.$appendChild](values);
                  formNode.items.push(values);
                  for (const {
                    ref,
                    labelRef,
                    valueRef,
                    connection
                  } of formNode.bindItems.children) {
                    if (connection) {
                      continue;
                    }
                    if (!ref) {
                      continue;
                    }
                    const nodes = (0, _som.searchNode)(this.root, dataNode, ref, false, false);
                    if (!nodes) {
                      (0, _util.warn)(`XFA - Invalid reference: ${ref}.`);
                      continue;
                    }
                    for (const node of nodes) {
                      if (!node[_symbol_utils.$isDescendent](this.datasets)) {
                        (0, _util.warn)(`XFA - Invalid ref (${ref}): must be a datasets child.`);
                        continue;
                      }
                      const labelNodes = (0, _som.searchNode)(this.root, node, labelRef, true, false);
                      if (!labelNodes) {
                        (0, _util.warn)(`XFA - Invalid label: ${labelRef}.`);
                        continue;
                      }
                      const [labelNode] = labelNodes;
                      if (!labelNode[_symbol_utils.$isDescendent](this.datasets)) {
                        (0, _util.warn)(`XFA - Invalid label: must be a datasets child.`);
                        continue;
                      }
                      const valueNodes = (0, _som.searchNode)(this.root, node, valueRef, true, false);
                      if (!valueNodes) {
                        (0, _util.warn)(`XFA - Invalid value: ${valueRef}.`);
                        continue;
                      }
                      const [valueNode] = valueNodes;
                      if (!valueNode[_symbol_utils.$isDescendent](this.datasets)) {
                        (0, _util.warn)(`XFA - Invalid value: must be a datasets child.`);
                        continue;
                      }
                      const label = createText(labelNode[_symbol_utils.$text]());
                      const value = createText(valueNode[_symbol_utils.$text]());
                      labels[_symbol_utils.$appendChild](label);
                      labels.text.push(label);
                      values[_symbol_utils.$appendChild](value);
                      values.text.push(value);
                    }
                  }
                }
                _bindOccurrences(formNode, matches, picture) {
                  let baseClone;
                  if (matches.length > 1) {
                    baseClone = formNode[_symbol_utils.$clone]();
                    baseClone[_symbol_utils.$removeChild](baseClone.occur);
                    baseClone.occur = null;
                  }
                  this._bindValue(formNode, matches[0], picture);
                  this._setProperties(formNode, matches[0]);
                  this._bindItems(formNode, matches[0]);
                  if (matches.length === 1) {
                    return;
                  }
                  const parent = formNode[_symbol_utils.$getParent]();
                  const name = formNode[_symbol_utils.$nodeName];
                  const pos = parent[_symbol_utils.$indexOf](formNode);
                  for (let i = 1, ii = matches.length; i < ii; i++) {
                    const match = matches[i];
                    const clone = baseClone[_symbol_utils.$clone]();
                    parent[name].push(clone);
                    parent[_symbol_utils.$insertAt](pos + i, clone);
                    this._bindValue(clone, match, picture);
                    this._setProperties(clone, match);
                    this._bindItems(clone, match);
                  }
                }
                _createOccurrences(formNode) {
                  if (!this.emptyMerge) {
                    return;
                  }
                  const {
                    occur
                  } = formNode;
                  if (!occur || occur.initial <= 1) {
                    return;
                  }
                  const parent = formNode[_symbol_utils.$getParent]();
                  const name = formNode[_symbol_utils.$nodeName];
                  if (!(parent[name] instanceof _xfa_object.XFAObjectArray)) {
                    return;
                  }
                  let currentNumber;
                  if (formNode.name) {
                    currentNumber = parent[name].children.filter((e) => e.name === formNode.name).length;
                  } else {
                    currentNumber = parent[name].children.length;
                  }
                  const pos = parent[_symbol_utils.$indexOf](formNode) + 1;
                  const ii = occur.initial - currentNumber;
                  if (ii) {
                    const nodeClone = formNode[_symbol_utils.$clone]();
                    nodeClone[_symbol_utils.$removeChild](nodeClone.occur);
                    nodeClone.occur = null;
                    parent[name].push(nodeClone);
                    parent[_symbol_utils.$insertAt](pos, nodeClone);
                    for (let i = 1; i < ii; i++) {
                      const clone = nodeClone[_symbol_utils.$clone]();
                      parent[name].push(clone);
                      parent[_symbol_utils.$insertAt](pos + i, clone);
                    }
                  }
                }
                _getOccurInfo(formNode) {
                  const {
                    name,
                    occur
                  } = formNode;
                  if (!occur || !name) {
                    return [1, 1];
                  }
                  const max = occur.max === -1 ? Infinity : occur.max;
                  return [occur.min, max];
                }
                _setAndBind(formNode, dataNode) {
                  this._setProperties(formNode, dataNode);
                  this._bindItems(formNode, dataNode);
                  this._bindElement(formNode, dataNode);
                }
                _bindElement(formNode, dataNode) {
                  const uselessNodes = [];
                  this._createOccurrences(formNode);
                  for (const child of formNode[_symbol_utils.$getChildren]()) {
                    if (child[_symbol_utils.$data]) {
                      continue;
                    }
                    if (this._mergeMode === void 0 && child[_symbol_utils.$nodeName] === "subform") {
                      this._mergeMode = child.mergeMode === "consumeData";
                      const dataChildren = dataNode[_symbol_utils.$getChildren]();
                      if (dataChildren.length > 0) {
                        this._bindOccurrences(child, [dataChildren[0]], null);
                      } else if (this.emptyMerge) {
                        const nsId = dataNode[_symbol_utils.$namespaceId] === NS_DATASETS ? -1 : dataNode[_symbol_utils.$namespaceId];
                        const dataChild = child[_symbol_utils.$data] = new _xfa_object.XmlObject(nsId, child.name || "root");
                        dataNode[_symbol_utils.$appendChild](dataChild);
                        this._bindElement(child, dataChild);
                      }
                      continue;
                    }
                    if (!child[_symbol_utils.$isBindable]()) {
                      continue;
                    }
                    let global = false;
                    let picture = null;
                    let ref = null;
                    let match = null;
                    if (child.bind) {
                      switch (child.bind.match) {
                        case "none":
                          this._setAndBind(child, dataNode);
                          continue;
                        case "global":
                          global = true;
                          break;
                        case "dataRef":
                          if (!child.bind.ref) {
                            (0, _util.warn)(`XFA - ref is empty in node ${child[_symbol_utils.$nodeName]}.`);
                            this._setAndBind(child, dataNode);
                            continue;
                          }
                          ref = child.bind.ref;
                          break;
                        default:
                          break;
                      }
                      if (child.bind.picture) {
                        picture = child.bind.picture[_symbol_utils.$content];
                      }
                    }
                    const [min, max] = this._getOccurInfo(child);
                    if (ref) {
                      match = (0, _som.searchNode)(this.root, dataNode, ref, true, false);
                      if (match === null) {
                        match = (0, _som.createDataNode)(this.data, dataNode, ref);
                        if (!match) {
                          continue;
                        }
                        if (this._isConsumeData()) {
                          match[_symbol_utils.$consumed] = true;
                        }
                        this._setAndBind(child, match);
                        continue;
                      } else {
                        if (this._isConsumeData()) {
                          match = match.filter((node) => !node[_symbol_utils.$consumed]);
                        }
                        if (match.length > max) {
                          match = match.slice(0, max);
                        } else if (match.length === 0) {
                          match = null;
                        }
                        if (match && this._isConsumeData()) {
                          match.forEach((node) => {
                            node[_symbol_utils.$consumed] = true;
                          });
                        }
                      }
                    } else {
                      if (!child.name) {
                        this._setAndBind(child, dataNode);
                        continue;
                      }
                      if (this._isConsumeData()) {
                        const matches = [];
                        while (matches.length < max) {
                          const found = this._findDataByNameToConsume(child.name, child[_symbol_utils.$hasSettableValue](), dataNode, global);
                          if (!found) {
                            break;
                          }
                          found[_symbol_utils.$consumed] = true;
                          matches.push(found);
                        }
                        match = matches.length > 0 ? matches : null;
                      } else {
                        match = dataNode[_symbol_utils.$getRealChildrenByNameIt](child.name, false, this.emptyMerge).next().value;
                        if (!match) {
                          if (min === 0) {
                            uselessNodes.push(child);
                            continue;
                          }
                          const nsId = dataNode[_symbol_utils.$namespaceId] === NS_DATASETS ? -1 : dataNode[_symbol_utils.$namespaceId];
                          match = child[_symbol_utils.$data] = new _xfa_object.XmlObject(nsId, child.name);
                          if (this.emptyMerge) {
                            match[_symbol_utils.$consumed] = true;
                          }
                          dataNode[_symbol_utils.$appendChild](match);
                          this._setAndBind(child, match);
                          continue;
                        }
                        if (this.emptyMerge) {
                          match[_symbol_utils.$consumed] = true;
                        }
                        match = [match];
                      }
                    }
                    if (match) {
                      this._bindOccurrences(child, match, picture);
                    } else if (min > 0) {
                      this._setAndBind(child, dataNode);
                    } else {
                      uselessNodes.push(child);
                    }
                  }
                  uselessNodes.forEach((node) => node[_symbol_utils.$getParent]()[_symbol_utils.$removeChild](node));
                }
              }
              exports2.Binder = Binder;
            },
            /* 80 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Value = exports2.Text = exports2.TemplateNamespace = exports2.Template = exports2.SetProperty = exports2.Items = exports2.Field = exports2.BindItems = void 0;
              var _symbol_utils = __w_pdfjs_require__2(78);
              var _namespaces = __w_pdfjs_require__2(81);
              var _layout = __w_pdfjs_require__2(82);
              var _html_utils = __w_pdfjs_require__2(83);
              var _xfa_object = __w_pdfjs_require__2(87);
              var _utils = __w_pdfjs_require__2(84);
              var _util = __w_pdfjs_require__2(2);
              var _fonts = __w_pdfjs_require__2(85);
              var _core_utils = __w_pdfjs_require__2(3);
              var _som = __w_pdfjs_require__2(88);
              const TEMPLATE_NS_ID = _namespaces.NamespaceIds.template.id;
              const SVG_NS = "http://www.w3.org/2000/svg";
              const MAX_ATTEMPTS_FOR_LRTB_LAYOUT = 2;
              const MAX_EMPTY_PAGES = 3;
              const DEFAULT_TAB_INDEX = 5e3;
              const HEADING_PATTERN = /^H(\d+)$/;
              const MIMES = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]);
              const IMAGES_HEADERS = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
              function getBorderDims(node) {
                if (!node || !node.border) {
                  return {
                    w: 0,
                    h: 0
                  };
                }
                const borderExtra = node.border[_symbol_utils.$getExtra]();
                if (!borderExtra) {
                  return {
                    w: 0,
                    h: 0
                  };
                }
                return {
                  w: borderExtra.widths[0] + borderExtra.widths[2] + borderExtra.insets[0] + borderExtra.insets[2],
                  h: borderExtra.widths[1] + borderExtra.widths[3] + borderExtra.insets[1] + borderExtra.insets[3]
                };
              }
              function hasMargin(node) {
                return node.margin && (node.margin.topInset || node.margin.rightInset || node.margin.bottomInset || node.margin.leftInset);
              }
              function _setValue(templateNode, value) {
                if (!templateNode.value) {
                  const nodeValue = new Value({});
                  templateNode[_symbol_utils.$appendChild](nodeValue);
                  templateNode.value = nodeValue;
                }
                templateNode.value[_symbol_utils.$setValue](value);
              }
              function* getContainedChildren(node) {
                for (const child of node[_symbol_utils.$getChildren]()) {
                  if (child instanceof SubformSet) {
                    yield* child[_symbol_utils.$getContainedChildren]();
                    continue;
                  }
                  yield child;
                }
              }
              function isRequired(node) {
                var _a;
                return ((_a = node.validate) == null ? void 0 : _a.nullTest) === "error";
              }
              function setTabIndex(node) {
                while (node) {
                  if (!node.traversal) {
                    node[_symbol_utils.$tabIndex] = node[_symbol_utils.$getParent]()[_symbol_utils.$tabIndex];
                    return;
                  }
                  if (node[_symbol_utils.$tabIndex]) {
                    return;
                  }
                  let next = null;
                  for (const child of node.traversal[_symbol_utils.$getChildren]()) {
                    if (child.operation === "next") {
                      next = child;
                      break;
                    }
                  }
                  if (!next || !next.ref) {
                    node[_symbol_utils.$tabIndex] = node[_symbol_utils.$getParent]()[_symbol_utils.$tabIndex];
                    return;
                  }
                  const root = node[_symbol_utils.$getTemplateRoot]();
                  node[_symbol_utils.$tabIndex] = ++root[_symbol_utils.$tabIndex];
                  const ref = root[_symbol_utils.$searchNode](next.ref, node);
                  if (!ref) {
                    return;
                  }
                  node = ref[0];
                }
              }
              function applyAssist(obj, attributes) {
                var _a;
                const assist = obj.assist;
                if (assist) {
                  const assistTitle = assist[_symbol_utils.$toHTML]();
                  if (assistTitle) {
                    attributes.title = assistTitle;
                  }
                  const role = assist.role;
                  const match = role.match(HEADING_PATTERN);
                  if (match) {
                    const ariaRole = "heading";
                    const ariaLevel = match[1];
                    attributes.role = ariaRole;
                    attributes["aria-level"] = ariaLevel;
                  }
                }
                if (obj.layout === "table") {
                  attributes.role = "table";
                } else if (obj.layout === "row") {
                  attributes.role = "row";
                } else {
                  const parent = obj[_symbol_utils.$getParent]();
                  if (parent.layout === "row") {
                    attributes.role = ((_a = parent.assist) == null ? void 0 : _a.role) === "TH" ? "columnheader" : "cell";
                  }
                }
              }
              function ariaLabel(obj) {
                if (!obj.assist) {
                  return null;
                }
                const assist = obj.assist;
                if (assist.speak && assist.speak[_symbol_utils.$content] !== "") {
                  return assist.speak[_symbol_utils.$content];
                }
                if (assist.toolTip) {
                  return assist.toolTip[_symbol_utils.$content];
                }
                return null;
              }
              function valueToHtml(value) {
                return _utils.HTMLResult.success({
                  name: "div",
                  attributes: {
                    class: ["xfaRich"],
                    style: /* @__PURE__ */ Object.create(null)
                  },
                  children: [{
                    name: "span",
                    attributes: {
                      style: /* @__PURE__ */ Object.create(null)
                    },
                    value
                  }]
                });
              }
              function setFirstUnsplittable(node) {
                const root = node[_symbol_utils.$getTemplateRoot]();
                if (root[_symbol_utils.$extra].firstUnsplittable === null) {
                  root[_symbol_utils.$extra].firstUnsplittable = node;
                  root[_symbol_utils.$extra].noLayoutFailure = true;
                }
              }
              function unsetFirstUnsplittable(node) {
                const root = node[_symbol_utils.$getTemplateRoot]();
                if (root[_symbol_utils.$extra].firstUnsplittable === node) {
                  root[_symbol_utils.$extra].noLayoutFailure = false;
                }
              }
              function handleBreak(node) {
                if (node[_symbol_utils.$extra]) {
                  return false;
                }
                node[_symbol_utils.$extra] = /* @__PURE__ */ Object.create(null);
                if (node.targetType === "auto") {
                  return false;
                }
                const root = node[_symbol_utils.$getTemplateRoot]();
                let target = null;
                if (node.target) {
                  target = root[_symbol_utils.$searchNode](node.target, node[_symbol_utils.$getParent]());
                  if (!target) {
                    return false;
                  }
                  target = target[0];
                }
                const {
                  currentPageArea,
                  currentContentArea
                } = root[_symbol_utils.$extra];
                if (node.targetType === "pageArea") {
                  if (!(target instanceof PageArea)) {
                    target = null;
                  }
                  if (node.startNew) {
                    node[_symbol_utils.$extra].target = target || currentPageArea;
                    return true;
                  } else if (target && target !== currentPageArea) {
                    node[_symbol_utils.$extra].target = target;
                    return true;
                  }
                  return false;
                }
                if (!(target instanceof ContentArea)) {
                  target = null;
                }
                const pageArea = target && target[_symbol_utils.$getParent]();
                let index;
                let nextPageArea = pageArea;
                if (node.startNew) {
                  if (target) {
                    const contentAreas = pageArea.contentArea.children;
                    const indexForCurrent = contentAreas.indexOf(currentContentArea);
                    const indexForTarget = contentAreas.indexOf(target);
                    if (indexForCurrent !== -1 && indexForCurrent < indexForTarget) {
                      nextPageArea = null;
                    }
                    index = indexForTarget - 1;
                  } else {
                    index = currentPageArea.contentArea.children.indexOf(currentContentArea);
                  }
                } else if (target && target !== currentContentArea) {
                  const contentAreas = pageArea.contentArea.children;
                  index = contentAreas.indexOf(target) - 1;
                  nextPageArea = pageArea === currentPageArea ? null : pageArea;
                } else {
                  return false;
                }
                node[_symbol_utils.$extra].target = nextPageArea;
                node[_symbol_utils.$extra].index = index;
                return true;
              }
              function handleOverflow(node, extraNode, space) {
                const root = node[_symbol_utils.$getTemplateRoot]();
                const saved = root[_symbol_utils.$extra].noLayoutFailure;
                const savedMethod = extraNode[_symbol_utils.$getSubformParent];
                extraNode[_symbol_utils.$getSubformParent] = () => node;
                root[_symbol_utils.$extra].noLayoutFailure = true;
                const res = extraNode[_symbol_utils.$toHTML](space);
                node[_symbol_utils.$addHTML](res.html, res.bbox);
                root[_symbol_utils.$extra].noLayoutFailure = saved;
                extraNode[_symbol_utils.$getSubformParent] = savedMethod;
              }
              class AppearanceFilter extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "appearanceFilter");
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class Arc extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "arc", true);
                  this.circular = (0, _utils.getInteger)({
                    data: attributes.circular,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
                  this.id = attributes.id || "";
                  this.startAngle = (0, _utils.getFloat)({
                    data: attributes.startAngle,
                    defaultValue: 0,
                    validate: (x) => true
                  });
                  this.sweepAngle = (0, _utils.getFloat)({
                    data: attributes.sweepAngle,
                    defaultValue: 360,
                    validate: (x) => true
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.edge = null;
                  this.fill = null;
                }
                [_symbol_utils.$toHTML]() {
                  var _a;
                  const edge = this.edge || new Edge({});
                  const edgeStyle = edge[_symbol_utils.$toStyle]();
                  const style = /* @__PURE__ */ Object.create(null);
                  if (((_a = this.fill) == null ? void 0 : _a.presence) === "visible") {
                    Object.assign(style, this.fill[_symbol_utils.$toStyle]());
                  } else {
                    style.fill = "transparent";
                  }
                  style.strokeWidth = (0, _html_utils.measureToString)(edge.presence === "visible" ? edge.thickness : 0);
                  style.stroke = edgeStyle.color;
                  let arc;
                  const attributes = {
                    xmlns: SVG_NS,
                    style: {
                      width: "100%",
                      height: "100%",
                      overflow: "visible"
                    }
                  };
                  if (this.sweepAngle === 360) {
                    arc = {
                      name: "ellipse",
                      attributes: {
                        xmlns: SVG_NS,
                        cx: "50%",
                        cy: "50%",
                        rx: "50%",
                        ry: "50%",
                        style
                      }
                    };
                  } else {
                    const startAngle = this.startAngle * Math.PI / 180;
                    const sweepAngle = this.sweepAngle * Math.PI / 180;
                    const largeArc = this.sweepAngle > 180 ? 1 : 0;
                    const [x1, y1, x2, y2] = [50 * (1 + Math.cos(startAngle)), 50 * (1 - Math.sin(startAngle)), 50 * (1 + Math.cos(startAngle + sweepAngle)), 50 * (1 - Math.sin(startAngle + sweepAngle))];
                    arc = {
                      name: "path",
                      attributes: {
                        xmlns: SVG_NS,
                        d: `M ${x1} ${y1} A 50 50 0 ${largeArc} 0 ${x2} ${y2}`,
                        vectorEffect: "non-scaling-stroke",
                        style
                      }
                    };
                    Object.assign(attributes, {
                      viewBox: "0 0 100 100",
                      preserveAspectRatio: "none"
                    });
                  }
                  const svg = {
                    name: "svg",
                    children: [arc],
                    attributes
                  };
                  const parent = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
                  if (hasMargin(parent)) {
                    return _utils.HTMLResult.success({
                      name: "div",
                      attributes: {
                        style: {
                          display: "inline",
                          width: "100%",
                          height: "100%"
                        }
                      },
                      children: [svg]
                    });
                  }
                  svg.attributes.style.position = "absolute";
                  return _utils.HTMLResult.success(svg);
                }
              }
              class Area extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "area", true);
                  this.colSpan = (0, _utils.getInteger)({
                    data: attributes.colSpan,
                    defaultValue: 1,
                    validate: (n) => n >= 1 || n === -1
                  });
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
                  this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
                  this.desc = null;
                  this.extras = null;
                  this.area = new _xfa_object.XFAObjectArray();
                  this.draw = new _xfa_object.XFAObjectArray();
                  this.exObject = new _xfa_object.XFAObjectArray();
                  this.exclGroup = new _xfa_object.XFAObjectArray();
                  this.field = new _xfa_object.XFAObjectArray();
                  this.subform = new _xfa_object.XFAObjectArray();
                  this.subformSet = new _xfa_object.XFAObjectArray();
                }
                *[_symbol_utils.$getContainedChildren]() {
                  yield* getContainedChildren(this);
                }
                [_symbol_utils.$isTransparent]() {
                  return true;
                }
                [_symbol_utils.$isBindable]() {
                  return true;
                }
                [_symbol_utils.$addHTML](html, bbox) {
                  const [x, y, w, h] = bbox;
                  this[_symbol_utils.$extra].width = Math.max(this[_symbol_utils.$extra].width, x + w);
                  this[_symbol_utils.$extra].height = Math.max(this[_symbol_utils.$extra].height, y + h);
                  this[_symbol_utils.$extra].children.push(html);
                }
                [_symbol_utils.$getAvailableSpace]() {
                  return this[_symbol_utils.$extra].availableSpace;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  const style = (0, _html_utils.toStyle)(this, "position");
                  const attributes = {
                    style,
                    id: this[_symbol_utils.$uid],
                    class: ["xfaArea"]
                  };
                  if ((0, _html_utils.isPrintOnly)(this)) {
                    attributes.class.push("xfaPrintOnly");
                  }
                  if (this.name) {
                    attributes.xfaName = this.name;
                  }
                  const children = [];
                  this[_symbol_utils.$extra] = {
                    children,
                    width: 0,
                    height: 0,
                    availableSpace
                  };
                  const result = this[_symbol_utils.$childrenToHTML]({
                    filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]),
                    include: true
                  });
                  if (!result.success) {
                    if (result.isBreak()) {
                      return result;
                    }
                    delete this[_symbol_utils.$extra];
                    return _utils.HTMLResult.FAILURE;
                  }
                  style.width = (0, _html_utils.measureToString)(this[_symbol_utils.$extra].width);
                  style.height = (0, _html_utils.measureToString)(this[_symbol_utils.$extra].height);
                  const html = {
                    name: "div",
                    attributes,
                    children
                  };
                  const bbox = [this.x, this.y, this[_symbol_utils.$extra].width, this[_symbol_utils.$extra].height];
                  delete this[_symbol_utils.$extra];
                  return _utils.HTMLResult.success(html, bbox);
                }
              }
              class Assist extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "assist", true);
                  this.id = attributes.id || "";
                  this.role = attributes.role || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.speak = null;
                  this.toolTip = null;
                }
                [_symbol_utils.$toHTML]() {
                  var _a;
                  return ((_a = this.toolTip) == null ? void 0 : _a[_symbol_utils.$content]) || null;
                }
              }
              class Barcode extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "barcode", true);
                  this.charEncoding = (0, _utils.getKeyword)({
                    data: attributes.charEncoding ? attributes.charEncoding.toLowerCase() : "",
                    defaultValue: "",
                    validate: (k) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(k) || k.match(/iso-8859-\d{2}/)
                  });
                  this.checksum = (0, _utils.getStringOption)(attributes.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]);
                  this.dataColumnCount = (0, _utils.getInteger)({
                    data: attributes.dataColumnCount,
                    defaultValue: -1,
                    validate: (x) => x >= 0
                  });
                  this.dataLength = (0, _utils.getInteger)({
                    data: attributes.dataLength,
                    defaultValue: -1,
                    validate: (x) => x >= 0
                  });
                  this.dataPrep = (0, _utils.getStringOption)(attributes.dataPrep, ["none", "flateCompress"]);
                  this.dataRowCount = (0, _utils.getInteger)({
                    data: attributes.dataRowCount,
                    defaultValue: -1,
                    validate: (x) => x >= 0
                  });
                  this.endChar = attributes.endChar || "";
                  this.errorCorrectionLevel = (0, _utils.getInteger)({
                    data: attributes.errorCorrectionLevel,
                    defaultValue: -1,
                    validate: (x) => x >= 0 && x <= 8
                  });
                  this.id = attributes.id || "";
                  this.moduleHeight = (0, _utils.getMeasurement)(attributes.moduleHeight, "5mm");
                  this.moduleWidth = (0, _utils.getMeasurement)(attributes.moduleWidth, "0.25mm");
                  this.printCheckDigit = (0, _utils.getInteger)({
                    data: attributes.printCheckDigit,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.rowColumnRatio = (0, _utils.getRatio)(attributes.rowColumnRatio);
                  this.startChar = attributes.startChar || "";
                  this.textLocation = (0, _utils.getStringOption)(attributes.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]);
                  this.truncate = (0, _utils.getInteger)({
                    data: attributes.truncate,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.type = (0, _utils.getStringOption)(attributes.type ? attributes.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]);
                  this.upsMode = (0, _utils.getStringOption)(attributes.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.wideNarrowRatio = (0, _utils.getRatio)(attributes.wideNarrowRatio);
                  this.encrypt = null;
                  this.extras = null;
                }
              }
              class Bind extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "bind", true);
                  this.match = (0, _utils.getStringOption)(attributes.match, ["once", "dataRef", "global", "none"]);
                  this.ref = attributes.ref || "";
                  this.picture = null;
                }
              }
              class BindItems extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "bindItems");
                  this.connection = attributes.connection || "";
                  this.labelRef = attributes.labelRef || "";
                  this.ref = attributes.ref || "";
                  this.valueRef = attributes.valueRef || "";
                }
              }
              exports2.BindItems = BindItems;
              class Bookend extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "bookend");
                  this.id = attributes.id || "";
                  this.leader = attributes.leader || "";
                  this.trailer = attributes.trailer || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class BooleanElement extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "boolean");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  return valueToHtml(this[_symbol_utils.$content] === 1 ? "1" : "0");
                }
              }
              class Border extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "border", true);
                  this.break = (0, _utils.getStringOption)(attributes.break, ["close", "open"]);
                  this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
                  this.id = attributes.id || "";
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.corner = new _xfa_object.XFAObjectArray(4);
                  this.edge = new _xfa_object.XFAObjectArray(4);
                  this.extras = null;
                  this.fill = null;
                  this.margin = null;
                }
                [_symbol_utils.$getExtra]() {
                  if (!this[_symbol_utils.$extra]) {
                    const edges = this.edge.children.slice();
                    if (edges.length < 4) {
                      const defaultEdge = edges.at(-1) || new Edge({});
                      for (let i = edges.length; i < 4; i++) {
                        edges.push(defaultEdge);
                      }
                    }
                    const widths = edges.map((edge) => edge.thickness);
                    const insets = [0, 0, 0, 0];
                    if (this.margin) {
                      insets[0] = this.margin.topInset;
                      insets[1] = this.margin.rightInset;
                      insets[2] = this.margin.bottomInset;
                      insets[3] = this.margin.leftInset;
                    }
                    this[_symbol_utils.$extra] = {
                      widths,
                      insets,
                      edges
                    };
                  }
                  return this[_symbol_utils.$extra];
                }
                [_symbol_utils.$toStyle]() {
                  var _a;
                  const {
                    edges
                  } = this[_symbol_utils.$getExtra]();
                  const edgeStyles = edges.map((node) => {
                    const style2 = node[_symbol_utils.$toStyle]();
                    style2.color || (style2.color = "#000000");
                    return style2;
                  });
                  const style = /* @__PURE__ */ Object.create(null);
                  if (this.margin) {
                    Object.assign(style, this.margin[_symbol_utils.$toStyle]());
                  }
                  if (((_a = this.fill) == null ? void 0 : _a.presence) === "visible") {
                    Object.assign(style, this.fill[_symbol_utils.$toStyle]());
                  }
                  if (this.corner.children.some((node) => node.radius !== 0)) {
                    const cornerStyles = this.corner.children.map((node) => node[_symbol_utils.$toStyle]());
                    if (cornerStyles.length === 2 || cornerStyles.length === 3) {
                      const last = cornerStyles.at(-1);
                      for (let i = cornerStyles.length; i < 4; i++) {
                        cornerStyles.push(last);
                      }
                    }
                    style.borderRadius = cornerStyles.map((s) => s.radius).join(" ");
                  }
                  switch (this.presence) {
                    case "invisible":
                    case "hidden":
                      style.borderStyle = "";
                      break;
                    case "inactive":
                      style.borderStyle = "none";
                      break;
                    default:
                      style.borderStyle = edgeStyles.map((s) => s.style).join(" ");
                      break;
                  }
                  style.borderWidth = edgeStyles.map((s) => s.width).join(" ");
                  style.borderColor = edgeStyles.map((s) => s.color).join(" ");
                  return style;
                }
              }
              class Break extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "break", true);
                  this.after = (0, _utils.getStringOption)(attributes.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
                  this.afterTarget = attributes.afterTarget || "";
                  this.before = (0, _utils.getStringOption)(attributes.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
                  this.beforeTarget = attributes.beforeTarget || "";
                  this.bookendLeader = attributes.bookendLeader || "";
                  this.bookendTrailer = attributes.bookendTrailer || "";
                  this.id = attributes.id || "";
                  this.overflowLeader = attributes.overflowLeader || "";
                  this.overflowTarget = attributes.overflowTarget || "";
                  this.overflowTrailer = attributes.overflowTrailer || "";
                  this.startNew = (0, _utils.getInteger)({
                    data: attributes.startNew,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                }
              }
              class BreakAfter extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "breakAfter", true);
                  this.id = attributes.id || "";
                  this.leader = attributes.leader || "";
                  this.startNew = (0, _utils.getInteger)({
                    data: attributes.startNew,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.target = attributes.target || "";
                  this.targetType = (0, _utils.getStringOption)(attributes.targetType, ["auto", "contentArea", "pageArea"]);
                  this.trailer = attributes.trailer || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.script = null;
                }
              }
              class BreakBefore extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "breakBefore", true);
                  this.id = attributes.id || "";
                  this.leader = attributes.leader || "";
                  this.startNew = (0, _utils.getInteger)({
                    data: attributes.startNew,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.target = attributes.target || "";
                  this.targetType = (0, _utils.getStringOption)(attributes.targetType, ["auto", "contentArea", "pageArea"]);
                  this.trailer = attributes.trailer || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.script = null;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  this[_symbol_utils.$extra] = {};
                  return _utils.HTMLResult.FAILURE;
                }
              }
              class Button extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "button", true);
                  this.highlight = (0, _utils.getStringOption)(attributes.highlight, ["inverted", "none", "outline", "push"]);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  const parent = this[_symbol_utils.$getParent]();
                  const grandpa = parent[_symbol_utils.$getParent]();
                  const htmlButton = {
                    name: "button",
                    attributes: {
                      id: this[_symbol_utils.$uid],
                      class: ["xfaButton"],
                      style: {}
                    },
                    children: []
                  };
                  for (const event of grandpa.event.children) {
                    if (event.activity !== "click" || !event.script) {
                      continue;
                    }
                    const jsURL = (0, _core_utils.recoverJsURL)(event.script[_symbol_utils.$content]);
                    if (!jsURL) {
                      continue;
                    }
                    const href = (0, _html_utils.fixURL)(jsURL.url);
                    if (!href) {
                      continue;
                    }
                    htmlButton.children.push({
                      name: "a",
                      attributes: {
                        id: "link" + this[_symbol_utils.$uid],
                        href,
                        newWindow: jsURL.newWindow,
                        class: ["xfaLink"],
                        style: {}
                      },
                      children: []
                    });
                  }
                  return _utils.HTMLResult.success(htmlButton);
                }
              }
              class Calculate extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "calculate", true);
                  this.id = attributes.id || "";
                  this.override = (0, _utils.getStringOption)(attributes.override, ["disabled", "error", "ignore", "warning"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.message = null;
                  this.script = null;
                }
              }
              class Caption extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "caption", true);
                  this.id = attributes.id || "";
                  this.placement = (0, _utils.getStringOption)(attributes.placement, ["left", "bottom", "inline", "right", "top"]);
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.reserve = Math.ceil((0, _utils.getMeasurement)(attributes.reserve));
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.font = null;
                  this.margin = null;
                  this.para = null;
                  this.value = null;
                }
                [_symbol_utils.$setValue](value) {
                  _setValue(this, value);
                }
                [_symbol_utils.$getExtra](availableSpace) {
                  if (!this[_symbol_utils.$extra]) {
                    let {
                      width,
                      height
                    } = availableSpace;
                    switch (this.placement) {
                      case "left":
                      case "right":
                      case "inline":
                        width = this.reserve <= 0 ? width : this.reserve;
                        break;
                      case "top":
                      case "bottom":
                        height = this.reserve <= 0 ? height : this.reserve;
                        break;
                    }
                    this[_symbol_utils.$extra] = (0, _html_utils.layoutNode)(this, {
                      width,
                      height
                    });
                  }
                  return this[_symbol_utils.$extra];
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  if (!this.value) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  this[_symbol_utils.$pushPara]();
                  const value = this.value[_symbol_utils.$toHTML](availableSpace).html;
                  if (!value) {
                    this[_symbol_utils.$popPara]();
                    return _utils.HTMLResult.EMPTY;
                  }
                  const savedReserve = this.reserve;
                  if (this.reserve <= 0) {
                    const {
                      w,
                      h
                    } = this[_symbol_utils.$getExtra](availableSpace);
                    switch (this.placement) {
                      case "left":
                      case "right":
                      case "inline":
                        this.reserve = w;
                        break;
                      case "top":
                      case "bottom":
                        this.reserve = h;
                        break;
                    }
                  }
                  const children = [];
                  if (typeof value === "string") {
                    children.push({
                      name: "#text",
                      value
                    });
                  } else {
                    children.push(value);
                  }
                  const style = (0, _html_utils.toStyle)(this, "font", "margin", "visibility");
                  switch (this.placement) {
                    case "left":
                    case "right":
                      if (this.reserve > 0) {
                        style.width = (0, _html_utils.measureToString)(this.reserve);
                      }
                      break;
                    case "top":
                    case "bottom":
                      if (this.reserve > 0) {
                        style.height = (0, _html_utils.measureToString)(this.reserve);
                      }
                      break;
                  }
                  (0, _html_utils.setPara)(this, null, value);
                  this[_symbol_utils.$popPara]();
                  this.reserve = savedReserve;
                  return _utils.HTMLResult.success({
                    name: "div",
                    attributes: {
                      style,
                      class: ["xfaCaption"]
                    },
                    children
                  });
                }
              }
              class Certificate extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "certificate");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class Certificates extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "certificates", true);
                  this.credentialServerPolicy = (0, _utils.getStringOption)(attributes.credentialServerPolicy, ["optional", "required"]);
                  this.id = attributes.id || "";
                  this.url = attributes.url || "";
                  this.urlPolicy = attributes.urlPolicy || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.encryption = null;
                  this.issuers = null;
                  this.keyUsage = null;
                  this.oids = null;
                  this.signing = null;
                  this.subjectDNs = null;
                }
              }
              class CheckButton extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "checkButton", true);
                  this.id = attributes.id || "";
                  this.mark = (0, _utils.getStringOption)(attributes.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]);
                  this.shape = (0, _utils.getStringOption)(attributes.shape, ["square", "round"]);
                  this.size = (0, _utils.getMeasurement)(attributes.size, "10pt");
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.border = null;
                  this.extras = null;
                  this.margin = null;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  var _a, _b, _c;
                  const style = (0, _html_utils.toStyle)("margin");
                  const size = (0, _html_utils.measureToString)(this.size);
                  style.width = style.height = size;
                  let type;
                  let className;
                  let groupId;
                  const field = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
                  const items = field.items.children.length && field.items.children[0][_symbol_utils.$toHTML]().html || [];
                  const exportedValue = {
                    on: (items[0] !== void 0 ? items[0] : "on").toString(),
                    off: (items[1] !== void 0 ? items[1] : "off").toString()
                  };
                  const value = ((_a = field.value) == null ? void 0 : _a[_symbol_utils.$text]()) || "off";
                  const checked = value === exportedValue.on || void 0;
                  const container = field[_symbol_utils.$getSubformParent]();
                  const fieldId = field[_symbol_utils.$uid];
                  let dataId;
                  if (container instanceof ExclGroup) {
                    groupId = container[_symbol_utils.$uid];
                    type = "radio";
                    className = "xfaRadio";
                    dataId = ((_b = container[_symbol_utils.$data]) == null ? void 0 : _b[_symbol_utils.$uid]) || container[_symbol_utils.$uid];
                  } else {
                    type = "checkbox";
                    className = "xfaCheckbox";
                    dataId = ((_c = field[_symbol_utils.$data]) == null ? void 0 : _c[_symbol_utils.$uid]) || field[_symbol_utils.$uid];
                  }
                  const input = {
                    name: "input",
                    attributes: {
                      class: [className],
                      style,
                      fieldId,
                      dataId,
                      type,
                      checked,
                      xfaOn: exportedValue.on,
                      xfaOff: exportedValue.off,
                      "aria-label": ariaLabel(field),
                      "aria-required": false
                    }
                  };
                  if (groupId) {
                    input.attributes.name = groupId;
                  }
                  if (isRequired(field)) {
                    input.attributes["aria-required"] = true;
                    input.attributes.required = true;
                  }
                  return _utils.HTMLResult.success({
                    name: "label",
                    attributes: {
                      class: ["xfaLabel"]
                    },
                    children: [input]
                  });
                }
              }
              class ChoiceList extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "choiceList", true);
                  this.commitOn = (0, _utils.getStringOption)(attributes.commitOn, ["select", "exit"]);
                  this.id = attributes.id || "";
                  this.open = (0, _utils.getStringOption)(attributes.open, ["userControl", "always", "multiSelect", "onEntry"]);
                  this.textEntry = (0, _utils.getInteger)({
                    data: attributes.textEntry,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.border = null;
                  this.extras = null;
                  this.margin = null;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  var _a, _b, _c;
                  const style = (0, _html_utils.toStyle)(this, "border", "margin");
                  const ui = this[_symbol_utils.$getParent]();
                  const field = ui[_symbol_utils.$getParent]();
                  const fontSize = ((_a = field.font) == null ? void 0 : _a.size) || 10;
                  const optionStyle = {
                    fontSize: `calc(${fontSize}px * var(--scale-factor))`
                  };
                  const children = [];
                  if (field.items.children.length > 0) {
                    const items = field.items;
                    let displayedIndex = 0;
                    let saveIndex = 0;
                    if (items.children.length === 2) {
                      displayedIndex = items.children[0].save;
                      saveIndex = 1 - displayedIndex;
                    }
                    const displayed = items.children[displayedIndex][_symbol_utils.$toHTML]().html;
                    const values = items.children[saveIndex][_symbol_utils.$toHTML]().html;
                    let selected = false;
                    const value = ((_b = field.value) == null ? void 0 : _b[_symbol_utils.$text]()) || "";
                    for (let i = 0, ii = displayed.length; i < ii; i++) {
                      const option = {
                        name: "option",
                        attributes: {
                          value: values[i] || displayed[i],
                          style: optionStyle
                        },
                        value: displayed[i]
                      };
                      if (values[i] === value) {
                        option.attributes.selected = selected = true;
                      }
                      children.push(option);
                    }
                    if (!selected) {
                      children.splice(0, 0, {
                        name: "option",
                        attributes: {
                          hidden: true,
                          selected: true
                        },
                        value: " "
                      });
                    }
                  }
                  const selectAttributes = {
                    class: ["xfaSelect"],
                    fieldId: field[_symbol_utils.$uid],
                    dataId: ((_c = field[_symbol_utils.$data]) == null ? void 0 : _c[_symbol_utils.$uid]) || field[_symbol_utils.$uid],
                    style,
                    "aria-label": ariaLabel(field),
                    "aria-required": false
                  };
                  if (isRequired(field)) {
                    selectAttributes["aria-required"] = true;
                    selectAttributes.required = true;
                  }
                  if (this.open === "multiSelect") {
                    selectAttributes.multiple = true;
                  }
                  return _utils.HTMLResult.success({
                    name: "label",
                    attributes: {
                      class: ["xfaLabel"]
                    },
                    children: [{
                      name: "select",
                      children,
                      attributes: selectAttributes
                    }]
                  });
                }
              }
              class Color extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "color", true);
                  this.cSpace = (0, _utils.getStringOption)(attributes.cSpace, ["SRGB"]);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.value = attributes.value ? (0, _utils.getColor)(attributes.value) : "";
                  this.extras = null;
                }
                [_symbol_utils.$hasSettableValue]() {
                  return false;
                }
                [_symbol_utils.$toStyle]() {
                  return this.value ? _util.Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
                }
              }
              class Comb extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "comb");
                  this.id = attributes.id || "";
                  this.numberOfCells = (0, _utils.getInteger)({
                    data: attributes.numberOfCells,
                    defaultValue: 0,
                    validate: (x) => x >= 0
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class Connect extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "connect", true);
                  this.connection = attributes.connection || "";
                  this.id = attributes.id || "";
                  this.ref = attributes.ref || "";
                  this.usage = (0, _utils.getStringOption)(attributes.usage, ["exportAndImport", "exportOnly", "importOnly"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.picture = null;
                }
              }
              class ContentArea extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "contentArea", true);
                  this.h = (0, _utils.getMeasurement)(attributes.h);
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.w = (0, _utils.getMeasurement)(attributes.w);
                  this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
                  this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
                  this.desc = null;
                  this.extras = null;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  const left = (0, _html_utils.measureToString)(this.x);
                  const top = (0, _html_utils.measureToString)(this.y);
                  const style = {
                    left,
                    top,
                    width: (0, _html_utils.measureToString)(this.w),
                    height: (0, _html_utils.measureToString)(this.h)
                  };
                  const classNames = ["xfaContentarea"];
                  if ((0, _html_utils.isPrintOnly)(this)) {
                    classNames.push("xfaPrintOnly");
                  }
                  return _utils.HTMLResult.success({
                    name: "div",
                    children: [],
                    attributes: {
                      style,
                      class: classNames,
                      id: this[_symbol_utils.$uid]
                    }
                  });
                }
              }
              class Corner extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "corner", true);
                  this.id = attributes.id || "";
                  this.inverted = (0, _utils.getInteger)({
                    data: attributes.inverted,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.join = (0, _utils.getStringOption)(attributes.join, ["square", "round"]);
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.radius = (0, _utils.getMeasurement)(attributes.radius);
                  this.stroke = (0, _utils.getStringOption)(attributes.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
                  this.thickness = (0, _utils.getMeasurement)(attributes.thickness, "0.5pt");
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.color = null;
                  this.extras = null;
                }
                [_symbol_utils.$toStyle]() {
                  const style = (0, _html_utils.toStyle)(this, "visibility");
                  style.radius = (0, _html_utils.measureToString)(this.join === "square" ? 0 : this.radius);
                  return style;
                }
              }
              class DateElement extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "date");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_symbol_utils.$finalize]() {
                  const date = this[_symbol_utils.$content].trim();
                  this[_symbol_utils.$content] = date ? new Date(date) : null;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  return valueToHtml(this[_symbol_utils.$content] ? this[_symbol_utils.$content].toString() : "");
                }
              }
              class DateTime extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "dateTime");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_symbol_utils.$finalize]() {
                  const date = this[_symbol_utils.$content].trim();
                  this[_symbol_utils.$content] = date ? new Date(date) : null;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  return valueToHtml(this[_symbol_utils.$content] ? this[_symbol_utils.$content].toString() : "");
                }
              }
              class DateTimeEdit extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "dateTimeEdit", true);
                  this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
                  this.id = attributes.id || "";
                  this.picker = (0, _utils.getStringOption)(attributes.picker, ["host", "none"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.border = null;
                  this.comb = null;
                  this.extras = null;
                  this.margin = null;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  var _a;
                  const style = (0, _html_utils.toStyle)(this, "border", "font", "margin");
                  const field = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
                  const html = {
                    name: "input",
                    attributes: {
                      type: "text",
                      fieldId: field[_symbol_utils.$uid],
                      dataId: ((_a = field[_symbol_utils.$data]) == null ? void 0 : _a[_symbol_utils.$uid]) || field[_symbol_utils.$uid],
                      class: ["xfaTextfield"],
                      style,
                      "aria-label": ariaLabel(field),
                      "aria-required": false
                    }
                  };
                  if (isRequired(field)) {
                    html.attributes["aria-required"] = true;
                    html.attributes.required = true;
                  }
                  return _utils.HTMLResult.success({
                    name: "label",
                    attributes: {
                      class: ["xfaLabel"]
                    },
                    children: [html]
                  });
                }
              }
              class Decimal extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "decimal");
                  this.fracDigits = (0, _utils.getInteger)({
                    data: attributes.fracDigits,
                    defaultValue: 2,
                    validate: (x) => true
                  });
                  this.id = attributes.id || "";
                  this.leadDigits = (0, _utils.getInteger)({
                    data: attributes.leadDigits,
                    defaultValue: -1,
                    validate: (x) => true
                  });
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_symbol_utils.$finalize]() {
                  const number = parseFloat(this[_symbol_utils.$content].trim());
                  this[_symbol_utils.$content] = isNaN(number) ? null : number;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  return valueToHtml(this[_symbol_utils.$content] !== null ? this[_symbol_utils.$content].toString() : "");
                }
              }
              class DefaultUi extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "defaultUi", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                }
              }
              class Desc extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "desc", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.boolean = new _xfa_object.XFAObjectArray();
                  this.date = new _xfa_object.XFAObjectArray();
                  this.dateTime = new _xfa_object.XFAObjectArray();
                  this.decimal = new _xfa_object.XFAObjectArray();
                  this.exData = new _xfa_object.XFAObjectArray();
                  this.float = new _xfa_object.XFAObjectArray();
                  this.image = new _xfa_object.XFAObjectArray();
                  this.integer = new _xfa_object.XFAObjectArray();
                  this.text = new _xfa_object.XFAObjectArray();
                  this.time = new _xfa_object.XFAObjectArray();
                }
              }
              class DigestMethod extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class DigestMethods extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "digestMethods", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.digestMethod = new _xfa_object.XFAObjectArray();
                }
              }
              class Draw extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "draw", true);
                  this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
                  this.colSpan = (0, _utils.getInteger)({
                    data: attributes.colSpan,
                    defaultValue: 1,
                    validate: (n) => n >= 1 || n === -1
                  });
                  this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
                  this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
                  this.id = attributes.id || "";
                  this.locale = attributes.locale || "";
                  this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
                  this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
                  this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
                  this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
                  this.name = attributes.name || "";
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.rotate = (0, _utils.getInteger)({
                    data: attributes.rotate,
                    defaultValue: 0,
                    validate: (x) => x % 90 === 0
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
                  this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
                  this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
                  this.assist = null;
                  this.border = null;
                  this.caption = null;
                  this.desc = null;
                  this.extras = null;
                  this.font = null;
                  this.keep = null;
                  this.margin = null;
                  this.para = null;
                  this.traversal = null;
                  this.ui = null;
                  this.value = null;
                  this.setProperty = new _xfa_object.XFAObjectArray();
                }
                [_symbol_utils.$setValue](value) {
                  _setValue(this, value);
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  setTabIndex(this);
                  if (this.presence === "hidden" || this.presence === "inactive") {
                    return _utils.HTMLResult.EMPTY;
                  }
                  (0, _html_utils.fixDimensions)(this);
                  this[_symbol_utils.$pushPara]();
                  const savedW = this.w;
                  const savedH = this.h;
                  const {
                    w,
                    h,
                    isBroken
                  } = (0, _html_utils.layoutNode)(this, availableSpace);
                  if (w && this.w === "") {
                    if (isBroken && this[_symbol_utils.$getSubformParent]()[_symbol_utils.$isThereMoreWidth]()) {
                      this[_symbol_utils.$popPara]();
                      return _utils.HTMLResult.FAILURE;
                    }
                    this.w = w;
                  }
                  if (h && this.h === "") {
                    this.h = h;
                  }
                  setFirstUnsplittable(this);
                  if (!(0, _layout.checkDimensions)(this, availableSpace)) {
                    this.w = savedW;
                    this.h = savedH;
                    this[_symbol_utils.$popPara]();
                    return _utils.HTMLResult.FAILURE;
                  }
                  unsetFirstUnsplittable(this);
                  const style = (0, _html_utils.toStyle)(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
                  (0, _html_utils.setMinMaxDimensions)(this, style);
                  if (style.margin) {
                    style.padding = style.margin;
                    delete style.margin;
                  }
                  const classNames = ["xfaDraw"];
                  if (this.font) {
                    classNames.push("xfaFont");
                  }
                  if ((0, _html_utils.isPrintOnly)(this)) {
                    classNames.push("xfaPrintOnly");
                  }
                  const attributes = {
                    style,
                    id: this[_symbol_utils.$uid],
                    class: classNames
                  };
                  if (this.name) {
                    attributes.xfaName = this.name;
                  }
                  const html = {
                    name: "div",
                    attributes,
                    children: []
                  };
                  applyAssist(this, attributes);
                  const bbox = (0, _html_utils.computeBbox)(this, html, availableSpace);
                  const value = this.value ? this.value[_symbol_utils.$toHTML](availableSpace).html : null;
                  if (value === null) {
                    this.w = savedW;
                    this.h = savedH;
                    this[_symbol_utils.$popPara]();
                    return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
                  }
                  html.children.push(value);
                  (0, _html_utils.setPara)(this, style, value);
                  this.w = savedW;
                  this.h = savedH;
                  this[_symbol_utils.$popPara]();
                  return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
                }
              }
              class Edge extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "edge", true);
                  this.cap = (0, _utils.getStringOption)(attributes.cap, ["square", "butt", "round"]);
                  this.id = attributes.id || "";
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.stroke = (0, _utils.getStringOption)(attributes.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
                  this.thickness = (0, _utils.getMeasurement)(attributes.thickness, "0.5pt");
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.color = null;
                  this.extras = null;
                }
                [_symbol_utils.$toStyle]() {
                  const style = (0, _html_utils.toStyle)(this, "visibility");
                  Object.assign(style, {
                    linecap: this.cap,
                    width: (0, _html_utils.measureToString)(this.thickness),
                    color: this.color ? this.color[_symbol_utils.$toStyle]() : "#000000",
                    style: ""
                  });
                  if (this.presence !== "visible") {
                    style.style = "none";
                  } else {
                    switch (this.stroke) {
                      case "solid":
                        style.style = "solid";
                        break;
                      case "dashDot":
                        style.style = "dashed";
                        break;
                      case "dashDotDot":
                        style.style = "dashed";
                        break;
                      case "dashed":
                        style.style = "dashed";
                        break;
                      case "dotted":
                        style.style = "dotted";
                        break;
                      case "embossed":
                        style.style = "ridge";
                        break;
                      case "etched":
                        style.style = "groove";
                        break;
                      case "lowered":
                        style.style = "inset";
                        break;
                      case "raised":
                        style.style = "outset";
                        break;
                    }
                  }
                  return style;
                }
              }
              class Encoding extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class Encodings extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "encodings", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.encoding = new _xfa_object.XFAObjectArray();
                }
              }
              class Encrypt extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "encrypt", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.certificate = null;
                }
              }
              class EncryptData extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "encryptData", true);
                  this.id = attributes.id || "";
                  this.operation = (0, _utils.getStringOption)(attributes.operation, ["encrypt", "decrypt"]);
                  this.target = attributes.target || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.filter = null;
                  this.manifest = null;
                }
              }
              class Encryption extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "encryption", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.certificate = new _xfa_object.XFAObjectArray();
                }
              }
              class EncryptionMethod extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class EncryptionMethods extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "encryptionMethods", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.encryptionMethod = new _xfa_object.XFAObjectArray();
                }
              }
              class Event extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "event", true);
                  this.activity = (0, _utils.getStringOption)(attributes.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]);
                  this.id = attributes.id || "";
                  this.listen = (0, _utils.getStringOption)(attributes.listen, ["refOnly", "refAndDescendents"]);
                  this.name = attributes.name || "";
                  this.ref = attributes.ref || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.encryptData = null;
                  this.execute = null;
                  this.script = null;
                  this.signData = null;
                  this.submit = null;
                }
              }
              class ExData extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "exData");
                  this.contentType = attributes.contentType || "";
                  this.href = attributes.href || "";
                  this.id = attributes.id || "";
                  this.maxLength = (0, _utils.getInteger)({
                    data: attributes.maxLength,
                    defaultValue: -1,
                    validate: (x) => x >= -1
                  });
                  this.name = attributes.name || "";
                  this.rid = attributes.rid || "";
                  this.transferEncoding = (0, _utils.getStringOption)(attributes.transferEncoding, ["none", "base64", "package"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_symbol_utils.$isCDATAXml]() {
                  return this.contentType === "text/html";
                }
                [_symbol_utils.$onChild](child) {
                  if (this.contentType === "text/html" && child[_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.xhtml.id) {
                    this[_symbol_utils.$content] = child;
                    return true;
                  }
                  if (this.contentType === "text/xml") {
                    this[_symbol_utils.$content] = child;
                    return true;
                  }
                  return false;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  if (this.contentType !== "text/html" || !this[_symbol_utils.$content]) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  return this[_symbol_utils.$content][_symbol_utils.$toHTML](availableSpace);
                }
              }
              class ExObject extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "exObject", true);
                  this.archive = attributes.archive || "";
                  this.classId = attributes.classId || "";
                  this.codeBase = attributes.codeBase || "";
                  this.codeType = attributes.codeType || "";
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.boolean = new _xfa_object.XFAObjectArray();
                  this.date = new _xfa_object.XFAObjectArray();
                  this.dateTime = new _xfa_object.XFAObjectArray();
                  this.decimal = new _xfa_object.XFAObjectArray();
                  this.exData = new _xfa_object.XFAObjectArray();
                  this.exObject = new _xfa_object.XFAObjectArray();
                  this.float = new _xfa_object.XFAObjectArray();
                  this.image = new _xfa_object.XFAObjectArray();
                  this.integer = new _xfa_object.XFAObjectArray();
                  this.text = new _xfa_object.XFAObjectArray();
                  this.time = new _xfa_object.XFAObjectArray();
                }
              }
              class ExclGroup extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "exclGroup", true);
                  this.access = (0, _utils.getStringOption)(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
                  this.accessKey = attributes.accessKey || "";
                  this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
                  this.colSpan = (0, _utils.getInteger)({
                    data: attributes.colSpan,
                    defaultValue: 1,
                    validate: (n) => n >= 1 || n === -1
                  });
                  this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
                  this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
                  this.id = attributes.id || "";
                  this.layout = (0, _utils.getStringOption)(attributes.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
                  this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
                  this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
                  this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
                  this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
                  this.name = attributes.name || "";
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
                  this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
                  this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
                  this.assist = null;
                  this.bind = null;
                  this.border = null;
                  this.calculate = null;
                  this.caption = null;
                  this.desc = null;
                  this.extras = null;
                  this.margin = null;
                  this.para = null;
                  this.traversal = null;
                  this.validate = null;
                  this.connect = new _xfa_object.XFAObjectArray();
                  this.event = new _xfa_object.XFAObjectArray();
                  this.field = new _xfa_object.XFAObjectArray();
                  this.setProperty = new _xfa_object.XFAObjectArray();
                }
                [_symbol_utils.$isBindable]() {
                  return true;
                }
                [_symbol_utils.$hasSettableValue]() {
                  return true;
                }
                [_symbol_utils.$setValue](value) {
                  for (const field of this.field.children) {
                    if (!field.value) {
                      const nodeValue = new Value({});
                      field[_symbol_utils.$appendChild](nodeValue);
                      field.value = nodeValue;
                    }
                    field.value[_symbol_utils.$setValue](value);
                  }
                }
                [_symbol_utils.$isThereMoreWidth]() {
                  return this.layout.endsWith("-tb") && this[_symbol_utils.$extra].attempt === 0 && this[_symbol_utils.$extra].numberInLine > 0 || this[_symbol_utils.$getParent]()[_symbol_utils.$isThereMoreWidth]();
                }
                [_symbol_utils.$isSplittable]() {
                  var _a;
                  const parent = this[_symbol_utils.$getSubformParent]();
                  if (!parent[_symbol_utils.$isSplittable]()) {
                    return false;
                  }
                  if (this[_symbol_utils.$extra]._isSplittable !== void 0) {
                    return this[_symbol_utils.$extra]._isSplittable;
                  }
                  if (this.layout === "position" || this.layout.includes("row")) {
                    this[_symbol_utils.$extra]._isSplittable = false;
                    return false;
                  }
                  if (((_a = parent.layout) == null ? void 0 : _a.endsWith("-tb")) && parent[_symbol_utils.$extra].numberInLine !== 0) {
                    return false;
                  }
                  this[_symbol_utils.$extra]._isSplittable = true;
                  return true;
                }
                [_symbol_utils.$flushHTML]() {
                  return (0, _layout.flushHTML)(this);
                }
                [_symbol_utils.$addHTML](html, bbox) {
                  (0, _layout.addHTML)(this, html, bbox);
                }
                [_symbol_utils.$getAvailableSpace]() {
                  return (0, _layout.getAvailableSpace)(this);
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  setTabIndex(this);
                  if (this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  (0, _html_utils.fixDimensions)(this);
                  const children = [];
                  const attributes = {
                    id: this[_symbol_utils.$uid],
                    class: []
                  };
                  (0, _html_utils.setAccess)(this, attributes.class);
                  if (!this[_symbol_utils.$extra]) {
                    this[_symbol_utils.$extra] = /* @__PURE__ */ Object.create(null);
                  }
                  Object.assign(this[_symbol_utils.$extra], {
                    children,
                    attributes,
                    attempt: 0,
                    line: null,
                    numberInLine: 0,
                    availableSpace: {
                      width: Math.min(this.w || Infinity, availableSpace.width),
                      height: Math.min(this.h || Infinity, availableSpace.height)
                    },
                    width: 0,
                    height: 0,
                    prevHeight: 0,
                    currentWidth: 0
                  });
                  const isSplittable = this[_symbol_utils.$isSplittable]();
                  if (!isSplittable) {
                    setFirstUnsplittable(this);
                  }
                  if (!(0, _layout.checkDimensions)(this, availableSpace)) {
                    return _utils.HTMLResult.FAILURE;
                  }
                  const filter = /* @__PURE__ */ new Set(["field"]);
                  if (this.layout.includes("row")) {
                    const columnWidths = this[_symbol_utils.$getSubformParent]().columnWidths;
                    if (Array.isArray(columnWidths) && columnWidths.length > 0) {
                      this[_symbol_utils.$extra].columnWidths = columnWidths;
                      this[_symbol_utils.$extra].currentColumn = 0;
                    }
                  }
                  const style = (0, _html_utils.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign");
                  const classNames = ["xfaExclgroup"];
                  const cl = (0, _html_utils.layoutClass)(this);
                  if (cl) {
                    classNames.push(cl);
                  }
                  if ((0, _html_utils.isPrintOnly)(this)) {
                    classNames.push("xfaPrintOnly");
                  }
                  attributes.style = style;
                  attributes.class = classNames;
                  if (this.name) {
                    attributes.xfaName = this.name;
                  }
                  this[_symbol_utils.$pushPara]();
                  const isLrTb = this.layout === "lr-tb" || this.layout === "rl-tb";
                  const maxRun = isLrTb ? MAX_ATTEMPTS_FOR_LRTB_LAYOUT : 1;
                  for (; this[_symbol_utils.$extra].attempt < maxRun; this[_symbol_utils.$extra].attempt++) {
                    if (isLrTb && this[_symbol_utils.$extra].attempt === MAX_ATTEMPTS_FOR_LRTB_LAYOUT - 1) {
                      this[_symbol_utils.$extra].numberInLine = 0;
                    }
                    const result = this[_symbol_utils.$childrenToHTML]({
                      filter,
                      include: true
                    });
                    if (result.success) {
                      break;
                    }
                    if (result.isBreak()) {
                      this[_symbol_utils.$popPara]();
                      return result;
                    }
                    if (isLrTb && this[_symbol_utils.$extra].attempt === 0 && this[_symbol_utils.$extra].numberInLine === 0 && !this[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
                      this[_symbol_utils.$extra].attempt = maxRun;
                      break;
                    }
                  }
                  this[_symbol_utils.$popPara]();
                  if (!isSplittable) {
                    unsetFirstUnsplittable(this);
                  }
                  if (this[_symbol_utils.$extra].attempt === maxRun) {
                    if (!isSplittable) {
                      delete this[_symbol_utils.$extra];
                    }
                    return _utils.HTMLResult.FAILURE;
                  }
                  let marginH = 0;
                  let marginV = 0;
                  if (this.margin) {
                    marginH = this.margin.leftInset + this.margin.rightInset;
                    marginV = this.margin.topInset + this.margin.bottomInset;
                  }
                  const width = Math.max(this[_symbol_utils.$extra].width + marginH, this.w || 0);
                  const height = Math.max(this[_symbol_utils.$extra].height + marginV, this.h || 0);
                  const bbox = [this.x, this.y, width, height];
                  if (this.w === "") {
                    style.width = (0, _html_utils.measureToString)(width);
                  }
                  if (this.h === "") {
                    style.height = (0, _html_utils.measureToString)(height);
                  }
                  const html = {
                    name: "div",
                    attributes,
                    children
                  };
                  applyAssist(this, attributes);
                  delete this[_symbol_utils.$extra];
                  return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
                }
              }
              class Execute extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "execute");
                  this.connection = attributes.connection || "";
                  this.executeType = (0, _utils.getStringOption)(attributes.executeType, ["import", "remerge"]);
                  this.id = attributes.id || "";
                  this.runAt = (0, _utils.getStringOption)(attributes.runAt, ["client", "both", "server"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class Extras extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "extras", true);
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.boolean = new _xfa_object.XFAObjectArray();
                  this.date = new _xfa_object.XFAObjectArray();
                  this.dateTime = new _xfa_object.XFAObjectArray();
                  this.decimal = new _xfa_object.XFAObjectArray();
                  this.exData = new _xfa_object.XFAObjectArray();
                  this.extras = new _xfa_object.XFAObjectArray();
                  this.float = new _xfa_object.XFAObjectArray();
                  this.image = new _xfa_object.XFAObjectArray();
                  this.integer = new _xfa_object.XFAObjectArray();
                  this.text = new _xfa_object.XFAObjectArray();
                  this.time = new _xfa_object.XFAObjectArray();
                }
              }
              class Field extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "field", true);
                  this.access = (0, _utils.getStringOption)(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
                  this.accessKey = attributes.accessKey || "";
                  this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
                  this.colSpan = (0, _utils.getInteger)({
                    data: attributes.colSpan,
                    defaultValue: 1,
                    validate: (n) => n >= 1 || n === -1
                  });
                  this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
                  this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
                  this.id = attributes.id || "";
                  this.locale = attributes.locale || "";
                  this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
                  this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
                  this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
                  this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
                  this.name = attributes.name || "";
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.rotate = (0, _utils.getInteger)({
                    data: attributes.rotate,
                    defaultValue: 0,
                    validate: (x) => x % 90 === 0
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
                  this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
                  this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
                  this.assist = null;
                  this.bind = null;
                  this.border = null;
                  this.calculate = null;
                  this.caption = null;
                  this.desc = null;
                  this.extras = null;
                  this.font = null;
                  this.format = null;
                  this.items = new _xfa_object.XFAObjectArray(2);
                  this.keep = null;
                  this.margin = null;
                  this.para = null;
                  this.traversal = null;
                  this.ui = null;
                  this.validate = null;
                  this.value = null;
                  this.bindItems = new _xfa_object.XFAObjectArray();
                  this.connect = new _xfa_object.XFAObjectArray();
                  this.event = new _xfa_object.XFAObjectArray();
                  this.setProperty = new _xfa_object.XFAObjectArray();
                }
                [_symbol_utils.$isBindable]() {
                  return true;
                }
                [_symbol_utils.$setValue](value) {
                  _setValue(this, value);
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  var _a, _b, _c;
                  setTabIndex(this);
                  if (!this.ui) {
                    this.ui = new Ui({});
                    this.ui[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
                    this[_symbol_utils.$appendChild](this.ui);
                    let node;
                    switch (this.items.children.length) {
                      case 0:
                        node = new TextEdit({});
                        this.ui.textEdit = node;
                        break;
                      case 1:
                        node = new CheckButton({});
                        this.ui.checkButton = node;
                        break;
                      case 2:
                        node = new ChoiceList({});
                        this.ui.choiceList = node;
                        break;
                    }
                    this.ui[_symbol_utils.$appendChild](node);
                  }
                  if (!this.ui || this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  if (this.caption) {
                    delete this.caption[_symbol_utils.$extra];
                  }
                  this[_symbol_utils.$pushPara]();
                  const caption = this.caption ? this.caption[_symbol_utils.$toHTML](availableSpace).html : null;
                  const savedW = this.w;
                  const savedH = this.h;
                  let marginH = 0;
                  let marginV = 0;
                  if (this.margin) {
                    marginH = this.margin.leftInset + this.margin.rightInset;
                    marginV = this.margin.topInset + this.margin.bottomInset;
                  }
                  let borderDims = null;
                  if (this.w === "" || this.h === "") {
                    let width = null;
                    let height = null;
                    let uiW = 0;
                    let uiH = 0;
                    if (this.ui.checkButton) {
                      uiW = uiH = this.ui.checkButton.size;
                    } else {
                      const {
                        w,
                        h
                      } = (0, _html_utils.layoutNode)(this, availableSpace);
                      if (w !== null) {
                        uiW = w;
                        uiH = h;
                      } else {
                        uiH = (0, _fonts.getMetrics)(this.font, true).lineNoGap;
                      }
                    }
                    borderDims = getBorderDims(this.ui[_symbol_utils.$getExtra]());
                    uiW += borderDims.w;
                    uiH += borderDims.h;
                    if (this.caption) {
                      const {
                        w,
                        h,
                        isBroken
                      } = this.caption[_symbol_utils.$getExtra](availableSpace);
                      if (isBroken && this[_symbol_utils.$getSubformParent]()[_symbol_utils.$isThereMoreWidth]()) {
                        this[_symbol_utils.$popPara]();
                        return _utils.HTMLResult.FAILURE;
                      }
                      width = w;
                      height = h;
                      switch (this.caption.placement) {
                        case "left":
                        case "right":
                        case "inline":
                          width += uiW;
                          break;
                        case "top":
                        case "bottom":
                          height += uiH;
                          break;
                      }
                    } else {
                      width = uiW;
                      height = uiH;
                    }
                    if (width && this.w === "") {
                      width += marginH;
                      this.w = Math.min(this.maxW <= 0 ? Infinity : this.maxW, this.minW + 1 < width ? width : this.minW);
                    }
                    if (height && this.h === "") {
                      height += marginV;
                      this.h = Math.min(this.maxH <= 0 ? Infinity : this.maxH, this.minH + 1 < height ? height : this.minH);
                    }
                  }
                  this[_symbol_utils.$popPara]();
                  (0, _html_utils.fixDimensions)(this);
                  setFirstUnsplittable(this);
                  if (!(0, _layout.checkDimensions)(this, availableSpace)) {
                    this.w = savedW;
                    this.h = savedH;
                    this[_symbol_utils.$popPara]();
                    return _utils.HTMLResult.FAILURE;
                  }
                  unsetFirstUnsplittable(this);
                  const style = (0, _html_utils.toStyle)(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
                  (0, _html_utils.setMinMaxDimensions)(this, style);
                  const classNames = ["xfaField"];
                  if (this.font) {
                    classNames.push("xfaFont");
                  }
                  if ((0, _html_utils.isPrintOnly)(this)) {
                    classNames.push("xfaPrintOnly");
                  }
                  const attributes = {
                    style,
                    id: this[_symbol_utils.$uid],
                    class: classNames
                  };
                  if (style.margin) {
                    style.padding = style.margin;
                    delete style.margin;
                  }
                  (0, _html_utils.setAccess)(this, classNames);
                  if (this.name) {
                    attributes.xfaName = this.name;
                  }
                  const children = [];
                  const html = {
                    name: "div",
                    attributes,
                    children
                  };
                  applyAssist(this, attributes);
                  const borderStyle = this.border ? this.border[_symbol_utils.$toStyle]() : null;
                  const bbox = (0, _html_utils.computeBbox)(this, html, availableSpace);
                  const ui = this.ui[_symbol_utils.$toHTML]().html;
                  if (!ui) {
                    Object.assign(style, borderStyle);
                    return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
                  }
                  if (this[_symbol_utils.$tabIndex]) {
                    if ((_a = ui.children) == null ? void 0 : _a[0]) {
                      ui.children[0].attributes.tabindex = this[_symbol_utils.$tabIndex];
                    } else {
                      ui.attributes.tabindex = this[_symbol_utils.$tabIndex];
                    }
                  }
                  if (!ui.attributes.style) {
                    ui.attributes.style = /* @__PURE__ */ Object.create(null);
                  }
                  let aElement = null;
                  if (this.ui.button) {
                    if (ui.children.length === 1) {
                      [aElement] = ui.children.splice(0, 1);
                    }
                    Object.assign(ui.attributes.style, borderStyle);
                  } else {
                    Object.assign(style, borderStyle);
                  }
                  children.push(ui);
                  if (this.value) {
                    if (this.ui.imageEdit) {
                      ui.children.push(this.value[_symbol_utils.$toHTML]().html);
                    } else if (!this.ui.button) {
                      let value = "";
                      if (this.value.exData) {
                        value = this.value.exData[_symbol_utils.$text]();
                      } else if (this.value.text) {
                        value = this.value.text[_symbol_utils.$getExtra]();
                      } else {
                        const htmlValue = this.value[_symbol_utils.$toHTML]().html;
                        if (htmlValue !== null) {
                          value = htmlValue.children[0].value;
                        }
                      }
                      if (this.ui.textEdit && ((_b = this.value.text) == null ? void 0 : _b.maxChars)) {
                        ui.children[0].attributes.maxLength = this.value.text.maxChars;
                      }
                      if (value) {
                        if (this.ui.numericEdit) {
                          value = parseFloat(value);
                          value = isNaN(value) ? "" : value.toString();
                        }
                        if (ui.children[0].name === "textarea") {
                          ui.children[0].attributes.textContent = value;
                        } else {
                          ui.children[0].attributes.value = value;
                        }
                      }
                    }
                  }
                  if (!this.ui.imageEdit && ((_c = ui.children) == null ? void 0 : _c[0]) && this.h) {
                    borderDims = borderDims || getBorderDims(this.ui[_symbol_utils.$getExtra]());
                    let captionHeight = 0;
                    if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
                      captionHeight = this.caption.reserve;
                      if (captionHeight <= 0) {
                        captionHeight = this.caption[_symbol_utils.$getExtra](availableSpace).h;
                      }
                      const inputHeight = this.h - captionHeight - marginV - borderDims.h;
                      ui.children[0].attributes.style.height = (0, _html_utils.measureToString)(inputHeight);
                    } else {
                      ui.children[0].attributes.style.height = "100%";
                    }
                  }
                  if (aElement) {
                    ui.children.push(aElement);
                  }
                  if (!caption) {
                    if (ui.attributes.class) {
                      ui.attributes.class.push("xfaLeft");
                    }
                    this.w = savedW;
                    this.h = savedH;
                    return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
                  }
                  if (this.ui.button) {
                    if (style.padding) {
                      delete style.padding;
                    }
                    if (caption.name === "div") {
                      caption.name = "span";
                    }
                    ui.children.push(caption);
                    return _utils.HTMLResult.success(html, bbox);
                  } else if (this.ui.checkButton) {
                    caption.attributes.class[0] = "xfaCaptionForCheckButton";
                  }
                  if (!ui.attributes.class) {
                    ui.attributes.class = [];
                  }
                  ui.children.splice(0, 0, caption);
                  switch (this.caption.placement) {
                    case "left":
                      ui.attributes.class.push("xfaLeft");
                      break;
                    case "right":
                      ui.attributes.class.push("xfaRight");
                      break;
                    case "top":
                      ui.attributes.class.push("xfaTop");
                      break;
                    case "bottom":
                      ui.attributes.class.push("xfaBottom");
                      break;
                    case "inline":
                      ui.attributes.class.push("xfaLeft");
                      break;
                  }
                  this.w = savedW;
                  this.h = savedH;
                  return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
                }
              }
              exports2.Field = Field;
              class Fill extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "fill", true);
                  this.id = attributes.id || "";
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.color = null;
                  this.extras = null;
                  this.linear = null;
                  this.pattern = null;
                  this.radial = null;
                  this.solid = null;
                  this.stipple = null;
                }
                [_symbol_utils.$toStyle]() {
                  var _a;
                  const parent = this[_symbol_utils.$getParent]();
                  const grandpa = parent[_symbol_utils.$getParent]();
                  const ggrandpa = grandpa[_symbol_utils.$getParent]();
                  const style = /* @__PURE__ */ Object.create(null);
                  let propName = "color";
                  let altPropName = propName;
                  if (parent instanceof Border) {
                    propName = "background-color";
                    altPropName = "background";
                    if (ggrandpa instanceof Ui) {
                      style.backgroundColor = "white";
                    }
                  }
                  if (parent instanceof Rectangle || parent instanceof Arc) {
                    propName = altPropName = "fill";
                    style.fill = "white";
                  }
                  for (const name of Object.getOwnPropertyNames(this)) {
                    if (name === "extras" || name === "color") {
                      continue;
                    }
                    const obj = this[name];
                    if (!(obj instanceof _xfa_object.XFAObject)) {
                      continue;
                    }
                    const color = obj[_symbol_utils.$toStyle](this.color);
                    if (color) {
                      style[color.startsWith("#") ? propName : altPropName] = color;
                    }
                    return style;
                  }
                  if ((_a = this.color) == null ? void 0 : _a.value) {
                    const color = this.color[_symbol_utils.$toStyle]();
                    style[color.startsWith("#") ? propName : altPropName] = color;
                  }
                  return style;
                }
              }
              class Filter extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "filter", true);
                  this.addRevocationInfo = (0, _utils.getStringOption)(attributes.addRevocationInfo, ["", "required", "optional", "none"]);
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.version = (0, _utils.getInteger)({
                    data: this.version,
                    defaultValue: 5,
                    validate: (x) => x >= 1 && x <= 5
                  });
                  this.appearanceFilter = null;
                  this.certificates = null;
                  this.digestMethods = null;
                  this.encodings = null;
                  this.encryptionMethods = null;
                  this.handler = null;
                  this.lockDocument = null;
                  this.mdp = null;
                  this.reasons = null;
                  this.timeStamp = null;
                }
              }
              class Float extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "float");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_symbol_utils.$finalize]() {
                  const number = parseFloat(this[_symbol_utils.$content].trim());
                  this[_symbol_utils.$content] = isNaN(number) ? null : number;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  return valueToHtml(this[_symbol_utils.$content] !== null ? this[_symbol_utils.$content].toString() : "");
                }
              }
              class Font extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "font", true);
                  this.baselineShift = (0, _utils.getMeasurement)(attributes.baselineShift);
                  this.fontHorizontalScale = (0, _utils.getFloat)({
                    data: attributes.fontHorizontalScale,
                    defaultValue: 100,
                    validate: (x) => x >= 0
                  });
                  this.fontVerticalScale = (0, _utils.getFloat)({
                    data: attributes.fontVerticalScale,
                    defaultValue: 100,
                    validate: (x) => x >= 0
                  });
                  this.id = attributes.id || "";
                  this.kerningMode = (0, _utils.getStringOption)(attributes.kerningMode, ["none", "pair"]);
                  this.letterSpacing = (0, _utils.getMeasurement)(attributes.letterSpacing, "0");
                  this.lineThrough = (0, _utils.getInteger)({
                    data: attributes.lineThrough,
                    defaultValue: 0,
                    validate: (x) => x === 1 || x === 2
                  });
                  this.lineThroughPeriod = (0, _utils.getStringOption)(attributes.lineThroughPeriod, ["all", "word"]);
                  this.overline = (0, _utils.getInteger)({
                    data: attributes.overline,
                    defaultValue: 0,
                    validate: (x) => x === 1 || x === 2
                  });
                  this.overlinePeriod = (0, _utils.getStringOption)(attributes.overlinePeriod, ["all", "word"]);
                  this.posture = (0, _utils.getStringOption)(attributes.posture, ["normal", "italic"]);
                  this.size = (0, _utils.getMeasurement)(attributes.size, "10pt");
                  this.typeface = attributes.typeface || "Courier";
                  this.underline = (0, _utils.getInteger)({
                    data: attributes.underline,
                    defaultValue: 0,
                    validate: (x) => x === 1 || x === 2
                  });
                  this.underlinePeriod = (0, _utils.getStringOption)(attributes.underlinePeriod, ["all", "word"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.weight = (0, _utils.getStringOption)(attributes.weight, ["normal", "bold"]);
                  this.extras = null;
                  this.fill = null;
                }
                [_symbol_utils.$clean](builder) {
                  super[_symbol_utils.$clean](builder);
                  this[_symbol_utils.$globalData].usedTypefaces.add(this.typeface);
                }
                [_symbol_utils.$toStyle]() {
                  const style = (0, _html_utils.toStyle)(this, "fill");
                  const color = style.color;
                  if (color) {
                    if (color === "#000000") {
                      delete style.color;
                    } else if (!color.startsWith("#")) {
                      style.background = color;
                      style.backgroundClip = "text";
                      style.color = "transparent";
                    }
                  }
                  if (this.baselineShift) {
                    style.verticalAlign = (0, _html_utils.measureToString)(this.baselineShift);
                  }
                  style.fontKerning = this.kerningMode === "none" ? "none" : "normal";
                  style.letterSpacing = (0, _html_utils.measureToString)(this.letterSpacing);
                  if (this.lineThrough !== 0) {
                    style.textDecoration = "line-through";
                    if (this.lineThrough === 2) {
                      style.textDecorationStyle = "double";
                    }
                  }
                  if (this.overline !== 0) {
                    style.textDecoration = "overline";
                    if (this.overline === 2) {
                      style.textDecorationStyle = "double";
                    }
                  }
                  style.fontStyle = this.posture;
                  style.fontSize = (0, _html_utils.measureToString)(0.99 * this.size);
                  (0, _html_utils.setFontFamily)(this, this, this[_symbol_utils.$globalData].fontFinder, style);
                  if (this.underline !== 0) {
                    style.textDecoration = "underline";
                    if (this.underline === 2) {
                      style.textDecorationStyle = "double";
                    }
                  }
                  style.fontWeight = this.weight;
                  return style;
                }
              }
              class Format extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "format", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.picture = null;
                }
              }
              class Handler extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "handler");
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class Hyphenation extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "hyphenation");
                  this.excludeAllCaps = (0, _utils.getInteger)({
                    data: attributes.excludeAllCaps,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.excludeInitialCap = (0, _utils.getInteger)({
                    data: attributes.excludeInitialCap,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.hyphenate = (0, _utils.getInteger)({
                    data: attributes.hyphenate,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.id = attributes.id || "";
                  this.pushCharacterCount = (0, _utils.getInteger)({
                    data: attributes.pushCharacterCount,
                    defaultValue: 3,
                    validate: (x) => x >= 0
                  });
                  this.remainCharacterCount = (0, _utils.getInteger)({
                    data: attributes.remainCharacterCount,
                    defaultValue: 3,
                    validate: (x) => x >= 0
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.wordCharacterCount = (0, _utils.getInteger)({
                    data: attributes.wordCharacterCount,
                    defaultValue: 7,
                    validate: (x) => x >= 0
                  });
                }
              }
              class Image extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "image");
                  this.aspect = (0, _utils.getStringOption)(attributes.aspect, ["fit", "actual", "height", "none", "width"]);
                  this.contentType = attributes.contentType || "";
                  this.href = attributes.href || "";
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.transferEncoding = (0, _utils.getStringOption)(attributes.transferEncoding, ["base64", "none", "package"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_symbol_utils.$toHTML]() {
                  if (this.contentType && !MIMES.has(this.contentType.toLowerCase())) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  let buffer = this[_symbol_utils.$globalData].images && this[_symbol_utils.$globalData].images.get(this.href);
                  if (!buffer && (this.href || !this[_symbol_utils.$content])) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  if (!buffer && this.transferEncoding === "base64") {
                    buffer = (0, _util.stringToBytes)(atob(this[_symbol_utils.$content]));
                  }
                  if (!buffer) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  if (!this.contentType) {
                    for (const [header, type] of IMAGES_HEADERS) {
                      if (buffer.length > header.length && header.every((x, i) => x === buffer[i])) {
                        this.contentType = type;
                        break;
                      }
                    }
                    if (!this.contentType) {
                      return _utils.HTMLResult.EMPTY;
                    }
                  }
                  const blob = new Blob([buffer], {
                    type: this.contentType
                  });
                  let style;
                  switch (this.aspect) {
                    case "fit":
                    case "actual":
                      break;
                    case "height":
                      style = {
                        height: "100%",
                        objectFit: "fill"
                      };
                      break;
                    case "none":
                      style = {
                        width: "100%",
                        height: "100%",
                        objectFit: "fill"
                      };
                      break;
                    case "width":
                      style = {
                        width: "100%",
                        objectFit: "fill"
                      };
                      break;
                  }
                  const parent = this[_symbol_utils.$getParent]();
                  return _utils.HTMLResult.success({
                    name: "img",
                    attributes: {
                      class: ["xfaImage"],
                      style,
                      src: URL.createObjectURL(blob),
                      alt: parent ? ariaLabel(parent[_symbol_utils.$getParent]()) : null
                    }
                  });
                }
              }
              class ImageEdit extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "imageEdit", true);
                  this.data = (0, _utils.getStringOption)(attributes.data, ["link", "embed"]);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.border = null;
                  this.extras = null;
                  this.margin = null;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  if (this.data === "embed") {
                    return _utils.HTMLResult.success({
                      name: "div",
                      children: [],
                      attributes: {}
                    });
                  }
                  return _utils.HTMLResult.EMPTY;
                }
              }
              class Integer extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "integer");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_symbol_utils.$finalize]() {
                  const number = parseInt(this[_symbol_utils.$content].trim(), 10);
                  this[_symbol_utils.$content] = isNaN(number) ? null : number;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  return valueToHtml(this[_symbol_utils.$content] !== null ? this[_symbol_utils.$content].toString() : "");
                }
              }
              class Issuers extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "issuers", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.certificate = new _xfa_object.XFAObjectArray();
                }
              }
              class Items extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "items", true);
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.ref = attributes.ref || "";
                  this.save = (0, _utils.getInteger)({
                    data: attributes.save,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.boolean = new _xfa_object.XFAObjectArray();
                  this.date = new _xfa_object.XFAObjectArray();
                  this.dateTime = new _xfa_object.XFAObjectArray();
                  this.decimal = new _xfa_object.XFAObjectArray();
                  this.exData = new _xfa_object.XFAObjectArray();
                  this.float = new _xfa_object.XFAObjectArray();
                  this.image = new _xfa_object.XFAObjectArray();
                  this.integer = new _xfa_object.XFAObjectArray();
                  this.text = new _xfa_object.XFAObjectArray();
                  this.time = new _xfa_object.XFAObjectArray();
                }
                [_symbol_utils.$toHTML]() {
                  const output = [];
                  for (const child of this[_symbol_utils.$getChildren]()) {
                    output.push(child[_symbol_utils.$text]());
                  }
                  return _utils.HTMLResult.success(output);
                }
              }
              exports2.Items = Items;
              class Keep extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "keep", true);
                  this.id = attributes.id || "";
                  const options = ["none", "contentArea", "pageArea"];
                  this.intact = (0, _utils.getStringOption)(attributes.intact, options);
                  this.next = (0, _utils.getStringOption)(attributes.next, options);
                  this.previous = (0, _utils.getStringOption)(attributes.previous, options);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                }
              }
              class KeyUsage extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "keyUsage");
                  const options = ["", "yes", "no"];
                  this.crlSign = (0, _utils.getStringOption)(attributes.crlSign, options);
                  this.dataEncipherment = (0, _utils.getStringOption)(attributes.dataEncipherment, options);
                  this.decipherOnly = (0, _utils.getStringOption)(attributes.decipherOnly, options);
                  this.digitalSignature = (0, _utils.getStringOption)(attributes.digitalSignature, options);
                  this.encipherOnly = (0, _utils.getStringOption)(attributes.encipherOnly, options);
                  this.id = attributes.id || "";
                  this.keyAgreement = (0, _utils.getStringOption)(attributes.keyAgreement, options);
                  this.keyCertSign = (0, _utils.getStringOption)(attributes.keyCertSign, options);
                  this.keyEncipherment = (0, _utils.getStringOption)(attributes.keyEncipherment, options);
                  this.nonRepudiation = (0, _utils.getStringOption)(attributes.nonRepudiation, options);
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class Line extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "line", true);
                  this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
                  this.id = attributes.id || "";
                  this.slope = (0, _utils.getStringOption)(attributes.slope, ["\\", "/"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.edge = null;
                }
                [_symbol_utils.$toHTML]() {
                  const parent = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
                  const edge = this.edge || new Edge({});
                  const edgeStyle = edge[_symbol_utils.$toStyle]();
                  const style = /* @__PURE__ */ Object.create(null);
                  const thickness = edge.presence === "visible" ? edge.thickness : 0;
                  style.strokeWidth = (0, _html_utils.measureToString)(thickness);
                  style.stroke = edgeStyle.color;
                  let x1, y1, x2, y2;
                  let width = "100%";
                  let height = "100%";
                  if (parent.w <= thickness) {
                    [x1, y1, x2, y2] = ["50%", 0, "50%", "100%"];
                    width = style.strokeWidth;
                  } else if (parent.h <= thickness) {
                    [x1, y1, x2, y2] = [0, "50%", "100%", "50%"];
                    height = style.strokeWidth;
                  } else if (this.slope === "\\") {
                    [x1, y1, x2, y2] = [0, 0, "100%", "100%"];
                  } else {
                    [x1, y1, x2, y2] = [0, "100%", "100%", 0];
                  }
                  const line = {
                    name: "line",
                    attributes: {
                      xmlns: SVG_NS,
                      x1,
                      y1,
                      x2,
                      y2,
                      style
                    }
                  };
                  const svg = {
                    name: "svg",
                    children: [line],
                    attributes: {
                      xmlns: SVG_NS,
                      width,
                      height,
                      style: {
                        overflow: "visible"
                      }
                    }
                  };
                  if (hasMargin(parent)) {
                    return _utils.HTMLResult.success({
                      name: "div",
                      attributes: {
                        style: {
                          display: "inline",
                          width: "100%",
                          height: "100%"
                        }
                      },
                      children: [svg]
                    });
                  }
                  svg.attributes.style.position = "absolute";
                  return _utils.HTMLResult.success(svg);
                }
              }
              class Linear extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "linear", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["toRight", "toBottom", "toLeft", "toTop"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.color = null;
                  this.extras = null;
                }
                [_symbol_utils.$toStyle](startColor) {
                  startColor = startColor ? startColor[_symbol_utils.$toStyle]() : "#FFFFFF";
                  const transf = this.type.replace(/([RBLT])/, " $1").toLowerCase();
                  const endColor = this.color ? this.color[_symbol_utils.$toStyle]() : "#000000";
                  return `linear-gradient(${transf}, ${startColor}, ${endColor})`;
                }
              }
              class LockDocument extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "lockDocument");
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_symbol_utils.$finalize]() {
                  this[_symbol_utils.$content] = (0, _utils.getStringOption)(this[_symbol_utils.$content], ["auto", "0", "1"]);
                }
              }
              class Manifest extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "manifest", true);
                  this.action = (0, _utils.getStringOption)(attributes.action, ["include", "all", "exclude"]);
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.ref = new _xfa_object.XFAObjectArray();
                }
              }
              class Margin extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "margin", true);
                  this.bottomInset = (0, _utils.getMeasurement)(attributes.bottomInset, "0");
                  this.id = attributes.id || "";
                  this.leftInset = (0, _utils.getMeasurement)(attributes.leftInset, "0");
                  this.rightInset = (0, _utils.getMeasurement)(attributes.rightInset, "0");
                  this.topInset = (0, _utils.getMeasurement)(attributes.topInset, "0");
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                }
                [_symbol_utils.$toStyle]() {
                  return {
                    margin: (0, _html_utils.measureToString)(this.topInset) + " " + (0, _html_utils.measureToString)(this.rightInset) + " " + (0, _html_utils.measureToString)(this.bottomInset) + " " + (0, _html_utils.measureToString)(this.leftInset)
                  };
                }
              }
              class Mdp extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "mdp");
                  this.id = attributes.id || "";
                  this.permissions = (0, _utils.getInteger)({
                    data: attributes.permissions,
                    defaultValue: 2,
                    validate: (x) => x === 1 || x === 3
                  });
                  this.signatureType = (0, _utils.getStringOption)(attributes.signatureType, ["filler", "author"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class Medium extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "medium");
                  this.id = attributes.id || "";
                  this.imagingBBox = (0, _utils.getBBox)(attributes.imagingBBox);
                  this.long = (0, _utils.getMeasurement)(attributes.long);
                  this.orientation = (0, _utils.getStringOption)(attributes.orientation, ["portrait", "landscape"]);
                  this.short = (0, _utils.getMeasurement)(attributes.short);
                  this.stock = attributes.stock || "";
                  this.trayIn = (0, _utils.getStringOption)(attributes.trayIn, ["auto", "delegate", "pageFront"]);
                  this.trayOut = (0, _utils.getStringOption)(attributes.trayOut, ["auto", "delegate"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class Message extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "message", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.text = new _xfa_object.XFAObjectArray();
                }
              }
              class NumericEdit extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "numericEdit", true);
                  this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.border = null;
                  this.comb = null;
                  this.extras = null;
                  this.margin = null;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  var _a;
                  const style = (0, _html_utils.toStyle)(this, "border", "font", "margin");
                  const field = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
                  const html = {
                    name: "input",
                    attributes: {
                      type: "text",
                      fieldId: field[_symbol_utils.$uid],
                      dataId: ((_a = field[_symbol_utils.$data]) == null ? void 0 : _a[_symbol_utils.$uid]) || field[_symbol_utils.$uid],
                      class: ["xfaTextfield"],
                      style,
                      "aria-label": ariaLabel(field),
                      "aria-required": false
                    }
                  };
                  if (isRequired(field)) {
                    html.attributes["aria-required"] = true;
                    html.attributes.required = true;
                  }
                  return _utils.HTMLResult.success({
                    name: "label",
                    attributes: {
                      class: ["xfaLabel"]
                    },
                    children: [html]
                  });
                }
              }
              class Occur extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "occur", true);
                  this.id = attributes.id || "";
                  this.initial = attributes.initial !== "" ? (0, _utils.getInteger)({
                    data: attributes.initial,
                    defaultValue: "",
                    validate: (x) => true
                  }) : "";
                  this.max = attributes.max !== "" ? (0, _utils.getInteger)({
                    data: attributes.max,
                    defaultValue: 1,
                    validate: (x) => true
                  }) : "";
                  this.min = attributes.min !== "" ? (0, _utils.getInteger)({
                    data: attributes.min,
                    defaultValue: 1,
                    validate: (x) => true
                  }) : "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                }
                [_symbol_utils.$clean]() {
                  const parent = this[_symbol_utils.$getParent]();
                  const originalMin = this.min;
                  if (this.min === "") {
                    this.min = parent instanceof PageArea || parent instanceof PageSet ? 0 : 1;
                  }
                  if (this.max === "") {
                    if (originalMin === "") {
                      this.max = parent instanceof PageArea || parent instanceof PageSet ? -1 : 1;
                    } else {
                      this.max = this.min;
                    }
                  }
                  if (this.max !== -1 && this.max < this.min) {
                    this.max = this.min;
                  }
                  if (this.initial === "") {
                    this.initial = parent instanceof Template ? 1 : this.min;
                  }
                }
              }
              class Oid extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "oid");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class Oids extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "oids", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.oid = new _xfa_object.XFAObjectArray();
                }
              }
              class Overflow extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "overflow");
                  this.id = attributes.id || "";
                  this.leader = attributes.leader || "";
                  this.target = attributes.target || "";
                  this.trailer = attributes.trailer || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_symbol_utils.$getExtra]() {
                  if (!this[_symbol_utils.$extra]) {
                    const parent = this[_symbol_utils.$getParent]();
                    const root = this[_symbol_utils.$getTemplateRoot]();
                    const target = root[_symbol_utils.$searchNode](this.target, parent);
                    const leader = root[_symbol_utils.$searchNode](this.leader, parent);
                    const trailer = root[_symbol_utils.$searchNode](this.trailer, parent);
                    this[_symbol_utils.$extra] = {
                      target: (target == null ? void 0 : target[0]) || null,
                      leader: (leader == null ? void 0 : leader[0]) || null,
                      trailer: (trailer == null ? void 0 : trailer[0]) || null,
                      addLeader: false,
                      addTrailer: false
                    };
                  }
                  return this[_symbol_utils.$extra];
                }
              }
              class PageArea extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "pageArea", true);
                  this.blankOrNotBlank = (0, _utils.getStringOption)(attributes.blankOrNotBlank, ["any", "blank", "notBlank"]);
                  this.id = attributes.id || "";
                  this.initialNumber = (0, _utils.getInteger)({
                    data: attributes.initialNumber,
                    defaultValue: 1,
                    validate: (x) => true
                  });
                  this.name = attributes.name || "";
                  this.numbered = (0, _utils.getInteger)({
                    data: attributes.numbered,
                    defaultValue: 1,
                    validate: (x) => true
                  });
                  this.oddOrEven = (0, _utils.getStringOption)(attributes.oddOrEven, ["any", "even", "odd"]);
                  this.pagePosition = (0, _utils.getStringOption)(attributes.pagePosition, ["any", "first", "last", "only", "rest"]);
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.desc = null;
                  this.extras = null;
                  this.medium = null;
                  this.occur = null;
                  this.area = new _xfa_object.XFAObjectArray();
                  this.contentArea = new _xfa_object.XFAObjectArray();
                  this.draw = new _xfa_object.XFAObjectArray();
                  this.exclGroup = new _xfa_object.XFAObjectArray();
                  this.field = new _xfa_object.XFAObjectArray();
                  this.subform = new _xfa_object.XFAObjectArray();
                }
                [_symbol_utils.$isUsable]() {
                  if (!this[_symbol_utils.$extra]) {
                    this[_symbol_utils.$extra] = {
                      numberOfUse: 0
                    };
                    return true;
                  }
                  return !this.occur || this.occur.max === -1 || this[_symbol_utils.$extra].numberOfUse < this.occur.max;
                }
                [_symbol_utils.$cleanPage]() {
                  delete this[_symbol_utils.$extra];
                }
                [_symbol_utils.$getNextPage]() {
                  if (!this[_symbol_utils.$extra]) {
                    this[_symbol_utils.$extra] = {
                      numberOfUse: 0
                    };
                  }
                  const parent = this[_symbol_utils.$getParent]();
                  if (parent.relation === "orderedOccurrence") {
                    if (this[_symbol_utils.$isUsable]()) {
                      this[_symbol_utils.$extra].numberOfUse += 1;
                      return this;
                    }
                  }
                  return parent[_symbol_utils.$getNextPage]();
                }
                [_symbol_utils.$getAvailableSpace]() {
                  return this[_symbol_utils.$extra].space || {
                    width: 0,
                    height: 0
                  };
                }
                [_symbol_utils.$toHTML]() {
                  if (!this[_symbol_utils.$extra]) {
                    this[_symbol_utils.$extra] = {
                      numberOfUse: 1
                    };
                  }
                  const children = [];
                  this[_symbol_utils.$extra].children = children;
                  const style = /* @__PURE__ */ Object.create(null);
                  if (this.medium && this.medium.short && this.medium.long) {
                    style.width = (0, _html_utils.measureToString)(this.medium.short);
                    style.height = (0, _html_utils.measureToString)(this.medium.long);
                    this[_symbol_utils.$extra].space = {
                      width: this.medium.short,
                      height: this.medium.long
                    };
                    if (this.medium.orientation === "landscape") {
                      const x = style.width;
                      style.width = style.height;
                      style.height = x;
                      this[_symbol_utils.$extra].space = {
                        width: this.medium.long,
                        height: this.medium.short
                      };
                    }
                  } else {
                    (0, _util.warn)("XFA - No medium specified in pageArea: please file a bug.");
                  }
                  this[_symbol_utils.$childrenToHTML]({
                    filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]),
                    include: true
                  });
                  this[_symbol_utils.$childrenToHTML]({
                    filter: /* @__PURE__ */ new Set(["contentArea"]),
                    include: true
                  });
                  return _utils.HTMLResult.success({
                    name: "div",
                    children,
                    attributes: {
                      class: ["xfaPage"],
                      id: this[_symbol_utils.$uid],
                      style,
                      xfaName: this.name
                    }
                  });
                }
              }
              class PageSet extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "pageSet", true);
                  this.duplexImposition = (0, _utils.getStringOption)(attributes.duplexImposition, ["longEdge", "shortEdge"]);
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.relation = (0, _utils.getStringOption)(attributes.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]);
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.occur = null;
                  this.pageArea = new _xfa_object.XFAObjectArray();
                  this.pageSet = new _xfa_object.XFAObjectArray();
                }
                [_symbol_utils.$cleanPage]() {
                  for (const page of this.pageArea.children) {
                    page[_symbol_utils.$cleanPage]();
                  }
                  for (const page of this.pageSet.children) {
                    page[_symbol_utils.$cleanPage]();
                  }
                }
                [_symbol_utils.$isUsable]() {
                  return !this.occur || this.occur.max === -1 || this[_symbol_utils.$extra].numberOfUse < this.occur.max;
                }
                [_symbol_utils.$getNextPage]() {
                  if (!this[_symbol_utils.$extra]) {
                    this[_symbol_utils.$extra] = {
                      numberOfUse: 1,
                      pageIndex: -1,
                      pageSetIndex: -1
                    };
                  }
                  if (this.relation === "orderedOccurrence") {
                    if (this[_symbol_utils.$extra].pageIndex + 1 < this.pageArea.children.length) {
                      this[_symbol_utils.$extra].pageIndex += 1;
                      const pageArea = this.pageArea.children[this[_symbol_utils.$extra].pageIndex];
                      return pageArea[_symbol_utils.$getNextPage]();
                    }
                    if (this[_symbol_utils.$extra].pageSetIndex + 1 < this.pageSet.children.length) {
                      this[_symbol_utils.$extra].pageSetIndex += 1;
                      return this.pageSet.children[this[_symbol_utils.$extra].pageSetIndex][_symbol_utils.$getNextPage]();
                    }
                    if (this[_symbol_utils.$isUsable]()) {
                      this[_symbol_utils.$extra].numberOfUse += 1;
                      this[_symbol_utils.$extra].pageIndex = -1;
                      this[_symbol_utils.$extra].pageSetIndex = -1;
                      return this[_symbol_utils.$getNextPage]();
                    }
                    const parent = this[_symbol_utils.$getParent]();
                    if (parent instanceof PageSet) {
                      return parent[_symbol_utils.$getNextPage]();
                    }
                    this[_symbol_utils.$cleanPage]();
                    return this[_symbol_utils.$getNextPage]();
                  }
                  const pageNumber = this[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].pageNumber;
                  const parity = pageNumber % 2 === 0 ? "even" : "odd";
                  const position = pageNumber === 0 ? "first" : "rest";
                  let page = this.pageArea.children.find((p) => p.oddOrEven === parity && p.pagePosition === position);
                  if (page) {
                    return page;
                  }
                  page = this.pageArea.children.find((p) => p.oddOrEven === "any" && p.pagePosition === position);
                  if (page) {
                    return page;
                  }
                  page = this.pageArea.children.find((p) => p.oddOrEven === "any" && p.pagePosition === "any");
                  if (page) {
                    return page;
                  }
                  return this.pageArea.children[0];
                }
              }
              class Para extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "para", true);
                  this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
                  this.id = attributes.id || "";
                  this.lineHeight = attributes.lineHeight ? (0, _utils.getMeasurement)(attributes.lineHeight, "0pt") : "";
                  this.marginLeft = attributes.marginLeft ? (0, _utils.getMeasurement)(attributes.marginLeft, "0pt") : "";
                  this.marginRight = attributes.marginRight ? (0, _utils.getMeasurement)(attributes.marginRight, "0pt") : "";
                  this.orphans = (0, _utils.getInteger)({
                    data: attributes.orphans,
                    defaultValue: 0,
                    validate: (x) => x >= 0
                  });
                  this.preserve = attributes.preserve || "";
                  this.radixOffset = attributes.radixOffset ? (0, _utils.getMeasurement)(attributes.radixOffset, "0pt") : "";
                  this.spaceAbove = attributes.spaceAbove ? (0, _utils.getMeasurement)(attributes.spaceAbove, "0pt") : "";
                  this.spaceBelow = attributes.spaceBelow ? (0, _utils.getMeasurement)(attributes.spaceBelow, "0pt") : "";
                  this.tabDefault = attributes.tabDefault ? (0, _utils.getMeasurement)(this.tabDefault) : "";
                  this.tabStops = (attributes.tabStops || "").trim().split(/\s+/).map((x, i) => i % 2 === 1 ? (0, _utils.getMeasurement)(x) : x);
                  this.textIndent = attributes.textIndent ? (0, _utils.getMeasurement)(attributes.textIndent, "0pt") : "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.vAlign = (0, _utils.getStringOption)(attributes.vAlign, ["top", "bottom", "middle"]);
                  this.widows = (0, _utils.getInteger)({
                    data: attributes.widows,
                    defaultValue: 0,
                    validate: (x) => x >= 0
                  });
                  this.hyphenation = null;
                }
                [_symbol_utils.$toStyle]() {
                  const style = (0, _html_utils.toStyle)(this, "hAlign");
                  if (this.marginLeft !== "") {
                    style.paddingLeft = (0, _html_utils.measureToString)(this.marginLeft);
                  }
                  if (this.marginRight !== "") {
                    style.paddingight = (0, _html_utils.measureToString)(this.marginRight);
                  }
                  if (this.spaceAbove !== "") {
                    style.paddingTop = (0, _html_utils.measureToString)(this.spaceAbove);
                  }
                  if (this.spaceBelow !== "") {
                    style.paddingBottom = (0, _html_utils.measureToString)(this.spaceBelow);
                  }
                  if (this.textIndent !== "") {
                    style.textIndent = (0, _html_utils.measureToString)(this.textIndent);
                    (0, _html_utils.fixTextIndent)(style);
                  }
                  if (this.lineHeight > 0) {
                    style.lineHeight = (0, _html_utils.measureToString)(this.lineHeight);
                  }
                  if (this.tabDefault !== "") {
                    style.tabSize = (0, _html_utils.measureToString)(this.tabDefault);
                  }
                  if (this.tabStops.length > 0) {
                  }
                  if (this.hyphenatation) {
                    Object.assign(style, this.hyphenatation[_symbol_utils.$toStyle]());
                  }
                  return style;
                }
              }
              class PasswordEdit extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "passwordEdit", true);
                  this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
                  this.id = attributes.id || "";
                  this.passwordChar = attributes.passwordChar || "*";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.border = null;
                  this.extras = null;
                  this.margin = null;
                }
              }
              class Pattern extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "pattern", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.color = null;
                  this.extras = null;
                }
                [_symbol_utils.$toStyle](startColor) {
                  startColor = startColor ? startColor[_symbol_utils.$toStyle]() : "#FFFFFF";
                  const endColor = this.color ? this.color[_symbol_utils.$toStyle]() : "#000000";
                  const width = 5;
                  const cmd = "repeating-linear-gradient";
                  const colors = `${startColor},${startColor} ${width}px,${endColor} ${width}px,${endColor} ${2 * width}px`;
                  switch (this.type) {
                    case "crossHatch":
                      return `${cmd}(to top,${colors}) ${cmd}(to right,${colors})`;
                    case "crossDiagonal":
                      return `${cmd}(45deg,${colors}) ${cmd}(-45deg,${colors})`;
                    case "diagonalLeft":
                      return `${cmd}(45deg,${colors})`;
                    case "diagonalRight":
                      return `${cmd}(-45deg,${colors})`;
                    case "horizontal":
                      return `${cmd}(to top,${colors})`;
                    case "vertical":
                      return `${cmd}(to right,${colors})`;
                  }
                  return "";
                }
              }
              class Picture extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "picture");
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class Proto extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "proto", true);
                  this.appearanceFilter = new _xfa_object.XFAObjectArray();
                  this.arc = new _xfa_object.XFAObjectArray();
                  this.area = new _xfa_object.XFAObjectArray();
                  this.assist = new _xfa_object.XFAObjectArray();
                  this.barcode = new _xfa_object.XFAObjectArray();
                  this.bindItems = new _xfa_object.XFAObjectArray();
                  this.bookend = new _xfa_object.XFAObjectArray();
                  this.boolean = new _xfa_object.XFAObjectArray();
                  this.border = new _xfa_object.XFAObjectArray();
                  this.break = new _xfa_object.XFAObjectArray();
                  this.breakAfter = new _xfa_object.XFAObjectArray();
                  this.breakBefore = new _xfa_object.XFAObjectArray();
                  this.button = new _xfa_object.XFAObjectArray();
                  this.calculate = new _xfa_object.XFAObjectArray();
                  this.caption = new _xfa_object.XFAObjectArray();
                  this.certificate = new _xfa_object.XFAObjectArray();
                  this.certificates = new _xfa_object.XFAObjectArray();
                  this.checkButton = new _xfa_object.XFAObjectArray();
                  this.choiceList = new _xfa_object.XFAObjectArray();
                  this.color = new _xfa_object.XFAObjectArray();
                  this.comb = new _xfa_object.XFAObjectArray();
                  this.connect = new _xfa_object.XFAObjectArray();
                  this.contentArea = new _xfa_object.XFAObjectArray();
                  this.corner = new _xfa_object.XFAObjectArray();
                  this.date = new _xfa_object.XFAObjectArray();
                  this.dateTime = new _xfa_object.XFAObjectArray();
                  this.dateTimeEdit = new _xfa_object.XFAObjectArray();
                  this.decimal = new _xfa_object.XFAObjectArray();
                  this.defaultUi = new _xfa_object.XFAObjectArray();
                  this.desc = new _xfa_object.XFAObjectArray();
                  this.digestMethod = new _xfa_object.XFAObjectArray();
                  this.digestMethods = new _xfa_object.XFAObjectArray();
                  this.draw = new _xfa_object.XFAObjectArray();
                  this.edge = new _xfa_object.XFAObjectArray();
                  this.encoding = new _xfa_object.XFAObjectArray();
                  this.encodings = new _xfa_object.XFAObjectArray();
                  this.encrypt = new _xfa_object.XFAObjectArray();
                  this.encryptData = new _xfa_object.XFAObjectArray();
                  this.encryption = new _xfa_object.XFAObjectArray();
                  this.encryptionMethod = new _xfa_object.XFAObjectArray();
                  this.encryptionMethods = new _xfa_object.XFAObjectArray();
                  this.event = new _xfa_object.XFAObjectArray();
                  this.exData = new _xfa_object.XFAObjectArray();
                  this.exObject = new _xfa_object.XFAObjectArray();
                  this.exclGroup = new _xfa_object.XFAObjectArray();
                  this.execute = new _xfa_object.XFAObjectArray();
                  this.extras = new _xfa_object.XFAObjectArray();
                  this.field = new _xfa_object.XFAObjectArray();
                  this.fill = new _xfa_object.XFAObjectArray();
                  this.filter = new _xfa_object.XFAObjectArray();
                  this.float = new _xfa_object.XFAObjectArray();
                  this.font = new _xfa_object.XFAObjectArray();
                  this.format = new _xfa_object.XFAObjectArray();
                  this.handler = new _xfa_object.XFAObjectArray();
                  this.hyphenation = new _xfa_object.XFAObjectArray();
                  this.image = new _xfa_object.XFAObjectArray();
                  this.imageEdit = new _xfa_object.XFAObjectArray();
                  this.integer = new _xfa_object.XFAObjectArray();
                  this.issuers = new _xfa_object.XFAObjectArray();
                  this.items = new _xfa_object.XFAObjectArray();
                  this.keep = new _xfa_object.XFAObjectArray();
                  this.keyUsage = new _xfa_object.XFAObjectArray();
                  this.line = new _xfa_object.XFAObjectArray();
                  this.linear = new _xfa_object.XFAObjectArray();
                  this.lockDocument = new _xfa_object.XFAObjectArray();
                  this.manifest = new _xfa_object.XFAObjectArray();
                  this.margin = new _xfa_object.XFAObjectArray();
                  this.mdp = new _xfa_object.XFAObjectArray();
                  this.medium = new _xfa_object.XFAObjectArray();
                  this.message = new _xfa_object.XFAObjectArray();
                  this.numericEdit = new _xfa_object.XFAObjectArray();
                  this.occur = new _xfa_object.XFAObjectArray();
                  this.oid = new _xfa_object.XFAObjectArray();
                  this.oids = new _xfa_object.XFAObjectArray();
                  this.overflow = new _xfa_object.XFAObjectArray();
                  this.pageArea = new _xfa_object.XFAObjectArray();
                  this.pageSet = new _xfa_object.XFAObjectArray();
                  this.para = new _xfa_object.XFAObjectArray();
                  this.passwordEdit = new _xfa_object.XFAObjectArray();
                  this.pattern = new _xfa_object.XFAObjectArray();
                  this.picture = new _xfa_object.XFAObjectArray();
                  this.radial = new _xfa_object.XFAObjectArray();
                  this.reason = new _xfa_object.XFAObjectArray();
                  this.reasons = new _xfa_object.XFAObjectArray();
                  this.rectangle = new _xfa_object.XFAObjectArray();
                  this.ref = new _xfa_object.XFAObjectArray();
                  this.script = new _xfa_object.XFAObjectArray();
                  this.setProperty = new _xfa_object.XFAObjectArray();
                  this.signData = new _xfa_object.XFAObjectArray();
                  this.signature = new _xfa_object.XFAObjectArray();
                  this.signing = new _xfa_object.XFAObjectArray();
                  this.solid = new _xfa_object.XFAObjectArray();
                  this.speak = new _xfa_object.XFAObjectArray();
                  this.stipple = new _xfa_object.XFAObjectArray();
                  this.subform = new _xfa_object.XFAObjectArray();
                  this.subformSet = new _xfa_object.XFAObjectArray();
                  this.subjectDN = new _xfa_object.XFAObjectArray();
                  this.subjectDNs = new _xfa_object.XFAObjectArray();
                  this.submit = new _xfa_object.XFAObjectArray();
                  this.text = new _xfa_object.XFAObjectArray();
                  this.textEdit = new _xfa_object.XFAObjectArray();
                  this.time = new _xfa_object.XFAObjectArray();
                  this.timeStamp = new _xfa_object.XFAObjectArray();
                  this.toolTip = new _xfa_object.XFAObjectArray();
                  this.traversal = new _xfa_object.XFAObjectArray();
                  this.traverse = new _xfa_object.XFAObjectArray();
                  this.ui = new _xfa_object.XFAObjectArray();
                  this.validate = new _xfa_object.XFAObjectArray();
                  this.value = new _xfa_object.XFAObjectArray();
                  this.variables = new _xfa_object.XFAObjectArray();
                }
              }
              class Radial extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "radial", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["toEdge", "toCenter"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.color = null;
                  this.extras = null;
                }
                [_symbol_utils.$toStyle](startColor) {
                  startColor = startColor ? startColor[_symbol_utils.$toStyle]() : "#FFFFFF";
                  const endColor = this.color ? this.color[_symbol_utils.$toStyle]() : "#000000";
                  const colors = this.type === "toEdge" ? `${startColor},${endColor}` : `${endColor},${startColor}`;
                  return `radial-gradient(circle at center, ${colors})`;
                }
              }
              class Reason extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "reason");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class Reasons extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "reasons", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.reason = new _xfa_object.XFAObjectArray();
                }
              }
              class Rectangle extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "rectangle", true);
                  this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.corner = new _xfa_object.XFAObjectArray(4);
                  this.edge = new _xfa_object.XFAObjectArray(4);
                  this.fill = null;
                }
                [_symbol_utils.$toHTML]() {
                  var _a;
                  const edge = this.edge.children.length ? this.edge.children[0] : new Edge({});
                  const edgeStyle = edge[_symbol_utils.$toStyle]();
                  const style = /* @__PURE__ */ Object.create(null);
                  if (((_a = this.fill) == null ? void 0 : _a.presence) === "visible") {
                    Object.assign(style, this.fill[_symbol_utils.$toStyle]());
                  } else {
                    style.fill = "transparent";
                  }
                  style.strokeWidth = (0, _html_utils.measureToString)(edge.presence === "visible" ? edge.thickness : 0);
                  style.stroke = edgeStyle.color;
                  const corner = this.corner.children.length ? this.corner.children[0] : new Corner({});
                  const cornerStyle = corner[_symbol_utils.$toStyle]();
                  const rect = {
                    name: "rect",
                    attributes: {
                      xmlns: SVG_NS,
                      width: "100%",
                      height: "100%",
                      x: 0,
                      y: 0,
                      rx: cornerStyle.radius,
                      ry: cornerStyle.radius,
                      style
                    }
                  };
                  const svg = {
                    name: "svg",
                    children: [rect],
                    attributes: {
                      xmlns: SVG_NS,
                      style: {
                        overflow: "visible"
                      },
                      width: "100%",
                      height: "100%"
                    }
                  };
                  const parent = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
                  if (hasMargin(parent)) {
                    return _utils.HTMLResult.success({
                      name: "div",
                      attributes: {
                        style: {
                          display: "inline",
                          width: "100%",
                          height: "100%"
                        }
                      },
                      children: [svg]
                    });
                  }
                  svg.attributes.style.position = "absolute";
                  return _utils.HTMLResult.success(svg);
                }
              }
              class RefElement extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "ref");
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class Script extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "script");
                  this.binding = attributes.binding || "";
                  this.contentType = attributes.contentType || "";
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.runAt = (0, _utils.getStringOption)(attributes.runAt, ["client", "both", "server"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class SetProperty extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "setProperty");
                  this.connection = attributes.connection || "";
                  this.ref = attributes.ref || "";
                  this.target = attributes.target || "";
                }
              }
              exports2.SetProperty = SetProperty;
              class SignData extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "signData", true);
                  this.id = attributes.id || "";
                  this.operation = (0, _utils.getStringOption)(attributes.operation, ["sign", "clear", "verify"]);
                  this.ref = attributes.ref || "";
                  this.target = attributes.target || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.filter = null;
                  this.manifest = null;
                }
              }
              class Signature extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "signature", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["PDF1.3", "PDF1.6"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.border = null;
                  this.extras = null;
                  this.filter = null;
                  this.manifest = null;
                  this.margin = null;
                }
              }
              class Signing extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "signing", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.certificate = new _xfa_object.XFAObjectArray();
                }
              }
              class Solid extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "solid", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                }
                [_symbol_utils.$toStyle](startColor) {
                  return startColor ? startColor[_symbol_utils.$toStyle]() : "#FFFFFF";
                }
              }
              class Speak extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "speak");
                  this.disable = (0, _utils.getInteger)({
                    data: attributes.disable,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.id = attributes.id || "";
                  this.priority = (0, _utils.getStringOption)(attributes.priority, ["custom", "caption", "name", "toolTip"]);
                  this.rid = attributes.rid || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class Stipple extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "stipple", true);
                  this.id = attributes.id || "";
                  this.rate = (0, _utils.getInteger)({
                    data: attributes.rate,
                    defaultValue: 50,
                    validate: (x) => x >= 0 && x <= 100
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.color = null;
                  this.extras = null;
                }
                [_symbol_utils.$toStyle](bgColor) {
                  const alpha = this.rate / 100;
                  return _util.Util.makeHexColor(Math.round(bgColor.value.r * (1 - alpha) + this.value.r * alpha), Math.round(bgColor.value.g * (1 - alpha) + this.value.g * alpha), Math.round(bgColor.value.b * (1 - alpha) + this.value.b * alpha));
                }
              }
              class Subform extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "subform", true);
                  this.access = (0, _utils.getStringOption)(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
                  this.allowMacro = (0, _utils.getInteger)({
                    data: attributes.allowMacro,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
                  this.colSpan = (0, _utils.getInteger)({
                    data: attributes.colSpan,
                    defaultValue: 1,
                    validate: (n) => n >= 1 || n === -1
                  });
                  this.columnWidths = (attributes.columnWidths || "").trim().split(/\s+/).map((x) => x === "-1" ? -1 : (0, _utils.getMeasurement)(x));
                  this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
                  this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
                  this.id = attributes.id || "";
                  this.layout = (0, _utils.getStringOption)(attributes.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
                  this.locale = attributes.locale || "";
                  this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
                  this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
                  this.mergeMode = (0, _utils.getStringOption)(attributes.mergeMode, ["consumeData", "matchTemplate"]);
                  this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
                  this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
                  this.name = attributes.name || "";
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.restoreState = (0, _utils.getStringOption)(attributes.restoreState, ["manual", "auto"]);
                  this.scope = (0, _utils.getStringOption)(attributes.scope, ["name", "none"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
                  this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
                  this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
                  this.assist = null;
                  this.bind = null;
                  this.bookend = null;
                  this.border = null;
                  this.break = null;
                  this.calculate = null;
                  this.desc = null;
                  this.extras = null;
                  this.keep = null;
                  this.margin = null;
                  this.occur = null;
                  this.overflow = null;
                  this.pageSet = null;
                  this.para = null;
                  this.traversal = null;
                  this.validate = null;
                  this.variables = null;
                  this.area = new _xfa_object.XFAObjectArray();
                  this.breakAfter = new _xfa_object.XFAObjectArray();
                  this.breakBefore = new _xfa_object.XFAObjectArray();
                  this.connect = new _xfa_object.XFAObjectArray();
                  this.draw = new _xfa_object.XFAObjectArray();
                  this.event = new _xfa_object.XFAObjectArray();
                  this.exObject = new _xfa_object.XFAObjectArray();
                  this.exclGroup = new _xfa_object.XFAObjectArray();
                  this.field = new _xfa_object.XFAObjectArray();
                  this.proto = new _xfa_object.XFAObjectArray();
                  this.setProperty = new _xfa_object.XFAObjectArray();
                  this.subform = new _xfa_object.XFAObjectArray();
                  this.subformSet = new _xfa_object.XFAObjectArray();
                }
                [_symbol_utils.$getSubformParent]() {
                  const parent = this[_symbol_utils.$getParent]();
                  if (parent instanceof SubformSet) {
                    return parent[_symbol_utils.$getSubformParent]();
                  }
                  return parent;
                }
                [_symbol_utils.$isBindable]() {
                  return true;
                }
                [_symbol_utils.$isThereMoreWidth]() {
                  return this.layout.endsWith("-tb") && this[_symbol_utils.$extra].attempt === 0 && this[_symbol_utils.$extra].numberInLine > 0 || this[_symbol_utils.$getParent]()[_symbol_utils.$isThereMoreWidth]();
                }
                *[_symbol_utils.$getContainedChildren]() {
                  yield* getContainedChildren(this);
                }
                [_symbol_utils.$flushHTML]() {
                  return (0, _layout.flushHTML)(this);
                }
                [_symbol_utils.$addHTML](html, bbox) {
                  (0, _layout.addHTML)(this, html, bbox);
                }
                [_symbol_utils.$getAvailableSpace]() {
                  return (0, _layout.getAvailableSpace)(this);
                }
                [_symbol_utils.$isSplittable]() {
                  var _a;
                  const parent = this[_symbol_utils.$getSubformParent]();
                  if (!parent[_symbol_utils.$isSplittable]()) {
                    return false;
                  }
                  if (this[_symbol_utils.$extra]._isSplittable !== void 0) {
                    return this[_symbol_utils.$extra]._isSplittable;
                  }
                  if (this.layout === "position" || this.layout.includes("row")) {
                    this[_symbol_utils.$extra]._isSplittable = false;
                    return false;
                  }
                  if (this.keep && this.keep.intact !== "none") {
                    this[_symbol_utils.$extra]._isSplittable = false;
                    return false;
                  }
                  if (((_a = parent.layout) == null ? void 0 : _a.endsWith("-tb")) && parent[_symbol_utils.$extra].numberInLine !== 0) {
                    return false;
                  }
                  this[_symbol_utils.$extra]._isSplittable = true;
                  return true;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  var _a;
                  setTabIndex(this);
                  if (this.break) {
                    if (this.break.after !== "auto" || this.break.afterTarget !== "") {
                      const node = new BreakAfter({
                        targetType: this.break.after,
                        target: this.break.afterTarget,
                        startNew: this.break.startNew.toString()
                      });
                      node[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
                      this[_symbol_utils.$appendChild](node);
                      this.breakAfter.push(node);
                    }
                    if (this.break.before !== "auto" || this.break.beforeTarget !== "") {
                      const node = new BreakBefore({
                        targetType: this.break.before,
                        target: this.break.beforeTarget,
                        startNew: this.break.startNew.toString()
                      });
                      node[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
                      this[_symbol_utils.$appendChild](node);
                      this.breakBefore.push(node);
                    }
                    if (this.break.overflowTarget !== "") {
                      const node = new Overflow({
                        target: this.break.overflowTarget,
                        leader: this.break.overflowLeader,
                        trailer: this.break.overflowTrailer
                      });
                      node[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
                      this[_symbol_utils.$appendChild](node);
                      this.overflow.push(node);
                    }
                    this[_symbol_utils.$removeChild](this.break);
                    this.break = null;
                  }
                  if (this.presence === "hidden" || this.presence === "inactive") {
                    return _utils.HTMLResult.EMPTY;
                  }
                  if (this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) {
                    (0, _util.warn)("XFA - Several breakBefore or breakAfter in subforms: please file a bug.");
                  }
                  if (this.breakBefore.children.length >= 1) {
                    const breakBefore = this.breakBefore.children[0];
                    if (handleBreak(breakBefore)) {
                      return _utils.HTMLResult.breakNode(breakBefore);
                    }
                  }
                  if ((_a = this[_symbol_utils.$extra]) == null ? void 0 : _a.afterBreakAfter) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  (0, _html_utils.fixDimensions)(this);
                  const children = [];
                  const attributes = {
                    id: this[_symbol_utils.$uid],
                    class: []
                  };
                  (0, _html_utils.setAccess)(this, attributes.class);
                  if (!this[_symbol_utils.$extra]) {
                    this[_symbol_utils.$extra] = /* @__PURE__ */ Object.create(null);
                  }
                  Object.assign(this[_symbol_utils.$extra], {
                    children,
                    line: null,
                    attributes,
                    attempt: 0,
                    numberInLine: 0,
                    availableSpace: {
                      width: Math.min(this.w || Infinity, availableSpace.width),
                      height: Math.min(this.h || Infinity, availableSpace.height)
                    },
                    width: 0,
                    height: 0,
                    prevHeight: 0,
                    currentWidth: 0
                  });
                  const root = this[_symbol_utils.$getTemplateRoot]();
                  const savedNoLayoutFailure = root[_symbol_utils.$extra].noLayoutFailure;
                  const isSplittable = this[_symbol_utils.$isSplittable]();
                  if (!isSplittable) {
                    setFirstUnsplittable(this);
                  }
                  if (!(0, _layout.checkDimensions)(this, availableSpace)) {
                    return _utils.HTMLResult.FAILURE;
                  }
                  const filter = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
                  if (this.layout.includes("row")) {
                    const columnWidths = this[_symbol_utils.$getSubformParent]().columnWidths;
                    if (Array.isArray(columnWidths) && columnWidths.length > 0) {
                      this[_symbol_utils.$extra].columnWidths = columnWidths;
                      this[_symbol_utils.$extra].currentColumn = 0;
                    }
                  }
                  const style = (0, _html_utils.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign");
                  const classNames = ["xfaSubform"];
                  const cl = (0, _html_utils.layoutClass)(this);
                  if (cl) {
                    classNames.push(cl);
                  }
                  attributes.style = style;
                  attributes.class = classNames;
                  if (this.name) {
                    attributes.xfaName = this.name;
                  }
                  if (this.overflow) {
                    const overflowExtra = this.overflow[_symbol_utils.$getExtra]();
                    if (overflowExtra.addLeader) {
                      overflowExtra.addLeader = false;
                      handleOverflow(this, overflowExtra.leader, availableSpace);
                    }
                  }
                  this[_symbol_utils.$pushPara]();
                  const isLrTb = this.layout === "lr-tb" || this.layout === "rl-tb";
                  const maxRun = isLrTb ? MAX_ATTEMPTS_FOR_LRTB_LAYOUT : 1;
                  for (; this[_symbol_utils.$extra].attempt < maxRun; this[_symbol_utils.$extra].attempt++) {
                    if (isLrTb && this[_symbol_utils.$extra].attempt === MAX_ATTEMPTS_FOR_LRTB_LAYOUT - 1) {
                      this[_symbol_utils.$extra].numberInLine = 0;
                    }
                    const result2 = this[_symbol_utils.$childrenToHTML]({
                      filter,
                      include: true
                    });
                    if (result2.success) {
                      break;
                    }
                    if (result2.isBreak()) {
                      this[_symbol_utils.$popPara]();
                      return result2;
                    }
                    if (isLrTb && this[_symbol_utils.$extra].attempt === 0 && this[_symbol_utils.$extra].numberInLine === 0 && !root[_symbol_utils.$extra].noLayoutFailure) {
                      this[_symbol_utils.$extra].attempt = maxRun;
                      break;
                    }
                  }
                  this[_symbol_utils.$popPara]();
                  if (!isSplittable) {
                    unsetFirstUnsplittable(this);
                  }
                  root[_symbol_utils.$extra].noLayoutFailure = savedNoLayoutFailure;
                  if (this[_symbol_utils.$extra].attempt === maxRun) {
                    if (this.overflow) {
                      this[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].overflowNode = this.overflow;
                    }
                    if (!isSplittable) {
                      delete this[_symbol_utils.$extra];
                    }
                    return _utils.HTMLResult.FAILURE;
                  }
                  if (this.overflow) {
                    const overflowExtra = this.overflow[_symbol_utils.$getExtra]();
                    if (overflowExtra.addTrailer) {
                      overflowExtra.addTrailer = false;
                      handleOverflow(this, overflowExtra.trailer, availableSpace);
                    }
                  }
                  let marginH = 0;
                  let marginV = 0;
                  if (this.margin) {
                    marginH = this.margin.leftInset + this.margin.rightInset;
                    marginV = this.margin.topInset + this.margin.bottomInset;
                  }
                  const width = Math.max(this[_symbol_utils.$extra].width + marginH, this.w || 0);
                  const height = Math.max(this[_symbol_utils.$extra].height + marginV, this.h || 0);
                  const bbox = [this.x, this.y, width, height];
                  if (this.w === "") {
                    style.width = (0, _html_utils.measureToString)(width);
                  }
                  if (this.h === "") {
                    style.height = (0, _html_utils.measureToString)(height);
                  }
                  if ((style.width === "0px" || style.height === "0px") && children.length === 0) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  const html = {
                    name: "div",
                    attributes,
                    children
                  };
                  applyAssist(this, attributes);
                  const result = _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
                  if (this.breakAfter.children.length >= 1) {
                    const breakAfter = this.breakAfter.children[0];
                    if (handleBreak(breakAfter)) {
                      this[_symbol_utils.$extra].afterBreakAfter = result;
                      return _utils.HTMLResult.breakNode(breakAfter);
                    }
                  }
                  delete this[_symbol_utils.$extra];
                  return result;
                }
              }
              class SubformSet extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "subformSet", true);
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.relation = (0, _utils.getStringOption)(attributes.relation, ["ordered", "choice", "unordered"]);
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.bookend = null;
                  this.break = null;
                  this.desc = null;
                  this.extras = null;
                  this.occur = null;
                  this.overflow = null;
                  this.breakAfter = new _xfa_object.XFAObjectArray();
                  this.breakBefore = new _xfa_object.XFAObjectArray();
                  this.subform = new _xfa_object.XFAObjectArray();
                  this.subformSet = new _xfa_object.XFAObjectArray();
                }
                *[_symbol_utils.$getContainedChildren]() {
                  yield* getContainedChildren(this);
                }
                [_symbol_utils.$getSubformParent]() {
                  let parent = this[_symbol_utils.$getParent]();
                  while (!(parent instanceof Subform)) {
                    parent = parent[_symbol_utils.$getParent]();
                  }
                  return parent;
                }
                [_symbol_utils.$isBindable]() {
                  return true;
                }
              }
              class SubjectDN extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "subjectDN");
                  this.delimiter = attributes.delimiter || ",";
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_symbol_utils.$finalize]() {
                  this[_symbol_utils.$content] = new Map(this[_symbol_utils.$content].split(this.delimiter).map((kv) => {
                    kv = kv.split("=", 2);
                    kv[0] = kv[0].trim();
                    return kv;
                  }));
                }
              }
              class SubjectDNs extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "subjectDNs", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.subjectDN = new _xfa_object.XFAObjectArray();
                }
              }
              class Submit extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "submit", true);
                  this.embedPDF = (0, _utils.getInteger)({
                    data: attributes.embedPDF,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.format = (0, _utils.getStringOption)(attributes.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]);
                  this.id = attributes.id || "";
                  this.target = attributes.target || "";
                  this.textEncoding = (0, _utils.getKeyword)({
                    data: attributes.textEncoding ? attributes.textEncoding.toLowerCase() : "",
                    defaultValue: "",
                    validate: (k) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(k) || k.match(/iso-8859-\d{2}/)
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.xdpContent = attributes.xdpContent || "";
                  this.encrypt = null;
                  this.encryptData = new _xfa_object.XFAObjectArray();
                  this.signData = new _xfa_object.XFAObjectArray();
                }
              }
              class Template extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "template", true);
                  this.baseProfile = (0, _utils.getStringOption)(attributes.baseProfile, ["full", "interactiveForms"]);
                  this.extras = null;
                  this.subform = new _xfa_object.XFAObjectArray();
                }
                [_symbol_utils.$finalize]() {
                  if (this.subform.children.length === 0) {
                    (0, _util.warn)("XFA - No subforms in template node.");
                  }
                  if (this.subform.children.length >= 2) {
                    (0, _util.warn)("XFA - Several subforms in template node: please file a bug.");
                  }
                  this[_symbol_utils.$tabIndex] = DEFAULT_TAB_INDEX;
                }
                [_symbol_utils.$isSplittable]() {
                  return true;
                }
                [_symbol_utils.$searchNode](expr, container) {
                  if (expr.startsWith("#")) {
                    return [this[_symbol_utils.$ids].get(expr.slice(1))];
                  }
                  return (0, _som.searchNode)(this, container, expr, true, true);
                }
                *[_symbol_utils.$toPages]() {
                  var _a, _b, _c;
                  if (!this.subform.children.length) {
                    return _utils.HTMLResult.success({
                      name: "div",
                      children: []
                    });
                  }
                  this[_symbol_utils.$extra] = {
                    overflowNode: null,
                    firstUnsplittable: null,
                    currentContentArea: null,
                    currentPageArea: null,
                    noLayoutFailure: false,
                    pageNumber: 1,
                    pagePosition: "first",
                    oddOrEven: "odd",
                    blankOrNotBlank: "nonBlank",
                    paraStack: []
                  };
                  const root = this.subform.children[0];
                  root.pageSet[_symbol_utils.$cleanPage]();
                  const pageAreas = root.pageSet.pageArea.children;
                  const mainHtml = {
                    name: "div",
                    children: []
                  };
                  let pageArea = null;
                  let breakBefore = null;
                  let breakBeforeTarget = null;
                  if (root.breakBefore.children.length >= 1) {
                    breakBefore = root.breakBefore.children[0];
                    breakBeforeTarget = breakBefore.target;
                  } else if (root.subform.children.length >= 1 && root.subform.children[0].breakBefore.children.length >= 1) {
                    breakBefore = root.subform.children[0].breakBefore.children[0];
                    breakBeforeTarget = breakBefore.target;
                  } else if ((_a = root.break) == null ? void 0 : _a.beforeTarget) {
                    breakBefore = root.break;
                    breakBeforeTarget = breakBefore.beforeTarget;
                  } else if (root.subform.children.length >= 1 && ((_b = root.subform.children[0].break) == null ? void 0 : _b.beforeTarget)) {
                    breakBefore = root.subform.children[0].break;
                    breakBeforeTarget = breakBefore.beforeTarget;
                  }
                  if (breakBefore) {
                    const target = this[_symbol_utils.$searchNode](breakBeforeTarget, breakBefore[_symbol_utils.$getParent]());
                    if (target instanceof PageArea) {
                      pageArea = target;
                      breakBefore[_symbol_utils.$extra] = {};
                    }
                  }
                  if (!pageArea) {
                    pageArea = pageAreas[0];
                  }
                  pageArea[_symbol_utils.$extra] = {
                    numberOfUse: 1
                  };
                  const pageAreaParent = pageArea[_symbol_utils.$getParent]();
                  pageAreaParent[_symbol_utils.$extra] = {
                    numberOfUse: 1,
                    pageIndex: pageAreaParent.pageArea.children.indexOf(pageArea),
                    pageSetIndex: 0
                  };
                  let targetPageArea;
                  let leader = null;
                  let trailer = null;
                  let hasSomething = true;
                  let hasSomethingCounter = 0;
                  let startIndex = 0;
                  while (true) {
                    if (!hasSomething) {
                      mainHtml.children.pop();
                      if (++hasSomethingCounter === MAX_EMPTY_PAGES) {
                        (0, _util.warn)("XFA - Something goes wrong: please file a bug.");
                        return mainHtml;
                      }
                    } else {
                      hasSomethingCounter = 0;
                    }
                    targetPageArea = null;
                    this[_symbol_utils.$extra].currentPageArea = pageArea;
                    const page = pageArea[_symbol_utils.$toHTML]().html;
                    mainHtml.children.push(page);
                    if (leader) {
                      this[_symbol_utils.$extra].noLayoutFailure = true;
                      page.children.push(leader[_symbol_utils.$toHTML](pageArea[_symbol_utils.$extra].space).html);
                      leader = null;
                    }
                    if (trailer) {
                      this[_symbol_utils.$extra].noLayoutFailure = true;
                      page.children.push(trailer[_symbol_utils.$toHTML](pageArea[_symbol_utils.$extra].space).html);
                      trailer = null;
                    }
                    const contentAreas = pageArea.contentArea.children;
                    const htmlContentAreas = page.children.filter((node) => node.attributes.class.includes("xfaContentarea"));
                    hasSomething = false;
                    this[_symbol_utils.$extra].firstUnsplittable = null;
                    this[_symbol_utils.$extra].noLayoutFailure = false;
                    const flush = (index) => {
                      var _a2;
                      const html = root[_symbol_utils.$flushHTML]();
                      if (html) {
                        hasSomething || (hasSomething = ((_a2 = html.children) == null ? void 0 : _a2.length) > 0);
                        htmlContentAreas[index].children.push(html);
                      }
                    };
                    for (let i = startIndex, ii = contentAreas.length; i < ii; i++) {
                      const contentArea = this[_symbol_utils.$extra].currentContentArea = contentAreas[i];
                      const space = {
                        width: contentArea.w,
                        height: contentArea.h
                      };
                      startIndex = 0;
                      if (leader) {
                        htmlContentAreas[i].children.push(leader[_symbol_utils.$toHTML](space).html);
                        leader = null;
                      }
                      if (trailer) {
                        htmlContentAreas[i].children.push(trailer[_symbol_utils.$toHTML](space).html);
                        trailer = null;
                      }
                      const html = root[_symbol_utils.$toHTML](space);
                      if (html.success) {
                        if (html.html) {
                          hasSomething || (hasSomething = ((_c = html.html.children) == null ? void 0 : _c.length) > 0);
                          htmlContentAreas[i].children.push(html.html);
                        } else if (!hasSomething && mainHtml.children.length > 1) {
                          mainHtml.children.pop();
                        }
                        return mainHtml;
                      }
                      if (html.isBreak()) {
                        const node = html.breakNode;
                        flush(i);
                        if (node.targetType === "auto") {
                          continue;
                        }
                        if (node.leader) {
                          leader = this[_symbol_utils.$searchNode](node.leader, node[_symbol_utils.$getParent]());
                          leader = leader ? leader[0] : null;
                        }
                        if (node.trailer) {
                          trailer = this[_symbol_utils.$searchNode](node.trailer, node[_symbol_utils.$getParent]());
                          trailer = trailer ? trailer[0] : null;
                        }
                        if (node.targetType === "pageArea") {
                          targetPageArea = node[_symbol_utils.$extra].target;
                          i = Infinity;
                        } else if (!node[_symbol_utils.$extra].target) {
                          i = node[_symbol_utils.$extra].index;
                        } else {
                          targetPageArea = node[_symbol_utils.$extra].target;
                          startIndex = node[_symbol_utils.$extra].index + 1;
                          i = Infinity;
                        }
                        continue;
                      }
                      if (this[_symbol_utils.$extra].overflowNode) {
                        const node = this[_symbol_utils.$extra].overflowNode;
                        this[_symbol_utils.$extra].overflowNode = null;
                        const overflowExtra = node[_symbol_utils.$getExtra]();
                        const target = overflowExtra.target;
                        overflowExtra.addLeader = overflowExtra.leader !== null;
                        overflowExtra.addTrailer = overflowExtra.trailer !== null;
                        flush(i);
                        const currentIndex = i;
                        i = Infinity;
                        if (target instanceof PageArea) {
                          targetPageArea = target;
                        } else if (target instanceof ContentArea) {
                          const index = contentAreas.indexOf(target);
                          if (index !== -1) {
                            if (index > currentIndex) {
                              i = index - 1;
                            } else {
                              startIndex = index;
                            }
                          } else {
                            targetPageArea = target[_symbol_utils.$getParent]();
                            startIndex = targetPageArea.contentArea.children.indexOf(target);
                          }
                        }
                        continue;
                      }
                      flush(i);
                    }
                    this[_symbol_utils.$extra].pageNumber += 1;
                    if (targetPageArea) {
                      if (targetPageArea[_symbol_utils.$isUsable]()) {
                        targetPageArea[_symbol_utils.$extra].numberOfUse += 1;
                      } else {
                        targetPageArea = null;
                      }
                    }
                    pageArea = targetPageArea || pageArea[_symbol_utils.$getNextPage]();
                    yield null;
                  }
                }
              }
              exports2.Template = Template;
              class Text extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "text");
                  this.id = attributes.id || "";
                  this.maxChars = (0, _utils.getInteger)({
                    data: attributes.maxChars,
                    defaultValue: 0,
                    validate: (x) => x >= 0
                  });
                  this.name = attributes.name || "";
                  this.rid = attributes.rid || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_symbol_utils.$acceptWhitespace]() {
                  return true;
                }
                [_symbol_utils.$onChild](child) {
                  if (child[_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.xhtml.id) {
                    this[_symbol_utils.$content] = child;
                    return true;
                  }
                  (0, _util.warn)(`XFA - Invalid content in Text: ${child[_symbol_utils.$nodeName]}.`);
                  return false;
                }
                [_symbol_utils.$onText](str) {
                  if (this[_symbol_utils.$content] instanceof _xfa_object.XFAObject) {
                    return;
                  }
                  super[_symbol_utils.$onText](str);
                }
                [_symbol_utils.$finalize]() {
                  if (typeof this[_symbol_utils.$content] === "string") {
                    this[_symbol_utils.$content] = this[_symbol_utils.$content].replaceAll("\r\n", "\n");
                  }
                }
                [_symbol_utils.$getExtra]() {
                  if (typeof this[_symbol_utils.$content] === "string") {
                    return this[_symbol_utils.$content].split(/[\u2029\u2028\n]/).reduce((acc, line) => {
                      if (line) {
                        acc.push(line);
                      }
                      return acc;
                    }, []).join("\n");
                  }
                  return this[_symbol_utils.$content][_symbol_utils.$text]();
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  if (typeof this[_symbol_utils.$content] === "string") {
                    const html = valueToHtml(this[_symbol_utils.$content]).html;
                    if (this[_symbol_utils.$content].includes("\u2029")) {
                      html.name = "div";
                      html.children = [];
                      this[_symbol_utils.$content].split("\u2029").map((para) => para.split(/[\u2028\n]/).reduce((acc, line) => {
                        acc.push({
                          name: "span",
                          value: line
                        }, {
                          name: "br"
                        });
                        return acc;
                      }, [])).forEach((lines) => {
                        html.children.push({
                          name: "p",
                          children: lines
                        });
                      });
                    } else if (/[\u2028\n]/.test(this[_symbol_utils.$content])) {
                      html.name = "div";
                      html.children = [];
                      this[_symbol_utils.$content].split(/[\u2028\n]/).forEach((line) => {
                        html.children.push({
                          name: "span",
                          value: line
                        }, {
                          name: "br"
                        });
                      });
                    }
                    return _utils.HTMLResult.success(html);
                  }
                  return this[_symbol_utils.$content][_symbol_utils.$toHTML](availableSpace);
                }
              }
              exports2.Text = Text;
              class TextEdit extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "textEdit", true);
                  this.allowRichText = (0, _utils.getInteger)({
                    data: attributes.allowRichText,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
                  this.id = attributes.id || "";
                  this.multiLine = (0, _utils.getInteger)({
                    data: attributes.multiLine,
                    defaultValue: "",
                    validate: (x) => x === 0 || x === 1
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.vScrollPolicy = (0, _utils.getStringOption)(attributes.vScrollPolicy, ["auto", "off", "on"]);
                  this.border = null;
                  this.comb = null;
                  this.extras = null;
                  this.margin = null;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  var _a, _b;
                  const style = (0, _html_utils.toStyle)(this, "border", "font", "margin");
                  let html;
                  const field = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
                  if (this.multiLine === "") {
                    this.multiLine = field instanceof Draw ? 1 : 0;
                  }
                  if (this.multiLine === 1) {
                    html = {
                      name: "textarea",
                      attributes: {
                        dataId: ((_a = field[_symbol_utils.$data]) == null ? void 0 : _a[_symbol_utils.$uid]) || field[_symbol_utils.$uid],
                        fieldId: field[_symbol_utils.$uid],
                        class: ["xfaTextfield"],
                        style,
                        "aria-label": ariaLabel(field),
                        "aria-required": false
                      }
                    };
                  } else {
                    html = {
                      name: "input",
                      attributes: {
                        type: "text",
                        dataId: ((_b = field[_symbol_utils.$data]) == null ? void 0 : _b[_symbol_utils.$uid]) || field[_symbol_utils.$uid],
                        fieldId: field[_symbol_utils.$uid],
                        class: ["xfaTextfield"],
                        style,
                        "aria-label": ariaLabel(field),
                        "aria-required": false
                      }
                    };
                  }
                  if (isRequired(field)) {
                    html.attributes["aria-required"] = true;
                    html.attributes.required = true;
                  }
                  return _utils.HTMLResult.success({
                    name: "label",
                    attributes: {
                      class: ["xfaLabel"]
                    },
                    children: [html]
                  });
                }
              }
              class Time extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "time");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_symbol_utils.$finalize]() {
                  const date = this[_symbol_utils.$content].trim();
                  this[_symbol_utils.$content] = date ? new Date(date) : null;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  return valueToHtml(this[_symbol_utils.$content] ? this[_symbol_utils.$content].toString() : "");
                }
              }
              class TimeStamp extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "timeStamp");
                  this.id = attributes.id || "";
                  this.server = attributes.server || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class ToolTip extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "toolTip");
                  this.id = attributes.id || "";
                  this.rid = attributes.rid || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class Traversal extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "traversal", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.traverse = new _xfa_object.XFAObjectArray();
                }
              }
              class Traverse extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "traverse", true);
                  this.id = attributes.id || "";
                  this.operation = (0, _utils.getStringOption)(attributes.operation, ["next", "back", "down", "first", "left", "right", "up"]);
                  this.ref = attributes.ref || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.script = null;
                }
                get name() {
                  return this.operation;
                }
                [_symbol_utils.$isTransparent]() {
                  return false;
                }
              }
              class Ui extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "ui", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.picture = null;
                  this.barcode = null;
                  this.button = null;
                  this.checkButton = null;
                  this.choiceList = null;
                  this.dateTimeEdit = null;
                  this.defaultUi = null;
                  this.imageEdit = null;
                  this.numericEdit = null;
                  this.passwordEdit = null;
                  this.signature = null;
                  this.textEdit = null;
                }
                [_symbol_utils.$getExtra]() {
                  if (this[_symbol_utils.$extra] === void 0) {
                    for (const name of Object.getOwnPropertyNames(this)) {
                      if (name === "extras" || name === "picture") {
                        continue;
                      }
                      const obj = this[name];
                      if (!(obj instanceof _xfa_object.XFAObject)) {
                        continue;
                      }
                      this[_symbol_utils.$extra] = obj;
                      return obj;
                    }
                    this[_symbol_utils.$extra] = null;
                  }
                  return this[_symbol_utils.$extra];
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  const obj = this[_symbol_utils.$getExtra]();
                  if (obj) {
                    return obj[_symbol_utils.$toHTML](availableSpace);
                  }
                  return _utils.HTMLResult.EMPTY;
                }
              }
              class Validate extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "validate", true);
                  this.formatTest = (0, _utils.getStringOption)(attributes.formatTest, ["warning", "disabled", "error"]);
                  this.id = attributes.id || "";
                  this.nullTest = (0, _utils.getStringOption)(attributes.nullTest, ["disabled", "error", "warning"]);
                  this.scriptTest = (0, _utils.getStringOption)(attributes.scriptTest, ["error", "disabled", "warning"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.message = null;
                  this.picture = null;
                  this.script = null;
                }
              }
              class Value extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "value", true);
                  this.id = attributes.id || "";
                  this.override = (0, _utils.getInteger)({
                    data: attributes.override,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.arc = null;
                  this.boolean = null;
                  this.date = null;
                  this.dateTime = null;
                  this.decimal = null;
                  this.exData = null;
                  this.float = null;
                  this.image = null;
                  this.integer = null;
                  this.line = null;
                  this.rectangle = null;
                  this.text = null;
                  this.time = null;
                }
                [_symbol_utils.$setValue](value) {
                  var _a;
                  const parent = this[_symbol_utils.$getParent]();
                  if (parent instanceof Field) {
                    if ((_a = parent.ui) == null ? void 0 : _a.imageEdit) {
                      if (!this.image) {
                        this.image = new Image({});
                        this[_symbol_utils.$appendChild](this.image);
                      }
                      this.image[_symbol_utils.$content] = value[_symbol_utils.$content];
                      return;
                    }
                  }
                  const valueName = value[_symbol_utils.$nodeName];
                  if (this[valueName] !== null) {
                    this[valueName][_symbol_utils.$content] = value[_symbol_utils.$content];
                    return;
                  }
                  for (const name of Object.getOwnPropertyNames(this)) {
                    const obj = this[name];
                    if (obj instanceof _xfa_object.XFAObject) {
                      this[name] = null;
                      this[_symbol_utils.$removeChild](obj);
                    }
                  }
                  this[value[_symbol_utils.$nodeName]] = value;
                  this[_symbol_utils.$appendChild](value);
                }
                [_symbol_utils.$text]() {
                  if (this.exData) {
                    if (typeof this.exData[_symbol_utils.$content] === "string") {
                      return this.exData[_symbol_utils.$content].trim();
                    }
                    return this.exData[_symbol_utils.$content][_symbol_utils.$text]().trim();
                  }
                  for (const name of Object.getOwnPropertyNames(this)) {
                    if (name === "image") {
                      continue;
                    }
                    const obj = this[name];
                    if (obj instanceof _xfa_object.XFAObject) {
                      return (obj[_symbol_utils.$content] || "").toString().trim();
                    }
                  }
                  return null;
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  for (const name of Object.getOwnPropertyNames(this)) {
                    const obj = this[name];
                    if (!(obj instanceof _xfa_object.XFAObject)) {
                      continue;
                    }
                    return obj[_symbol_utils.$toHTML](availableSpace);
                  }
                  return _utils.HTMLResult.EMPTY;
                }
              }
              exports2.Value = Value;
              class Variables extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "variables", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.boolean = new _xfa_object.XFAObjectArray();
                  this.date = new _xfa_object.XFAObjectArray();
                  this.dateTime = new _xfa_object.XFAObjectArray();
                  this.decimal = new _xfa_object.XFAObjectArray();
                  this.exData = new _xfa_object.XFAObjectArray();
                  this.float = new _xfa_object.XFAObjectArray();
                  this.image = new _xfa_object.XFAObjectArray();
                  this.integer = new _xfa_object.XFAObjectArray();
                  this.manifest = new _xfa_object.XFAObjectArray();
                  this.script = new _xfa_object.XFAObjectArray();
                  this.text = new _xfa_object.XFAObjectArray();
                  this.time = new _xfa_object.XFAObjectArray();
                }
                [_symbol_utils.$isTransparent]() {
                  return true;
                }
              }
              class TemplateNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (TemplateNamespace.hasOwnProperty(name)) {
                    const node = TemplateNamespace[name](attributes);
                    node[_symbol_utils.$setSetAttributes](attributes);
                    return node;
                  }
                  return void 0;
                }
                static appearanceFilter(attrs) {
                  return new AppearanceFilter(attrs);
                }
                static arc(attrs) {
                  return new Arc(attrs);
                }
                static area(attrs) {
                  return new Area(attrs);
                }
                static assist(attrs) {
                  return new Assist(attrs);
                }
                static barcode(attrs) {
                  return new Barcode(attrs);
                }
                static bind(attrs) {
                  return new Bind(attrs);
                }
                static bindItems(attrs) {
                  return new BindItems(attrs);
                }
                static bookend(attrs) {
                  return new Bookend(attrs);
                }
                static boolean(attrs) {
                  return new BooleanElement(attrs);
                }
                static border(attrs) {
                  return new Border(attrs);
                }
                static break(attrs) {
                  return new Break(attrs);
                }
                static breakAfter(attrs) {
                  return new BreakAfter(attrs);
                }
                static breakBefore(attrs) {
                  return new BreakBefore(attrs);
                }
                static button(attrs) {
                  return new Button(attrs);
                }
                static calculate(attrs) {
                  return new Calculate(attrs);
                }
                static caption(attrs) {
                  return new Caption(attrs);
                }
                static certificate(attrs) {
                  return new Certificate(attrs);
                }
                static certificates(attrs) {
                  return new Certificates(attrs);
                }
                static checkButton(attrs) {
                  return new CheckButton(attrs);
                }
                static choiceList(attrs) {
                  return new ChoiceList(attrs);
                }
                static color(attrs) {
                  return new Color(attrs);
                }
                static comb(attrs) {
                  return new Comb(attrs);
                }
                static connect(attrs) {
                  return new Connect(attrs);
                }
                static contentArea(attrs) {
                  return new ContentArea(attrs);
                }
                static corner(attrs) {
                  return new Corner(attrs);
                }
                static date(attrs) {
                  return new DateElement(attrs);
                }
                static dateTime(attrs) {
                  return new DateTime(attrs);
                }
                static dateTimeEdit(attrs) {
                  return new DateTimeEdit(attrs);
                }
                static decimal(attrs) {
                  return new Decimal(attrs);
                }
                static defaultUi(attrs) {
                  return new DefaultUi(attrs);
                }
                static desc(attrs) {
                  return new Desc(attrs);
                }
                static digestMethod(attrs) {
                  return new DigestMethod(attrs);
                }
                static digestMethods(attrs) {
                  return new DigestMethods(attrs);
                }
                static draw(attrs) {
                  return new Draw(attrs);
                }
                static edge(attrs) {
                  return new Edge(attrs);
                }
                static encoding(attrs) {
                  return new Encoding(attrs);
                }
                static encodings(attrs) {
                  return new Encodings(attrs);
                }
                static encrypt(attrs) {
                  return new Encrypt(attrs);
                }
                static encryptData(attrs) {
                  return new EncryptData(attrs);
                }
                static encryption(attrs) {
                  return new Encryption(attrs);
                }
                static encryptionMethod(attrs) {
                  return new EncryptionMethod(attrs);
                }
                static encryptionMethods(attrs) {
                  return new EncryptionMethods(attrs);
                }
                static event(attrs) {
                  return new Event(attrs);
                }
                static exData(attrs) {
                  return new ExData(attrs);
                }
                static exObject(attrs) {
                  return new ExObject(attrs);
                }
                static exclGroup(attrs) {
                  return new ExclGroup(attrs);
                }
                static execute(attrs) {
                  return new Execute(attrs);
                }
                static extras(attrs) {
                  return new Extras(attrs);
                }
                static field(attrs) {
                  return new Field(attrs);
                }
                static fill(attrs) {
                  return new Fill(attrs);
                }
                static filter(attrs) {
                  return new Filter(attrs);
                }
                static float(attrs) {
                  return new Float(attrs);
                }
                static font(attrs) {
                  return new Font(attrs);
                }
                static format(attrs) {
                  return new Format(attrs);
                }
                static handler(attrs) {
                  return new Handler(attrs);
                }
                static hyphenation(attrs) {
                  return new Hyphenation(attrs);
                }
                static image(attrs) {
                  return new Image(attrs);
                }
                static imageEdit(attrs) {
                  return new ImageEdit(attrs);
                }
                static integer(attrs) {
                  return new Integer(attrs);
                }
                static issuers(attrs) {
                  return new Issuers(attrs);
                }
                static items(attrs) {
                  return new Items(attrs);
                }
                static keep(attrs) {
                  return new Keep(attrs);
                }
                static keyUsage(attrs) {
                  return new KeyUsage(attrs);
                }
                static line(attrs) {
                  return new Line(attrs);
                }
                static linear(attrs) {
                  return new Linear(attrs);
                }
                static lockDocument(attrs) {
                  return new LockDocument(attrs);
                }
                static manifest(attrs) {
                  return new Manifest(attrs);
                }
                static margin(attrs) {
                  return new Margin(attrs);
                }
                static mdp(attrs) {
                  return new Mdp(attrs);
                }
                static medium(attrs) {
                  return new Medium(attrs);
                }
                static message(attrs) {
                  return new Message(attrs);
                }
                static numericEdit(attrs) {
                  return new NumericEdit(attrs);
                }
                static occur(attrs) {
                  return new Occur(attrs);
                }
                static oid(attrs) {
                  return new Oid(attrs);
                }
                static oids(attrs) {
                  return new Oids(attrs);
                }
                static overflow(attrs) {
                  return new Overflow(attrs);
                }
                static pageArea(attrs) {
                  return new PageArea(attrs);
                }
                static pageSet(attrs) {
                  return new PageSet(attrs);
                }
                static para(attrs) {
                  return new Para(attrs);
                }
                static passwordEdit(attrs) {
                  return new PasswordEdit(attrs);
                }
                static pattern(attrs) {
                  return new Pattern(attrs);
                }
                static picture(attrs) {
                  return new Picture(attrs);
                }
                static proto(attrs) {
                  return new Proto(attrs);
                }
                static radial(attrs) {
                  return new Radial(attrs);
                }
                static reason(attrs) {
                  return new Reason(attrs);
                }
                static reasons(attrs) {
                  return new Reasons(attrs);
                }
                static rectangle(attrs) {
                  return new Rectangle(attrs);
                }
                static ref(attrs) {
                  return new RefElement(attrs);
                }
                static script(attrs) {
                  return new Script(attrs);
                }
                static setProperty(attrs) {
                  return new SetProperty(attrs);
                }
                static signData(attrs) {
                  return new SignData(attrs);
                }
                static signature(attrs) {
                  return new Signature(attrs);
                }
                static signing(attrs) {
                  return new Signing(attrs);
                }
                static solid(attrs) {
                  return new Solid(attrs);
                }
                static speak(attrs) {
                  return new Speak(attrs);
                }
                static stipple(attrs) {
                  return new Stipple(attrs);
                }
                static subform(attrs) {
                  return new Subform(attrs);
                }
                static subformSet(attrs) {
                  return new SubformSet(attrs);
                }
                static subjectDN(attrs) {
                  return new SubjectDN(attrs);
                }
                static subjectDNs(attrs) {
                  return new SubjectDNs(attrs);
                }
                static submit(attrs) {
                  return new Submit(attrs);
                }
                static template(attrs) {
                  return new Template(attrs);
                }
                static text(attrs) {
                  return new Text(attrs);
                }
                static textEdit(attrs) {
                  return new TextEdit(attrs);
                }
                static time(attrs) {
                  return new Time(attrs);
                }
                static timeStamp(attrs) {
                  return new TimeStamp(attrs);
                }
                static toolTip(attrs) {
                  return new ToolTip(attrs);
                }
                static traversal(attrs) {
                  return new Traversal(attrs);
                }
                static traverse(attrs) {
                  return new Traverse(attrs);
                }
                static ui(attrs) {
                  return new Ui(attrs);
                }
                static validate(attrs) {
                  return new Validate(attrs);
                }
                static value(attrs) {
                  return new Value(attrs);
                }
                static variables(attrs) {
                  return new Variables(attrs);
                }
              }
              exports2.TemplateNamespace = TemplateNamespace;
            },
            /* 81 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NamespaceIds = exports2.$buildXFAObject = void 0;
              const $buildXFAObject = Symbol();
              exports2.$buildXFAObject = $buildXFAObject;
              const NamespaceIds = {
                config: {
                  id: 0,
                  check: (ns) => ns.startsWith("http://www.xfa.org/schema/xci/")
                },
                connectionSet: {
                  id: 1,
                  check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
                },
                datasets: {
                  id: 2,
                  check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-data/")
                },
                form: {
                  id: 3,
                  check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-form/")
                },
                localeSet: {
                  id: 4,
                  check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
                },
                pdf: {
                  id: 5,
                  check: (ns) => ns === "http://ns.adobe.com/xdp/pdf/"
                },
                signature: {
                  id: 6,
                  check: (ns) => ns === "http://www.w3.org/2000/09/xmldsig#"
                },
                sourceSet: {
                  id: 7,
                  check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-source-set/")
                },
                stylesheet: {
                  id: 8,
                  check: (ns) => ns === "http://www.w3.org/1999/XSL/Transform"
                },
                template: {
                  id: 9,
                  check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-template/")
                },
                xdc: {
                  id: 10,
                  check: (ns) => ns.startsWith("http://www.xfa.org/schema/xdc/")
                },
                xdp: {
                  id: 11,
                  check: (ns) => ns === "http://ns.adobe.com/xdp/"
                },
                xfdf: {
                  id: 12,
                  check: (ns) => ns === "http://ns.adobe.com/xfdf/"
                },
                xhtml: {
                  id: 13,
                  check: (ns) => ns === "http://www.w3.org/1999/xhtml"
                },
                xmpmeta: {
                  id: 14,
                  check: (ns) => ns === "http://ns.adobe.com/xmpmeta/"
                }
              };
              exports2.NamespaceIds = NamespaceIds;
            },
            /* 82 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.addHTML = addHTML;
              exports2.checkDimensions = checkDimensions;
              exports2.flushHTML = flushHTML;
              exports2.getAvailableSpace = getAvailableSpace;
              var _symbol_utils = __w_pdfjs_require__2(78);
              var _html_utils = __w_pdfjs_require__2(83);
              function createLine(node, children) {
                return {
                  name: "div",
                  attributes: {
                    class: [node.layout === "lr-tb" ? "xfaLr" : "xfaRl"]
                  },
                  children
                };
              }
              function flushHTML(node) {
                if (!node[_symbol_utils.$extra]) {
                  return null;
                }
                const attributes = node[_symbol_utils.$extra].attributes;
                const html = {
                  name: "div",
                  attributes,
                  children: node[_symbol_utils.$extra].children
                };
                if (node[_symbol_utils.$extra].failingNode) {
                  const htmlFromFailing = node[_symbol_utils.$extra].failingNode[_symbol_utils.$flushHTML]();
                  if (htmlFromFailing) {
                    if (node.layout.endsWith("-tb")) {
                      html.children.push(createLine(node, [htmlFromFailing]));
                    } else {
                      html.children.push(htmlFromFailing);
                    }
                  }
                }
                if (html.children.length === 0) {
                  return null;
                }
                return html;
              }
              function addHTML(node, html, bbox) {
                const extra = node[_symbol_utils.$extra];
                const availableSpace = extra.availableSpace;
                const [x, y, w, h] = bbox;
                switch (node.layout) {
                  case "position": {
                    extra.width = Math.max(extra.width, x + w);
                    extra.height = Math.max(extra.height, y + h);
                    extra.children.push(html);
                    break;
                  }
                  case "lr-tb":
                  case "rl-tb":
                    if (!extra.line || extra.attempt === 1) {
                      extra.line = createLine(node, []);
                      extra.children.push(extra.line);
                      extra.numberInLine = 0;
                    }
                    extra.numberInLine += 1;
                    extra.line.children.push(html);
                    if (extra.attempt === 0) {
                      extra.currentWidth += w;
                      extra.height = Math.max(extra.height, extra.prevHeight + h);
                    } else {
                      extra.currentWidth = w;
                      extra.prevHeight = extra.height;
                      extra.height += h;
                      extra.attempt = 0;
                    }
                    extra.width = Math.max(extra.width, extra.currentWidth);
                    break;
                  case "rl-row":
                  case "row": {
                    extra.children.push(html);
                    extra.width += w;
                    extra.height = Math.max(extra.height, h);
                    const height = (0, _html_utils.measureToString)(extra.height);
                    for (const child of extra.children) {
                      child.attributes.style.height = height;
                    }
                    break;
                  }
                  case "table": {
                    extra.width = Math.min(availableSpace.width, Math.max(extra.width, w));
                    extra.height += h;
                    extra.children.push(html);
                    break;
                  }
                  case "tb": {
                    extra.width = Math.min(availableSpace.width, Math.max(extra.width, w));
                    extra.height += h;
                    extra.children.push(html);
                    break;
                  }
                }
              }
              function getAvailableSpace(node) {
                const availableSpace = node[_symbol_utils.$extra].availableSpace;
                const marginV = node.margin ? node.margin.topInset + node.margin.bottomInset : 0;
                const marginH = node.margin ? node.margin.leftInset + node.margin.rightInset : 0;
                switch (node.layout) {
                  case "lr-tb":
                  case "rl-tb":
                    if (node[_symbol_utils.$extra].attempt === 0) {
                      return {
                        width: availableSpace.width - marginH - node[_symbol_utils.$extra].currentWidth,
                        height: availableSpace.height - marginV - node[_symbol_utils.$extra].prevHeight
                      };
                    }
                    return {
                      width: availableSpace.width - marginH,
                      height: availableSpace.height - marginV - node[_symbol_utils.$extra].height
                    };
                  case "rl-row":
                  case "row":
                    const width = node[_symbol_utils.$extra].columnWidths.slice(node[_symbol_utils.$extra].currentColumn).reduce((a, x) => a + x);
                    return {
                      width,
                      height: availableSpace.height - marginH
                    };
                  case "table":
                  case "tb":
                    return {
                      width: availableSpace.width - marginH,
                      height: availableSpace.height - marginV - node[_symbol_utils.$extra].height
                    };
                  case "position":
                  default:
                    return availableSpace;
                }
              }
              function getTransformedBBox(node) {
                let w = node.w === "" ? NaN : node.w;
                let h = node.h === "" ? NaN : node.h;
                let [centerX, centerY] = [0, 0];
                switch (node.anchorType || "") {
                  case "bottomCenter":
                    [centerX, centerY] = [w / 2, h];
                    break;
                  case "bottomLeft":
                    [centerX, centerY] = [0, h];
                    break;
                  case "bottomRight":
                    [centerX, centerY] = [w, h];
                    break;
                  case "middleCenter":
                    [centerX, centerY] = [w / 2, h / 2];
                    break;
                  case "middleLeft":
                    [centerX, centerY] = [0, h / 2];
                    break;
                  case "middleRight":
                    [centerX, centerY] = [w, h / 2];
                    break;
                  case "topCenter":
                    [centerX, centerY] = [w / 2, 0];
                    break;
                  case "topRight":
                    [centerX, centerY] = [w, 0];
                    break;
                }
                let x, y;
                switch (node.rotate || 0) {
                  case 0:
                    [x, y] = [-centerX, -centerY];
                    break;
                  case 90:
                    [x, y] = [-centerY, centerX];
                    [w, h] = [h, -w];
                    break;
                  case 180:
                    [x, y] = [centerX, centerY];
                    [w, h] = [-w, -h];
                    break;
                  case 270:
                    [x, y] = [centerY, -centerX];
                    [w, h] = [-h, w];
                    break;
                }
                return [node.x + x + Math.min(0, w), node.y + y + Math.min(0, h), Math.abs(w), Math.abs(h)];
              }
              function checkDimensions(node, space) {
                var _a;
                if (node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].firstUnsplittable === null) {
                  return true;
                }
                if (node.w === 0 || node.h === 0) {
                  return true;
                }
                const ERROR = 2;
                const parent = node[_symbol_utils.$getSubformParent]();
                const attempt = ((_a = parent[_symbol_utils.$extra]) == null ? void 0 : _a.attempt) || 0;
                const [, y, w, h] = getTransformedBBox(node);
                switch (parent.layout) {
                  case "lr-tb":
                  case "rl-tb":
                    if (attempt === 0) {
                      if (!node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
                        if (node.h !== "" && Math.round(h - space.height) > ERROR) {
                          return false;
                        }
                        if (node.w !== "") {
                          if (Math.round(w - space.width) <= ERROR) {
                            return true;
                          }
                          if (parent[_symbol_utils.$extra].numberInLine === 0) {
                            return space.height > ERROR;
                          }
                          return false;
                        }
                        return space.width > ERROR;
                      }
                      if (node.w !== "") {
                        return Math.round(w - space.width) <= ERROR;
                      }
                      return space.width > ERROR;
                    }
                    if (node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
                      return true;
                    }
                    if (node.h !== "" && Math.round(h - space.height) > ERROR) {
                      return false;
                    }
                    if (node.w === "" || Math.round(w - space.width) <= ERROR) {
                      return space.height > ERROR;
                    }
                    if (parent[_symbol_utils.$isThereMoreWidth]()) {
                      return false;
                    }
                    return space.height > ERROR;
                  case "table":
                  case "tb":
                    if (node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
                      return true;
                    }
                    if (node.h !== "" && !node[_symbol_utils.$isSplittable]()) {
                      return Math.round(h - space.height) <= ERROR;
                    }
                    if (node.w === "" || Math.round(w - space.width) <= ERROR) {
                      return space.height > ERROR;
                    }
                    if (parent[_symbol_utils.$isThereMoreWidth]()) {
                      return false;
                    }
                    return space.height > ERROR;
                  case "position":
                    if (node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
                      return true;
                    }
                    if (node.h === "" || Math.round(h + y - space.height) <= ERROR) {
                      return true;
                    }
                    const area = node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].currentContentArea;
                    return h + y > area.h;
                  case "rl-row":
                  case "row":
                    if (node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
                      return true;
                    }
                    if (node.h !== "") {
                      return Math.round(h - space.height) <= ERROR;
                    }
                    return true;
                  default:
                    return true;
                }
              }
            },
            /* 83 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.computeBbox = computeBbox;
              exports2.createWrapper = createWrapper;
              exports2.fixDimensions = fixDimensions;
              exports2.fixTextIndent = fixTextIndent;
              exports2.fixURL = fixURL;
              exports2.isPrintOnly = isPrintOnly;
              exports2.layoutClass = layoutClass;
              exports2.layoutNode = layoutNode;
              exports2.measureToString = measureToString;
              exports2.setAccess = setAccess;
              exports2.setFontFamily = setFontFamily;
              exports2.setMinMaxDimensions = setMinMaxDimensions;
              exports2.setPara = setPara;
              exports2.toStyle = toStyle;
              var _symbol_utils = __w_pdfjs_require__2(78);
              var _util = __w_pdfjs_require__2(2);
              var _utils = __w_pdfjs_require__2(84);
              var _fonts = __w_pdfjs_require__2(85);
              var _text = __w_pdfjs_require__2(86);
              var _xfa_object = __w_pdfjs_require__2(87);
              function measureToString(m) {
                if (typeof m === "string") {
                  return "0px";
                }
                return Number.isInteger(m) ? `${m}px` : `${m.toFixed(2)}px`;
              }
              const converters = {
                anchorType(node, style) {
                  const parent = node[_symbol_utils.$getSubformParent]();
                  if (!parent || parent.layout && parent.layout !== "position") {
                    return;
                  }
                  if (!("transform" in style)) {
                    style.transform = "";
                  }
                  switch (node.anchorType) {
                    case "bottomCenter":
                      style.transform += "translate(-50%, -100%)";
                      break;
                    case "bottomLeft":
                      style.transform += "translate(0,-100%)";
                      break;
                    case "bottomRight":
                      style.transform += "translate(-100%,-100%)";
                      break;
                    case "middleCenter":
                      style.transform += "translate(-50%,-50%)";
                      break;
                    case "middleLeft":
                      style.transform += "translate(0,-50%)";
                      break;
                    case "middleRight":
                      style.transform += "translate(-100%,-50%)";
                      break;
                    case "topCenter":
                      style.transform += "translate(-50%,0)";
                      break;
                    case "topRight":
                      style.transform += "translate(-100%,0)";
                      break;
                  }
                },
                dimensions(node, style) {
                  var _a;
                  const parent = node[_symbol_utils.$getSubformParent]();
                  let width = node.w;
                  const height = node.h;
                  if ((_a = parent.layout) == null ? void 0 : _a.includes("row")) {
                    const extra = parent[_symbol_utils.$extra];
                    const colSpan = node.colSpan;
                    let w;
                    if (colSpan === -1) {
                      w = extra.columnWidths.slice(extra.currentColumn).reduce((a, x) => a + x, 0);
                      extra.currentColumn = 0;
                    } else {
                      w = extra.columnWidths.slice(extra.currentColumn, extra.currentColumn + colSpan).reduce((a, x) => a + x, 0);
                      extra.currentColumn = (extra.currentColumn + node.colSpan) % extra.columnWidths.length;
                    }
                    if (!isNaN(w)) {
                      width = node.w = w;
                    }
                  }
                  style.width = width !== "" ? measureToString(width) : "auto";
                  style.height = height !== "" ? measureToString(height) : "auto";
                },
                position(node, style) {
                  const parent = node[_symbol_utils.$getSubformParent]();
                  if ((parent == null ? void 0 : parent.layout) && parent.layout !== "position") {
                    return;
                  }
                  style.position = "absolute";
                  style.left = measureToString(node.x);
                  style.top = measureToString(node.y);
                },
                rotate(node, style) {
                  if (node.rotate) {
                    if (!("transform" in style)) {
                      style.transform = "";
                    }
                    style.transform += `rotate(-${node.rotate}deg)`;
                    style.transformOrigin = "top left";
                  }
                },
                presence(node, style) {
                  switch (node.presence) {
                    case "invisible":
                      style.visibility = "hidden";
                      break;
                    case "hidden":
                    case "inactive":
                      style.display = "none";
                      break;
                  }
                },
                hAlign(node, style) {
                  if (node[_symbol_utils.$nodeName] === "para") {
                    switch (node.hAlign) {
                      case "justifyAll":
                        style.textAlign = "justify-all";
                        break;
                      case "radix":
                        style.textAlign = "left";
                        break;
                      default:
                        style.textAlign = node.hAlign;
                    }
                  } else {
                    switch (node.hAlign) {
                      case "left":
                        style.alignSelf = "start";
                        break;
                      case "center":
                        style.alignSelf = "center";
                        break;
                      case "right":
                        style.alignSelf = "end";
                        break;
                    }
                  }
                },
                margin(node, style) {
                  if (node.margin) {
                    style.margin = node.margin[_symbol_utils.$toStyle]().margin;
                  }
                }
              };
              function setMinMaxDimensions(node, style) {
                const parent = node[_symbol_utils.$getSubformParent]();
                if (parent.layout === "position") {
                  if (node.minW > 0) {
                    style.minWidth = measureToString(node.minW);
                  }
                  if (node.maxW > 0) {
                    style.maxWidth = measureToString(node.maxW);
                  }
                  if (node.minH > 0) {
                    style.minHeight = measureToString(node.minH);
                  }
                  if (node.maxH > 0) {
                    style.maxHeight = measureToString(node.maxH);
                  }
                }
              }
              function layoutText(text, xfaFont, margin, lineHeight, fontFinder, width) {
                const measure = new _text.TextMeasure(xfaFont, margin, lineHeight, fontFinder);
                if (typeof text === "string") {
                  measure.addString(text);
                } else {
                  text[_symbol_utils.$pushGlyphs](measure);
                }
                return measure.compute(width);
              }
              function layoutNode(node, availableSpace) {
                let height = null;
                let width = null;
                let isBroken = false;
                if ((!node.w || !node.h) && node.value) {
                  let marginH = 0;
                  let marginV = 0;
                  if (node.margin) {
                    marginH = node.margin.leftInset + node.margin.rightInset;
                    marginV = node.margin.topInset + node.margin.bottomInset;
                  }
                  let lineHeight = null;
                  let margin = null;
                  if (node.para) {
                    margin = /* @__PURE__ */ Object.create(null);
                    lineHeight = node.para.lineHeight === "" ? null : node.para.lineHeight;
                    margin.top = node.para.spaceAbove === "" ? 0 : node.para.spaceAbove;
                    margin.bottom = node.para.spaceBelow === "" ? 0 : node.para.spaceBelow;
                    margin.left = node.para.marginLeft === "" ? 0 : node.para.marginLeft;
                    margin.right = node.para.marginRight === "" ? 0 : node.para.marginRight;
                  }
                  let font = node.font;
                  if (!font) {
                    const root = node[_symbol_utils.$getTemplateRoot]();
                    let parent = node[_symbol_utils.$getParent]();
                    while (parent && parent !== root) {
                      if (parent.font) {
                        font = parent.font;
                        break;
                      }
                      parent = parent[_symbol_utils.$getParent]();
                    }
                  }
                  const maxWidth = (node.w || availableSpace.width) - marginH;
                  const fontFinder = node[_symbol_utils.$globalData].fontFinder;
                  if (node.value.exData && node.value.exData[_symbol_utils.$content] && node.value.exData.contentType === "text/html") {
                    const res = layoutText(node.value.exData[_symbol_utils.$content], font, margin, lineHeight, fontFinder, maxWidth);
                    width = res.width;
                    height = res.height;
                    isBroken = res.isBroken;
                  } else {
                    const text = node.value[_symbol_utils.$text]();
                    if (text) {
                      const res = layoutText(text, font, margin, lineHeight, fontFinder, maxWidth);
                      width = res.width;
                      height = res.height;
                      isBroken = res.isBroken;
                    }
                  }
                  if (width !== null && !node.w) {
                    width += marginH;
                  }
                  if (height !== null && !node.h) {
                    height += marginV;
                  }
                }
                return {
                  w: width,
                  h: height,
                  isBroken
                };
              }
              function computeBbox(node, html, availableSpace) {
                let bbox;
                if (node.w !== "" && node.h !== "") {
                  bbox = [node.x, node.y, node.w, node.h];
                } else {
                  if (!availableSpace) {
                    return null;
                  }
                  let width = node.w;
                  if (width === "") {
                    if (node.maxW === 0) {
                      const parent = node[_symbol_utils.$getSubformParent]();
                      width = parent.layout === "position" && parent.w !== "" ? 0 : node.minW;
                    } else {
                      width = Math.min(node.maxW, availableSpace.width);
                    }
                    html.attributes.style.width = measureToString(width);
                  }
                  let height = node.h;
                  if (height === "") {
                    if (node.maxH === 0) {
                      const parent = node[_symbol_utils.$getSubformParent]();
                      height = parent.layout === "position" && parent.h !== "" ? 0 : node.minH;
                    } else {
                      height = Math.min(node.maxH, availableSpace.height);
                    }
                    html.attributes.style.height = measureToString(height);
                  }
                  bbox = [node.x, node.y, width, height];
                }
                return bbox;
              }
              function fixDimensions(node) {
                var _a;
                const parent = node[_symbol_utils.$getSubformParent]();
                if ((_a = parent.layout) == null ? void 0 : _a.includes("row")) {
                  const extra = parent[_symbol_utils.$extra];
                  const colSpan = node.colSpan;
                  let width;
                  if (colSpan === -1) {
                    width = extra.columnWidths.slice(extra.currentColumn).reduce((a, w) => a + w, 0);
                  } else {
                    width = extra.columnWidths.slice(extra.currentColumn, extra.currentColumn + colSpan).reduce((a, w) => a + w, 0);
                  }
                  if (!isNaN(width)) {
                    node.w = width;
                  }
                }
                if (parent.layout && parent.layout !== "position") {
                  node.x = node.y = 0;
                }
                if (node.layout === "table") {
                  if (node.w === "" && Array.isArray(node.columnWidths)) {
                    node.w = node.columnWidths.reduce((a, x) => a + x, 0);
                  }
                }
              }
              function layoutClass(node) {
                switch (node.layout) {
                  case "position":
                    return "xfaPosition";
                  case "lr-tb":
                    return "xfaLrTb";
                  case "rl-row":
                    return "xfaRlRow";
                  case "rl-tb":
                    return "xfaRlTb";
                  case "row":
                    return "xfaRow";
                  case "table":
                    return "xfaTable";
                  case "tb":
                    return "xfaTb";
                  default:
                    return "xfaPosition";
                }
              }
              function toStyle(node, ...names) {
                const style = /* @__PURE__ */ Object.create(null);
                for (const name of names) {
                  const value = node[name];
                  if (value === null) {
                    continue;
                  }
                  if (converters.hasOwnProperty(name)) {
                    converters[name](node, style);
                    continue;
                  }
                  if (value instanceof _xfa_object.XFAObject) {
                    const newStyle = value[_symbol_utils.$toStyle]();
                    if (newStyle) {
                      Object.assign(style, newStyle);
                    } else {
                      (0, _util.warn)(`(DEBUG) - XFA - style for ${name} not implemented yet`);
                    }
                  }
                }
                return style;
              }
              function createWrapper(node, html) {
                const {
                  attributes
                } = html;
                const {
                  style
                } = attributes;
                const wrapper = {
                  name: "div",
                  attributes: {
                    class: ["xfaWrapper"],
                    style: /* @__PURE__ */ Object.create(null)
                  },
                  children: []
                };
                attributes.class.push("xfaWrapped");
                if (node.border) {
                  const {
                    widths,
                    insets
                  } = node.border[_symbol_utils.$extra];
                  let width, height;
                  let top = insets[0];
                  let left = insets[3];
                  const insetsH = insets[0] + insets[2];
                  const insetsW = insets[1] + insets[3];
                  switch (node.border.hand) {
                    case "even":
                      top -= widths[0] / 2;
                      left -= widths[3] / 2;
                      width = `calc(100% + ${(widths[1] + widths[3]) / 2 - insetsW}px)`;
                      height = `calc(100% + ${(widths[0] + widths[2]) / 2 - insetsH}px)`;
                      break;
                    case "left":
                      top -= widths[0];
                      left -= widths[3];
                      width = `calc(100% + ${widths[1] + widths[3] - insetsW}px)`;
                      height = `calc(100% + ${widths[0] + widths[2] - insetsH}px)`;
                      break;
                    case "right":
                      width = insetsW ? `calc(100% - ${insetsW}px)` : "100%";
                      height = insetsH ? `calc(100% - ${insetsH}px)` : "100%";
                      break;
                  }
                  const classNames = ["xfaBorder"];
                  if (isPrintOnly(node.border)) {
                    classNames.push("xfaPrintOnly");
                  }
                  const border = {
                    name: "div",
                    attributes: {
                      class: classNames,
                      style: {
                        top: `${top}px`,
                        left: `${left}px`,
                        width,
                        height
                      }
                    },
                    children: []
                  };
                  for (const key of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"]) {
                    if (style[key] !== void 0) {
                      border.attributes.style[key] = style[key];
                      delete style[key];
                    }
                  }
                  wrapper.children.push(border, html);
                } else {
                  wrapper.children.push(html);
                }
                for (const key of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"]) {
                  if (style[key] !== void 0) {
                    wrapper.attributes.style[key] = style[key];
                    delete style[key];
                  }
                }
                wrapper.attributes.style.position = style.position === "absolute" ? "absolute" : "relative";
                delete style.position;
                if (style.alignSelf) {
                  wrapper.attributes.style.alignSelf = style.alignSelf;
                  delete style.alignSelf;
                }
                return wrapper;
              }
              function fixTextIndent(styles) {
                const indent = (0, _utils.getMeasurement)(styles.textIndent, "0px");
                if (indent >= 0) {
                  return;
                }
                const align = styles.textAlign === "right" ? "right" : "left";
                const name = "padding" + (align === "left" ? "Left" : "Right");
                const padding = (0, _utils.getMeasurement)(styles[name], "0px");
                styles[name] = `${padding - indent}px`;
              }
              function setAccess(node, classNames) {
                switch (node.access) {
                  case "nonInteractive":
                    classNames.push("xfaNonInteractive");
                    break;
                  case "readOnly":
                    classNames.push("xfaReadOnly");
                    break;
                  case "protected":
                    classNames.push("xfaDisabled");
                    break;
                }
              }
              function isPrintOnly(node) {
                return node.relevant.length > 0 && !node.relevant[0].excluded && node.relevant[0].viewname === "print";
              }
              function getCurrentPara(node) {
                const stack = node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].paraStack;
                return stack.length ? stack.at(-1) : null;
              }
              function setPara(node, nodeStyle, value) {
                var _a;
                if ((_a = value.attributes.class) == null ? void 0 : _a.includes("xfaRich")) {
                  if (nodeStyle) {
                    if (node.h === "") {
                      nodeStyle.height = "auto";
                    }
                    if (node.w === "") {
                      nodeStyle.width = "auto";
                    }
                  }
                  const para = getCurrentPara(node);
                  if (para) {
                    const valueStyle = value.attributes.style;
                    valueStyle.display = "flex";
                    valueStyle.flexDirection = "column";
                    switch (para.vAlign) {
                      case "top":
                        valueStyle.justifyContent = "start";
                        break;
                      case "bottom":
                        valueStyle.justifyContent = "end";
                        break;
                      case "middle":
                        valueStyle.justifyContent = "center";
                        break;
                    }
                    const paraStyle = para[_symbol_utils.$toStyle]();
                    for (const [key, val] of Object.entries(paraStyle)) {
                      if (!(key in valueStyle)) {
                        valueStyle[key] = val;
                      }
                    }
                  }
                }
              }
              function setFontFamily(xfaFont, node, fontFinder, style) {
                if (!fontFinder) {
                  delete style.fontFamily;
                  return;
                }
                const name = (0, _utils.stripQuotes)(xfaFont.typeface);
                style.fontFamily = `"${name}"`;
                const typeface = fontFinder.find(name);
                if (typeface) {
                  const {
                    fontFamily
                  } = typeface.regular.cssFontInfo;
                  if (fontFamily !== name) {
                    style.fontFamily = `"${fontFamily}"`;
                  }
                  const para = getCurrentPara(node);
                  if (para && para.lineHeight !== "") {
                    return;
                  }
                  if (style.lineHeight) {
                    return;
                  }
                  const pdfFont = (0, _fonts.selectFont)(xfaFont, typeface);
                  if (pdfFont) {
                    style.lineHeight = Math.max(1.2, pdfFont.lineHeight);
                  }
                }
              }
              function fixURL(str) {
                const absoluteUrl = (0, _util.createValidAbsoluteUrl)(str, null, {
                  addDefaultProtocol: true,
                  tryConvertEncoding: true
                });
                return absoluteUrl ? absoluteUrl.href : null;
              }
            },
            /* 84 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.HTMLResult = void 0;
              exports2.getBBox = getBBox;
              exports2.getColor = getColor;
              exports2.getFloat = getFloat;
              exports2.getInteger = getInteger;
              exports2.getKeyword = getKeyword;
              exports2.getMeasurement = getMeasurement;
              exports2.getRatio = getRatio;
              exports2.getRelevant = getRelevant;
              exports2.getStringOption = getStringOption;
              exports2.stripQuotes = stripQuotes;
              var _util = __w_pdfjs_require__2(2);
              const dimConverters = {
                pt: (x) => x,
                cm: (x) => x / 2.54 * 72,
                mm: (x) => x / (10 * 2.54) * 72,
                in: (x) => x * 72,
                px: (x) => x
              };
              const measurementPattern = /([+-]?\d+\.?\d*)(.*)/;
              function stripQuotes(str) {
                if (str.startsWith("'") || str.startsWith('"')) {
                  return str.slice(1, -1);
                }
                return str;
              }
              function getInteger({
                data,
                defaultValue,
                validate
              }) {
                if (!data) {
                  return defaultValue;
                }
                data = data.trim();
                const n = parseInt(data, 10);
                if (!isNaN(n) && validate(n)) {
                  return n;
                }
                return defaultValue;
              }
              function getFloat({
                data,
                defaultValue,
                validate
              }) {
                if (!data) {
                  return defaultValue;
                }
                data = data.trim();
                const n = parseFloat(data);
                if (!isNaN(n) && validate(n)) {
                  return n;
                }
                return defaultValue;
              }
              function getKeyword({
                data,
                defaultValue,
                validate
              }) {
                if (!data) {
                  return defaultValue;
                }
                data = data.trim();
                if (validate(data)) {
                  return data;
                }
                return defaultValue;
              }
              function getStringOption(data, options) {
                return getKeyword({
                  data,
                  defaultValue: options[0],
                  validate: (k) => options.includes(k)
                });
              }
              function getMeasurement(str, def = "0") {
                def || (def = "0");
                if (!str) {
                  return getMeasurement(def);
                }
                const match = str.trim().match(measurementPattern);
                if (!match) {
                  return getMeasurement(def);
                }
                const [, valueStr, unit] = match;
                const value = parseFloat(valueStr);
                if (isNaN(value)) {
                  return getMeasurement(def);
                }
                if (value === 0) {
                  return 0;
                }
                const conv = dimConverters[unit];
                if (conv) {
                  return conv(value);
                }
                return value;
              }
              function getRatio(data) {
                if (!data) {
                  return {
                    num: 1,
                    den: 1
                  };
                }
                const ratio = data.trim().split(/\s*:\s*/).map((x) => parseFloat(x)).filter((x) => !isNaN(x));
                if (ratio.length === 1) {
                  ratio.push(1);
                }
                if (ratio.length === 0) {
                  return {
                    num: 1,
                    den: 1
                  };
                }
                const [num, den] = ratio;
                return {
                  num,
                  den
                };
              }
              function getRelevant(data) {
                if (!data) {
                  return [];
                }
                return data.trim().split(/\s+/).map((e) => {
                  return {
                    excluded: e[0] === "-",
                    viewname: e.substring(1)
                  };
                });
              }
              function getColor(data, def = [0, 0, 0]) {
                let [r, g, b] = def;
                if (!data) {
                  return {
                    r,
                    g,
                    b
                  };
                }
                const color = data.trim().split(/\s*,\s*/).map((c) => Math.min(Math.max(0, parseInt(c.trim(), 10)), 255)).map((c) => isNaN(c) ? 0 : c);
                if (color.length < 3) {
                  return {
                    r,
                    g,
                    b
                  };
                }
                [r, g, b] = color;
                return {
                  r,
                  g,
                  b
                };
              }
              function getBBox(data) {
                const def = -1;
                if (!data) {
                  return {
                    x: def,
                    y: def,
                    width: def,
                    height: def
                  };
                }
                const bbox = data.trim().split(/\s*,\s*/).map((m) => getMeasurement(m, "-1"));
                if (bbox.length < 4 || bbox[2] < 0 || bbox[3] < 0) {
                  return {
                    x: def,
                    y: def,
                    width: def,
                    height: def
                  };
                }
                const [x, y, width, height] = bbox;
                return {
                  x,
                  y,
                  width,
                  height
                };
              }
              class HTMLResult {
                static get FAILURE() {
                  return (0, _util.shadow)(this, "FAILURE", new HTMLResult(false, null, null, null));
                }
                static get EMPTY() {
                  return (0, _util.shadow)(this, "EMPTY", new HTMLResult(true, null, null, null));
                }
                constructor(success, html, bbox, breakNode) {
                  this.success = success;
                  this.html = html;
                  this.bbox = bbox;
                  this.breakNode = breakNode;
                }
                isBreak() {
                  return !!this.breakNode;
                }
                static breakNode(node) {
                  return new HTMLResult(false, null, null, node);
                }
                static success(html, bbox = null) {
                  return new HTMLResult(true, html, bbox, null);
                }
              }
              exports2.HTMLResult = HTMLResult;
            },
            /* 85 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FontFinder = void 0;
              exports2.getMetrics = getMetrics;
              exports2.selectFont = selectFont;
              var _symbol_utils = __w_pdfjs_require__2(78);
              var _utils = __w_pdfjs_require__2(84);
              var _util = __w_pdfjs_require__2(2);
              class FontFinder {
                constructor(pdfFonts) {
                  this.fonts = /* @__PURE__ */ new Map();
                  this.cache = /* @__PURE__ */ new Map();
                  this.warned = /* @__PURE__ */ new Set();
                  this.defaultFont = null;
                  this.add(pdfFonts);
                }
                add(pdfFonts, reallyMissingFonts = null) {
                  for (const pdfFont of pdfFonts) {
                    this.addPdfFont(pdfFont);
                  }
                  for (const pdfFont of this.fonts.values()) {
                    if (!pdfFont.regular) {
                      pdfFont.regular = pdfFont.italic || pdfFont.bold || pdfFont.bolditalic;
                    }
                  }
                  if (!reallyMissingFonts || reallyMissingFonts.size === 0) {
                    return;
                  }
                  const myriad = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
                  for (const missing of reallyMissingFonts) {
                    this.fonts.set(missing, myriad);
                  }
                }
                addPdfFont(pdfFont) {
                  var _a, _b, _c;
                  const cssFontInfo = pdfFont.cssFontInfo;
                  const name = cssFontInfo.fontFamily;
                  let font = this.fonts.get(name);
                  if (!font) {
                    font = /* @__PURE__ */ Object.create(null);
                    this.fonts.set(name, font);
                    if (!this.defaultFont) {
                      this.defaultFont = font;
                    }
                  }
                  let property = "";
                  const fontWeight = parseFloat(cssFontInfo.fontWeight);
                  if (parseFloat(cssFontInfo.italicAngle) !== 0) {
                    property = fontWeight >= 700 ? "bolditalic" : "italic";
                  } else if (fontWeight >= 700) {
                    property = "bold";
                  }
                  if (!property) {
                    if (pdfFont.name.includes("Bold") || ((_a = pdfFont.psName) == null ? void 0 : _a.includes("Bold"))) {
                      property = "bold";
                    }
                    if (pdfFont.name.includes("Italic") || pdfFont.name.endsWith("It") || ((_b = pdfFont.psName) == null ? void 0 : _b.includes("Italic")) || ((_c = pdfFont.psName) == null ? void 0 : _c.endsWith("It"))) {
                      property += "italic";
                    }
                  }
                  if (!property) {
                    property = "regular";
                  }
                  font[property] = pdfFont;
                }
                getDefault() {
                  return this.defaultFont;
                }
                find(fontName, mustWarn = true) {
                  var _a, _b;
                  let font = this.fonts.get(fontName) || this.cache.get(fontName);
                  if (font) {
                    return font;
                  }
                  const pattern = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
                  let name = fontName.replaceAll(pattern, "");
                  font = this.fonts.get(name);
                  if (font) {
                    this.cache.set(fontName, font);
                    return font;
                  }
                  name = name.toLowerCase();
                  const maybe = [];
                  for (const [family, pdfFont] of this.fonts.entries()) {
                    if (family.replaceAll(pattern, "").toLowerCase().startsWith(name)) {
                      maybe.push(pdfFont);
                    }
                  }
                  if (maybe.length === 0) {
                    for (const [, pdfFont] of this.fonts.entries()) {
                      if ((_a = pdfFont.regular.name) == null ? void 0 : _a.replaceAll(pattern, "").toLowerCase().startsWith(name)) {
                        maybe.push(pdfFont);
                      }
                    }
                  }
                  if (maybe.length === 0) {
                    name = name.replaceAll(/psmt|mt/gi, "");
                    for (const [family, pdfFont] of this.fonts.entries()) {
                      if (family.replaceAll(pattern, "").toLowerCase().startsWith(name)) {
                        maybe.push(pdfFont);
                      }
                    }
                  }
                  if (maybe.length === 0) {
                    for (const pdfFont of this.fonts.values()) {
                      if ((_b = pdfFont.regular.name) == null ? void 0 : _b.replaceAll(pattern, "").toLowerCase().startsWith(name)) {
                        maybe.push(pdfFont);
                      }
                    }
                  }
                  if (maybe.length >= 1) {
                    if (maybe.length !== 1 && mustWarn) {
                      (0, _util.warn)(`XFA - Too many choices to guess the correct font: ${fontName}`);
                    }
                    this.cache.set(fontName, maybe[0]);
                    return maybe[0];
                  }
                  if (mustWarn && !this.warned.has(fontName)) {
                    this.warned.add(fontName);
                    (0, _util.warn)(`XFA - Cannot find the font: ${fontName}`);
                  }
                  return null;
                }
              }
              exports2.FontFinder = FontFinder;
              function selectFont(xfaFont, typeface) {
                if (xfaFont.posture === "italic") {
                  if (xfaFont.weight === "bold") {
                    return typeface.bolditalic;
                  }
                  return typeface.italic;
                } else if (xfaFont.weight === "bold") {
                  return typeface.bold;
                }
                return typeface.regular;
              }
              function getMetrics(xfaFont, real = false) {
                let pdfFont = null;
                if (xfaFont) {
                  const name = (0, _utils.stripQuotes)(xfaFont.typeface);
                  const typeface = xfaFont[_symbol_utils.$globalData].fontFinder.find(name);
                  pdfFont = selectFont(xfaFont, typeface);
                }
                if (!pdfFont) {
                  return {
                    lineHeight: 12,
                    lineGap: 2,
                    lineNoGap: 10
                  };
                }
                const size = xfaFont.size || 10;
                const lineHeight = pdfFont.lineHeight ? Math.max(real ? 0 : 1.2, pdfFont.lineHeight) : 1.2;
                const lineGap = pdfFont.lineGap === void 0 ? 0.2 : pdfFont.lineGap;
                return {
                  lineHeight: lineHeight * size,
                  lineGap: lineGap * size,
                  lineNoGap: Math.max(1, lineHeight - lineGap) * size
                };
              }
            },
            /* 86 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TextMeasure = void 0;
              var _fonts = __w_pdfjs_require__2(85);
              const WIDTH_FACTOR = 1.02;
              class FontInfo {
                constructor(xfaFont, margin, lineHeight, fontFinder) {
                  this.lineHeight = lineHeight;
                  this.paraMargin = margin || {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0
                  };
                  if (!xfaFont) {
                    [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);
                    return;
                  }
                  this.xfaFont = {
                    typeface: xfaFont.typeface,
                    posture: xfaFont.posture,
                    weight: xfaFont.weight,
                    size: xfaFont.size,
                    letterSpacing: xfaFont.letterSpacing
                  };
                  const typeface = fontFinder.find(xfaFont.typeface);
                  if (!typeface) {
                    [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);
                    return;
                  }
                  this.pdfFont = (0, _fonts.selectFont)(xfaFont, typeface);
                  if (!this.pdfFont) {
                    [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);
                  }
                }
                defaultFont(fontFinder) {
                  const font = fontFinder.find("Helvetica", false) || fontFinder.find("Myriad Pro", false) || fontFinder.find("Arial", false) || fontFinder.getDefault();
                  if (font == null ? void 0 : font.regular) {
                    const pdfFont = font.regular;
                    const info = pdfFont.cssFontInfo;
                    const xfaFont2 = {
                      typeface: info.fontFamily,
                      posture: "normal",
                      weight: "normal",
                      size: 10,
                      letterSpacing: 0
                    };
                    return [pdfFont, xfaFont2];
                  }
                  const xfaFont = {
                    typeface: "Courier",
                    posture: "normal",
                    weight: "normal",
                    size: 10,
                    letterSpacing: 0
                  };
                  return [null, xfaFont];
                }
              }
              class FontSelector {
                constructor(defaultXfaFont, defaultParaMargin, defaultLineHeight, fontFinder) {
                  this.fontFinder = fontFinder;
                  this.stack = [new FontInfo(defaultXfaFont, defaultParaMargin, defaultLineHeight, fontFinder)];
                }
                pushData(xfaFont, margin, lineHeight) {
                  const lastFont = this.stack.at(-1);
                  for (const name of ["typeface", "posture", "weight", "size", "letterSpacing"]) {
                    if (!xfaFont[name]) {
                      xfaFont[name] = lastFont.xfaFont[name];
                    }
                  }
                  for (const name of ["top", "bottom", "left", "right"]) {
                    if (isNaN(margin[name])) {
                      margin[name] = lastFont.paraMargin[name];
                    }
                  }
                  const fontInfo = new FontInfo(xfaFont, margin, lineHeight || lastFont.lineHeight, this.fontFinder);
                  if (!fontInfo.pdfFont) {
                    fontInfo.pdfFont = lastFont.pdfFont;
                  }
                  this.stack.push(fontInfo);
                }
                popFont() {
                  this.stack.pop();
                }
                topFont() {
                  return this.stack.at(-1);
                }
              }
              class TextMeasure {
                constructor(defaultXfaFont, defaultParaMargin, defaultLineHeight, fonts) {
                  this.glyphs = [];
                  this.fontSelector = new FontSelector(defaultXfaFont, defaultParaMargin, defaultLineHeight, fonts);
                  this.extraHeight = 0;
                }
                pushData(xfaFont, margin, lineHeight) {
                  this.fontSelector.pushData(xfaFont, margin, lineHeight);
                }
                popFont(xfaFont) {
                  return this.fontSelector.popFont();
                }
                addPara() {
                  const lastFont = this.fontSelector.topFont();
                  this.extraHeight += lastFont.paraMargin.top + lastFont.paraMargin.bottom;
                }
                addString(str) {
                  if (!str) {
                    return;
                  }
                  const lastFont = this.fontSelector.topFont();
                  const fontSize = lastFont.xfaFont.size;
                  if (lastFont.pdfFont) {
                    const letterSpacing = lastFont.xfaFont.letterSpacing;
                    const pdfFont = lastFont.pdfFont;
                    const fontLineHeight = pdfFont.lineHeight || 1.2;
                    const lineHeight = lastFont.lineHeight || Math.max(1.2, fontLineHeight) * fontSize;
                    const lineGap = pdfFont.lineGap === void 0 ? 0.2 : pdfFont.lineGap;
                    const noGap = fontLineHeight - lineGap;
                    const firstLineHeight = Math.max(1, noGap) * fontSize;
                    const scale = fontSize / 1e3;
                    const fallbackWidth = pdfFont.defaultWidth || pdfFont.charsToGlyphs(" ")[0].width;
                    for (const line of str.split(/[\u2029\n]/)) {
                      const encodedLine = pdfFont.encodeString(line).join("");
                      const glyphs = pdfFont.charsToGlyphs(encodedLine);
                      for (const glyph of glyphs) {
                        const width = glyph.width || fallbackWidth;
                        this.glyphs.push([width * scale + letterSpacing, lineHeight, firstLineHeight, glyph.unicode, false]);
                      }
                      this.glyphs.push([0, 0, 0, "\n", true]);
                    }
                    this.glyphs.pop();
                    return;
                  }
                  for (const line of str.split(/[\u2029\n]/)) {
                    for (const char of line.split("")) {
                      this.glyphs.push([fontSize, 1.2 * fontSize, fontSize, char, false]);
                    }
                    this.glyphs.push([0, 0, 0, "\n", true]);
                  }
                  this.glyphs.pop();
                }
                compute(maxWidth) {
                  let lastSpacePos = -1, lastSpaceWidth = 0, width = 0, height = 0, currentLineWidth = 0, currentLineHeight = 0;
                  let isBroken = false;
                  let isFirstLine = true;
                  for (let i = 0, ii = this.glyphs.length; i < ii; i++) {
                    const [glyphWidth, lineHeight, firstLineHeight, char, isEOL] = this.glyphs[i];
                    const isSpace = char === " ";
                    const glyphHeight = isFirstLine ? firstLineHeight : lineHeight;
                    if (isEOL) {
                      width = Math.max(width, currentLineWidth);
                      currentLineWidth = 0;
                      height += currentLineHeight;
                      currentLineHeight = glyphHeight;
                      lastSpacePos = -1;
                      lastSpaceWidth = 0;
                      isFirstLine = false;
                      continue;
                    }
                    if (isSpace) {
                      if (currentLineWidth + glyphWidth > maxWidth) {
                        width = Math.max(width, currentLineWidth);
                        currentLineWidth = 0;
                        height += currentLineHeight;
                        currentLineHeight = glyphHeight;
                        lastSpacePos = -1;
                        lastSpaceWidth = 0;
                        isBroken = true;
                        isFirstLine = false;
                      } else {
                        currentLineHeight = Math.max(glyphHeight, currentLineHeight);
                        lastSpaceWidth = currentLineWidth;
                        currentLineWidth += glyphWidth;
                        lastSpacePos = i;
                      }
                      continue;
                    }
                    if (currentLineWidth + glyphWidth > maxWidth) {
                      height += currentLineHeight;
                      currentLineHeight = glyphHeight;
                      if (lastSpacePos !== -1) {
                        i = lastSpacePos;
                        width = Math.max(width, lastSpaceWidth);
                        currentLineWidth = 0;
                        lastSpacePos = -1;
                        lastSpaceWidth = 0;
                      } else {
                        width = Math.max(width, currentLineWidth);
                        currentLineWidth = glyphWidth;
                      }
                      isBroken = true;
                      isFirstLine = false;
                      continue;
                    }
                    currentLineWidth += glyphWidth;
                    currentLineHeight = Math.max(glyphHeight, currentLineHeight);
                  }
                  width = Math.max(width, currentLineWidth);
                  height += currentLineHeight + this.extraHeight;
                  return {
                    width: WIDTH_FACTOR * width,
                    height,
                    isBroken
                  };
                }
              }
              exports2.TextMeasure = TextMeasure;
            },
            /* 87 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XmlObject = exports2.XFAObjectArray = exports2.XFAObject = exports2.XFAAttribute = exports2.StringObject = exports2.OptionObject = exports2.Option10 = exports2.Option01 = exports2.IntegerObject = exports2.ContentObject = void 0;
              var _symbol_utils = __w_pdfjs_require__2(78);
              var _utils = __w_pdfjs_require__2(84);
              var _util = __w_pdfjs_require__2(2);
              var _core_utils = __w_pdfjs_require__2(3);
              var _namespaces = __w_pdfjs_require__2(81);
              var _som = __w_pdfjs_require__2(88);
              const _applyPrototype = Symbol();
              const _attributes = Symbol();
              const _attributeNames = Symbol();
              const _children = Symbol("_children");
              const _cloneAttribute = Symbol();
              const _dataValue = Symbol();
              const _defaultValue = Symbol();
              const _filteredChildrenGenerator = Symbol();
              const _getPrototype = Symbol();
              const _getUnsetAttributes = Symbol();
              const _hasChildren = Symbol();
              const _max = Symbol();
              const _options = Symbol();
              const _parent = Symbol("parent");
              const _resolvePrototypesHelper = Symbol();
              const _setAttributes = Symbol();
              const _validator = Symbol();
              let uid = 0;
              const NS_DATASETS = _namespaces.NamespaceIds.datasets.id;
              class XFAObject {
                constructor(nsId, name, hasChildren = false) {
                  this[_symbol_utils.$namespaceId] = nsId;
                  this[_symbol_utils.$nodeName] = name;
                  this[_hasChildren] = hasChildren;
                  this[_parent] = null;
                  this[_children] = [];
                  this[_symbol_utils.$uid] = `${name}${uid++}`;
                  this[_symbol_utils.$globalData] = null;
                }
                get isXFAObject() {
                  return true;
                }
                get isXFAObjectArray() {
                  return false;
                }
                createNodes(path) {
                  let root = this, node = null;
                  for (const {
                    name,
                    index
                  } of path) {
                    for (let i = 0, ii = isFinite(index) ? index : 0; i <= ii; i++) {
                      const nsId = root[_symbol_utils.$namespaceId] === NS_DATASETS ? -1 : root[_symbol_utils.$namespaceId];
                      node = new XmlObject(nsId, name);
                      root[_symbol_utils.$appendChild](node);
                    }
                    root = node;
                  }
                  return node;
                }
                [_symbol_utils.$onChild](child) {
                  if (!this[_hasChildren] || !this[_symbol_utils.$onChildCheck](child)) {
                    return false;
                  }
                  const name = child[_symbol_utils.$nodeName];
                  const node = this[name];
                  if (node instanceof XFAObjectArray) {
                    if (node.push(child)) {
                      this[_symbol_utils.$appendChild](child);
                      return true;
                    }
                  } else {
                    if (node !== null) {
                      this[_symbol_utils.$removeChild](node);
                    }
                    this[name] = child;
                    this[_symbol_utils.$appendChild](child);
                    return true;
                  }
                  let id = "";
                  if (this.id) {
                    id = ` (id: ${this.id})`;
                  } else if (this.name) {
                    id = ` (name: ${this.name} ${this.h.value})`;
                  }
                  (0, _util.warn)(`XFA - node "${this[_symbol_utils.$nodeName]}"${id} has already enough "${name}"!`);
                  return false;
                }
                [_symbol_utils.$onChildCheck](child) {
                  return this.hasOwnProperty(child[_symbol_utils.$nodeName]) && child[_symbol_utils.$namespaceId] === this[_symbol_utils.$namespaceId];
                }
                [_symbol_utils.$isNsAgnostic]() {
                  return false;
                }
                [_symbol_utils.$acceptWhitespace]() {
                  return false;
                }
                [_symbol_utils.$isCDATAXml]() {
                  return false;
                }
                [_symbol_utils.$isBindable]() {
                  return false;
                }
                [_symbol_utils.$popPara]() {
                  if (this.para) {
                    this[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].paraStack.pop();
                  }
                }
                [_symbol_utils.$pushPara]() {
                  this[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].paraStack.push(this.para);
                }
                [_symbol_utils.$setId](ids) {
                  if (this.id && this[_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.template.id) {
                    ids.set(this.id, this);
                  }
                }
                [_symbol_utils.$getTemplateRoot]() {
                  return this[_symbol_utils.$globalData].template;
                }
                [_symbol_utils.$isSplittable]() {
                  return false;
                }
                [_symbol_utils.$isThereMoreWidth]() {
                  return false;
                }
                [_symbol_utils.$appendChild](child) {
                  child[_parent] = this;
                  this[_children].push(child);
                  if (!child[_symbol_utils.$globalData] && this[_symbol_utils.$globalData]) {
                    child[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
                  }
                }
                [_symbol_utils.$removeChild](child) {
                  const i = this[_children].indexOf(child);
                  this[_children].splice(i, 1);
                }
                [_symbol_utils.$hasSettableValue]() {
                  return this.hasOwnProperty("value");
                }
                [_symbol_utils.$setValue](_) {
                }
                [_symbol_utils.$onText](_) {
                }
                [_symbol_utils.$finalize]() {
                }
                [_symbol_utils.$clean](builder) {
                  delete this[_hasChildren];
                  if (this[_symbol_utils.$cleanup]) {
                    builder.clean(this[_symbol_utils.$cleanup]);
                    delete this[_symbol_utils.$cleanup];
                  }
                }
                [_symbol_utils.$indexOf](child) {
                  return this[_children].indexOf(child);
                }
                [_symbol_utils.$insertAt](i, child) {
                  child[_parent] = this;
                  this[_children].splice(i, 0, child);
                  if (!child[_symbol_utils.$globalData] && this[_symbol_utils.$globalData]) {
                    child[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
                  }
                }
                [_symbol_utils.$isTransparent]() {
                  return !this.name;
                }
                [_symbol_utils.$lastAttribute]() {
                  return "";
                }
                [_symbol_utils.$text]() {
                  if (this[_children].length === 0) {
                    return this[_symbol_utils.$content];
                  }
                  return this[_children].map((c) => c[_symbol_utils.$text]()).join("");
                }
                get [_attributeNames]() {
                  const proto = Object.getPrototypeOf(this);
                  if (!proto._attributes) {
                    const attributes = proto._attributes = /* @__PURE__ */ new Set();
                    for (const name of Object.getOwnPropertyNames(this)) {
                      if (this[name] === null || this[name] instanceof XFAObject || this[name] instanceof XFAObjectArray) {
                        break;
                      }
                      attributes.add(name);
                    }
                  }
                  return (0, _util.shadow)(this, _attributeNames, proto._attributes);
                }
                [_symbol_utils.$isDescendent](parent) {
                  let node = this;
                  while (node) {
                    if (node === parent) {
                      return true;
                    }
                    node = node[_symbol_utils.$getParent]();
                  }
                  return false;
                }
                [_symbol_utils.$getParent]() {
                  return this[_parent];
                }
                [_symbol_utils.$getSubformParent]() {
                  return this[_symbol_utils.$getParent]();
                }
                [_symbol_utils.$getChildren](name = null) {
                  if (!name) {
                    return this[_children];
                  }
                  return this[name];
                }
                [_symbol_utils.$dump]() {
                  const dumped = /* @__PURE__ */ Object.create(null);
                  if (this[_symbol_utils.$content]) {
                    dumped.$content = this[_symbol_utils.$content];
                  }
                  for (const name of Object.getOwnPropertyNames(this)) {
                    const value = this[name];
                    if (value === null) {
                      continue;
                    }
                    if (value instanceof XFAObject) {
                      dumped[name] = value[_symbol_utils.$dump]();
                    } else if (value instanceof XFAObjectArray) {
                      if (!value.isEmpty()) {
                        dumped[name] = value.dump();
                      }
                    } else {
                      dumped[name] = value;
                    }
                  }
                  return dumped;
                }
                [_symbol_utils.$toStyle]() {
                  return null;
                }
                [_symbol_utils.$toHTML]() {
                  return _utils.HTMLResult.EMPTY;
                }
                *[_symbol_utils.$getContainedChildren]() {
                  for (const node of this[_symbol_utils.$getChildren]()) {
                    yield node;
                  }
                }
                *[_filteredChildrenGenerator](filter, include) {
                  for (const node of this[_symbol_utils.$getContainedChildren]()) {
                    if (!filter || include === filter.has(node[_symbol_utils.$nodeName])) {
                      const availableSpace = this[_symbol_utils.$getAvailableSpace]();
                      const res = node[_symbol_utils.$toHTML](availableSpace);
                      if (!res.success) {
                        this[_symbol_utils.$extra].failingNode = node;
                      }
                      yield res;
                    }
                  }
                }
                [_symbol_utils.$flushHTML]() {
                  return null;
                }
                [_symbol_utils.$addHTML](html, bbox) {
                  this[_symbol_utils.$extra].children.push(html);
                }
                [_symbol_utils.$getAvailableSpace]() {
                }
                [_symbol_utils.$childrenToHTML]({
                  filter = null,
                  include = true
                }) {
                  if (!this[_symbol_utils.$extra].generator) {
                    this[_symbol_utils.$extra].generator = this[_filteredChildrenGenerator](filter, include);
                  } else {
                    const availableSpace = this[_symbol_utils.$getAvailableSpace]();
                    const res = this[_symbol_utils.$extra].failingNode[_symbol_utils.$toHTML](availableSpace);
                    if (!res.success) {
                      return res;
                    }
                    if (res.html) {
                      this[_symbol_utils.$addHTML](res.html, res.bbox);
                    }
                    delete this[_symbol_utils.$extra].failingNode;
                  }
                  while (true) {
                    const gen = this[_symbol_utils.$extra].generator.next();
                    if (gen.done) {
                      break;
                    }
                    const res = gen.value;
                    if (!res.success) {
                      return res;
                    }
                    if (res.html) {
                      this[_symbol_utils.$addHTML](res.html, res.bbox);
                    }
                  }
                  this[_symbol_utils.$extra].generator = null;
                  return _utils.HTMLResult.EMPTY;
                }
                [_symbol_utils.$setSetAttributes](attributes) {
                  this[_setAttributes] = new Set(Object.keys(attributes));
                }
                [_getUnsetAttributes](protoAttributes) {
                  const allAttr = this[_attributeNames];
                  const setAttr = this[_setAttributes];
                  return [...protoAttributes].filter((x) => allAttr.has(x) && !setAttr.has(x));
                }
                [_symbol_utils.$resolvePrototypes](ids, ancestors = /* @__PURE__ */ new Set()) {
                  for (const child of this[_children]) {
                    child[_resolvePrototypesHelper](ids, ancestors);
                  }
                }
                [_resolvePrototypesHelper](ids, ancestors) {
                  const proto = this[_getPrototype](ids, ancestors);
                  if (proto) {
                    this[_applyPrototype](proto, ids, ancestors);
                  } else {
                    this[_symbol_utils.$resolvePrototypes](ids, ancestors);
                  }
                }
                [_getPrototype](ids, ancestors) {
                  const {
                    use,
                    usehref
                  } = this;
                  if (!use && !usehref) {
                    return null;
                  }
                  let proto = null;
                  let somExpression = null;
                  let id = null;
                  let ref = use;
                  if (usehref) {
                    ref = usehref;
                    if (usehref.startsWith("#som(") && usehref.endsWith(")")) {
                      somExpression = usehref.slice("#som(".length, -1);
                    } else if (usehref.startsWith(".#som(") && usehref.endsWith(")")) {
                      somExpression = usehref.slice(".#som(".length, -1);
                    } else if (usehref.startsWith("#")) {
                      id = usehref.slice(1);
                    } else if (usehref.startsWith(".#")) {
                      id = usehref.slice(2);
                    }
                  } else if (use.startsWith("#")) {
                    id = use.slice(1);
                  } else {
                    somExpression = use;
                  }
                  this.use = this.usehref = "";
                  if (id) {
                    proto = ids.get(id);
                  } else {
                    proto = (0, _som.searchNode)(ids.get(_symbol_utils.$root), this, somExpression, true, false);
                    if (proto) {
                      proto = proto[0];
                    }
                  }
                  if (!proto) {
                    (0, _util.warn)(`XFA - Invalid prototype reference: ${ref}.`);
                    return null;
                  }
                  if (proto[_symbol_utils.$nodeName] !== this[_symbol_utils.$nodeName]) {
                    (0, _util.warn)(`XFA - Incompatible prototype: ${proto[_symbol_utils.$nodeName]} !== ${this[_symbol_utils.$nodeName]}.`);
                    return null;
                  }
                  if (ancestors.has(proto)) {
                    (0, _util.warn)(`XFA - Cycle detected in prototypes use.`);
                    return null;
                  }
                  ancestors.add(proto);
                  const protoProto = proto[_getPrototype](ids, ancestors);
                  if (protoProto) {
                    proto[_applyPrototype](protoProto, ids, ancestors);
                  }
                  proto[_symbol_utils.$resolvePrototypes](ids, ancestors);
                  ancestors.delete(proto);
                  return proto;
                }
                [_applyPrototype](proto, ids, ancestors) {
                  if (ancestors.has(proto)) {
                    (0, _util.warn)(`XFA - Cycle detected in prototypes use.`);
                    return;
                  }
                  if (!this[_symbol_utils.$content] && proto[_symbol_utils.$content]) {
                    this[_symbol_utils.$content] = proto[_symbol_utils.$content];
                  }
                  const newAncestors = new Set(ancestors);
                  newAncestors.add(proto);
                  for (const unsetAttrName of this[_getUnsetAttributes](proto[_setAttributes])) {
                    this[unsetAttrName] = proto[unsetAttrName];
                    if (this[_setAttributes]) {
                      this[_setAttributes].add(unsetAttrName);
                    }
                  }
                  for (const name of Object.getOwnPropertyNames(this)) {
                    if (this[_attributeNames].has(name)) {
                      continue;
                    }
                    const value = this[name];
                    const protoValue = proto[name];
                    if (value instanceof XFAObjectArray) {
                      for (const child of value[_children]) {
                        child[_resolvePrototypesHelper](ids, ancestors);
                      }
                      for (let i = value[_children].length, ii = protoValue[_children].length; i < ii; i++) {
                        const child = proto[_children][i][_symbol_utils.$clone]();
                        if (value.push(child)) {
                          child[_parent] = this;
                          this[_children].push(child);
                          child[_resolvePrototypesHelper](ids, ancestors);
                        } else {
                          break;
                        }
                      }
                      continue;
                    }
                    if (value !== null) {
                      value[_symbol_utils.$resolvePrototypes](ids, ancestors);
                      if (protoValue) {
                        value[_applyPrototype](protoValue, ids, ancestors);
                      }
                      continue;
                    }
                    if (protoValue !== null) {
                      const child = protoValue[_symbol_utils.$clone]();
                      child[_parent] = this;
                      this[name] = child;
                      this[_children].push(child);
                      child[_resolvePrototypesHelper](ids, ancestors);
                    }
                  }
                }
                static [_cloneAttribute](obj) {
                  if (Array.isArray(obj)) {
                    return obj.map((x) => XFAObject[_cloneAttribute](x));
                  }
                  if (typeof obj === "object" && obj !== null) {
                    return Object.assign({}, obj);
                  }
                  return obj;
                }
                [_symbol_utils.$clone]() {
                  const clone = Object.create(Object.getPrototypeOf(this));
                  for (const $symbol of Object.getOwnPropertySymbols(this)) {
                    try {
                      clone[$symbol] = this[$symbol];
                    } catch {
                      (0, _util.shadow)(clone, $symbol, this[$symbol]);
                    }
                  }
                  clone[_symbol_utils.$uid] = `${clone[_symbol_utils.$nodeName]}${uid++}`;
                  clone[_children] = [];
                  for (const name of Object.getOwnPropertyNames(this)) {
                    if (this[_attributeNames].has(name)) {
                      clone[name] = XFAObject[_cloneAttribute](this[name]);
                      continue;
                    }
                    const value = this[name];
                    clone[name] = value instanceof XFAObjectArray ? new XFAObjectArray(value[_max]) : null;
                  }
                  for (const child of this[_children]) {
                    const name = child[_symbol_utils.$nodeName];
                    const clonedChild = child[_symbol_utils.$clone]();
                    clone[_children].push(clonedChild);
                    clonedChild[_parent] = clone;
                    if (clone[name] === null) {
                      clone[name] = clonedChild;
                    } else {
                      clone[name][_children].push(clonedChild);
                    }
                  }
                  return clone;
                }
                [_symbol_utils.$getChildren](name = null) {
                  if (!name) {
                    return this[_children];
                  }
                  return this[_children].filter((c) => c[_symbol_utils.$nodeName] === name);
                }
                [_symbol_utils.$getChildrenByClass](name) {
                  return this[name];
                }
                [_symbol_utils.$getChildrenByName](name, allTransparent, first = true) {
                  return Array.from(this[_symbol_utils.$getChildrenByNameIt](name, allTransparent, first));
                }
                *[_symbol_utils.$getChildrenByNameIt](name, allTransparent, first = true) {
                  if (name === "parent") {
                    yield this[_parent];
                    return;
                  }
                  for (const child of this[_children]) {
                    if (child[_symbol_utils.$nodeName] === name) {
                      yield child;
                    }
                    if (child.name === name) {
                      yield child;
                    }
                    if (allTransparent || child[_symbol_utils.$isTransparent]()) {
                      yield* child[_symbol_utils.$getChildrenByNameIt](name, allTransparent, false);
                    }
                  }
                  if (first && this[_attributeNames].has(name)) {
                    yield new XFAAttribute(this, name, this[name]);
                  }
                }
              }
              exports2.XFAObject = XFAObject;
              class XFAObjectArray {
                constructor(max = Infinity) {
                  this[_max] = max;
                  this[_children] = [];
                }
                get isXFAObject() {
                  return false;
                }
                get isXFAObjectArray() {
                  return true;
                }
                push(child) {
                  const len = this[_children].length;
                  if (len <= this[_max]) {
                    this[_children].push(child);
                    return true;
                  }
                  (0, _util.warn)(`XFA - node "${child[_symbol_utils.$nodeName]}" accepts no more than ${this[_max]} children`);
                  return false;
                }
                isEmpty() {
                  return this[_children].length === 0;
                }
                dump() {
                  return this[_children].length === 1 ? this[_children][0][_symbol_utils.$dump]() : this[_children].map((x) => x[_symbol_utils.$dump]());
                }
                [_symbol_utils.$clone]() {
                  const clone = new XFAObjectArray(this[_max]);
                  clone[_children] = this[_children].map((c) => c[_symbol_utils.$clone]());
                  return clone;
                }
                get children() {
                  return this[_children];
                }
                clear() {
                  this[_children].length = 0;
                }
              }
              exports2.XFAObjectArray = XFAObjectArray;
              class XFAAttribute {
                constructor(node, name, value) {
                  this[_parent] = node;
                  this[_symbol_utils.$nodeName] = name;
                  this[_symbol_utils.$content] = value;
                  this[_symbol_utils.$consumed] = false;
                  this[_symbol_utils.$uid] = `attribute${uid++}`;
                }
                [_symbol_utils.$getParent]() {
                  return this[_parent];
                }
                [_symbol_utils.$isDataValue]() {
                  return true;
                }
                [_symbol_utils.$getDataValue]() {
                  return this[_symbol_utils.$content].trim();
                }
                [_symbol_utils.$setValue](value) {
                  value = value.value || "";
                  this[_symbol_utils.$content] = value.toString();
                }
                [_symbol_utils.$text]() {
                  return this[_symbol_utils.$content];
                }
                [_symbol_utils.$isDescendent](parent) {
                  return this[_parent] === parent || this[_parent][_symbol_utils.$isDescendent](parent);
                }
              }
              exports2.XFAAttribute = XFAAttribute;
              class XmlObject extends XFAObject {
                constructor(nsId, name, attributes = {}) {
                  super(nsId, name);
                  this[_symbol_utils.$content] = "";
                  this[_dataValue] = null;
                  if (name !== "#text") {
                    const map = /* @__PURE__ */ new Map();
                    this[_attributes] = map;
                    for (const [attrName, value] of Object.entries(attributes)) {
                      map.set(attrName, new XFAAttribute(this, attrName, value));
                    }
                    if (attributes.hasOwnProperty(_symbol_utils.$nsAttributes)) {
                      const dataNode = attributes[_symbol_utils.$nsAttributes].xfa.dataNode;
                      if (dataNode !== void 0) {
                        if (dataNode === "dataGroup") {
                          this[_dataValue] = false;
                        } else if (dataNode === "dataValue") {
                          this[_dataValue] = true;
                        }
                      }
                    }
                  }
                  this[_symbol_utils.$consumed] = false;
                }
                [_symbol_utils.$toString](buf) {
                  const tagName = this[_symbol_utils.$nodeName];
                  if (tagName === "#text") {
                    buf.push((0, _core_utils.encodeToXmlString)(this[_symbol_utils.$content]));
                    return;
                  }
                  const utf8TagName = (0, _util.utf8StringToString)(tagName);
                  const prefix = this[_symbol_utils.$namespaceId] === NS_DATASETS ? "xfa:" : "";
                  buf.push(`<${prefix}${utf8TagName}`);
                  for (const [name, value] of this[_attributes].entries()) {
                    const utf8Name = (0, _util.utf8StringToString)(name);
                    buf.push(` ${utf8Name}="${(0, _core_utils.encodeToXmlString)(value[_symbol_utils.$content])}"`);
                  }
                  if (this[_dataValue] !== null) {
                    if (this[_dataValue]) {
                      buf.push(` xfa:dataNode="dataValue"`);
                    } else {
                      buf.push(` xfa:dataNode="dataGroup"`);
                    }
                  }
                  if (!this[_symbol_utils.$content] && this[_children].length === 0) {
                    buf.push("/>");
                    return;
                  }
                  buf.push(">");
                  if (this[_symbol_utils.$content]) {
                    if (typeof this[_symbol_utils.$content] === "string") {
                      buf.push((0, _core_utils.encodeToXmlString)(this[_symbol_utils.$content]));
                    } else {
                      this[_symbol_utils.$content][_symbol_utils.$toString](buf);
                    }
                  } else {
                    for (const child of this[_children]) {
                      child[_symbol_utils.$toString](buf);
                    }
                  }
                  buf.push(`</${prefix}${utf8TagName}>`);
                }
                [_symbol_utils.$onChild](child) {
                  if (this[_symbol_utils.$content]) {
                    const node = new XmlObject(this[_symbol_utils.$namespaceId], "#text");
                    this[_symbol_utils.$appendChild](node);
                    node[_symbol_utils.$content] = this[_symbol_utils.$content];
                    this[_symbol_utils.$content] = "";
                  }
                  this[_symbol_utils.$appendChild](child);
                  return true;
                }
                [_symbol_utils.$onText](str) {
                  this[_symbol_utils.$content] += str;
                }
                [_symbol_utils.$finalize]() {
                  if (this[_symbol_utils.$content] && this[_children].length > 0) {
                    const node = new XmlObject(this[_symbol_utils.$namespaceId], "#text");
                    this[_symbol_utils.$appendChild](node);
                    node[_symbol_utils.$content] = this[_symbol_utils.$content];
                    delete this[_symbol_utils.$content];
                  }
                }
                [_symbol_utils.$toHTML]() {
                  if (this[_symbol_utils.$nodeName] === "#text") {
                    return _utils.HTMLResult.success({
                      name: "#text",
                      value: this[_symbol_utils.$content]
                    });
                  }
                  return _utils.HTMLResult.EMPTY;
                }
                [_symbol_utils.$getChildren](name = null) {
                  if (!name) {
                    return this[_children];
                  }
                  return this[_children].filter((c) => c[_symbol_utils.$nodeName] === name);
                }
                [_symbol_utils.$getAttributes]() {
                  return this[_attributes];
                }
                [_symbol_utils.$getChildrenByClass](name) {
                  const value = this[_attributes].get(name);
                  if (value !== void 0) {
                    return value;
                  }
                  return this[_symbol_utils.$getChildren](name);
                }
                *[_symbol_utils.$getChildrenByNameIt](name, allTransparent) {
                  const value = this[_attributes].get(name);
                  if (value) {
                    yield value;
                  }
                  for (const child of this[_children]) {
                    if (child[_symbol_utils.$nodeName] === name) {
                      yield child;
                    }
                    if (allTransparent) {
                      yield* child[_symbol_utils.$getChildrenByNameIt](name, allTransparent);
                    }
                  }
                }
                *[_symbol_utils.$getAttributeIt](name, skipConsumed) {
                  const value = this[_attributes].get(name);
                  if (value && (!skipConsumed || !value[_symbol_utils.$consumed])) {
                    yield value;
                  }
                  for (const child of this[_children]) {
                    yield* child[_symbol_utils.$getAttributeIt](name, skipConsumed);
                  }
                }
                *[_symbol_utils.$getRealChildrenByNameIt](name, allTransparent, skipConsumed) {
                  for (const child of this[_children]) {
                    if (child[_symbol_utils.$nodeName] === name && (!skipConsumed || !child[_symbol_utils.$consumed])) {
                      yield child;
                    }
                    if (allTransparent) {
                      yield* child[_symbol_utils.$getRealChildrenByNameIt](name, allTransparent, skipConsumed);
                    }
                  }
                }
                [_symbol_utils.$isDataValue]() {
                  if (this[_dataValue] === null) {
                    return this[_children].length === 0 || this[_children][0][_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.xhtml.id;
                  }
                  return this[_dataValue];
                }
                [_symbol_utils.$getDataValue]() {
                  if (this[_dataValue] === null) {
                    if (this[_children].length === 0) {
                      return this[_symbol_utils.$content].trim();
                    }
                    if (this[_children][0][_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.xhtml.id) {
                      return this[_children][0][_symbol_utils.$text]().trim();
                    }
                    return null;
                  }
                  return this[_symbol_utils.$content].trim();
                }
                [_symbol_utils.$setValue](value) {
                  value = value.value || "";
                  this[_symbol_utils.$content] = value.toString();
                }
                [_symbol_utils.$dump](hasNS = false) {
                  const dumped = /* @__PURE__ */ Object.create(null);
                  if (hasNS) {
                    dumped.$ns = this[_symbol_utils.$namespaceId];
                  }
                  if (this[_symbol_utils.$content]) {
                    dumped.$content = this[_symbol_utils.$content];
                  }
                  dumped.$name = this[_symbol_utils.$nodeName];
                  dumped.children = [];
                  for (const child of this[_children]) {
                    dumped.children.push(child[_symbol_utils.$dump](hasNS));
                  }
                  dumped.attributes = /* @__PURE__ */ Object.create(null);
                  for (const [name, value] of this[_attributes]) {
                    dumped.attributes[name] = value[_symbol_utils.$content];
                  }
                  return dumped;
                }
              }
              exports2.XmlObject = XmlObject;
              class ContentObject extends XFAObject {
                constructor(nsId, name) {
                  super(nsId, name);
                  this[_symbol_utils.$content] = "";
                }
                [_symbol_utils.$onText](text) {
                  this[_symbol_utils.$content] += text;
                }
                [_symbol_utils.$finalize]() {
                }
              }
              exports2.ContentObject = ContentObject;
              class OptionObject extends ContentObject {
                constructor(nsId, name, options) {
                  super(nsId, name);
                  this[_options] = options;
                }
                [_symbol_utils.$finalize]() {
                  this[_symbol_utils.$content] = (0, _utils.getKeyword)({
                    data: this[_symbol_utils.$content],
                    defaultValue: this[_options][0],
                    validate: (k) => this[_options].includes(k)
                  });
                }
                [_symbol_utils.$clean](builder) {
                  super[_symbol_utils.$clean](builder);
                  delete this[_options];
                }
              }
              exports2.OptionObject = OptionObject;
              class StringObject extends ContentObject {
                [_symbol_utils.$finalize]() {
                  this[_symbol_utils.$content] = this[_symbol_utils.$content].trim();
                }
              }
              exports2.StringObject = StringObject;
              class IntegerObject extends ContentObject {
                constructor(nsId, name, defaultValue, validator) {
                  super(nsId, name);
                  this[_defaultValue] = defaultValue;
                  this[_validator] = validator;
                }
                [_symbol_utils.$finalize]() {
                  this[_symbol_utils.$content] = (0, _utils.getInteger)({
                    data: this[_symbol_utils.$content],
                    defaultValue: this[_defaultValue],
                    validate: this[_validator]
                  });
                }
                [_symbol_utils.$clean](builder) {
                  super[_symbol_utils.$clean](builder);
                  delete this[_defaultValue];
                  delete this[_validator];
                }
              }
              exports2.IntegerObject = IntegerObject;
              class Option01 extends IntegerObject {
                constructor(nsId, name) {
                  super(nsId, name, 0, (n) => n === 1);
                }
              }
              exports2.Option01 = Option01;
              class Option10 extends IntegerObject {
                constructor(nsId, name) {
                  super(nsId, name, 1, (n) => n === 0);
                }
              }
              exports2.Option10 = Option10;
            },
            /* 88 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.createDataNode = createDataNode;
              exports2.searchNode = searchNode;
              var _symbol_utils = __w_pdfjs_require__2(78);
              var _util = __w_pdfjs_require__2(2);
              const namePattern = /^[^.[]+/;
              const indexPattern = /^[^\]]+/;
              const operators = {
                dot: 0,
                dotDot: 1,
                dotHash: 2,
                dotBracket: 3,
                dotParen: 4
              };
              const shortcuts = /* @__PURE__ */ new Map([["$data", (root, current) => root.datasets ? root.datasets.data : root], ["$record", (root, current) => (root.datasets ? root.datasets.data : root)[_symbol_utils.$getChildren]()[0]], ["$template", (root, current) => root.template], ["$connectionSet", (root, current) => root.connectionSet], ["$form", (root, current) => root.form], ["$layout", (root, current) => root.layout], ["$host", (root, current) => root.host], ["$dataWindow", (root, current) => root.dataWindow], ["$event", (root, current) => root.event], ["!", (root, current) => root.datasets], ["$xfa", (root, current) => root], ["xfa", (root, current) => root], ["$", (root, current) => current]]);
              const somCache = /* @__PURE__ */ new WeakMap();
              function parseIndex(index) {
                index = index.trim();
                if (index === "*") {
                  return Infinity;
                }
                return parseInt(index, 10) || 0;
              }
              function parseExpression(expr, dotDotAllowed, noExpr = true) {
                let match = expr.match(namePattern);
                if (!match) {
                  return null;
                }
                let [name] = match;
                const parsed = [{
                  name,
                  cacheName: "." + name,
                  index: 0,
                  js: null,
                  formCalc: null,
                  operator: operators.dot
                }];
                let pos = name.length;
                while (pos < expr.length) {
                  const spos = pos;
                  const char = expr.charAt(pos++);
                  if (char === "[") {
                    match = expr.slice(pos).match(indexPattern);
                    if (!match) {
                      (0, _util.warn)("XFA - Invalid index in SOM expression");
                      return null;
                    }
                    parsed.at(-1).index = parseIndex(match[0]);
                    pos += match[0].length + 1;
                    continue;
                  }
                  let operator;
                  switch (expr.charAt(pos)) {
                    case ".":
                      if (!dotDotAllowed) {
                        return null;
                      }
                      pos++;
                      operator = operators.dotDot;
                      break;
                    case "#":
                      pos++;
                      operator = operators.dotHash;
                      break;
                    case "[":
                      if (noExpr) {
                        (0, _util.warn)("XFA - SOM expression contains a FormCalc subexpression which is not supported for now.");
                        return null;
                      }
                      operator = operators.dotBracket;
                      break;
                    case "(":
                      if (noExpr) {
                        (0, _util.warn)("XFA - SOM expression contains a JavaScript subexpression which is not supported for now.");
                        return null;
                      }
                      operator = operators.dotParen;
                      break;
                    default:
                      operator = operators.dot;
                      break;
                  }
                  match = expr.slice(pos).match(namePattern);
                  if (!match) {
                    break;
                  }
                  [name] = match;
                  pos += name.length;
                  parsed.push({
                    name,
                    cacheName: expr.slice(spos, pos),
                    operator,
                    index: 0,
                    js: null,
                    formCalc: null
                  });
                }
                return parsed;
              }
              function searchNode(root, container, expr, dotDotAllowed = true, useCache = true) {
                const parsed = parseExpression(expr, dotDotAllowed);
                if (!parsed) {
                  return null;
                }
                const fn = shortcuts.get(parsed[0].name);
                let i = 0;
                let isQualified;
                if (fn) {
                  isQualified = true;
                  root = [fn(root, container)];
                  i = 1;
                } else {
                  isQualified = container === null;
                  root = [container || root];
                }
                for (let ii = parsed.length; i < ii; i++) {
                  const {
                    name,
                    cacheName,
                    operator,
                    index
                  } = parsed[i];
                  const nodes = [];
                  for (const node of root) {
                    if (!node.isXFAObject) {
                      continue;
                    }
                    let children, cached;
                    if (useCache) {
                      cached = somCache.get(node);
                      if (!cached) {
                        cached = /* @__PURE__ */ new Map();
                        somCache.set(node, cached);
                      }
                      children = cached.get(cacheName);
                    }
                    if (!children) {
                      switch (operator) {
                        case operators.dot:
                          children = node[_symbol_utils.$getChildrenByName](name, false);
                          break;
                        case operators.dotDot:
                          children = node[_symbol_utils.$getChildrenByName](name, true);
                          break;
                        case operators.dotHash:
                          children = node[_symbol_utils.$getChildrenByClass](name);
                          children = children.isXFAObjectArray ? children.children : [children];
                          break;
                        default:
                          break;
                      }
                      if (useCache) {
                        cached.set(cacheName, children);
                      }
                    }
                    if (children.length > 0) {
                      nodes.push(children);
                    }
                  }
                  if (nodes.length === 0 && !isQualified && i === 0) {
                    const parent = container[_symbol_utils.$getParent]();
                    container = parent;
                    if (!container) {
                      return null;
                    }
                    i = -1;
                    root = [container];
                    continue;
                  }
                  root = isFinite(index) ? nodes.filter((node) => index < node.length).map((node) => node[index]) : nodes.flat();
                }
                if (root.length === 0) {
                  return null;
                }
                return root;
              }
              function createDataNode(root, container, expr) {
                const parsed = parseExpression(expr);
                if (!parsed) {
                  return null;
                }
                if (parsed.some((x) => x.operator === operators.dotDot)) {
                  return null;
                }
                const fn = shortcuts.get(parsed[0].name);
                let i = 0;
                if (fn) {
                  root = fn(root, container);
                  i = 1;
                } else {
                  root = container || root;
                }
                for (let ii = parsed.length; i < ii; i++) {
                  const {
                    name,
                    operator,
                    index
                  } = parsed[i];
                  if (!isFinite(index)) {
                    parsed[i].index = 0;
                    return root.createNodes(parsed.slice(i));
                  }
                  let children;
                  switch (operator) {
                    case operators.dot:
                      children = root[_symbol_utils.$getChildrenByName](name, false);
                      break;
                    case operators.dotDot:
                      children = root[_symbol_utils.$getChildrenByName](name, true);
                      break;
                    case operators.dotHash:
                      children = root[_symbol_utils.$getChildrenByClass](name);
                      children = children.isXFAObjectArray ? children.children : [children];
                      break;
                    default:
                      break;
                  }
                  if (children.length === 0) {
                    return root.createNodes(parsed.slice(i));
                  }
                  if (index < children.length) {
                    const child = children[index];
                    if (!child.isXFAObject) {
                      (0, _util.warn)(`XFA - Cannot create a node.`);
                      return null;
                    }
                    root = child;
                  } else {
                    parsed[i].index = index - children.length;
                    return root.createNodes(parsed.slice(i));
                  }
                }
                return null;
              }
            },
            /* 89 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.DataHandler = void 0;
              var _symbol_utils = __w_pdfjs_require__2(78);
              class DataHandler {
                constructor(root, data) {
                  this.data = data;
                  this.dataset = root.datasets || null;
                }
                serialize(storage) {
                  const stack = [[-1, this.data[_symbol_utils.$getChildren]()]];
                  while (stack.length > 0) {
                    const last = stack.at(-1);
                    const [i, children] = last;
                    if (i + 1 === children.length) {
                      stack.pop();
                      continue;
                    }
                    const child = children[++last[0]];
                    const storageEntry = storage.get(child[_symbol_utils.$uid]);
                    if (storageEntry) {
                      child[_symbol_utils.$setValue](storageEntry);
                    } else {
                      const attributes = child[_symbol_utils.$getAttributes]();
                      for (const value of attributes.values()) {
                        const entry = storage.get(value[_symbol_utils.$uid]);
                        if (entry) {
                          value[_symbol_utils.$setValue](entry);
                          break;
                        }
                      }
                    }
                    const nodes = child[_symbol_utils.$getChildren]();
                    if (nodes.length > 0) {
                      stack.push([-1, nodes]);
                    }
                  }
                  const buf = [`<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">`];
                  if (this.dataset) {
                    for (const child of this.dataset[_symbol_utils.$getChildren]()) {
                      if (child[_symbol_utils.$nodeName] !== "data") {
                        child[_symbol_utils.$toString](buf);
                      }
                    }
                  }
                  this.data[_symbol_utils.$toString](buf);
                  buf.push("</xfa:datasets>");
                  return buf.join("");
                }
              }
              exports2.DataHandler = DataHandler;
            },
            /* 90 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XFAParser = void 0;
              var _symbol_utils = __w_pdfjs_require__2(78);
              var _xml_parser = __w_pdfjs_require__2(71);
              var _builder = __w_pdfjs_require__2(91);
              var _util = __w_pdfjs_require__2(2);
              class XFAParser extends _xml_parser.XMLParserBase {
                constructor(rootNameSpace = null, richText = false) {
                  super();
                  this._builder = new _builder.Builder(rootNameSpace);
                  this._stack = [];
                  this._globalData = {
                    usedTypefaces: /* @__PURE__ */ new Set()
                  };
                  this._ids = /* @__PURE__ */ new Map();
                  this._current = this._builder.buildRoot(this._ids);
                  this._errorCode = _xml_parser.XMLParserErrorCode.NoError;
                  this._whiteRegex = /^\s+$/;
                  this._nbsps = /\xa0+/g;
                  this._richText = richText;
                }
                parse(data) {
                  this.parseXml(data);
                  if (this._errorCode !== _xml_parser.XMLParserErrorCode.NoError) {
                    return void 0;
                  }
                  this._current[_symbol_utils.$finalize]();
                  return this._current.element;
                }
                onText(text) {
                  text = text.replace(this._nbsps, (match) => match.slice(1) + " ");
                  if (this._richText || this._current[_symbol_utils.$acceptWhitespace]()) {
                    this._current[_symbol_utils.$onText](text, this._richText);
                    return;
                  }
                  if (this._whiteRegex.test(text)) {
                    return;
                  }
                  this._current[_symbol_utils.$onText](text.trim());
                }
                onCdata(text) {
                  this._current[_symbol_utils.$onText](text);
                }
                _mkAttributes(attributes, tagName) {
                  let namespace = null;
                  let prefixes = null;
                  const attributeObj = /* @__PURE__ */ Object.create({});
                  for (const {
                    name,
                    value
                  } of attributes) {
                    if (name === "xmlns") {
                      if (!namespace) {
                        namespace = value;
                      } else {
                        (0, _util.warn)(`XFA - multiple namespace definition in <${tagName}>`);
                      }
                    } else if (name.startsWith("xmlns:")) {
                      const prefix = name.substring("xmlns:".length);
                      if (!prefixes) {
                        prefixes = [];
                      }
                      prefixes.push({
                        prefix,
                        value
                      });
                    } else {
                      const i = name.indexOf(":");
                      if (i === -1) {
                        attributeObj[name] = value;
                      } else {
                        let nsAttrs = attributeObj[_symbol_utils.$nsAttributes];
                        if (!nsAttrs) {
                          nsAttrs = attributeObj[_symbol_utils.$nsAttributes] = /* @__PURE__ */ Object.create(null);
                        }
                        const [ns, attrName] = [name.slice(0, i), name.slice(i + 1)];
                        const attrs = nsAttrs[ns] || (nsAttrs[ns] = /* @__PURE__ */ Object.create(null));
                        attrs[attrName] = value;
                      }
                    }
                  }
                  return [namespace, prefixes, attributeObj];
                }
                _getNameAndPrefix(name, nsAgnostic) {
                  const i = name.indexOf(":");
                  if (i === -1) {
                    return [name, null];
                  }
                  return [name.substring(i + 1), nsAgnostic ? "" : name.substring(0, i)];
                }
                onBeginElement(tagName, attributes, isEmpty) {
                  const [namespace, prefixes, attributesObj] = this._mkAttributes(attributes, tagName);
                  const [name, nsPrefix] = this._getNameAndPrefix(tagName, this._builder.isNsAgnostic());
                  const node = this._builder.build({
                    nsPrefix,
                    name,
                    attributes: attributesObj,
                    namespace,
                    prefixes
                  });
                  node[_symbol_utils.$globalData] = this._globalData;
                  if (isEmpty) {
                    node[_symbol_utils.$finalize]();
                    if (this._current[_symbol_utils.$onChild](node)) {
                      node[_symbol_utils.$setId](this._ids);
                    }
                    node[_symbol_utils.$clean](this._builder);
                    return;
                  }
                  this._stack.push(this._current);
                  this._current = node;
                }
                onEndElement(name) {
                  const node = this._current;
                  if (node[_symbol_utils.$isCDATAXml]() && typeof node[_symbol_utils.$content] === "string") {
                    const parser = new XFAParser();
                    parser._globalData = this._globalData;
                    const root = parser.parse(node[_symbol_utils.$content]);
                    node[_symbol_utils.$content] = null;
                    node[_symbol_utils.$onChild](root);
                  }
                  node[_symbol_utils.$finalize]();
                  this._current = this._stack.pop();
                  if (this._current[_symbol_utils.$onChild](node)) {
                    node[_symbol_utils.$setId](this._ids);
                  }
                  node[_symbol_utils.$clean](this._builder);
                }
                onError(code) {
                  this._errorCode = code;
                }
              }
              exports2.XFAParser = XFAParser;
            },
            /* 91 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Builder = void 0;
              var _namespaces = __w_pdfjs_require__2(81);
              var _symbol_utils = __w_pdfjs_require__2(78);
              var _setup = __w_pdfjs_require__2(92);
              var _template = __w_pdfjs_require__2(80);
              var _unknown = __w_pdfjs_require__2(101);
              var _util = __w_pdfjs_require__2(2);
              var _xfa_object = __w_pdfjs_require__2(87);
              class Root extends _xfa_object.XFAObject {
                constructor(ids) {
                  super(-1, "root", /* @__PURE__ */ Object.create(null));
                  this.element = null;
                  this[_symbol_utils.$ids] = ids;
                }
                [_symbol_utils.$onChild](child) {
                  this.element = child;
                  return true;
                }
                [_symbol_utils.$finalize]() {
                  super[_symbol_utils.$finalize]();
                  if (this.element.template instanceof _template.Template) {
                    this[_symbol_utils.$ids].set(_symbol_utils.$root, this.element);
                    this.element.template[_symbol_utils.$resolvePrototypes](this[_symbol_utils.$ids]);
                    this.element.template[_symbol_utils.$ids] = this[_symbol_utils.$ids];
                  }
                }
              }
              class Empty extends _xfa_object.XFAObject {
                constructor() {
                  super(-1, "", /* @__PURE__ */ Object.create(null));
                }
                [_symbol_utils.$onChild](_) {
                  return false;
                }
              }
              class Builder {
                constructor(rootNameSpace = null) {
                  this._namespaceStack = [];
                  this._nsAgnosticLevel = 0;
                  this._namespacePrefixes = /* @__PURE__ */ new Map();
                  this._namespaces = /* @__PURE__ */ new Map();
                  this._nextNsId = Math.max(...Object.values(_namespaces.NamespaceIds).map(({
                    id
                  }) => id));
                  this._currentNamespace = rootNameSpace || new _unknown.UnknownNamespace(++this._nextNsId);
                }
                buildRoot(ids) {
                  return new Root(ids);
                }
                build({
                  nsPrefix,
                  name,
                  attributes,
                  namespace,
                  prefixes
                }) {
                  const hasNamespaceDef = namespace !== null;
                  if (hasNamespaceDef) {
                    this._namespaceStack.push(this._currentNamespace);
                    this._currentNamespace = this._searchNamespace(namespace);
                  }
                  if (prefixes) {
                    this._addNamespacePrefix(prefixes);
                  }
                  if (attributes.hasOwnProperty(_symbol_utils.$nsAttributes)) {
                    const dataTemplate = _setup.NamespaceSetUp.datasets;
                    const nsAttrs = attributes[_symbol_utils.$nsAttributes];
                    let xfaAttrs = null;
                    for (const [ns, attrs] of Object.entries(nsAttrs)) {
                      const nsToUse = this._getNamespaceToUse(ns);
                      if (nsToUse === dataTemplate) {
                        xfaAttrs = {
                          xfa: attrs
                        };
                        break;
                      }
                    }
                    if (xfaAttrs) {
                      attributes[_symbol_utils.$nsAttributes] = xfaAttrs;
                    } else {
                      delete attributes[_symbol_utils.$nsAttributes];
                    }
                  }
                  const namespaceToUse = this._getNamespaceToUse(nsPrefix);
                  const node = (namespaceToUse == null ? void 0 : namespaceToUse[_namespaces.$buildXFAObject](name, attributes)) || new Empty();
                  if (node[_symbol_utils.$isNsAgnostic]()) {
                    this._nsAgnosticLevel++;
                  }
                  if (hasNamespaceDef || prefixes || node[_symbol_utils.$isNsAgnostic]()) {
                    node[_symbol_utils.$cleanup] = {
                      hasNamespace: hasNamespaceDef,
                      prefixes,
                      nsAgnostic: node[_symbol_utils.$isNsAgnostic]()
                    };
                  }
                  return node;
                }
                isNsAgnostic() {
                  return this._nsAgnosticLevel > 0;
                }
                _searchNamespace(nsName) {
                  let ns = this._namespaces.get(nsName);
                  if (ns) {
                    return ns;
                  }
                  for (const [name, {
                    check
                  }] of Object.entries(_namespaces.NamespaceIds)) {
                    if (check(nsName)) {
                      ns = _setup.NamespaceSetUp[name];
                      if (ns) {
                        this._namespaces.set(nsName, ns);
                        return ns;
                      }
                      break;
                    }
                  }
                  ns = new _unknown.UnknownNamespace(++this._nextNsId);
                  this._namespaces.set(nsName, ns);
                  return ns;
                }
                _addNamespacePrefix(prefixes) {
                  for (const {
                    prefix,
                    value
                  } of prefixes) {
                    const namespace = this._searchNamespace(value);
                    let prefixStack = this._namespacePrefixes.get(prefix);
                    if (!prefixStack) {
                      prefixStack = [];
                      this._namespacePrefixes.set(prefix, prefixStack);
                    }
                    prefixStack.push(namespace);
                  }
                }
                _getNamespaceToUse(prefix) {
                  if (!prefix) {
                    return this._currentNamespace;
                  }
                  const prefixStack = this._namespacePrefixes.get(prefix);
                  if ((prefixStack == null ? void 0 : prefixStack.length) > 0) {
                    return prefixStack.at(-1);
                  }
                  (0, _util.warn)(`Unknown namespace prefix: ${prefix}.`);
                  return null;
                }
                clean(data) {
                  const {
                    hasNamespace,
                    prefixes,
                    nsAgnostic
                  } = data;
                  if (hasNamespace) {
                    this._currentNamespace = this._namespaceStack.pop();
                  }
                  if (prefixes) {
                    prefixes.forEach(({
                      prefix
                    }) => {
                      this._namespacePrefixes.get(prefix).pop();
                    });
                  }
                  if (nsAgnostic) {
                    this._nsAgnosticLevel--;
                  }
                }
              }
              exports2.Builder = Builder;
            },
            /* 92 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NamespaceSetUp = void 0;
              var _config = __w_pdfjs_require__2(93);
              var _connection_set = __w_pdfjs_require__2(94);
              var _datasets = __w_pdfjs_require__2(95);
              var _locale_set = __w_pdfjs_require__2(96);
              var _signature = __w_pdfjs_require__2(97);
              var _stylesheet = __w_pdfjs_require__2(98);
              var _template = __w_pdfjs_require__2(80);
              var _xdp = __w_pdfjs_require__2(99);
              var _xhtml = __w_pdfjs_require__2(100);
              const NamespaceSetUp = {
                config: _config.ConfigNamespace,
                connection: _connection_set.ConnectionSetNamespace,
                datasets: _datasets.DatasetsNamespace,
                localeSet: _locale_set.LocaleSetNamespace,
                signature: _signature.SignatureNamespace,
                stylesheet: _stylesheet.StylesheetNamespace,
                template: _template.TemplateNamespace,
                xdp: _xdp.XdpNamespace,
                xhtml: _xhtml.XhtmlNamespace
              };
              exports2.NamespaceSetUp = NamespaceSetUp;
            },
            /* 93 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ConfigNamespace = void 0;
              var _namespaces = __w_pdfjs_require__2(81);
              var _symbol_utils = __w_pdfjs_require__2(78);
              var _xfa_object = __w_pdfjs_require__2(87);
              var _utils = __w_pdfjs_require__2(84);
              var _util = __w_pdfjs_require__2(2);
              const CONFIG_NS_ID = _namespaces.NamespaceIds.config.id;
              class Acrobat extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "acrobat", true);
                  this.acrobat7 = null;
                  this.autoSave = null;
                  this.common = null;
                  this.validate = null;
                  this.validateApprovalSignatures = null;
                  this.submitUrl = new _xfa_object.XFAObjectArray();
                }
              }
              class Acrobat7 extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "acrobat7", true);
                  this.dynamicRender = null;
                }
              }
              class ADBE_JSConsole extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
                }
              }
              class ADBE_JSDebugger extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
                }
              }
              class AddSilentPrint extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "addSilentPrint");
                }
              }
              class AddViewerPreferences extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "addViewerPreferences");
                }
              }
              class AdjustData extends _xfa_object.Option10 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "adjustData");
                }
              }
              class AdobeExtensionLevel extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "adobeExtensionLevel", 0, (n) => n >= 1 && n <= 8);
                }
              }
              class Agent extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "agent", true);
                  this.name = attributes.name ? attributes.name.trim() : "";
                  this.common = new _xfa_object.XFAObjectArray();
                }
              }
              class AlwaysEmbed extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "alwaysEmbed");
                }
              }
              class Amd extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "amd");
                }
              }
              class Area extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "area");
                  this.level = (0, _utils.getInteger)({
                    data: attributes.level,
                    defaultValue: 0,
                    validate: (n) => n >= 1 && n <= 3
                  });
                  this.name = (0, _utils.getStringOption)(attributes.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
                }
              }
              class Attributes extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "attributes", ["preserve", "delegate", "ignore"]);
                }
              }
              class AutoSave extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "autoSave", ["disabled", "enabled"]);
                }
              }
              class Base extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "base");
                }
              }
              class BatchOutput extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "batchOutput");
                  this.format = (0, _utils.getStringOption)(attributes.format, ["none", "concat", "zip", "zipCompress"]);
                }
              }
              class BehaviorOverride extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "behaviorOverride");
                }
                [_symbol_utils.$finalize]() {
                  this[_symbol_utils.$content] = new Map(this[_symbol_utils.$content].trim().split(/\s+/).filter((x) => x.includes(":")).map((x) => x.split(":", 2)));
                }
              }
              class Cache extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "cache", true);
                  this.templateCache = null;
                }
              }
              class Change extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "change");
                }
              }
              class Common extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "common", true);
                  this.data = null;
                  this.locale = null;
                  this.localeSet = null;
                  this.messaging = null;
                  this.suppressBanner = null;
                  this.template = null;
                  this.validationMessaging = null;
                  this.versionControl = null;
                  this.log = new _xfa_object.XFAObjectArray();
                }
              }
              class Compress extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "compress");
                  this.scope = (0, _utils.getStringOption)(attributes.scope, ["imageOnly", "document"]);
                }
              }
              class CompressLogicalStructure extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "compressLogicalStructure");
                }
              }
              class CompressObjectStream extends _xfa_object.Option10 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "compressObjectStream");
                }
              }
              class Compression extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "compression", true);
                  this.compressLogicalStructure = null;
                  this.compressObjectStream = null;
                  this.level = null;
                  this.type = null;
                }
              }
              class Config extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "config", true);
                  this.acrobat = null;
                  this.present = null;
                  this.trace = null;
                  this.agent = new _xfa_object.XFAObjectArray();
                }
              }
              class Conformance extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "conformance", ["A", "B"]);
                }
              }
              class ContentCopy extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "contentCopy");
                }
              }
              class Copies extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "copies", 1, (n) => n >= 1);
                }
              }
              class Creator extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "creator");
                }
              }
              class CurrentPage extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "currentPage", 0, (n) => n >= 0);
                }
              }
              class Data extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "data", true);
                  this.adjustData = null;
                  this.attributes = null;
                  this.incrementalLoad = null;
                  this.outputXSL = null;
                  this.range = null;
                  this.record = null;
                  this.startNode = null;
                  this.uri = null;
                  this.window = null;
                  this.xsl = null;
                  this.excludeNS = new _xfa_object.XFAObjectArray();
                  this.transform = new _xfa_object.XFAObjectArray();
                }
              }
              class Debug extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "debug", true);
                  this.uri = null;
                }
              }
              class DefaultTypeface extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "defaultTypeface");
                  this.writingScript = (0, _utils.getStringOption)(attributes.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
                }
              }
              class Destination extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
                }
              }
              class DocumentAssembly extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "documentAssembly");
                }
              }
              class Driver extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "driver", true);
                  this.name = attributes.name ? attributes.name.trim() : "";
                  this.fontInfo = null;
                  this.xdc = null;
                }
              }
              class DuplexOption extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
                }
              }
              class DynamicRender extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "dynamicRender", ["forbidden", "required"]);
                }
              }
              class Embed extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "embed");
                }
              }
              class Encrypt extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "encrypt");
                }
              }
              class Encryption extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "encryption", true);
                  this.encrypt = null;
                  this.encryptionLevel = null;
                  this.permissions = null;
                }
              }
              class EncryptionLevel extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "encryptionLevel", ["40bit", "128bit"]);
                }
              }
              class Enforce extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "enforce");
                }
              }
              class Equate extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "equate");
                  this.force = (0, _utils.getInteger)({
                    data: attributes.force,
                    defaultValue: 1,
                    validate: (n) => n === 0
                  });
                  this.from = attributes.from || "";
                  this.to = attributes.to || "";
                }
              }
              class EquateRange extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "equateRange");
                  this.from = attributes.from || "";
                  this.to = attributes.to || "";
                  this._unicodeRange = attributes.unicodeRange || "";
                }
                get unicodeRange() {
                  const ranges = [];
                  const unicodeRegex = /U\+([0-9a-fA-F]+)/;
                  const unicodeRange = this._unicodeRange;
                  for (let range of unicodeRange.split(",").map((x) => x.trim()).filter((x) => !!x)) {
                    range = range.split("-", 2).map((x) => {
                      const found = x.match(unicodeRegex);
                      if (!found) {
                        return 0;
                      }
                      return parseInt(found[1], 16);
                    });
                    if (range.length === 1) {
                      range.push(range[0]);
                    }
                    ranges.push(range);
                  }
                  return (0, _util.shadow)(this, "unicodeRange", ranges);
                }
              }
              class Exclude extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "exclude");
                }
                [_symbol_utils.$finalize]() {
                  this[_symbol_utils.$content] = this[_symbol_utils.$content].trim().split(/\s+/).filter((x) => x && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(x));
                }
              }
              class ExcludeNS extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "excludeNS");
                }
              }
              class FlipLabel extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "flipLabel", ["usePrinterSetting", "on", "off"]);
                }
              }
              class FontInfo extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "fontInfo", true);
                  this.embed = null;
                  this.map = null;
                  this.subsetBelow = null;
                  this.alwaysEmbed = new _xfa_object.XFAObjectArray();
                  this.defaultTypeface = new _xfa_object.XFAObjectArray();
                  this.neverEmbed = new _xfa_object.XFAObjectArray();
                }
              }
              class FormFieldFilling extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "formFieldFilling");
                }
              }
              class GroupParent extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "groupParent");
                }
              }
              class IfEmpty extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
                }
              }
              class IncludeXDPContent extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "includeXDPContent");
                }
              }
              class IncrementalLoad extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "incrementalLoad", ["none", "forwardOnly"]);
                }
              }
              class IncrementalMerge extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "incrementalMerge");
                }
              }
              class Interactive extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "interactive");
                }
              }
              class Jog extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "jog", ["usePrinterSetting", "none", "pageSet"]);
                }
              }
              class LabelPrinter extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "labelPrinter", true);
                  this.name = (0, _utils.getStringOption)(attributes.name, ["zpl", "dpl", "ipl", "tcpl"]);
                  this.batchOutput = null;
                  this.flipLabel = null;
                  this.fontInfo = null;
                  this.xdc = null;
                }
              }
              class Layout extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "layout", ["paginate", "panel"]);
                }
              }
              class Level extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "level", 0, (n) => n > 0);
                }
              }
              class Linearized extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "linearized");
                }
              }
              class Locale extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "locale");
                }
              }
              class LocaleSet extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "localeSet");
                }
              }
              class Log extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "log", true);
                  this.mode = null;
                  this.threshold = null;
                  this.to = null;
                  this.uri = null;
                }
              }
              class MapElement extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "map", true);
                  this.equate = new _xfa_object.XFAObjectArray();
                  this.equateRange = new _xfa_object.XFAObjectArray();
                }
              }
              class MediumInfo extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "mediumInfo", true);
                  this.map = null;
                }
              }
              class Message extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "message", true);
                  this.msgId = null;
                  this.severity = null;
                }
              }
              class Messaging extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "messaging", true);
                  this.message = new _xfa_object.XFAObjectArray();
                }
              }
              class Mode extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "mode", ["append", "overwrite"]);
                }
              }
              class ModifyAnnots extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "modifyAnnots");
                }
              }
              class MsgId extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "msgId", 1, (n) => n >= 1);
                }
              }
              class NameAttr extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "nameAttr");
                }
              }
              class NeverEmbed extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "neverEmbed");
                }
              }
              class NumberOfCopies extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "numberOfCopies", null, (n) => n >= 2 && n <= 5);
                }
              }
              class OpenAction extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "openAction", true);
                  this.destination = null;
                }
              }
              class Output extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "output", true);
                  this.to = null;
                  this.type = null;
                  this.uri = null;
                }
              }
              class OutputBin extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "outputBin");
                }
              }
              class OutputXSL extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "outputXSL", true);
                  this.uri = null;
                }
              }
              class Overprint extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "overprint", ["none", "both", "draw", "field"]);
                }
              }
              class Packets extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "packets");
                }
                [_symbol_utils.$finalize]() {
                  if (this[_symbol_utils.$content] === "*") {
                    return;
                  }
                  this[_symbol_utils.$content] = this[_symbol_utils.$content].trim().split(/\s+/).filter((x) => ["config", "datasets", "template", "xfdf", "xslt"].includes(x));
                }
              }
              class PageOffset extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "pageOffset");
                  this.x = (0, _utils.getInteger)({
                    data: attributes.x,
                    defaultValue: "useXDCSetting",
                    validate: (n) => true
                  });
                  this.y = (0, _utils.getInteger)({
                    data: attributes.y,
                    defaultValue: "useXDCSetting",
                    validate: (n) => true
                  });
                }
              }
              class PageRange extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "pageRange");
                }
                [_symbol_utils.$finalize]() {
                  const numbers = this[_symbol_utils.$content].trim().split(/\s+/).map((x) => parseInt(x, 10));
                  const ranges = [];
                  for (let i = 0, ii = numbers.length; i < ii; i += 2) {
                    ranges.push(numbers.slice(i, i + 2));
                  }
                  this[_symbol_utils.$content] = ranges;
                }
              }
              class Pagination extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
                }
              }
              class PaginationOverride extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
                }
              }
              class Part extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "part", 1, (n) => false);
                }
              }
              class Pcl extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "pcl", true);
                  this.name = attributes.name || "";
                  this.batchOutput = null;
                  this.fontInfo = null;
                  this.jog = null;
                  this.mediumInfo = null;
                  this.outputBin = null;
                  this.pageOffset = null;
                  this.staple = null;
                  this.xdc = null;
                }
              }
              class Pdf extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "pdf", true);
                  this.name = attributes.name || "";
                  this.adobeExtensionLevel = null;
                  this.batchOutput = null;
                  this.compression = null;
                  this.creator = null;
                  this.encryption = null;
                  this.fontInfo = null;
                  this.interactive = null;
                  this.linearized = null;
                  this.openAction = null;
                  this.pdfa = null;
                  this.producer = null;
                  this.renderPolicy = null;
                  this.scriptModel = null;
                  this.silentPrint = null;
                  this.submitFormat = null;
                  this.tagged = null;
                  this.version = null;
                  this.viewerPreferences = null;
                  this.xdc = null;
                }
              }
              class Pdfa extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "pdfa", true);
                  this.amd = null;
                  this.conformance = null;
                  this.includeXDPContent = null;
                  this.part = null;
                }
              }
              class Permissions extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "permissions", true);
                  this.accessibleContent = null;
                  this.change = null;
                  this.contentCopy = null;
                  this.documentAssembly = null;
                  this.formFieldFilling = null;
                  this.modifyAnnots = null;
                  this.plaintextMetadata = null;
                  this.print = null;
                  this.printHighQuality = null;
                }
              }
              class PickTrayByPDFSize extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "pickTrayByPDFSize");
                }
              }
              class Picture extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "picture");
                }
              }
              class PlaintextMetadata extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "plaintextMetadata");
                }
              }
              class Presence extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
                }
              }
              class Present extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "present", true);
                  this.behaviorOverride = null;
                  this.cache = null;
                  this.common = null;
                  this.copies = null;
                  this.destination = null;
                  this.incrementalMerge = null;
                  this.layout = null;
                  this.output = null;
                  this.overprint = null;
                  this.pagination = null;
                  this.paginationOverride = null;
                  this.script = null;
                  this.validate = null;
                  this.xdp = null;
                  this.driver = new _xfa_object.XFAObjectArray();
                  this.labelPrinter = new _xfa_object.XFAObjectArray();
                  this.pcl = new _xfa_object.XFAObjectArray();
                  this.pdf = new _xfa_object.XFAObjectArray();
                  this.ps = new _xfa_object.XFAObjectArray();
                  this.submitUrl = new _xfa_object.XFAObjectArray();
                  this.webClient = new _xfa_object.XFAObjectArray();
                  this.zpl = new _xfa_object.XFAObjectArray();
                }
              }
              class Print extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "print");
                }
              }
              class PrintHighQuality extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "printHighQuality");
                }
              }
              class PrintScaling extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "printScaling", ["appdefault", "noScaling"]);
                }
              }
              class PrinterName extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "printerName");
                }
              }
              class Producer extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "producer");
                }
              }
              class Ps extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "ps", true);
                  this.name = attributes.name || "";
                  this.batchOutput = null;
                  this.fontInfo = null;
                  this.jog = null;
                  this.mediumInfo = null;
                  this.outputBin = null;
                  this.staple = null;
                  this.xdc = null;
                }
              }
              class Range extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "range");
                }
                [_symbol_utils.$finalize]() {
                  this[_symbol_utils.$content] = this[_symbol_utils.$content].trim().split(/\s*,\s*/, 2).map((range) => range.split("-").map((x) => parseInt(x.trim(), 10))).filter((range) => range.every((x) => !isNaN(x))).map((range) => {
                    if (range.length === 1) {
                      range.push(range[0]);
                    }
                    return range;
                  });
                }
              }
              class Record extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "record");
                }
                [_symbol_utils.$finalize]() {
                  this[_symbol_utils.$content] = this[_symbol_utils.$content].trim();
                  const n = parseInt(this[_symbol_utils.$content], 10);
                  if (!isNaN(n) && n >= 0) {
                    this[_symbol_utils.$content] = n;
                  }
                }
              }
              class Relevant extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "relevant");
                }
                [_symbol_utils.$finalize]() {
                  this[_symbol_utils.$content] = this[_symbol_utils.$content].trim().split(/\s+/);
                }
              }
              class Rename extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "rename");
                }
                [_symbol_utils.$finalize]() {
                  this[_symbol_utils.$content] = this[_symbol_utils.$content].trim();
                  if (this[_symbol_utils.$content].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[_symbol_utils.$content])) {
                    (0, _util.warn)("XFA - Rename: invalid XFA name");
                  }
                }
              }
              class RenderPolicy extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "renderPolicy", ["server", "client"]);
                }
              }
              class RunScripts extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "runScripts", ["both", "client", "none", "server"]);
                }
              }
              class Script extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "script", true);
                  this.currentPage = null;
                  this.exclude = null;
                  this.runScripts = null;
                }
              }
              class ScriptModel extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "scriptModel", ["XFA", "none"]);
                }
              }
              class Severity extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "severity", ["ignore", "error", "information", "trace", "warning"]);
                }
              }
              class SilentPrint extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "silentPrint", true);
                  this.addSilentPrint = null;
                  this.printerName = null;
                }
              }
              class Staple extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "staple");
                  this.mode = (0, _utils.getStringOption)(attributes.mode, ["usePrinterSetting", "on", "off"]);
                }
              }
              class StartNode extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "startNode");
                }
              }
              class StartPage extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "startPage", 0, (n) => true);
                }
              }
              class SubmitFormat extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
                }
              }
              class SubmitUrl extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "submitUrl");
                }
              }
              class SubsetBelow extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "subsetBelow", 100, (n) => n >= 0 && n <= 100);
                }
              }
              class SuppressBanner extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "suppressBanner");
                }
              }
              class Tagged extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "tagged");
                }
              }
              class Template extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "template", true);
                  this.base = null;
                  this.relevant = null;
                  this.startPage = null;
                  this.uri = null;
                  this.xsl = null;
                }
              }
              class Threshold extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "threshold", ["trace", "error", "information", "warning"]);
                }
              }
              class To extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
                }
              }
              class TemplateCache extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "templateCache");
                  this.maxEntries = (0, _utils.getInteger)({
                    data: attributes.maxEntries,
                    defaultValue: 5,
                    validate: (n) => n >= 0
                  });
                }
              }
              class Trace extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "trace", true);
                  this.area = new _xfa_object.XFAObjectArray();
                }
              }
              class Transform extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "transform", true);
                  this.groupParent = null;
                  this.ifEmpty = null;
                  this.nameAttr = null;
                  this.picture = null;
                  this.presence = null;
                  this.rename = null;
                  this.whitespace = null;
                }
              }
              class Type extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
                }
              }
              class Uri extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "uri");
                }
              }
              class Validate extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
                }
              }
              class ValidateApprovalSignatures extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "validateApprovalSignatures");
                }
                [_symbol_utils.$finalize]() {
                  this[_symbol_utils.$content] = this[_symbol_utils.$content].trim().split(/\s+/).filter((x) => ["docReady", "postSign"].includes(x));
                }
              }
              class ValidationMessaging extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
                }
              }
              class Version extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
                }
              }
              class VersionControl extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "VersionControl");
                  this.outputBelow = (0, _utils.getStringOption)(attributes.outputBelow, ["warn", "error", "update"]);
                  this.sourceAbove = (0, _utils.getStringOption)(attributes.sourceAbove, ["warn", "error"]);
                  this.sourceBelow = (0, _utils.getStringOption)(attributes.sourceBelow, ["update", "maintain"]);
                }
              }
              class ViewerPreferences extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "viewerPreferences", true);
                  this.ADBE_JSConsole = null;
                  this.ADBE_JSDebugger = null;
                  this.addViewerPreferences = null;
                  this.duplexOption = null;
                  this.enforce = null;
                  this.numberOfCopies = null;
                  this.pageRange = null;
                  this.pickTrayByPDFSize = null;
                  this.printScaling = null;
                }
              }
              class WebClient extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "webClient", true);
                  this.name = attributes.name ? attributes.name.trim() : "";
                  this.fontInfo = null;
                  this.xdc = null;
                }
              }
              class Whitespace extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
                }
              }
              class Window extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "window");
                }
                [_symbol_utils.$finalize]() {
                  const pair = this[_symbol_utils.$content].trim().split(/\s*,\s*/, 2).map((x) => parseInt(x, 10));
                  if (pair.some((x) => isNaN(x))) {
                    this[_symbol_utils.$content] = [0, 0];
                    return;
                  }
                  if (pair.length === 1) {
                    pair.push(pair[0]);
                  }
                  this[_symbol_utils.$content] = pair;
                }
              }
              class Xdc extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "xdc", true);
                  this.uri = new _xfa_object.XFAObjectArray();
                  this.xsl = new _xfa_object.XFAObjectArray();
                }
              }
              class Xdp extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "xdp", true);
                  this.packets = null;
                }
              }
              class Xsl extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "xsl", true);
                  this.debug = null;
                  this.uri = null;
                }
              }
              class Zpl extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "zpl", true);
                  this.name = attributes.name ? attributes.name.trim() : "";
                  this.batchOutput = null;
                  this.flipLabel = null;
                  this.fontInfo = null;
                  this.xdc = null;
                }
              }
              class ConfigNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (ConfigNamespace.hasOwnProperty(name)) {
                    return ConfigNamespace[name](attributes);
                  }
                  return void 0;
                }
                static acrobat(attrs) {
                  return new Acrobat(attrs);
                }
                static acrobat7(attrs) {
                  return new Acrobat7(attrs);
                }
                static ADBE_JSConsole(attrs) {
                  return new ADBE_JSConsole(attrs);
                }
                static ADBE_JSDebugger(attrs) {
                  return new ADBE_JSDebugger(attrs);
                }
                static addSilentPrint(attrs) {
                  return new AddSilentPrint(attrs);
                }
                static addViewerPreferences(attrs) {
                  return new AddViewerPreferences(attrs);
                }
                static adjustData(attrs) {
                  return new AdjustData(attrs);
                }
                static adobeExtensionLevel(attrs) {
                  return new AdobeExtensionLevel(attrs);
                }
                static agent(attrs) {
                  return new Agent(attrs);
                }
                static alwaysEmbed(attrs) {
                  return new AlwaysEmbed(attrs);
                }
                static amd(attrs) {
                  return new Amd(attrs);
                }
                static area(attrs) {
                  return new Area(attrs);
                }
                static attributes(attrs) {
                  return new Attributes(attrs);
                }
                static autoSave(attrs) {
                  return new AutoSave(attrs);
                }
                static base(attrs) {
                  return new Base(attrs);
                }
                static batchOutput(attrs) {
                  return new BatchOutput(attrs);
                }
                static behaviorOverride(attrs) {
                  return new BehaviorOverride(attrs);
                }
                static cache(attrs) {
                  return new Cache(attrs);
                }
                static change(attrs) {
                  return new Change(attrs);
                }
                static common(attrs) {
                  return new Common(attrs);
                }
                static compress(attrs) {
                  return new Compress(attrs);
                }
                static compressLogicalStructure(attrs) {
                  return new CompressLogicalStructure(attrs);
                }
                static compressObjectStream(attrs) {
                  return new CompressObjectStream(attrs);
                }
                static compression(attrs) {
                  return new Compression(attrs);
                }
                static config(attrs) {
                  return new Config(attrs);
                }
                static conformance(attrs) {
                  return new Conformance(attrs);
                }
                static contentCopy(attrs) {
                  return new ContentCopy(attrs);
                }
                static copies(attrs) {
                  return new Copies(attrs);
                }
                static creator(attrs) {
                  return new Creator(attrs);
                }
                static currentPage(attrs) {
                  return new CurrentPage(attrs);
                }
                static data(attrs) {
                  return new Data(attrs);
                }
                static debug(attrs) {
                  return new Debug(attrs);
                }
                static defaultTypeface(attrs) {
                  return new DefaultTypeface(attrs);
                }
                static destination(attrs) {
                  return new Destination(attrs);
                }
                static documentAssembly(attrs) {
                  return new DocumentAssembly(attrs);
                }
                static driver(attrs) {
                  return new Driver(attrs);
                }
                static duplexOption(attrs) {
                  return new DuplexOption(attrs);
                }
                static dynamicRender(attrs) {
                  return new DynamicRender(attrs);
                }
                static embed(attrs) {
                  return new Embed(attrs);
                }
                static encrypt(attrs) {
                  return new Encrypt(attrs);
                }
                static encryption(attrs) {
                  return new Encryption(attrs);
                }
                static encryptionLevel(attrs) {
                  return new EncryptionLevel(attrs);
                }
                static enforce(attrs) {
                  return new Enforce(attrs);
                }
                static equate(attrs) {
                  return new Equate(attrs);
                }
                static equateRange(attrs) {
                  return new EquateRange(attrs);
                }
                static exclude(attrs) {
                  return new Exclude(attrs);
                }
                static excludeNS(attrs) {
                  return new ExcludeNS(attrs);
                }
                static flipLabel(attrs) {
                  return new FlipLabel(attrs);
                }
                static fontInfo(attrs) {
                  return new FontInfo(attrs);
                }
                static formFieldFilling(attrs) {
                  return new FormFieldFilling(attrs);
                }
                static groupParent(attrs) {
                  return new GroupParent(attrs);
                }
                static ifEmpty(attrs) {
                  return new IfEmpty(attrs);
                }
                static includeXDPContent(attrs) {
                  return new IncludeXDPContent(attrs);
                }
                static incrementalLoad(attrs) {
                  return new IncrementalLoad(attrs);
                }
                static incrementalMerge(attrs) {
                  return new IncrementalMerge(attrs);
                }
                static interactive(attrs) {
                  return new Interactive(attrs);
                }
                static jog(attrs) {
                  return new Jog(attrs);
                }
                static labelPrinter(attrs) {
                  return new LabelPrinter(attrs);
                }
                static layout(attrs) {
                  return new Layout(attrs);
                }
                static level(attrs) {
                  return new Level(attrs);
                }
                static linearized(attrs) {
                  return new Linearized(attrs);
                }
                static locale(attrs) {
                  return new Locale(attrs);
                }
                static localeSet(attrs) {
                  return new LocaleSet(attrs);
                }
                static log(attrs) {
                  return new Log(attrs);
                }
                static map(attrs) {
                  return new MapElement(attrs);
                }
                static mediumInfo(attrs) {
                  return new MediumInfo(attrs);
                }
                static message(attrs) {
                  return new Message(attrs);
                }
                static messaging(attrs) {
                  return new Messaging(attrs);
                }
                static mode(attrs) {
                  return new Mode(attrs);
                }
                static modifyAnnots(attrs) {
                  return new ModifyAnnots(attrs);
                }
                static msgId(attrs) {
                  return new MsgId(attrs);
                }
                static nameAttr(attrs) {
                  return new NameAttr(attrs);
                }
                static neverEmbed(attrs) {
                  return new NeverEmbed(attrs);
                }
                static numberOfCopies(attrs) {
                  return new NumberOfCopies(attrs);
                }
                static openAction(attrs) {
                  return new OpenAction(attrs);
                }
                static output(attrs) {
                  return new Output(attrs);
                }
                static outputBin(attrs) {
                  return new OutputBin(attrs);
                }
                static outputXSL(attrs) {
                  return new OutputXSL(attrs);
                }
                static overprint(attrs) {
                  return new Overprint(attrs);
                }
                static packets(attrs) {
                  return new Packets(attrs);
                }
                static pageOffset(attrs) {
                  return new PageOffset(attrs);
                }
                static pageRange(attrs) {
                  return new PageRange(attrs);
                }
                static pagination(attrs) {
                  return new Pagination(attrs);
                }
                static paginationOverride(attrs) {
                  return new PaginationOverride(attrs);
                }
                static part(attrs) {
                  return new Part(attrs);
                }
                static pcl(attrs) {
                  return new Pcl(attrs);
                }
                static pdf(attrs) {
                  return new Pdf(attrs);
                }
                static pdfa(attrs) {
                  return new Pdfa(attrs);
                }
                static permissions(attrs) {
                  return new Permissions(attrs);
                }
                static pickTrayByPDFSize(attrs) {
                  return new PickTrayByPDFSize(attrs);
                }
                static picture(attrs) {
                  return new Picture(attrs);
                }
                static plaintextMetadata(attrs) {
                  return new PlaintextMetadata(attrs);
                }
                static presence(attrs) {
                  return new Presence(attrs);
                }
                static present(attrs) {
                  return new Present(attrs);
                }
                static print(attrs) {
                  return new Print(attrs);
                }
                static printHighQuality(attrs) {
                  return new PrintHighQuality(attrs);
                }
                static printScaling(attrs) {
                  return new PrintScaling(attrs);
                }
                static printerName(attrs) {
                  return new PrinterName(attrs);
                }
                static producer(attrs) {
                  return new Producer(attrs);
                }
                static ps(attrs) {
                  return new Ps(attrs);
                }
                static range(attrs) {
                  return new Range(attrs);
                }
                static record(attrs) {
                  return new Record(attrs);
                }
                static relevant(attrs) {
                  return new Relevant(attrs);
                }
                static rename(attrs) {
                  return new Rename(attrs);
                }
                static renderPolicy(attrs) {
                  return new RenderPolicy(attrs);
                }
                static runScripts(attrs) {
                  return new RunScripts(attrs);
                }
                static script(attrs) {
                  return new Script(attrs);
                }
                static scriptModel(attrs) {
                  return new ScriptModel(attrs);
                }
                static severity(attrs) {
                  return new Severity(attrs);
                }
                static silentPrint(attrs) {
                  return new SilentPrint(attrs);
                }
                static staple(attrs) {
                  return new Staple(attrs);
                }
                static startNode(attrs) {
                  return new StartNode(attrs);
                }
                static startPage(attrs) {
                  return new StartPage(attrs);
                }
                static submitFormat(attrs) {
                  return new SubmitFormat(attrs);
                }
                static submitUrl(attrs) {
                  return new SubmitUrl(attrs);
                }
                static subsetBelow(attrs) {
                  return new SubsetBelow(attrs);
                }
                static suppressBanner(attrs) {
                  return new SuppressBanner(attrs);
                }
                static tagged(attrs) {
                  return new Tagged(attrs);
                }
                static template(attrs) {
                  return new Template(attrs);
                }
                static templateCache(attrs) {
                  return new TemplateCache(attrs);
                }
                static threshold(attrs) {
                  return new Threshold(attrs);
                }
                static to(attrs) {
                  return new To(attrs);
                }
                static trace(attrs) {
                  return new Trace(attrs);
                }
                static transform(attrs) {
                  return new Transform(attrs);
                }
                static type(attrs) {
                  return new Type(attrs);
                }
                static uri(attrs) {
                  return new Uri(attrs);
                }
                static validate(attrs) {
                  return new Validate(attrs);
                }
                static validateApprovalSignatures(attrs) {
                  return new ValidateApprovalSignatures(attrs);
                }
                static validationMessaging(attrs) {
                  return new ValidationMessaging(attrs);
                }
                static version(attrs) {
                  return new Version(attrs);
                }
                static versionControl(attrs) {
                  return new VersionControl(attrs);
                }
                static viewerPreferences(attrs) {
                  return new ViewerPreferences(attrs);
                }
                static webClient(attrs) {
                  return new WebClient(attrs);
                }
                static whitespace(attrs) {
                  return new Whitespace(attrs);
                }
                static window(attrs) {
                  return new Window(attrs);
                }
                static xdc(attrs) {
                  return new Xdc(attrs);
                }
                static xdp(attrs) {
                  return new Xdp(attrs);
                }
                static xsl(attrs) {
                  return new Xsl(attrs);
                }
                static zpl(attrs) {
                  return new Zpl(attrs);
                }
              }
              exports2.ConfigNamespace = ConfigNamespace;
            },
            /* 94 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ConnectionSetNamespace = void 0;
              var _namespaces = __w_pdfjs_require__2(81);
              var _xfa_object = __w_pdfjs_require__2(87);
              const CONNECTION_SET_NS_ID = _namespaces.NamespaceIds.connectionSet.id;
              class ConnectionSet extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "connectionSet", true);
                  this.wsdlConnection = new _xfa_object.XFAObjectArray();
                  this.xmlConnection = new _xfa_object.XFAObjectArray();
                  this.xsdConnection = new _xfa_object.XFAObjectArray();
                }
              }
              class EffectiveInputPolicy extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "effectiveInputPolicy");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class EffectiveOutputPolicy extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "effectiveOutputPolicy");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class Operation extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "operation");
                  this.id = attributes.id || "";
                  this.input = attributes.input || "";
                  this.name = attributes.name || "";
                  this.output = attributes.output || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class RootElement extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "rootElement");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class SoapAction extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "soapAction");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class SoapAddress extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "soapAddress");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class Uri extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "uri");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class WsdlAddress extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "wsdlAddress");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              }
              class WsdlConnection extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "wsdlConnection", true);
                  this.dataDescription = attributes.dataDescription || "";
                  this.name = attributes.name || "";
                  this.effectiveInputPolicy = null;
                  this.effectiveOutputPolicy = null;
                  this.operation = null;
                  this.soapAction = null;
                  this.soapAddress = null;
                  this.wsdlAddress = null;
                }
              }
              class XmlConnection extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "xmlConnection", true);
                  this.dataDescription = attributes.dataDescription || "";
                  this.name = attributes.name || "";
                  this.uri = null;
                }
              }
              class XsdConnection extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "xsdConnection", true);
                  this.dataDescription = attributes.dataDescription || "";
                  this.name = attributes.name || "";
                  this.rootElement = null;
                  this.uri = null;
                }
              }
              class ConnectionSetNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (ConnectionSetNamespace.hasOwnProperty(name)) {
                    return ConnectionSetNamespace[name](attributes);
                  }
                  return void 0;
                }
                static connectionSet(attrs) {
                  return new ConnectionSet(attrs);
                }
                static effectiveInputPolicy(attrs) {
                  return new EffectiveInputPolicy(attrs);
                }
                static effectiveOutputPolicy(attrs) {
                  return new EffectiveOutputPolicy(attrs);
                }
                static operation(attrs) {
                  return new Operation(attrs);
                }
                static rootElement(attrs) {
                  return new RootElement(attrs);
                }
                static soapAction(attrs) {
                  return new SoapAction(attrs);
                }
                static soapAddress(attrs) {
                  return new SoapAddress(attrs);
                }
                static uri(attrs) {
                  return new Uri(attrs);
                }
                static wsdlAddress(attrs) {
                  return new WsdlAddress(attrs);
                }
                static wsdlConnection(attrs) {
                  return new WsdlConnection(attrs);
                }
                static xmlConnection(attrs) {
                  return new XmlConnection(attrs);
                }
                static xsdConnection(attrs) {
                  return new XsdConnection(attrs);
                }
              }
              exports2.ConnectionSetNamespace = ConnectionSetNamespace;
            },
            /* 95 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.DatasetsNamespace = void 0;
              var _symbol_utils = __w_pdfjs_require__2(78);
              var _namespaces = __w_pdfjs_require__2(81);
              var _xfa_object = __w_pdfjs_require__2(87);
              const DATASETS_NS_ID = _namespaces.NamespaceIds.datasets.id;
              class Data extends _xfa_object.XmlObject {
                constructor(attributes) {
                  super(DATASETS_NS_ID, "data", attributes);
                }
                [_symbol_utils.$isNsAgnostic]() {
                  return true;
                }
              }
              class Datasets extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(DATASETS_NS_ID, "datasets", true);
                  this.data = null;
                  this.Signature = null;
                }
                [_symbol_utils.$onChild](child) {
                  const name = child[_symbol_utils.$nodeName];
                  if (name === "data" && child[_symbol_utils.$namespaceId] === DATASETS_NS_ID || name === "Signature" && child[_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.signature.id) {
                    this[name] = child;
                  }
                  this[_symbol_utils.$appendChild](child);
                }
              }
              class DatasetsNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (DatasetsNamespace.hasOwnProperty(name)) {
                    return DatasetsNamespace[name](attributes);
                  }
                  return void 0;
                }
                static datasets(attributes) {
                  return new Datasets(attributes);
                }
                static data(attributes) {
                  return new Data(attributes);
                }
              }
              exports2.DatasetsNamespace = DatasetsNamespace;
            },
            /* 96 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.LocaleSetNamespace = void 0;
              var _namespaces = __w_pdfjs_require__2(81);
              var _xfa_object = __w_pdfjs_require__2(87);
              var _utils = __w_pdfjs_require__2(84);
              const LOCALE_SET_NS_ID = _namespaces.NamespaceIds.localeSet.id;
              class CalendarSymbols extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "calendarSymbols", true);
                  this.name = "gregorian";
                  this.dayNames = new _xfa_object.XFAObjectArray(2);
                  this.eraNames = null;
                  this.meridiemNames = null;
                  this.monthNames = new _xfa_object.XFAObjectArray(2);
                }
              }
              class CurrencySymbol extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "currencySymbol");
                  this.name = (0, _utils.getStringOption)(attributes.name, ["symbol", "isoname", "decimal"]);
                }
              }
              class CurrencySymbols extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "currencySymbols", true);
                  this.currencySymbol = new _xfa_object.XFAObjectArray(3);
                }
              }
              class DatePattern extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "datePattern");
                  this.name = (0, _utils.getStringOption)(attributes.name, ["full", "long", "med", "short"]);
                }
              }
              class DatePatterns extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "datePatterns", true);
                  this.datePattern = new _xfa_object.XFAObjectArray(4);
                }
              }
              class DateTimeSymbols extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "dateTimeSymbols");
                }
              }
              class Day extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "day");
                }
              }
              class DayNames extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "dayNames", true);
                  this.abbr = (0, _utils.getInteger)({
                    data: attributes.abbr,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.day = new _xfa_object.XFAObjectArray(7);
                }
              }
              class Era extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "era");
                }
              }
              class EraNames extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "eraNames", true);
                  this.era = new _xfa_object.XFAObjectArray(2);
                }
              }
              class Locale extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "locale", true);
                  this.desc = attributes.desc || "";
                  this.name = "isoname";
                  this.calendarSymbols = null;
                  this.currencySymbols = null;
                  this.datePatterns = null;
                  this.dateTimeSymbols = null;
                  this.numberPatterns = null;
                  this.numberSymbols = null;
                  this.timePatterns = null;
                  this.typeFaces = null;
                }
              }
              class LocaleSet extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "localeSet", true);
                  this.locale = new _xfa_object.XFAObjectArray();
                }
              }
              class Meridiem extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "meridiem");
                }
              }
              class MeridiemNames extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "meridiemNames", true);
                  this.meridiem = new _xfa_object.XFAObjectArray(2);
                }
              }
              class Month extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "month");
                }
              }
              class MonthNames extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "monthNames", true);
                  this.abbr = (0, _utils.getInteger)({
                    data: attributes.abbr,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.month = new _xfa_object.XFAObjectArray(12);
                }
              }
              class NumberPattern extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "numberPattern");
                  this.name = (0, _utils.getStringOption)(attributes.name, ["full", "long", "med", "short"]);
                }
              }
              class NumberPatterns extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "numberPatterns", true);
                  this.numberPattern = new _xfa_object.XFAObjectArray(4);
                }
              }
              class NumberSymbol extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "numberSymbol");
                  this.name = (0, _utils.getStringOption)(attributes.name, ["decimal", "grouping", "percent", "minus", "zero"]);
                }
              }
              class NumberSymbols extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "numberSymbols", true);
                  this.numberSymbol = new _xfa_object.XFAObjectArray(5);
                }
              }
              class TimePattern extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "timePattern");
                  this.name = (0, _utils.getStringOption)(attributes.name, ["full", "long", "med", "short"]);
                }
              }
              class TimePatterns extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "timePatterns", true);
                  this.timePattern = new _xfa_object.XFAObjectArray(4);
                }
              }
              class TypeFace extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "typeFace", true);
                  this.name = attributes.name | "";
                }
              }
              class TypeFaces extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "typeFaces", true);
                  this.typeFace = new _xfa_object.XFAObjectArray();
                }
              }
              class LocaleSetNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (LocaleSetNamespace.hasOwnProperty(name)) {
                    return LocaleSetNamespace[name](attributes);
                  }
                  return void 0;
                }
                static calendarSymbols(attrs) {
                  return new CalendarSymbols(attrs);
                }
                static currencySymbol(attrs) {
                  return new CurrencySymbol(attrs);
                }
                static currencySymbols(attrs) {
                  return new CurrencySymbols(attrs);
                }
                static datePattern(attrs) {
                  return new DatePattern(attrs);
                }
                static datePatterns(attrs) {
                  return new DatePatterns(attrs);
                }
                static dateTimeSymbols(attrs) {
                  return new DateTimeSymbols(attrs);
                }
                static day(attrs) {
                  return new Day(attrs);
                }
                static dayNames(attrs) {
                  return new DayNames(attrs);
                }
                static era(attrs) {
                  return new Era(attrs);
                }
                static eraNames(attrs) {
                  return new EraNames(attrs);
                }
                static locale(attrs) {
                  return new Locale(attrs);
                }
                static localeSet(attrs) {
                  return new LocaleSet(attrs);
                }
                static meridiem(attrs) {
                  return new Meridiem(attrs);
                }
                static meridiemNames(attrs) {
                  return new MeridiemNames(attrs);
                }
                static month(attrs) {
                  return new Month(attrs);
                }
                static monthNames(attrs) {
                  return new MonthNames(attrs);
                }
                static numberPattern(attrs) {
                  return new NumberPattern(attrs);
                }
                static numberPatterns(attrs) {
                  return new NumberPatterns(attrs);
                }
                static numberSymbol(attrs) {
                  return new NumberSymbol(attrs);
                }
                static numberSymbols(attrs) {
                  return new NumberSymbols(attrs);
                }
                static timePattern(attrs) {
                  return new TimePattern(attrs);
                }
                static timePatterns(attrs) {
                  return new TimePatterns(attrs);
                }
                static typeFace(attrs) {
                  return new TypeFace(attrs);
                }
                static typeFaces(attrs) {
                  return new TypeFaces(attrs);
                }
              }
              exports2.LocaleSetNamespace = LocaleSetNamespace;
            },
            /* 97 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SignatureNamespace = void 0;
              var _namespaces = __w_pdfjs_require__2(81);
              var _xfa_object = __w_pdfjs_require__2(87);
              const SIGNATURE_NS_ID = _namespaces.NamespaceIds.signature.id;
              class Signature extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(SIGNATURE_NS_ID, "signature", true);
                }
              }
              class SignatureNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (SignatureNamespace.hasOwnProperty(name)) {
                    return SignatureNamespace[name](attributes);
                  }
                  return void 0;
                }
                static signature(attributes) {
                  return new Signature(attributes);
                }
              }
              exports2.SignatureNamespace = SignatureNamespace;
            },
            /* 98 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StylesheetNamespace = void 0;
              var _namespaces = __w_pdfjs_require__2(81);
              var _xfa_object = __w_pdfjs_require__2(87);
              const STYLESHEET_NS_ID = _namespaces.NamespaceIds.stylesheet.id;
              class Stylesheet extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(STYLESHEET_NS_ID, "stylesheet", true);
                }
              }
              class StylesheetNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (StylesheetNamespace.hasOwnProperty(name)) {
                    return StylesheetNamespace[name](attributes);
                  }
                  return void 0;
                }
                static stylesheet(attributes) {
                  return new Stylesheet(attributes);
                }
              }
              exports2.StylesheetNamespace = StylesheetNamespace;
            },
            /* 99 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XdpNamespace = void 0;
              var _namespaces = __w_pdfjs_require__2(81);
              var _symbol_utils = __w_pdfjs_require__2(78);
              var _xfa_object = __w_pdfjs_require__2(87);
              const XDP_NS_ID = _namespaces.NamespaceIds.xdp.id;
              class Xdp extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(XDP_NS_ID, "xdp", true);
                  this.uuid = attributes.uuid || "";
                  this.timeStamp = attributes.timeStamp || "";
                  this.config = null;
                  this.connectionSet = null;
                  this.datasets = null;
                  this.localeSet = null;
                  this.stylesheet = new _xfa_object.XFAObjectArray();
                  this.template = null;
                }
                [_symbol_utils.$onChildCheck](child) {
                  const ns = _namespaces.NamespaceIds[child[_symbol_utils.$nodeName]];
                  return ns && child[_symbol_utils.$namespaceId] === ns.id;
                }
              }
              class XdpNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (XdpNamespace.hasOwnProperty(name)) {
                    return XdpNamespace[name](attributes);
                  }
                  return void 0;
                }
                static xdp(attributes) {
                  return new Xdp(attributes);
                }
              }
              exports2.XdpNamespace = XdpNamespace;
            },
            /* 100 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XhtmlNamespace = void 0;
              var _symbol_utils = __w_pdfjs_require__2(78);
              var _namespaces = __w_pdfjs_require__2(81);
              var _html_utils = __w_pdfjs_require__2(83);
              var _utils = __w_pdfjs_require__2(84);
              var _xfa_object = __w_pdfjs_require__2(87);
              const XHTML_NS_ID = _namespaces.NamespaceIds.xhtml.id;
              const $richText = Symbol();
              const VALID_STYLES = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]);
              const StyleMapping = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (value) => value === "none" ? "none" : "normal"], ["xfa-font-horizontal-scale", (value) => `scaleX(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", (value) => `scaleY(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (value, original) => {
                value = original.fontSize = (0, _utils.getMeasurement)(value);
                return (0, _html_utils.measureToString)(0.99 * value);
              }], ["letter-spacing", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["line-height", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-bottom", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-left", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-right", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-top", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["text-indent", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["font-family", (value) => value], ["vertical-align", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))]]);
              const spacesRegExp = /\s+/g;
              const crlfRegExp = /[\r\n]+/g;
              const crlfForRichTextRegExp = /\r\n?/g;
              function mapStyle(styleStr, node, richText) {
                const style = /* @__PURE__ */ Object.create(null);
                if (!styleStr) {
                  return style;
                }
                const original = /* @__PURE__ */ Object.create(null);
                for (const [key, value] of styleStr.split(";").map((s) => s.split(":", 2))) {
                  const mapping = StyleMapping.get(key);
                  if (mapping === "") {
                    continue;
                  }
                  let newValue = value;
                  if (mapping) {
                    newValue = typeof mapping === "string" ? mapping : mapping(value, original);
                  }
                  if (key.endsWith("scale")) {
                    style.transform = style.transform ? `${style[key]} ${newValue}` : newValue;
                  } else {
                    style[key.replaceAll(/-([a-zA-Z])/g, (_, x) => x.toUpperCase())] = newValue;
                  }
                }
                if (style.fontFamily) {
                  (0, _html_utils.setFontFamily)({
                    typeface: style.fontFamily,
                    weight: style.fontWeight || "normal",
                    posture: style.fontStyle || "normal",
                    size: original.fontSize || 0
                  }, node, node[_symbol_utils.$globalData].fontFinder, style);
                }
                if (richText && style.verticalAlign && style.verticalAlign !== "0px" && style.fontSize) {
                  const SUB_SUPER_SCRIPT_FACTOR = 0.583;
                  const VERTICAL_FACTOR = 0.333;
                  const fontSize = (0, _utils.getMeasurement)(style.fontSize);
                  style.fontSize = (0, _html_utils.measureToString)(fontSize * SUB_SUPER_SCRIPT_FACTOR);
                  style.verticalAlign = (0, _html_utils.measureToString)(Math.sign((0, _utils.getMeasurement)(style.verticalAlign)) * fontSize * VERTICAL_FACTOR);
                }
                if (richText && style.fontSize) {
                  style.fontSize = `calc(${style.fontSize} * var(--scale-factor))`;
                }
                (0, _html_utils.fixTextIndent)(style);
                return style;
              }
              function checkStyle(node) {
                if (!node.style) {
                  return "";
                }
                return node.style.trim().split(/\s*;\s*/).filter((s) => !!s).map((s) => s.split(/\s*:\s*/, 2)).filter(([key, value]) => {
                  if (key === "font-family") {
                    node[_symbol_utils.$globalData].usedTypefaces.add(value);
                  }
                  return VALID_STYLES.has(key);
                }).map((kv) => kv.join(":")).join(";");
              }
              const NoWhites = /* @__PURE__ */ new Set(["body", "html"]);
              class XhtmlObject extends _xfa_object.XmlObject {
                constructor(attributes, name) {
                  super(XHTML_NS_ID, name);
                  this[$richText] = false;
                  this.style = attributes.style || "";
                }
                [_symbol_utils.$clean](builder) {
                  super[_symbol_utils.$clean](builder);
                  this.style = checkStyle(this);
                }
                [_symbol_utils.$acceptWhitespace]() {
                  return !NoWhites.has(this[_symbol_utils.$nodeName]);
                }
                [_symbol_utils.$onText](str, richText = false) {
                  if (!richText) {
                    str = str.replaceAll(crlfRegExp, "");
                    if (!this.style.includes("xfa-spacerun:yes")) {
                      str = str.replaceAll(spacesRegExp, " ");
                    }
                  } else {
                    this[$richText] = true;
                  }
                  if (str) {
                    this[_symbol_utils.$content] += str;
                  }
                }
                [_symbol_utils.$pushGlyphs](measure, mustPop = true) {
                  const xfaFont = /* @__PURE__ */ Object.create(null);
                  const margin = {
                    top: NaN,
                    bottom: NaN,
                    left: NaN,
                    right: NaN
                  };
                  let lineHeight = null;
                  for (const [key, value] of this.style.split(";").map((s) => s.split(":", 2))) {
                    switch (key) {
                      case "font-family":
                        xfaFont.typeface = (0, _utils.stripQuotes)(value);
                        break;
                      case "font-size":
                        xfaFont.size = (0, _utils.getMeasurement)(value);
                        break;
                      case "font-weight":
                        xfaFont.weight = value;
                        break;
                      case "font-style":
                        xfaFont.posture = value;
                        break;
                      case "letter-spacing":
                        xfaFont.letterSpacing = (0, _utils.getMeasurement)(value);
                        break;
                      case "margin":
                        const values = value.split(/ \t/).map((x) => (0, _utils.getMeasurement)(x));
                        switch (values.length) {
                          case 1:
                            margin.top = margin.bottom = margin.left = margin.right = values[0];
                            break;
                          case 2:
                            margin.top = margin.bottom = values[0];
                            margin.left = margin.right = values[1];
                            break;
                          case 3:
                            margin.top = values[0];
                            margin.bottom = values[2];
                            margin.left = margin.right = values[1];
                            break;
                          case 4:
                            margin.top = values[0];
                            margin.left = values[1];
                            margin.bottom = values[2];
                            margin.right = values[3];
                            break;
                        }
                        break;
                      case "margin-top":
                        margin.top = (0, _utils.getMeasurement)(value);
                        break;
                      case "margin-bottom":
                        margin.bottom = (0, _utils.getMeasurement)(value);
                        break;
                      case "margin-left":
                        margin.left = (0, _utils.getMeasurement)(value);
                        break;
                      case "margin-right":
                        margin.right = (0, _utils.getMeasurement)(value);
                        break;
                      case "line-height":
                        lineHeight = (0, _utils.getMeasurement)(value);
                        break;
                    }
                  }
                  measure.pushData(xfaFont, margin, lineHeight);
                  if (this[_symbol_utils.$content]) {
                    measure.addString(this[_symbol_utils.$content]);
                  } else {
                    for (const child of this[_symbol_utils.$getChildren]()) {
                      if (child[_symbol_utils.$nodeName] === "#text") {
                        measure.addString(child[_symbol_utils.$content]);
                        continue;
                      }
                      child[_symbol_utils.$pushGlyphs](measure);
                    }
                  }
                  if (mustPop) {
                    measure.popFont();
                  }
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  const children = [];
                  this[_symbol_utils.$extra] = {
                    children
                  };
                  this[_symbol_utils.$childrenToHTML]({});
                  if (children.length === 0 && !this[_symbol_utils.$content]) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  let value;
                  if (this[$richText]) {
                    value = this[_symbol_utils.$content] ? this[_symbol_utils.$content].replaceAll(crlfForRichTextRegExp, "\n") : void 0;
                  } else {
                    value = this[_symbol_utils.$content] || void 0;
                  }
                  return _utils.HTMLResult.success({
                    name: this[_symbol_utils.$nodeName],
                    attributes: {
                      href: this.href,
                      style: mapStyle(this.style, this, this[$richText])
                    },
                    children,
                    value
                  });
                }
              }
              class A extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "a");
                  this.href = (0, _html_utils.fixURL)(attributes.href) || "";
                }
              }
              class B extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "b");
                }
                [_symbol_utils.$pushGlyphs](measure) {
                  measure.pushFont({
                    weight: "bold"
                  });
                  super[_symbol_utils.$pushGlyphs](measure);
                  measure.popFont();
                }
              }
              class Body extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "body");
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  const res = super[_symbol_utils.$toHTML](availableSpace);
                  const {
                    html
                  } = res;
                  if (!html) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  html.name = "div";
                  html.attributes.class = ["xfaRich"];
                  return res;
                }
              }
              class Br extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "br");
                }
                [_symbol_utils.$text]() {
                  return "\n";
                }
                [_symbol_utils.$pushGlyphs](measure) {
                  measure.addString("\n");
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  return _utils.HTMLResult.success({
                    name: "br"
                  });
                }
              }
              class Html extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "html");
                }
                [_symbol_utils.$toHTML](availableSpace) {
                  var _a;
                  const children = [];
                  this[_symbol_utils.$extra] = {
                    children
                  };
                  this[_symbol_utils.$childrenToHTML]({});
                  if (children.length === 0) {
                    return _utils.HTMLResult.success({
                      name: "div",
                      attributes: {
                        class: ["xfaRich"],
                        style: {}
                      },
                      value: this[_symbol_utils.$content] || ""
                    });
                  }
                  if (children.length === 1) {
                    const child = children[0];
                    if ((_a = child.attributes) == null ? void 0 : _a.class.includes("xfaRich")) {
                      return _utils.HTMLResult.success(child);
                    }
                  }
                  return _utils.HTMLResult.success({
                    name: "div",
                    attributes: {
                      class: ["xfaRich"],
                      style: {}
                    },
                    children
                  });
                }
              }
              class I extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "i");
                }
                [_symbol_utils.$pushGlyphs](measure) {
                  measure.pushFont({
                    posture: "italic"
                  });
                  super[_symbol_utils.$pushGlyphs](measure);
                  measure.popFont();
                }
              }
              class Li extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "li");
                }
              }
              class Ol extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "ol");
                }
              }
              class P extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "p");
                }
                [_symbol_utils.$pushGlyphs](measure) {
                  super[_symbol_utils.$pushGlyphs](measure, false);
                  measure.addString("\n");
                  measure.addPara();
                  measure.popFont();
                }
                [_symbol_utils.$text]() {
                  const siblings = this[_symbol_utils.$getParent]()[_symbol_utils.$getChildren]();
                  if (siblings.at(-1) === this) {
                    return super[_symbol_utils.$text]();
                  }
                  return super[_symbol_utils.$text]() + "\n";
                }
              }
              class Span extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "span");
                }
              }
              class Sub extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "sub");
                }
              }
              class Sup extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "sup");
                }
              }
              class Ul extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "ul");
                }
              }
              class XhtmlNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (XhtmlNamespace.hasOwnProperty(name)) {
                    return XhtmlNamespace[name](attributes);
                  }
                  return void 0;
                }
                static a(attributes) {
                  return new A(attributes);
                }
                static b(attributes) {
                  return new B(attributes);
                }
                static body(attributes) {
                  return new Body(attributes);
                }
                static br(attributes) {
                  return new Br(attributes);
                }
                static html(attributes) {
                  return new Html(attributes);
                }
                static i(attributes) {
                  return new I(attributes);
                }
                static li(attributes) {
                  return new Li(attributes);
                }
                static ol(attributes) {
                  return new Ol(attributes);
                }
                static p(attributes) {
                  return new P(attributes);
                }
                static span(attributes) {
                  return new Span(attributes);
                }
                static sub(attributes) {
                  return new Sub(attributes);
                }
                static sup(attributes) {
                  return new Sup(attributes);
                }
                static ul(attributes) {
                  return new Ul(attributes);
                }
              }
              exports2.XhtmlNamespace = XhtmlNamespace;
            },
            /* 101 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.UnknownNamespace = void 0;
              var _namespaces = __w_pdfjs_require__2(81);
              var _xfa_object = __w_pdfjs_require__2(87);
              class UnknownNamespace {
                constructor(nsId) {
                  this.namespaceId = nsId;
                }
                [_namespaces.$buildXFAObject](name, attributes) {
                  return new _xfa_object.XmlObject(this.namespaceId, name, attributes);
                }
              }
              exports2.UnknownNamespace = UnknownNamespace;
            },
            /* 102 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.DatasetReader = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _core_utils = __w_pdfjs_require__2(3);
              var _xml_parser = __w_pdfjs_require__2(71);
              function decodeString(str) {
                try {
                  return (0, _util.stringToUTF8String)(str);
                } catch (ex) {
                  (0, _util.warn)(`UTF-8 decoding failed: "${ex}".`);
                  return str;
                }
              }
              class DatasetXMLParser extends _xml_parser.SimpleXMLParser {
                constructor(options) {
                  super(options);
                  this.node = null;
                }
                onEndElement(name) {
                  const node = super.onEndElement(name);
                  if (node && name === "xfa:datasets") {
                    this.node = node;
                    throw new Error("Aborting DatasetXMLParser.");
                  }
                }
              }
              class DatasetReader {
                constructor(data) {
                  if (data.datasets) {
                    this.node = new _xml_parser.SimpleXMLParser({
                      hasAttributes: true
                    }).parseFromString(data.datasets).documentElement;
                  } else {
                    const parser = new DatasetXMLParser({
                      hasAttributes: true
                    });
                    try {
                      parser.parseFromString(data["xdp:xdp"]);
                    } catch {
                    }
                    this.node = parser.node;
                  }
                }
                getValue(path) {
                  if (!this.node || !path) {
                    return "";
                  }
                  const node = this.node.searchNode((0, _core_utils.parseXFAPath)(path), 0);
                  if (!node) {
                    return "";
                  }
                  const first = node.firstChild;
                  if ((first == null ? void 0 : first.nodeName) === "value") {
                    return node.children.map((child) => decodeString(child.textContent));
                  }
                  return decodeString(node.textContent);
                }
              }
              exports2.DatasetReader = DatasetReader;
            },
            /* 103 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var _firstXRefStmPos;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XRef = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(4);
              var _parser = __w_pdfjs_require__2(16);
              var _core_utils = __w_pdfjs_require__2(3);
              var _base_stream = __w_pdfjs_require__2(5);
              var _crypto = __w_pdfjs_require__2(74);
              class XRef {
                constructor(stream, pdfManager) {
                  __privateAdd(this, _firstXRefStmPos, null);
                  this.stream = stream;
                  this.pdfManager = pdfManager;
                  this.entries = [];
                  this._xrefStms = /* @__PURE__ */ new Set();
                  this._cacheMap = /* @__PURE__ */ new Map();
                  this._pendingRefs = new _primitives.RefSet();
                  this._newPersistentRefNum = null;
                  this._newTemporaryRefNum = null;
                }
                getNewPersistentRef(obj) {
                  if (this._newPersistentRefNum === null) {
                    this._newPersistentRefNum = this.entries.length || 1;
                  }
                  const num = this._newPersistentRefNum++;
                  this._cacheMap.set(num, obj);
                  return _primitives.Ref.get(num, 0);
                }
                getNewTemporaryRef() {
                  if (this._newTemporaryRefNum === null) {
                    this._newTemporaryRefNum = this.entries.length || 1;
                  }
                  return _primitives.Ref.get(this._newTemporaryRefNum++, 0);
                }
                resetNewTemporaryRef() {
                  this._newTemporaryRefNum = null;
                }
                setStartXRef(startXRef) {
                  this.startXRefQueue = [startXRef];
                }
                parse(recoveryMode = false) {
                  let trailerDict;
                  if (!recoveryMode) {
                    trailerDict = this.readXRef();
                  } else {
                    (0, _util.warn)("Indexing all PDF objects");
                    trailerDict = this.indexObjects();
                  }
                  trailerDict.assignXref(this);
                  this.trailer = trailerDict;
                  let encrypt;
                  try {
                    encrypt = trailerDict.get("Encrypt");
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)(`XRef.parse - Invalid "Encrypt" reference: "${ex}".`);
                  }
                  if (encrypt instanceof _primitives.Dict) {
                    const ids = trailerDict.get("ID");
                    const fileId = (ids == null ? void 0 : ids.length) ? ids[0] : "";
                    encrypt.suppressEncryption = true;
                    this.encrypt = new _crypto.CipherTransformFactory(encrypt, fileId, this.pdfManager.password);
                  }
                  let root;
                  try {
                    root = trailerDict.get("Root");
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)(`XRef.parse - Invalid "Root" reference: "${ex}".`);
                  }
                  if (root instanceof _primitives.Dict) {
                    try {
                      const pages = root.get("Pages");
                      if (pages instanceof _primitives.Dict) {
                        this.root = root;
                        return;
                      }
                    } catch (ex) {
                      if (ex instanceof _core_utils.MissingDataException) {
                        throw ex;
                      }
                      (0, _util.warn)(`XRef.parse - Invalid "Pages" reference: "${ex}".`);
                    }
                  }
                  if (!recoveryMode) {
                    throw new _core_utils.XRefParseException();
                  }
                  throw new _util.InvalidPDFException("Invalid Root reference.");
                }
                processXRefTable(parser) {
                  if (!("tableState" in this)) {
                    this.tableState = {
                      entryNum: 0,
                      streamPos: parser.lexer.stream.pos,
                      parserBuf1: parser.buf1,
                      parserBuf2: parser.buf2
                    };
                  }
                  const obj = this.readXRefTable(parser);
                  if (!(0, _primitives.isCmd)(obj, "trailer")) {
                    throw new _util.FormatError("Invalid XRef table: could not find trailer dictionary");
                  }
                  let dict = parser.getObj();
                  if (!(dict instanceof _primitives.Dict) && dict.dict) {
                    dict = dict.dict;
                  }
                  if (!(dict instanceof _primitives.Dict)) {
                    throw new _util.FormatError("Invalid XRef table: could not parse trailer dictionary");
                  }
                  delete this.tableState;
                  return dict;
                }
                readXRefTable(parser) {
                  const stream = parser.lexer.stream;
                  const tableState = this.tableState;
                  stream.pos = tableState.streamPos;
                  parser.buf1 = tableState.parserBuf1;
                  parser.buf2 = tableState.parserBuf2;
                  let obj;
                  while (true) {
                    if (!("firstEntryNum" in tableState) || !("entryCount" in tableState)) {
                      if ((0, _primitives.isCmd)(obj = parser.getObj(), "trailer")) {
                        break;
                      }
                      tableState.firstEntryNum = obj;
                      tableState.entryCount = parser.getObj();
                    }
                    let first = tableState.firstEntryNum;
                    const count = tableState.entryCount;
                    if (!Number.isInteger(first) || !Number.isInteger(count)) {
                      throw new _util.FormatError("Invalid XRef table: wrong types in subsection header");
                    }
                    for (let i = tableState.entryNum; i < count; i++) {
                      tableState.streamPos = stream.pos;
                      tableState.entryNum = i;
                      tableState.parserBuf1 = parser.buf1;
                      tableState.parserBuf2 = parser.buf2;
                      const entry = {};
                      entry.offset = parser.getObj();
                      entry.gen = parser.getObj();
                      const type = parser.getObj();
                      if (type instanceof _primitives.Cmd) {
                        switch (type.cmd) {
                          case "f":
                            entry.free = true;
                            break;
                          case "n":
                            entry.uncompressed = true;
                            break;
                        }
                      }
                      if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {
                        throw new _util.FormatError(`Invalid entry in XRef subsection: ${first}, ${count}`);
                      }
                      if (i === 0 && entry.free && first === 1) {
                        first = 0;
                      }
                      if (!this.entries[i + first]) {
                        this.entries[i + first] = entry;
                      }
                    }
                    tableState.entryNum = 0;
                    tableState.streamPos = stream.pos;
                    tableState.parserBuf1 = parser.buf1;
                    tableState.parserBuf2 = parser.buf2;
                    delete tableState.firstEntryNum;
                    delete tableState.entryCount;
                  }
                  if (this.entries[0] && !this.entries[0].free) {
                    throw new _util.FormatError("Invalid XRef table: unexpected first object");
                  }
                  return obj;
                }
                processXRefStream(stream) {
                  if (!("streamState" in this)) {
                    const streamParameters = stream.dict;
                    const byteWidths = streamParameters.get("W");
                    let range = streamParameters.get("Index");
                    if (!range) {
                      range = [0, streamParameters.get("Size")];
                    }
                    this.streamState = {
                      entryRanges: range,
                      byteWidths,
                      entryNum: 0,
                      streamPos: stream.pos
                    };
                  }
                  this.readXRefStream(stream);
                  delete this.streamState;
                  return stream.dict;
                }
                readXRefStream(stream) {
                  const streamState = this.streamState;
                  stream.pos = streamState.streamPos;
                  const [typeFieldWidth, offsetFieldWidth, generationFieldWidth] = streamState.byteWidths;
                  const entryRanges = streamState.entryRanges;
                  while (entryRanges.length > 0) {
                    const [first, n] = entryRanges;
                    if (!Number.isInteger(first) || !Number.isInteger(n)) {
                      throw new _util.FormatError(`Invalid XRef range fields: ${first}, ${n}`);
                    }
                    if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {
                      throw new _util.FormatError(`Invalid XRef entry fields length: ${first}, ${n}`);
                    }
                    for (let i = streamState.entryNum; i < n; ++i) {
                      streamState.entryNum = i;
                      streamState.streamPos = stream.pos;
                      let type = 0, offset = 0, generation = 0;
                      for (let j = 0; j < typeFieldWidth; ++j) {
                        const typeByte = stream.getByte();
                        if (typeByte === -1) {
                          throw new _util.FormatError("Invalid XRef byteWidths 'type'.");
                        }
                        type = type << 8 | typeByte;
                      }
                      if (typeFieldWidth === 0) {
                        type = 1;
                      }
                      for (let j = 0; j < offsetFieldWidth; ++j) {
                        const offsetByte = stream.getByte();
                        if (offsetByte === -1) {
                          throw new _util.FormatError("Invalid XRef byteWidths 'offset'.");
                        }
                        offset = offset << 8 | offsetByte;
                      }
                      for (let j = 0; j < generationFieldWidth; ++j) {
                        const generationByte = stream.getByte();
                        if (generationByte === -1) {
                          throw new _util.FormatError("Invalid XRef byteWidths 'generation'.");
                        }
                        generation = generation << 8 | generationByte;
                      }
                      const entry = {};
                      entry.offset = offset;
                      entry.gen = generation;
                      switch (type) {
                        case 0:
                          entry.free = true;
                          break;
                        case 1:
                          entry.uncompressed = true;
                          break;
                        case 2:
                          break;
                        default:
                          throw new _util.FormatError(`Invalid XRef entry type: ${type}`);
                      }
                      if (!this.entries[first + i]) {
                        this.entries[first + i] = entry;
                      }
                    }
                    streamState.entryNum = 0;
                    streamState.streamPos = stream.pos;
                    entryRanges.splice(0, 2);
                  }
                }
                indexObjects() {
                  const TAB = 9, LF = 10, CR = 13, SPACE = 32;
                  const PERCENT = 37, LT = 60;
                  function readToken(data, offset) {
                    let token = "", ch = data[offset];
                    while (ch !== LF && ch !== CR && ch !== LT) {
                      if (++offset >= data.length) {
                        break;
                      }
                      token += String.fromCharCode(ch);
                      ch = data[offset];
                    }
                    return token;
                  }
                  function skipUntil(data, offset, what) {
                    const length2 = what.length, dataLength = data.length;
                    let skipped = 0;
                    while (offset < dataLength) {
                      let i = 0;
                      while (i < length2 && data[offset + i] === what[i]) {
                        ++i;
                      }
                      if (i >= length2) {
                        break;
                      }
                      offset++;
                      skipped++;
                    }
                    return skipped;
                  }
                  const gEndobjRegExp = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g;
                  const gStartxrefRegExp = /\b(startxref|\d+\s+\d+\s+obj)\b/g;
                  const objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
                  const trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
                  const startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
                  const xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
                  this.entries.length = 0;
                  this._cacheMap.clear();
                  const stream = this.stream;
                  stream.pos = 0;
                  const buffer = stream.getBytes(), bufferStr = (0, _util.bytesToString)(buffer), length = buffer.length;
                  let position = stream.start;
                  const trailers = [], xrefStms = [];
                  while (position < length) {
                    let ch = buffer[position];
                    if (ch === TAB || ch === LF || ch === CR || ch === SPACE) {
                      ++position;
                      continue;
                    }
                    if (ch === PERCENT) {
                      do {
                        ++position;
                        if (position >= length) {
                          break;
                        }
                        ch = buffer[position];
                      } while (ch !== LF && ch !== CR);
                      continue;
                    }
                    const token = readToken(buffer, position);
                    let m;
                    if (token.startsWith("xref") && (token.length === 4 || /\s/.test(token[4]))) {
                      position += skipUntil(buffer, position, trailerBytes);
                      trailers.push(position);
                      position += skipUntil(buffer, position, startxrefBytes);
                    } else if (m = objRegExp.exec(token)) {
                      const num = m[1] | 0, gen = m[2] | 0;
                      const startPos = position + token.length;
                      let contentLength, updateEntries = false;
                      if (!this.entries[num]) {
                        updateEntries = true;
                      } else if (this.entries[num].gen === gen) {
                        try {
                          const parser = new _parser.Parser({
                            lexer: new _parser.Lexer(stream.makeSubStream(startPos))
                          });
                          parser.getObj();
                          updateEntries = true;
                        } catch (ex) {
                          if (ex instanceof _core_utils.ParserEOFException) {
                            (0, _util.warn)(`indexObjects -- checking object (${token}): "${ex}".`);
                          } else {
                            updateEntries = true;
                          }
                        }
                      }
                      if (updateEntries) {
                        this.entries[num] = {
                          offset: position - stream.start,
                          gen,
                          uncompressed: true
                        };
                      }
                      gEndobjRegExp.lastIndex = startPos;
                      const match = gEndobjRegExp.exec(bufferStr);
                      if (match) {
                        const endPos = gEndobjRegExp.lastIndex + 1;
                        contentLength = endPos - position;
                        if (match[1] !== "endobj") {
                          (0, _util.warn)(`indexObjects: Found "${match[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`);
                          contentLength -= match[1].length + 1;
                        }
                      } else {
                        contentLength = length - position;
                      }
                      const content = buffer.subarray(position, position + contentLength);
                      const xrefTagOffset = skipUntil(content, 0, xrefBytes);
                      if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
                        xrefStms.push(position - stream.start);
                        this._xrefStms.add(position - stream.start);
                      }
                      position += contentLength;
                    } else if (token.startsWith("trailer") && (token.length === 7 || /\s/.test(token[7]))) {
                      trailers.push(position);
                      const startPos = position + token.length;
                      let contentLength;
                      gStartxrefRegExp.lastIndex = startPos;
                      const match = gStartxrefRegExp.exec(bufferStr);
                      if (match) {
                        const endPos = gStartxrefRegExp.lastIndex + 1;
                        contentLength = endPos - position;
                        if (match[1] !== "startxref") {
                          (0, _util.warn)(`indexObjects: Found "${match[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`);
                          contentLength -= match[1].length + 1;
                        }
                      } else {
                        contentLength = length - position;
                      }
                      position += contentLength;
                    } else {
                      position += token.length + 1;
                    }
                  }
                  for (const xrefStm of xrefStms) {
                    this.startXRefQueue.push(xrefStm);
                    this.readXRef(true);
                  }
                  const trailerDicts = [];
                  let isEncrypted = false;
                  for (const trailer of trailers) {
                    stream.pos = trailer;
                    const parser = new _parser.Parser({
                      lexer: new _parser.Lexer(stream),
                      xref: this,
                      allowStreams: true,
                      recoveryMode: true
                    });
                    const obj = parser.getObj();
                    if (!(0, _primitives.isCmd)(obj, "trailer")) {
                      continue;
                    }
                    const dict = parser.getObj();
                    if (!(dict instanceof _primitives.Dict)) {
                      continue;
                    }
                    trailerDicts.push(dict);
                    if (dict.has("Encrypt")) {
                      isEncrypted = true;
                    }
                  }
                  let trailerDict, trailerError;
                  for (const dict of [...trailerDicts, "genFallback", ...trailerDicts]) {
                    if (dict === "genFallback") {
                      if (!trailerError) {
                        break;
                      }
                      this._generationFallback = true;
                      continue;
                    }
                    let validPagesDict = false;
                    try {
                      const rootDict = dict.get("Root");
                      if (!(rootDict instanceof _primitives.Dict)) {
                        continue;
                      }
                      const pagesDict = rootDict.get("Pages");
                      if (!(pagesDict instanceof _primitives.Dict)) {
                        continue;
                      }
                      const pagesCount = pagesDict.get("Count");
                      if (Number.isInteger(pagesCount)) {
                        validPagesDict = true;
                      }
                    } catch (ex) {
                      trailerError = ex;
                      continue;
                    }
                    if (validPagesDict && (!isEncrypted || dict.has("Encrypt")) && dict.has("ID")) {
                      return dict;
                    }
                    trailerDict = dict;
                  }
                  if (trailerDict) {
                    return trailerDict;
                  }
                  if (this.topDict) {
                    return this.topDict;
                  }
                  throw new _util.InvalidPDFException("Invalid PDF structure.");
                }
                readXRef(recoveryMode = false) {
                  const stream = this.stream;
                  const startXRefParsedCache = /* @__PURE__ */ new Set();
                  while (this.startXRefQueue.length) {
                    try {
                      const startXRef = this.startXRefQueue[0];
                      if (startXRefParsedCache.has(startXRef)) {
                        (0, _util.warn)("readXRef - skipping XRef table since it was already parsed.");
                        this.startXRefQueue.shift();
                        continue;
                      }
                      startXRefParsedCache.add(startXRef);
                      stream.pos = startXRef + stream.start;
                      const parser = new _parser.Parser({
                        lexer: new _parser.Lexer(stream),
                        xref: this,
                        allowStreams: true
                      });
                      let obj = parser.getObj();
                      let dict;
                      if ((0, _primitives.isCmd)(obj, "xref")) {
                        dict = this.processXRefTable(parser);
                        if (!this.topDict) {
                          this.topDict = dict;
                        }
                        obj = dict.get("XRefStm");
                        if (Number.isInteger(obj) && !this._xrefStms.has(obj)) {
                          this._xrefStms.add(obj);
                          this.startXRefQueue.push(obj);
                          __privateGet(this, _firstXRefStmPos) ?? __privateSet(this, _firstXRefStmPos, obj);
                        }
                      } else if (Number.isInteger(obj)) {
                        if (!Number.isInteger(parser.getObj()) || !(0, _primitives.isCmd)(parser.getObj(), "obj") || !((obj = parser.getObj()) instanceof _base_stream.BaseStream)) {
                          throw new _util.FormatError("Invalid XRef stream");
                        }
                        dict = this.processXRefStream(obj);
                        if (!this.topDict) {
                          this.topDict = dict;
                        }
                        if (!dict) {
                          throw new _util.FormatError("Failed to read XRef stream");
                        }
                      } else {
                        throw new _util.FormatError("Invalid XRef stream header");
                      }
                      obj = dict.get("Prev");
                      if (Number.isInteger(obj)) {
                        this.startXRefQueue.push(obj);
                      } else if (obj instanceof _primitives.Ref) {
                        this.startXRefQueue.push(obj.num);
                      }
                    } catch (e) {
                      if (e instanceof _core_utils.MissingDataException) {
                        throw e;
                      }
                      (0, _util.info)("(while reading XRef): " + e);
                    }
                    this.startXRefQueue.shift();
                  }
                  if (this.topDict) {
                    return this.topDict;
                  }
                  if (recoveryMode) {
                    return void 0;
                  }
                  throw new _core_utils.XRefParseException();
                }
                get lastXRefStreamPos() {
                  return __privateGet(this, _firstXRefStmPos) ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);
                }
                getEntry(i) {
                  const xrefEntry = this.entries[i];
                  if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
                    return xrefEntry;
                  }
                  return null;
                }
                fetchIfRef(obj, suppressEncryption = false) {
                  if (obj instanceof _primitives.Ref) {
                    return this.fetch(obj, suppressEncryption);
                  }
                  return obj;
                }
                fetch(ref, suppressEncryption = false) {
                  if (!(ref instanceof _primitives.Ref)) {
                    throw new Error("ref object is not a reference");
                  }
                  const num = ref.num;
                  const cacheEntry = this._cacheMap.get(num);
                  if (cacheEntry !== void 0) {
                    if (cacheEntry instanceof _primitives.Dict && !cacheEntry.objId) {
                      cacheEntry.objId = ref.toString();
                    }
                    return cacheEntry;
                  }
                  let xrefEntry = this.getEntry(num);
                  if (xrefEntry === null) {
                    this._cacheMap.set(num, xrefEntry);
                    return xrefEntry;
                  }
                  if (this._pendingRefs.has(ref)) {
                    this._pendingRefs.remove(ref);
                    (0, _util.warn)(`Ignoring circular reference: ${ref}.`);
                    return _primitives.CIRCULAR_REF;
                  }
                  this._pendingRefs.put(ref);
                  try {
                    xrefEntry = xrefEntry.uncompressed ? this.fetchUncompressed(ref, xrefEntry, suppressEncryption) : this.fetchCompressed(ref, xrefEntry, suppressEncryption);
                    this._pendingRefs.remove(ref);
                  } catch (ex) {
                    this._pendingRefs.remove(ref);
                    throw ex;
                  }
                  if (xrefEntry instanceof _primitives.Dict) {
                    xrefEntry.objId = ref.toString();
                  } else if (xrefEntry instanceof _base_stream.BaseStream) {
                    xrefEntry.dict.objId = ref.toString();
                  }
                  return xrefEntry;
                }
                fetchUncompressed(ref, xrefEntry, suppressEncryption = false) {
                  const gen = ref.gen;
                  let num = ref.num;
                  if (xrefEntry.gen !== gen) {
                    const msg = `Inconsistent generation in XRef: ${ref}`;
                    if (this._generationFallback && xrefEntry.gen < gen) {
                      (0, _util.warn)(msg);
                      return this.fetchUncompressed(_primitives.Ref.get(num, xrefEntry.gen), xrefEntry, suppressEncryption);
                    }
                    throw new _core_utils.XRefEntryException(msg);
                  }
                  const stream = this.stream.makeSubStream(xrefEntry.offset + this.stream.start);
                  const parser = new _parser.Parser({
                    lexer: new _parser.Lexer(stream),
                    xref: this,
                    allowStreams: true
                  });
                  const obj1 = parser.getObj();
                  const obj2 = parser.getObj();
                  const obj3 = parser.getObj();
                  if (obj1 !== num || obj2 !== gen || !(obj3 instanceof _primitives.Cmd)) {
                    throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
                  }
                  if (obj3.cmd !== "obj") {
                    if (obj3.cmd.startsWith("obj")) {
                      num = parseInt(obj3.cmd.substring(3), 10);
                      if (!Number.isNaN(num)) {
                        return num;
                      }
                    }
                    throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
                  }
                  xrefEntry = this.encrypt && !suppressEncryption ? parser.getObj(this.encrypt.createCipherTransform(num, gen)) : parser.getObj();
                  if (!(xrefEntry instanceof _base_stream.BaseStream)) {
                    this._cacheMap.set(num, xrefEntry);
                  }
                  return xrefEntry;
                }
                fetchCompressed(ref, xrefEntry, suppressEncryption = false) {
                  const tableOffset = xrefEntry.offset;
                  const stream = this.fetch(_primitives.Ref.get(tableOffset, 0));
                  if (!(stream instanceof _base_stream.BaseStream)) {
                    throw new _util.FormatError("bad ObjStm stream");
                  }
                  const first = stream.dict.get("First");
                  const n = stream.dict.get("N");
                  if (!Number.isInteger(first) || !Number.isInteger(n)) {
                    throw new _util.FormatError("invalid first and n parameters for ObjStm stream");
                  }
                  let parser = new _parser.Parser({
                    lexer: new _parser.Lexer(stream),
                    xref: this,
                    allowStreams: true
                  });
                  const nums = new Array(n);
                  const offsets = new Array(n);
                  for (let i = 0; i < n; ++i) {
                    const num = parser.getObj();
                    if (!Number.isInteger(num)) {
                      throw new _util.FormatError(`invalid object number in the ObjStm stream: ${num}`);
                    }
                    const offset = parser.getObj();
                    if (!Number.isInteger(offset)) {
                      throw new _util.FormatError(`invalid object offset in the ObjStm stream: ${offset}`);
                    }
                    nums[i] = num;
                    offsets[i] = offset;
                  }
                  const start = (stream.start || 0) + first;
                  const entries = new Array(n);
                  for (let i = 0; i < n; ++i) {
                    const length = i < n - 1 ? offsets[i + 1] - offsets[i] : void 0;
                    if (length < 0) {
                      throw new _util.FormatError("Invalid offset in the ObjStm stream.");
                    }
                    parser = new _parser.Parser({
                      lexer: new _parser.Lexer(stream.makeSubStream(start + offsets[i], length, stream.dict)),
                      xref: this,
                      allowStreams: true
                    });
                    const obj = parser.getObj();
                    entries[i] = obj;
                    if (obj instanceof _base_stream.BaseStream) {
                      continue;
                    }
                    const num = nums[i], entry = this.entries[num];
                    if (entry && entry.offset === tableOffset && entry.gen === i) {
                      this._cacheMap.set(num, obj);
                    }
                  }
                  xrefEntry = entries[xrefEntry.gen];
                  if (xrefEntry === void 0) {
                    throw new _core_utils.XRefEntryException(`Bad (compressed) XRef entry: ${ref}`);
                  }
                  return xrefEntry;
                }
                async fetchIfRefAsync(obj, suppressEncryption) {
                  if (obj instanceof _primitives.Ref) {
                    return this.fetchAsync(obj, suppressEncryption);
                  }
                  return obj;
                }
                async fetchAsync(ref, suppressEncryption) {
                  try {
                    return this.fetch(ref, suppressEncryption);
                  } catch (ex) {
                    if (!(ex instanceof _core_utils.MissingDataException)) {
                      throw ex;
                    }
                    await this.pdfManager.requestRange(ex.begin, ex.end);
                    return this.fetchAsync(ref, suppressEncryption);
                  }
                }
                getCatalogObj() {
                  return this.root;
                }
              }
              _firstXRefStmPos = new WeakMap();
              exports2.XRef = XRef;
            },
            /* 104 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var _createStreamSink, createStreamSink_fn, _processStreamMessage, processStreamMessage_fn, _deleteStreamController, deleteStreamController_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MessageHandler = void 0;
              var _util = __w_pdfjs_require__2(2);
              const CallbackKind = {
                UNKNOWN: 0,
                DATA: 1,
                ERROR: 2
              };
              const StreamKind = {
                UNKNOWN: 0,
                CANCEL: 1,
                CANCEL_COMPLETE: 2,
                CLOSE: 3,
                ENQUEUE: 4,
                ERROR: 5,
                PULL: 6,
                PULL_COMPLETE: 7,
                START_COMPLETE: 8
              };
              function wrapReason(reason) {
                if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
                  (0, _util.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
                }
                switch (reason.name) {
                  case "AbortException":
                    return new _util.AbortException(reason.message);
                  case "MissingPDFException":
                    return new _util.MissingPDFException(reason.message);
                  case "PasswordException":
                    return new _util.PasswordException(reason.message, reason.code);
                  case "UnexpectedResponseException":
                    return new _util.UnexpectedResponseException(reason.message, reason.status);
                  case "UnknownErrorException":
                    return new _util.UnknownErrorException(reason.message, reason.details);
                  default:
                    return new _util.UnknownErrorException(reason.message, reason.toString());
                }
              }
              class MessageHandler {
                constructor(sourceName, targetName, comObj) {
                  __privateAdd(this, _createStreamSink);
                  __privateAdd(this, _processStreamMessage);
                  __privateAdd(this, _deleteStreamController);
                  this.sourceName = sourceName;
                  this.targetName = targetName;
                  this.comObj = comObj;
                  this.callbackId = 1;
                  this.streamId = 1;
                  this.streamSinks = /* @__PURE__ */ Object.create(null);
                  this.streamControllers = /* @__PURE__ */ Object.create(null);
                  this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                  this.actionHandler = /* @__PURE__ */ Object.create(null);
                  this._onComObjOnMessage = (event) => {
                    const data = event.data;
                    if (data.targetName !== this.sourceName) {
                      return;
                    }
                    if (data.stream) {
                      __privateMethod(this, _processStreamMessage, processStreamMessage_fn).call(this, data);
                      return;
                    }
                    if (data.callback) {
                      const callbackId = data.callbackId;
                      const capability = this.callbackCapabilities[callbackId];
                      if (!capability) {
                        throw new Error(`Cannot resolve callback ${callbackId}`);
                      }
                      delete this.callbackCapabilities[callbackId];
                      if (data.callback === CallbackKind.DATA) {
                        capability.resolve(data.data);
                      } else if (data.callback === CallbackKind.ERROR) {
                        capability.reject(wrapReason(data.reason));
                      } else {
                        throw new Error("Unexpected callback case");
                      }
                      return;
                    }
                    const action = this.actionHandler[data.action];
                    if (!action) {
                      throw new Error(`Unknown action from worker: ${data.action}`);
                    }
                    if (data.callbackId) {
                      const cbSourceName = this.sourceName;
                      const cbTargetName = data.sourceName;
                      new Promise(function(resolve) {
                        resolve(action(data.data));
                      }).then(function(result) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.DATA,
                          callbackId: data.callbackId,
                          data: result
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.ERROR,
                          callbackId: data.callbackId,
                          reason: wrapReason(reason)
                        });
                      });
                      return;
                    }
                    if (data.streamId) {
                      __privateMethod(this, _createStreamSink, createStreamSink_fn).call(this, data);
                      return;
                    }
                    action(data.data);
                  };
                  comObj.addEventListener("message", this._onComObjOnMessage);
                }
                on(actionName, handler) {
                  const ah = this.actionHandler;
                  if (ah[actionName]) {
                    throw new Error(`There is already an actionName called "${actionName}"`);
                  }
                  ah[actionName] = handler;
                }
                send(actionName, data, transfers) {
                  this.comObj.postMessage({
                    sourceName: this.sourceName,
                    targetName: this.targetName,
                    action: actionName,
                    data
                  }, transfers);
                }
                sendWithPromise(actionName, data, transfers) {
                  const callbackId = this.callbackId++;
                  const capability = new _util.PromiseCapability();
                  this.callbackCapabilities[callbackId] = capability;
                  try {
                    this.comObj.postMessage({
                      sourceName: this.sourceName,
                      targetName: this.targetName,
                      action: actionName,
                      callbackId,
                      data
                    }, transfers);
                  } catch (ex) {
                    capability.reject(ex);
                  }
                  return capability.promise;
                }
                sendWithStream(actionName, data, queueingStrategy, transfers) {
                  const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
                  return new ReadableStream({
                    start: (controller) => {
                      const startCapability = new _util.PromiseCapability();
                      this.streamControllers[streamId] = {
                        controller,
                        startCall: startCapability,
                        pullCall: null,
                        cancelCall: null,
                        isClosed: false
                      };
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        action: actionName,
                        streamId,
                        data,
                        desiredSize: controller.desiredSize
                      }, transfers);
                      return startCapability.promise;
                    },
                    pull: (controller) => {
                      const pullCapability = new _util.PromiseCapability();
                      this.streamControllers[streamId].pullCall = pullCapability;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL,
                        streamId,
                        desiredSize: controller.desiredSize
                      });
                      return pullCapability.promise;
                    },
                    cancel: (reason) => {
                      (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
                      const cancelCapability = new _util.PromiseCapability();
                      this.streamControllers[streamId].cancelCall = cancelCapability;
                      this.streamControllers[streamId].isClosed = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL,
                        streamId,
                        reason: wrapReason(reason)
                      });
                      return cancelCapability.promise;
                    }
                  }, queueingStrategy);
                }
                destroy() {
                  this.comObj.removeEventListener("message", this._onComObjOnMessage);
                }
              }
              _createStreamSink = new WeakSet();
              createStreamSink_fn = function(data) {
                const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                const self2 = this, action = this.actionHandler[data.action];
                const streamSink = {
                  enqueue(chunk, size = 1, transfers) {
                    if (this.isCancelled) {
                      return;
                    }
                    const lastDesiredSize = this.desiredSize;
                    this.desiredSize -= size;
                    if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                      this.sinkCapability = new _util.PromiseCapability();
                      this.ready = this.sinkCapability.promise;
                    }
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.ENQUEUE,
                      streamId,
                      chunk
                    }, transfers);
                  },
                  close() {
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.CLOSE,
                      streamId
                    });
                    delete self2.streamSinks[streamId];
                  },
                  error(reason) {
                    (0, _util.assert)(reason instanceof Error, "error must have a valid reason");
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.ERROR,
                      streamId,
                      reason: wrapReason(reason)
                    });
                  },
                  sinkCapability: new _util.PromiseCapability(),
                  onPull: null,
                  onCancel: null,
                  isCancelled: false,
                  desiredSize: data.desiredSize,
                  ready: null
                };
                streamSink.sinkCapability.resolve();
                streamSink.ready = streamSink.sinkCapability.promise;
                this.streamSinks[streamId] = streamSink;
                new Promise(function(resolve) {
                  resolve(action(data.data, streamSink));
                }).then(function() {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.START_COMPLETE,
                    streamId,
                    success: true
                  });
                }, function(reason) {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.START_COMPLETE,
                    streamId,
                    reason: wrapReason(reason)
                  });
                });
              };
              _processStreamMessage = new WeakSet();
              processStreamMessage_fn = function(data) {
                const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
                switch (data.stream) {
                  case StreamKind.START_COMPLETE:
                    if (data.success) {
                      streamController.startCall.resolve();
                    } else {
                      streamController.startCall.reject(wrapReason(data.reason));
                    }
                    break;
                  case StreamKind.PULL_COMPLETE:
                    if (data.success) {
                      streamController.pullCall.resolve();
                    } else {
                      streamController.pullCall.reject(wrapReason(data.reason));
                    }
                    break;
                  case StreamKind.PULL:
                    if (!streamSink) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        success: true
                      });
                      break;
                    }
                    if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
                      streamSink.sinkCapability.resolve();
                    }
                    streamSink.desiredSize = data.desiredSize;
                    new Promise(function(resolve) {
                      var _a;
                      resolve((_a = streamSink.onPull) == null ? void 0 : _a.call(streamSink));
                    }).then(function() {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        success: true
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    });
                    break;
                  case StreamKind.ENQUEUE:
                    (0, _util.assert)(streamController, "enqueue should have stream controller");
                    if (streamController.isClosed) {
                      break;
                    }
                    streamController.controller.enqueue(data.chunk);
                    break;
                  case StreamKind.CLOSE:
                    (0, _util.assert)(streamController, "close should have stream controller");
                    if (streamController.isClosed) {
                      break;
                    }
                    streamController.isClosed = true;
                    streamController.controller.close();
                    __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
                    break;
                  case StreamKind.ERROR:
                    (0, _util.assert)(streamController, "error should have stream controller");
                    streamController.controller.error(wrapReason(data.reason));
                    __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
                    break;
                  case StreamKind.CANCEL_COMPLETE:
                    if (data.success) {
                      streamController.cancelCall.resolve();
                    } else {
                      streamController.cancelCall.reject(wrapReason(data.reason));
                    }
                    __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
                    break;
                  case StreamKind.CANCEL:
                    if (!streamSink) {
                      break;
                    }
                    new Promise(function(resolve) {
                      var _a;
                      resolve((_a = streamSink.onCancel) == null ? void 0 : _a.call(streamSink, wrapReason(data.reason)));
                    }).then(function() {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId,
                        success: true
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    });
                    streamSink.sinkCapability.reject(wrapReason(data.reason));
                    streamSink.isCancelled = true;
                    delete this.streamSinks[streamId];
                    break;
                  default:
                    throw new Error("Unexpected stream case");
                }
              };
              _deleteStreamController = new WeakSet();
              deleteStreamController_fn = async function(streamController, streamId) {
                var _a, _b, _c;
                await Promise.allSettled([(_a = streamController.startCall) == null ? void 0 : _a.promise, (_b = streamController.pullCall) == null ? void 0 : _b.promise, (_c = streamController.cancelCall) == null ? void 0 : _c.promise]);
                delete this.streamControllers[streamId];
              };
              exports2.MessageHandler = MessageHandler;
            },
            /* 105 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFWorkerStream = void 0;
              var _util = __w_pdfjs_require__2(2);
              class PDFWorkerStream {
                constructor(msgHandler) {
                  this._msgHandler = msgHandler;
                  this._contentLength = null;
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                getFullReader() {
                  (0, _util.assert)(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once.");
                  this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);
                  return this._fullRequestReader;
                }
                getRangeReader(begin, end) {
                  const reader = new PDFWorkerStreamRangeReader(begin, end, this._msgHandler);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  var _a;
                  (_a = this._fullRequestReader) == null ? void 0 : _a.cancel(reason);
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFWorkerStream = PDFWorkerStream;
              class PDFWorkerStreamReader {
                constructor(msgHandler) {
                  this._msgHandler = msgHandler;
                  this.onProgress = null;
                  this._contentLength = null;
                  this._isRangeSupported = false;
                  this._isStreamingSupported = false;
                  const readableStream = this._msgHandler.sendWithStream("GetReader");
                  this._reader = readableStream.getReader();
                  this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((data) => {
                    this._isStreamingSupported = data.isStreamingSupported;
                    this._isRangeSupported = data.isRangeSupported;
                    this._contentLength = data.contentLength;
                  });
                }
                get headersReady() {
                  return this._headersReady;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                async read() {
                  const {
                    value,
                    done
                  } = await this._reader.read();
                  if (done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  return {
                    value: value.buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  this._reader.cancel(reason);
                }
              }
              class PDFWorkerStreamRangeReader {
                constructor(begin, end, msgHandler) {
                  this._msgHandler = msgHandler;
                  this.onProgress = null;
                  const readableStream = this._msgHandler.sendWithStream("GetRangeReader", {
                    begin,
                    end
                  });
                  this._reader = readableStream.getReader();
                }
                get isStreamingSupported() {
                  return false;
                }
                async read() {
                  const {
                    value,
                    done
                  } = await this._reader.read();
                  if (done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  return {
                    value: value.buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  this._reader.cancel(reason);
                }
              }
            }
            /******/
          ];
          var __webpack_module_cache__ = {};
          function __w_pdfjs_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId](module2, module2.exports, __w_pdfjs_require__);
            return module2.exports;
          }
          var __webpack_exports__ = {};
          (() => {
            var exports2 = __webpack_exports__;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            Object.defineProperty(exports2, "WorkerMessageHandler", {
              enumerable: true,
              get: function() {
                return _worker.WorkerMessageHandler;
              }
            });
            var _worker = __w_pdfjs_require__(1);
            const pdfjsVersion = "3.11.174";
            const pdfjsBuild = "ce8716743";
          })();
          return __webpack_exports__;
        })()
      );
    });
  }
});
export default require_pdf_worker();
//# sourceMappingURL=pdfjs-dist_build_pdf__worker__js.js.map
